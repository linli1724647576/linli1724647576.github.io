<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>27-Python内存管理与垃圾回收(第一部分)：深度剖析Python内存管理架构、内存池的实现原理 | LinLi's Blog</title><meta name="author" content="Lin Li"><meta name="copyright" content="Lin Li"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="27-Python内存管理与垃圾回收(第一部分)：深度剖析Python内存管理架构、内存池的实现原理楔子内存管理，对于Python这样的动态语言来说是非常重要的一部分，它在很大程度上决定了Python的执行效率，因为Python在运行中会创建和销毁大量的对象，这些都涉及内存的管理，因此精湛的内存管理技术是确保内存使用效率的关键。 此外，我们知道Python还是一门提供了垃圾回收机制(GC, gar">
<meta property="og:type" content="article">
<meta property="og:title" content="27-Python内存管理与垃圾回收(第一部分)：深度剖析Python内存管理架构、内存池的实现原理">
<meta property="og:url" content="http://example.com/2023/04/25/27-Python%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%EF%BC%9A%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90Python%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9E%B6%E6%9E%84%E3%80%81%E5%86%85%E5%AD%98%E6%B1%A0%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/index.html">
<meta property="og:site_name" content="LinLi&#39;s Blog">
<meta property="og:description" content="27-Python内存管理与垃圾回收(第一部分)：深度剖析Python内存管理架构、内存池的实现原理楔子内存管理，对于Python这样的动态语言来说是非常重要的一部分，它在很大程度上决定了Python的执行效率，因为Python在运行中会创建和销毁大量的对象，这些都涉及内存的管理，因此精湛的内存管理技术是确保内存使用效率的关键。 此外，我们知道Python还是一门提供了垃圾回收机制(GC, gar">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2023-04-25T08:27:54.000Z">
<meta property="article:modified_time" content="2023-04-25T08:28:37.565Z">
<meta property="article:author" content="Lin Li">
<meta property="article:tag" content="CPython">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/04/25/27-Python%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%EF%BC%9A%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90Python%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9E%B6%E6%9E%84%E3%80%81%E5%86%85%E5%AD%98%E6%B1%A0%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '27-Python内存管理与垃圾回收(第一部分)：深度剖析Python内存管理架构、内存池的实现原理',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-04-25 16:28:37'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">122</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="LinLi's Blog"><span class="site-name">LinLi's Blog</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">27-Python内存管理与垃圾回收(第一部分)：深度剖析Python内存管理架构、内存池的实现原理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-04-25T08:27:54.000Z" title="发表于 2023-04-25 16:27:54">2023-04-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-04-25T08:28:37.565Z" title="更新于 2023-04-25 16:28:37">2023-04-25</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="27-Python内存管理与垃圾回收(第一部分)：深度剖析Python内存管理架构、内存池的实现原理"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="27-Python内存管理与垃圾回收-第一部分-：深度剖析Python内存管理架构、内存池的实现原理"><a href="#27-Python内存管理与垃圾回收-第一部分-：深度剖析Python内存管理架构、内存池的实现原理" class="headerlink" title="27-Python内存管理与垃圾回收(第一部分)：深度剖析Python内存管理架构、内存池的实现原理"></a>27-Python内存管理与垃圾回收(第一部分)：深度剖析Python内存管理架构、内存池的实现原理</h3><h3 id="楔子"><a href="#楔子" class="headerlink" title="楔子"></a>楔子</h3><p><strong>内存管理，对于Python这样的动态语言来说是非常重要的一部分，它在很大程度上决定了Python的执行效率，因为Python在运行中会创建和销毁大量的对象，这些都涉及内存的管理，因此精湛的内存管理技术是确保内存使用效率的关键。</strong></p>
<p><strong>此外，我们知道Python还是一门提供了垃圾回收机制<code>(GC, garbage collection)</code>的语言，可以将开发者从繁琐的手动维护内存的工作中解放出来。</strong></p>
<p><strong>那么下面我们就来分析一下Python中的内存管理和垃圾回收。</strong></p>
<h3 id="内存管理架构"><a href="#内存管理架构" class="headerlink" title="内存管理架构"></a>内存管理架构</h3><p><strong>首先Python的内存管理机制是分层次的，我们可以看成是有6层：-2、-1、0、1、2、3。</strong></p>
<ul>
<li><strong>最底层，也就是-2和-1层是由操作系统提供的内存管理接口，因为计算机硬件资源由操作系统负责管理，内存资源也不例外，应用程序通过系统调用向操作系统申请内存。注意：这一层Python是无权干预的。</strong></li>
<li><strong>第0层，C的库函数会将系统调用封装成通用的内存分配器，也就是我们所熟悉的malloc系列函数。注意：这一层Python同样无法干预。</strong></li>
<li><strong>第1、2、3层，由于Python解释器实现并负责维护。</strong></li>
</ul>
<blockquote>
<p><strong>所以我们看到Python的内存管理实际上封装了C的malloc，C的malloc则是封装了系统调用。</strong></p>
</blockquote>
<p><img src="https://img2020.cnblogs.com/blog/1229382/202009/1229382-20200919125532129-648009563.png" alt="img"></p>
<p><strong>我们自下而上来简单说一下，首先操作系统内部是一个基于页表的虚拟内存管理器(第-1层)，以”页(page)”为单位管理内存，而CPU内存管理单元(MMU)在这个过程中发挥重要作用。虚拟内存管理器下方则是底层存储设备(第-2层)，直接管理物理内存以及磁盘等二级存储设备。</strong></p>
<blockquote>
<p><strong>所以最后的两层是操作系统的领域，过于底层，不在我们的涉及范围内，简单了解就好。有兴趣的话，可以网上查阅相关资料，看看操作系统是如何管理内存的。</strong></p>
</blockquote>
<p><strong>C库函数实现的”通用目的内存分配器”是一个重要的分水岭，即内存管理层次中的第0层。此层之上是应用程序自己的内存管理，之下则是隐藏在冰山中的操作系统的内存管理。</strong></p>
<p><strong>第1、2、3层则是Python自己的内存管理，总共分为3层，作用如下：</strong></p>
<p><strong>第1层：基于第0层的”通用目的内存分配器”包装而成。</strong></p>
<p><strong>这一层并没有在第0层上加入太多的动作，其目的仅仅是为Python提供一层统一的raw memory的管理接口。这么做的原因就是虽然不同的操作系统都提供了ANSI C标准 所定义的内存管理接口，但是对于某些特殊情况不同操作系统有不同的行为。比如调用<code>malloc(0)</code>，有的操作系统会返回NULL，表示申请失败，但是有的操作系统则会返回一个貌似正常的指针，  但是这个指针指向的内存并不是有效的。为了最广泛的可移植性，Python必须保证相同的语义一定代表着相同的运行时行为，为了处理这些与平台相关的内存分配行为，Python必须要在C的内存分配接口之上再提供一层包装。</strong></p>
<p><strong>在Python中，第一层的实现就是一组以<code>PyMem_</code>为前缀的函数簇，下面来看一下。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Include/pymem.h</span></span><br><span class="line">PyAPI_FUNC(<span class="type">void</span> *) PyMem_Malloc(<span class="type">size_t</span> size);</span><br><span class="line">PyAPI_FUNC(<span class="type">void</span> *) PyMem_Realloc(<span class="type">void</span> *ptr, <span class="type">size_t</span> new_size);</span><br><span class="line">PyAPI_FUNC(<span class="type">void</span>) PyMem_Free(<span class="type">void</span> *ptr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Objects/obmalloc.c</span></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">PyMem_Malloc</span><span class="params">(<span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* see PyMem_RawMalloc() */</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt; (<span class="type">size_t</span>)PY_SSIZE_T_MAX)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> _PyMem.<span class="built_in">malloc</span>(_PyMem.ctx, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">PyMem_Realloc</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> new_size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* see PyMem_RawMalloc() */</span></span><br><span class="line">    <span class="keyword">if</span> (new_size &gt; (<span class="type">size_t</span>)PY_SSIZE_T_MAX)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> _PyMem.<span class="built_in">realloc</span>(_PyMem.ctx, ptr, new_size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">PyMem_Free</span><span class="params">(<span class="type">void</span> *ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">    _PyMem.<span class="built_in">free</span>(_PyMem.ctx, ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们看到在第一层，Python提供了类似于类似于C中malloc、realloc、free的语义。并且我们发现，比如 *PyMem_Malloc* ，如果申请的内存大小超过了 *PY_SSIZE_T_MAX* 直接返回NULL，并且还调用了 *_PyMem.malloc* ，这和C中的malloc几乎没啥区别，但是会对特殊值进行一些处理。到目前为止，仅仅是分配了raw memory而已。当然在第一层，Python还提供了面向对象中类型的内存分配器。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Include/pymem.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PyMem_New(type, n) \</span></span><br><span class="line"><span class="meta">  ( ((size_t)(n) &gt; PY_SSIZE_T_MAX / sizeof(type)) ? NULL :      \</span></span><br><span class="line"><span class="meta">        ( (type *) PyMem_Malloc((n) * sizeof(type)) ) )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PyMem_NEW(type, n) \</span></span><br><span class="line"><span class="meta">  ( ((size_t)(n) &gt; PY_SSIZE_T_MAX / sizeof(type)) ? NULL :      \</span></span><br><span class="line"><span class="meta">        ( (type *) PyMem_MALLOC((n) * sizeof(type)) ) )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PyMem_Resize(p, type, n) \</span></span><br><span class="line"><span class="meta">  ( (p) = ((size_t)(n) &gt; PY_SSIZE_T_MAX / sizeof(type)) ? NULL :        \</span></span><br><span class="line"><span class="meta">        (type *) PyMem_Realloc((p), (n) * sizeof(type)) )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PyMem_RESIZE(p, type, n) \</span></span><br><span class="line"><span class="meta">  ( (p) = ((size_t)(n) &gt; PY_SSIZE_T_MAX / sizeof(type)) ? NULL :        \</span></span><br><span class="line"><span class="meta">        (type *) PyMem_REALLOC((p), (n) * sizeof(type)) )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PyMem_Del               PyMem_Free</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PyMem_DEL               PyMem_FREE</span></span><br></pre></td></tr></table></figure>

<p><strong>很明显，在 *PyMem_Malloc* 中需要程序员自行提供所申请的空间大小。然而在 *PyMem_New* 中，只需要提供类型和数量，Python会自动侦测其所需的内存空间大小。</strong></p>
<p><strong>第2层：在第1层提供的通用 *PyMem_* 接口基础上，实现统一的对象内存分配(object.tp_alloc)</strong></p>
<p><strong>第1层所提供的内存管理接口的功能是非常有限的，如果创建一个PyLongObject对象，还需要做很多额外的工作，比如设置对象的类型参数、初始化对象的引用计数值等等。因此为了简化Python自身的开发，Python在比第1层更高的抽象层次上提供了第2层内存管理接口。在这一层，是一组以<code>PyObject_</code>为前缀的函数簇，主要提供了创建Python对象的接口。这一套函数簇又被称为Pymalloc机制，因此在第2层的内存管理机制上，Python对于一些内建对象构建了更高抽象层次的内存管理策略。</strong></p>
<p><strong>第3层：为特定对象服务</strong></p>
<p><strong>这一层主要是用于对象的缓存机制，比如：小整数对象池，浮点数缓存池等等。</strong></p>
<p><strong>所以Python中GC是隐藏在哪一层呢？不用想，肯定是第二层，也是在Python的内存管理中发挥巨大作用的一层，我们后面也会基于第二层进行剖析。</strong></p>
<h3 id="小块空间的内存池"><a href="#小块空间的内存池" class="headerlink" title="小块空间的内存池"></a>小块空间的内存池</h3><h4 id="为什么要引入内存池"><a href="#为什么要引入内存池" class="headerlink" title="为什么要引入内存池"></a>为什么要引入内存池</h4><p><strong>在Python中，很多时候申请的内存都是小块的内存，这些小块的内存在申请后很快又被释放，并且这些内存的申请并不是为了创建对象，所以并没有对象一级的内存池机制。这就意味着Python在运行期间需要大量地执行底层的malloc和free操作，导致操作系统在用户态和内核态之间进行切换，这将严重影响Python的效率。所以为了提高执行效率，Python引入了一个内存池机制，用于管理对小块内存的申请和释放，这就是之前说的Pymalloc机制，并且提供了<code>pymalloc_alloc</code>，<code>pymalloc_realloc</code>，<code>pymalloc_free</code>三个接口。</strong></p>
<p><strong>而整个小块内存的内存池可以视为一个层次结构，从下至上分别是：block、pool、arena。当然内存池只是一个概念上的东西，表示Python对整个小块内存分配和释放行为的内存管理机制。</strong></p>
<h4 id="block"><a href="#block" class="headerlink" title="block"></a>block</h4><p><strong>在最底层，block是一个确定大小的内存块。而Python中，有很多种block，不同种类的block都有不同的内存大小，这个内存大小的值被称之为<code>size class</code>。为了在当前主流的32位平台和64位平台都能获得最佳性能，所有的block的长度都是8字节对齐的。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Objects/obmalloc.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALIGNMENT               8               <span class="comment">/* must be 2^N */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALIGNMENT_SHIFT         3</span></span><br></pre></td></tr></table></figure>

<p><strong>但是问题来了，Python为什么要有这么多种类的block呢？为了更好理解这一点，我们需要了解”内存碎片化”这个概念。</strong></p>
<p><strong>“内存碎片化”是困扰经典内存分配器的一大难题，碎片化导致的结果也是惨重的。看一个典型的内存碎片化例子：</strong></p>
<p><img src="/2023/04/25/27-Python%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%EF%BC%9A%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90Python%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9E%B6%E6%9E%84%E3%80%81%E5%86%85%E5%AD%98%E6%B1%A0%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/1229382-20200919125540072-1741043173.png" alt="img"></p>
<p><strong>虽然还有1350K的可用内存，但由于分散在一系列不连续的碎片上，因此连675K、总可用内存的一半都分配不出来。</strong></p>
<p><strong>那么如何避免内存碎片化呢？想要解决问题，就必须先分析导致问题的根源。</strong></p>
<p><strong>我们知道，应用程序请求内存尺寸是不确定的，有大有小；释放内存的时机也是不确定的，有先有后。经典内存分配器将不同尺寸的内存混合管理，按照先来后到的顺序分配：</strong></p>
<p><img src="/2023/04/25/27-Python%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%EF%BC%9A%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90Python%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9E%B6%E6%9E%84%E3%80%81%E5%86%85%E5%AD%98%E6%B1%A0%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/1229382-20200919125545745-2114131433.png" alt="img"></p>
<p><strong>由此可见，将不同尺寸内存块混合管理，将大块内存切分后再次分配的做法是罪魁祸首。</strong></p>
<p><strong>找到了问题的原因，那么解决方案也就自然而然浮出水面了，那就是将内存空间划分成不同区域，独立管理，比如：</strong></p>
<p><img src="/2023/04/25/27-Python%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%EF%BC%9A%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90Python%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9E%B6%E6%9E%84%E3%80%81%E5%86%85%E5%AD%98%E6%B1%A0%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/1229382-20200919125551739-1476151263.png" alt="img"></p>
<p><strong>如图，内存被划分成小、中、大三个不同尺寸的区域，区域可由若干内存页组成，每个页都划分为统一规格的内存块。这样一来，小块内存的分配，不会影响大块内存区域，使其碎片化。</strong></p>
<p><strong>不过每个区域的碎片仍无法完全避免，但这些碎片都是可以被重新分配出去的，影响不大。此外，通过优化分配策略，碎片还可被进一步合并。以小块内存为例，新内存优先从内存页1分配，内存页2将慢慢变空，最终将被整体回收。</strong></p>
<p><strong>在 *Python* 虚拟机内部，每时每刻都有对象创建、销毁，这引发频繁的内存申请、释放动作。这类内存尺寸一般不大，但分配、释放频率非常高，因此 *Python* 专门设计内存池对此进行优化。</strong></p>
<p><strong>那么，尺寸多大的内存才会动用内存池呢？*Python* 以 *512* 字节为上限，小于等于 *512* 的内存分配才会被内存池接管。所以当申请的内存大小不超过这个上限时， *Python* 可以使用不同种类的block满足对内存的需求；当申请的内存大小超过了上限， *Python* 就会将对内存的请求转交给第一层的内存管理机制，即PyMem函数簇来处理。所以这个上限值在 *Python* 中被设置为 *512* ，如果超过了这个值还是要经过操作系统临时申请的。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Objects/obmalloc.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SMALL_REQUEST_THRESHOLD 512</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NB_SMALL_SIZE_CLASSES   (SMALL_REQUEST_THRESHOLD / ALIGNMENT)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>0: 直接调用 malloc 函数</code></li>
<li><code>1 ~ 512: 由专门的内存池负责分配，内存池以内存尺寸进行划分</code></li>
<li><code>512以上: 直接调动 malloc 函数 </code></li>
</ul>
<p><strong>那么，*Python* 是否为每个尺寸的内存都准备一个独立内存池呢？答案是否定的，原因有几个：</strong></p>
<ul>
<li><code>内存规格有 512 种之多，如果内存池分也分 512 种，徒增复杂性</code></li>
<li><code>内存池种类越多，额外开销越大</code></li>
<li><code>如果某个尺寸内存只申请一次，将浪费内存页内其他空闲内存</code></li>
</ul>
<p><strong>相反，*Python* 以 *8* 字节为梯度，将内存块分为：*8* 字节、*16* 字节、*24* 字节，以此类推。总共 *64* 种block：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">* Request in bytes     Size of allocated block      Size <span class="class"><span class="keyword">class</span> <span class="title">idx</span></span></span><br><span class="line"><span class="class">* ----------------------------------------------------------------</span></span><br><span class="line"><span class="class">*        1-8                     8                       0</span></span><br><span class="line"><span class="class">*        9-16                   16                       1</span></span><br><span class="line"><span class="class">*       17-24                   24                       2</span></span><br><span class="line"><span class="class">*       25-32                   32                       3</span></span><br><span class="line"><span class="class">*       33-40                   40                       4</span></span><br><span class="line"><span class="class">*       41-48                   48                       5</span></span><br><span class="line"><span class="class">*       49-56                   56                       6</span></span><br><span class="line"><span class="class">*       57-64                   64                       7</span></span><br><span class="line"><span class="class">*       65-72                   72                       8</span></span><br><span class="line"><span class="class">*        ...                   ...                     ...</span></span><br><span class="line"><span class="class">*      497-504                 504                      62</span></span><br><span class="line"><span class="class">*      505-512                 512                      63</span></span><br></pre></td></tr></table></figure>

<p><strong>当然Python也提供了一个宏，来描述”Size of allocated block”和”Size class idx”之间的关系：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INDEX2SIZE(I) (((uint)(I) + 1) &lt;&lt; ALIGNMENT_SHIFT)</span></span><br><span class="line"><span class="comment">//索引为0的话, 就是1 &lt;&lt; 3, 显然结果为8</span></span><br><span class="line"><span class="comment">//索引为1的话, 就是2 &lt;&lt; 3, 显然结果为16</span></span><br><span class="line"><span class="comment">//以此类推</span></span><br></pre></td></tr></table></figure>

<p><strong>因此当我们申请一个 *44* 字节的内存时， *PyObject_Malloc* 会从内存池中划分一个 *48* 字节的block给我们。</strong></p>
<p><strong>但是这样也暴露了一个问题，首先内存池是由多个内存页组成，每个内存页划分为多个内存块(block)，这些后面会说。假设我们申请 *7* 字节的内存，那么毫无疑问会给我们一个 *8* 字节的块；但是当我们申请 *1* 字节的时候，分配给我们的还是 *8* 字节的块，因为最小的块就是 *8* 字节。</strong></p>
<p><strong>这种做法好处显而易见，前面提到的问题均得到解决。此外这种方式是字对齐的，内存以字对齐的方式可以提高读写速度。字大小从早期硬件的 *2* 字节、*4* 字节，慢慢发展到现在的 *8* 字节，甚至 *16* 字节。</strong></p>
<p><strong>当然了，有得必有失，内存利用率成了被牺牲的因素，以8字节内存块为例，平均利用率为 *(1+8)&#x2F;2&#x2F;8*100%* ，大约只有 *56.25%* 。当然对于现在的机器而言，完全是可以容忍的。</strong></p>
<p><strong>另外在 *Python* 中，block其实也只是一个概念，在 *Python* 源码中没有与之对应的实体存在。之前我们说对象，对象在源码中有对应的 *PyObject* ，列表在源码中则有对应的 *PyListObject* ，但是这里的block仅仅是概念上的东西，我们知道它是具有一定大小的内存，但是它并不与 *Python* 源码里面的某个东西对应。但是， *Python* 提供了一个管理block的东西，也就是我们下面要分析的pool。</strong></p>
<h4 id="pool"><a href="#pool" class="headerlink" title="pool"></a>pool</h4><p><strong>一组block的集合称为一个pool，换句话说，一个pool管理着一堆具有固定大小的内存块(block)。事实上，pool管理着一大块内存，它有一定的策略，将这块大的内存划分为多个小的内存块。在Python中，一个pool的大小通常是为一个系统内存页，也就是4kb。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Objects/obmalloc.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYSTEM_PAGE_SIZE        (4 * 1024)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYSTEM_PAGE_SIZE_MASK   (SYSTEM_PAGE_SIZE - 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POOL_SIZE               SYSTEM_PAGE_SIZE        <span class="comment">/* must be 2^N */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POOL_SIZE_MASK          SYSTEM_PAGE_SIZE_MASK</span></span><br></pre></td></tr></table></figure>

<p><strong>虽然Python没有为block提供对应的结构，但是提供了和pool相关的结构，我们说Python是将内存页看成由一个个内存块(block)组成的池子(pool)，我们来看看pool的结构：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Objects/obmalloc.c</span></span><br><span class="line"><span class="comment">/* Pool for small blocks. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pool_header</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span> block *_padding;</span><br><span class="line">            uint count; &#125; ref;          <span class="comment">/* 当前pool里面已分配出去的block数量 */</span></span><br><span class="line">    block *freeblock;                   <span class="comment">/* 指向空闲block链表的第一块 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 底层会有多个pool, 多个pool之间也会形成一个链表 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pool_header</span> *<span class="title">nextpool</span>;</span>       <span class="comment">/* 所以nextpool指向下一个pool */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pool_header</span> *<span class="title">prevpool</span>;</span>       <span class="comment">/* prevpool指向上一个pool */</span></span><br><span class="line">    uint arenaindex;                    <span class="comment">/* 在area里面的索引(area后面会说) */</span></span><br><span class="line">    uint szidx;                         <span class="comment">/* 尺寸类别编号, 如果是2, 那么管理的block的大小就是24 */</span></span><br><span class="line">    uint nextoffset;                    <span class="comment">/* 下一个可用block的内存偏移量 */</span></span><br><span class="line">    uint maxnextoffset;                 <span class="comment">/* 最后一个block距离开始位置的偏移量 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pool_header</span> *<span class="title">poolp</span>;</span></span><br></pre></td></tr></table></figure>

<p><strong>我们刚才说了一个pool的大小在Python中是4KB，但是从当前的这个pool的结构体来看，用鼻子想也知道吃不完4KB(4048字节)的内存，事实上这个结构体只占48字节。所以呀，这个结构体叫做pool_header，它仅仅一个pool的头部，除去这个pool_header，剩下的内存才是维护的所有block的集合所占的内存。</strong></p>
<p><strong>我们注意到，pool_header里面有一个szidx，这就意味着pool里面管理的内存块大小都是一样的。也就是说，一个pool管理的block可以是32字节、也可以是64字节，但是不会出现既有32字节的block、又有64字节的block。每一个pool都和一个size联系在一起，更确切的说都和一个<code>size class index</code>联系在一起，表示pool里面存储的block都是多少字节的。这就是里面的域<code>szidx</code>存在的意义。</strong></p>
<p><strong>我们以16字节(szidx&#x3D;1)的block为例，看看Python是如何将一块4KB的内存改造成管理16字节block的pool：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Objects/obmalloc.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POOL_OVERHEAD   _Py_SIZE_ROUND_UP(sizeof(struct pool_header), ALIGNMENT)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span>*</span><br><span class="line"><span class="title function_">pymalloc_alloc</span><span class="params">(<span class="type">void</span> *ctx, <span class="type">size_t</span> nbytes)</span></span><br><span class="line">&#123;</span><br><span class="line">    block *bp;</span><br><span class="line">    poolp pool;</span><br><span class="line">    poolp next;</span><br><span class="line">    uint size;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    init_pool: <span class="comment">//pool指向了一块4KB的内存</span></span><br><span class="line">        next = usedpools[size + size]; <span class="comment">/* == prev */</span></span><br><span class="line">        pool-&gt;nextpool = next;</span><br><span class="line">        pool-&gt;prevpool = next;</span><br><span class="line">        next-&gt;nextpool = pool;</span><br><span class="line">        next-&gt;prevpool = pool;</span><br><span class="line">        pool-&gt;ref.count = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">        <span class="comment">//设置pool的size class index</span></span><br><span class="line">        pool-&gt;szidx = size;</span><br><span class="line">        <span class="comment">//一个宏, 将szidx转成内存块的大小, 比如: 0-&gt;8， 1-&gt;16， 63-&gt;512</span></span><br><span class="line">        size = INDEX2SIZE(size);</span><br><span class="line">        <span class="comment">//跳过用于pool_header的内存，并进行对齐</span></span><br><span class="line">        bp = (block *)pool + POOL_OVERHEAD;</span><br><span class="line">        <span class="comment">//等价于pool-&gt;nextoffset = POOL_OVERHEAD+size+size</span></span><br><span class="line">        pool-&gt;nextoffset = POOL_OVERHEAD + (size &lt;&lt; <span class="number">1</span>);</span><br><span class="line">        pool-&gt;maxnextoffset = POOL_SIZE - size;</span><br><span class="line">        pool-&gt;freeblock = bp + size;</span><br><span class="line">        *(block **)(pool-&gt;freeblock) = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">goto</span> success;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//.....</span></span><br><span class="line">success:</span><br><span class="line">    assert(bp != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span> *)bp;</span><br><span class="line"></span><br><span class="line">failed:</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意最后的<code>(void \*)bp;</code>，它指的就是pool的freeblock域。我们说它指向的是pool中的第一块空闲block、或者说可用block，但是新内存页总是由内存请求触发，所以第一个block一定会被分配出去，因此这里的bp最后指向的只能是第二个、或者第二个之后的内存块。而且从ref.count中我们也可以看出端倪，我们说ref.count记录了当前已经被分配的block的数量，但初始化的时候不是0，而是1。最终改造成pool之后的4kb内存如图所示：</strong></p>
<p><img src="https://img2020.cnblogs.com/blog/1229382/202009/1229382-20200919125607338-965966475.png" alt="img"></p>
<blockquote>
<p><strong>实线箭头是指针，但是虚线箭头则是偏移位置的形象表示。在nextoffset，maxnextoffset中存储的是相对于pool头部的偏移位置。</strong></p>
</blockquote>
<p><strong>在了解初始化之后的pool的样子之后，可以来看看Python在申请block时，pool_header中的各个域是怎么变动的。假设我们再申请1块16字节的内存块：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Objects/obmalloc.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span>*</span><br><span class="line"><span class="title function_">pymalloc_alloc</span><span class="params">(<span class="type">void</span> *ctx, <span class="type">size_t</span> nbytes)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="keyword">if</span> (pool != pool-&gt;nextpool) &#123;</span><br><span class="line">        <span class="comment">//首先pool中已分配的block数自增1</span></span><br><span class="line">        ++pool-&gt;ref.count;</span><br><span class="line">        <span class="comment">//这里的freeblock指向的是下一个可用的block的起始地址</span></span><br><span class="line">        bp = pool-&gt;freeblock;</span><br><span class="line">        assert(bp != <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> ((pool-&gt;freeblock = *(block **)bp) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> success;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//因此当再次申请16字节block时，只需要返回freeblock指向的地址就可以了。</span></span><br><span class="line">        <span class="comment">//那么很显然，freeblock需要前进，指向下一个可用的block，这个时候nextoffset就现身了</span></span><br><span class="line">        <span class="keyword">if</span> (pool-&gt;nextoffset &lt;= pool-&gt;maxnextoffset) &#123;</span><br><span class="line">            <span class="comment">//当nextoffset小于等于maxoffset时候</span></span><br><span class="line">            <span class="comment">//freeblock等于当前block的地址 + nextoffset(下一个可用block的内存偏移量)</span></span><br><span class="line">            <span class="comment">//所以freeblock正好指向了下一个可用block的地址</span></span><br><span class="line">            pool-&gt;freeblock = (block*)pool +</span><br><span class="line">                              pool-&gt;nextoffset;</span><br><span class="line">            <span class="comment">//同理，nextoffset也要向前移动一个block的距离</span></span><br><span class="line">            pool-&gt;nextoffset += INDEX2SIZE(size);</span><br><span class="line">            <span class="comment">//依次反复，即可对所有的block进行遍历。而maxnextoffset指明了该pool中最后一个可用的block距离pool开始位置的偏移</span></span><br><span class="line">            <span class="comment">//当pool-&gt;nextoffset &gt; pool-&gt;maxnextoffset就意味着遍历完pool中的所有block了</span></span><br><span class="line">            <span class="comment">//再次获取显然就是NULL了</span></span><br><span class="line">            *(block **)(pool-&gt;freeblock) = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">goto</span> success;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Pool is full, unlink from used pools. */</span></span><br><span class="line">        next = pool-&gt;nextpool;</span><br><span class="line">        pool = pool-&gt;prevpool;</span><br><span class="line">        next-&gt;prevpool = pool;</span><br><span class="line">        pool-&gt;nextpool = next;</span><br><span class="line">        <span class="keyword">goto</span> success;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所以当我们再申请1块16字节的内存块时，pool的结构图就变成了这样：</strong></p>
<p><img src="/2023/04/25/27-Python%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%EF%BC%9A%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90Python%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9E%B6%E6%9E%84%E3%80%81%E5%86%85%E5%AD%98%E6%B1%A0%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/1229382-20200919125617964-1871506331.png" alt="img"></p>
<p><strong>首先freeblock指向了第三块block，仍然是第一块可用block；注意：nextoffset，它表示下一块可用block的偏移量，显然下一块的可用block是第三块，因此48 + 16 * 3 &#x3D; 96，前进了16字节的偏移量；至于maxnextoffset仍然是4080，它是不变的。</strong></p>
<p><strong>随着内存分配的请求不断发起，空闲的block(内存块)也将不断地分配出去，freeblock不断前进、指向下一个可用内存块，nextoffset也在不断前进、偏移量每次增加内存块的大小，直到所有的空闲内存块被消耗完。</strong></p>
<p><strong>所以，申请、前进、申请、前进，一直重复着相同的动作，整个过程非常自然，也很容易理解。但是我们知道一个pool里面的block都是相同大小的，这就使得一个pool只能满足<code>POOL_SIZE / size</code>次对block的申请，但是这样存在一个问题，举个栗子：</strong></p>
<blockquote>
<p><strong>我们知道内存块不可能一直被使用，肯定有释放的那一天。假设我们分配了两个内存块，理论上下一次应该申请第三个内存块，但是某一时刻第一个内存块被释放了，那么下一次申请的时候，Python是申请第一个内存块、还是第三个内存块呢？</strong></p>
<p><strong>显然为了pool的使用效率，最好分配第一个block。因此可以想象，一旦Python运转起来，内存的释放动作将导致pool中出现大量的离散的自由block，Python为了知道哪些block是被使用之后再次被释放的，必须建立一种机制，将这些离散自由的block组合起来，再次使用。这个机制就是所有的自由block链表(freeblock list)，这个链表的关键就在pool_header中的那个freeblock身上。</strong></p>
</blockquote>
<p><strong>再来回顾一下pool_header的定义：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Objects/obmalloc.c</span></span><br><span class="line"><span class="comment">/* Pool for small blocks. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pool_header</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span> block *_padding;</span><br><span class="line">            uint count; &#125; ref;          </span><br><span class="line">    block *freeblock;                   <span class="comment">/* 指向空闲block链表的第一块 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pool_header</span> *<span class="title">nextpool</span>;</span>       </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pool_header</span> *<span class="title">prevpool</span>;</span>       </span><br><span class="line">    uint arenaindex;                    </span><br><span class="line">    uint szidx;                         </span><br><span class="line">    uint nextoffset;                    </span><br><span class="line">    uint maxnextoffset;                 </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pool_header</span> *<span class="title">poolp</span>;</span></span><br></pre></td></tr></table></figure>

<p><strong>当pool初始化完后之后，freeblock指向了一个有效的地址，也就是下一个可以分配出去的block的地址。然而奇特的是，当Python设置了freeblock时，还设置了 *freeblock。这个动作看似诡异，然而我们马上就能看到设置  *freeblock的动作正是建立离散自由block链表的关键所在。目前我们看到的freeblock只是在机械地前进前进，因为它在等待一个特殊的时刻，在这个特殊的时刻，你会发现freeblock开始成为一个苏醒的精灵，在这4kb的内存上开始灵活地舞动，这个特殊的时刻就是一个block被释放的时刻。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Objects/obmalloc.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//基于地址P获得离P最近的pool的边界地址</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POOL_ADDR(P) ((poolp)_Py_ALIGN_DOWN((P), POOL_SIZE))</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">pymalloc_free</span><span class="params">(<span class="type">void</span> *ctx, <span class="type">void</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    poolp pool;</span><br><span class="line">    block *lastfree;</span><br><span class="line">    poolp next, prev;</span><br><span class="line">    uint size;</span><br><span class="line"></span><br><span class="line">    assert(p != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    pool = POOL_ADDR(p);</span><br><span class="line">    <span class="comment">//如果p不再pool里面，直接返回0</span></span><br><span class="line">    <span class="keyword">if</span> (!address_in_range(p, pool)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//释放，那么ref.count就势必大于0</span></span><br><span class="line">    assert(pool-&gt;ref.count &gt; <span class="number">0</span>);            <span class="comment">/* else it was empty */</span></span><br><span class="line">    *(block **)p = lastfree = pool-&gt;freeblock;</span><br><span class="line">    pool-&gt;freeblock = (block *)p;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在释放block时，神秘的freeblock惊鸿一瞥，显然覆盖在freeblock身上的那层面纱就要被揭开了。我们知道，这是freeblock虽然指向了一个有效的pool里面的地址，但是 *freeblock是为NULL的。假设这时候Python释放的是block 1，那么block 1中的第一个字节的值被设置成了当前freeblock的值，然后freeblock的值被更新了，指向了block  1的首地址。就是这两个步骤，一个block被插入到了离散自由的block链表中。</strong></p>
<blockquote>
<p><strong>简单点，说人话就是：原来freeblock指向block 3，现在变成了block 1指向block 3，而freeblock则指向了block 1。</strong></p>
</blockquote>
<p><strong>所以pool的结构图变化如下：</strong></p>
<p><img src="/2023/04/25/27-Python%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%EF%BC%9A%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90Python%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9E%B6%E6%9E%84%E3%80%81%E5%86%85%E5%AD%98%E6%B1%A0%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/1229382-20200919125626518-102748426.png" alt="img"></p>
<p><strong>到了这里，这条实现方式非常奇特的block链表被我们挖掘出来了，从freeblock开始，我们可以很容易的以<code>freeblock = \*freeblock</code>的方式遍历这条链表，而当发现了<code>\*freeblock</code>为NULL时，则表明到达了该链表<code>(可用自由链表)</code>的尾部了，那么下次就需要申请新的block了。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Objects/obmalloc.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span>*</span><br><span class="line"><span class="title function_">pymalloc_alloc</span><span class="params">(<span class="type">void</span> *ctx, <span class="type">size_t</span> nbytes)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (pool != pool-&gt;nextpool) &#123;</span><br><span class="line">        ++pool-&gt;ref.count;</span><br><span class="line">        bp = pool-&gt;freeblock;</span><br><span class="line">        assert(bp != <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">//如果这里的条件不为真，表明离散自由链表中已经不存在可用的block了</span></span><br><span class="line">        <span class="comment">//如果为真那么代表存在，则会继续分配pool的nextoffset指定的下一块block</span></span><br><span class="line">        <span class="keyword">if</span> ((pool-&gt;freeblock = *(block **)bp) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> success;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//离散自由block链表中不存在，则从pool里面申请新的block</span></span><br><span class="line">        <span class="keyword">if</span> (pool-&gt;nextoffset &lt;= pool-&gt;maxnextoffset) &#123;</span><br><span class="line">            pool-&gt;freeblock = (block*)pool +</span><br><span class="line">                              pool-&gt;nextoffset;</span><br><span class="line">            pool-&gt;nextoffset += INDEX2SIZE(size);</span><br><span class="line">            *(block **)(pool-&gt;freeblock) = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">goto</span> success;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>因此我们可以得出，一个pool在其声明周期内，可以处于以下三种状态：</strong></p>
<p><img src="https://img2020.cnblogs.com/blog/1229382/202009/1229382-20200919125634428-1296151636.png" alt="img"></p>
<p><strong>为什么要讨论pool的状态呢？我们在上面的代码中说自由链表中不存在可用的block时，会从pool中申请，但是显然是有条件的。我们看到必须满足：<code>pool-&gt;nextoffset &lt;= pool-&gt;maxnextoffset</code>才行，但如果连这个条件都不成立了呢？而这个条件不成立显然意味着pool中已经没有可用的block了，因为pool是有大小限制的。所以这个时候想在申请一个block要怎么做？答案很简单，再来一个pool不就好了，然后从新的pool里面申请。</strong></p>
<p><strong>所以block组合起来可以成为一个pool，那么同理多个pool也是可以组合起来的。而多个pool组合起来会得到什么呢，我们说内存池是分层次的，从下至上分别是：block、pool、arena，显然多个pool组合起来，可以得到我们下面要介绍的arena。</strong></p>
<h4 id="arena"><a href="#arena" class="headerlink" title="arena"></a>arena</h4><p><strong>在Python中，多个pool聚合的结果就是一个arena。上一节提到，pool的大小默认是4kb，同样每个arena的大小也有一个默认值。<code>#define ARENA_SIZE (256 &lt;&lt; 10)</code>，显然这个值默认是256KB，也就是<code>ARENA_SIZE / POOL_SIZE = 64</code>个pool的大小。我们来看看arena的底层结构体定义，同样藏身于 *Objects&#x2F;obmalloc.c* 中。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arena_object</span> &#123;</span></span><br><span class="line">    <span class="comment">//arena的地址</span></span><br><span class="line">    <span class="type">uintptr_t</span> address;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//池对齐指针，指向下一个被划分的pool</span></span><br><span class="line">    block* pool_address;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//该arena中可用pool的数量</span></span><br><span class="line">    uint nfreepools;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该arena中所有pool的数量</span></span><br><span class="line">    uint ntotalpools;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//我们在介绍pool的时候说过，pool之间也会形成一个链表，而这里freepools指的是第一个可用pool</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pool_header</span>* <span class="title">freepools</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//从名字上也能看出：nextarena指向下一个arena、prevarena指向上一个arena</span></span><br><span class="line">    <span class="comment">//是不是说明arena之间也会组成链表呢？答案不是的，其实多个arena之间组成的是一个数组，至于为什么我们下面说</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">arena_object</span>* <span class="title">nextarena</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">arena_object</span>* <span class="title">prevarena</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>一个概念上的arena在Python源码中就对应一个arena_object结构体实例，确切的说，arena_object仅仅是arena的一部分。就像pool_header仅仅是pool的一部分一样，一个完整的pool包括一个pool_header和透过这个pool_header管理的block集合；一个完整的arena也包括一个arena_object和透过这个arena_object管理的pool集合。</strong></p>
<p><strong>“未使用的”的arena和”可用”的arena</strong></p>
<p><strong>在arena_object结构体的定义中，我们看到了nextarena和prevarena这两个东西，这似乎意味着在Python中会有一个或多个arena构成的链表。呃，这种猜测实际上只对了一半，实际上，在Python中确实会存在多个arena_object构成的集合，但是这个集合不够成链表，而是一个数组。数组的首地址由arenas来维护，这个数组就是Python中的通用小块内存的内存池。另一方面，nextarea和prevarena也确实是用来连接arena_object组成链表的，咦，不是已经构成或数组了吗？为啥又要来一个链表。</strong></p>
<p><strong>我们曾说arena是用来管理一组pool的集合的，arena_object的作用看上去和pool_header的作用是一样的。但是实际上，pool_header管理的内存(block所使用)和arena_object管理的内存(pool所使用)有一点细微的差别，pool_header管理的内存pool_header自身是一块连续的内存，但是arena_object与其管理的内存则是分离的：</strong></p>
<p><img src="/2023/04/25/27-Python%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%EF%BC%9A%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90Python%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9E%B6%E6%9E%84%E3%80%81%E5%86%85%E5%AD%98%E6%B1%A0%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/1229382-20200919125643819-1760241218.png" alt="img"></p>
<p><strong>咋一看，貌似没啥区别，不过一个是连着的，一个是分开的。但是这后面隐藏了这样一个事实：当pool_header被申请时，它所管理的内存也一定被申请了；但是当arena_object被申请时，它所管理的pool集合的内存则没有被申请。换句话说，arena_object和pool集合在某一时刻需要建立联系。</strong></p>
<p><strong>当一个arena的arena_object没有与pool集合建立联系的时候，这时的arena就处于”未使用”状态；一旦建立了联系，这时arena就转换到了”可用”状态。对于每一种状态，都有一个arena链表。”未使用”的arena链表表头是<code>unused_arena_objects</code>，多个arena之间通过nextarena连接，并且是一个单向的链表；而”可用的”arena链表表头是<code>usable_arenas</code>，多个arena之间通过nextarena、prevarena连接，是一个双向链表。</strong></p>
<p><img src="https://img2020.cnblogs.com/blog/1229382/202009/1229382-20200919125651170-218981901.png" alt="img"></p>
<p><strong>申请arena</strong></p>
<p><strong>在运行期间，Python使用new_arena来创建一个arena，我们来看看它是如何被创建的。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//arenas，多个arena组成的数组的首地址</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">arena_object</span>* <span class="title">arenas</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当arena数组中的所有arena的个数</span></span><br><span class="line"><span class="type">static</span> uint maxarenas = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//未使用的arena的个数</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">arena_object</span>* <span class="title">unused_arena_objects</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可用的arena的个数</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">arena_object</span>* <span class="title">usable_arenas</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化需要申请的arena的个数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INITIAL_ARENA_OBJECTS 16</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> arena_object*</span><br><span class="line"><span class="title function_">new_arena</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//arena，一个arena_object结构体对象</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">arena_object</span>* <span class="title">arenaobj</span>;</span></span><br><span class="line">    uint excess;        <span class="comment">/* number of bytes above pool alignment */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//[1]：判断是否需要扩充&quot;未使用&quot;的arena列表</span></span><br><span class="line">    <span class="keyword">if</span> (unused_arena_objects == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        uint i;</span><br><span class="line">        uint numarenas;</span><br><span class="line">        <span class="type">size_t</span> nbytes;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//[2]：确定本次需要申请的arena_object的个数，并申请内存</span></span><br><span class="line">        numarenas = maxarenas ? maxarenas &lt;&lt; <span class="number">1</span> : INITIAL_ARENA_OBJECTS;</span><br><span class="line">        nbytes = numarenas * <span class="keyword">sizeof</span>(*arenas);</span><br><span class="line">        arenaobj = (<span class="keyword">struct</span> arena_object *)PyMem_RawRealloc(arenas, nbytes);</span><br><span class="line">        <span class="keyword">if</span> (arenaobj == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        arenas = arenaobj;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//[3]：初始化新申请的arena_object，并将其放入&quot;未使用&quot;arena链表中</span></span><br><span class="line">        <span class="keyword">for</span> (i = maxarenas; i &lt; numarenas; ++i) &#123;</span><br><span class="line">            arenas[i].address = <span class="number">0</span>;              <span class="comment">/* mark as unassociated */</span></span><br><span class="line">            arenas[i].nextarena = i &lt; numarenas - <span class="number">1</span> ?</span><br><span class="line">                                   &amp;arenas[i+<span class="number">1</span>] : <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Update globals. */</span></span><br><span class="line">        unused_arena_objects = &amp;arenas[maxarenas];</span><br><span class="line">        maxarenas = numarenas;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Take the next available arena object off the head of the list. */</span></span><br><span class="line">    <span class="comment">//[4]：从&quot;未使用&quot;arena链表中取出一个&quot;未使用&quot;的arena</span></span><br><span class="line">    assert(unused_arena_objects != <span class="literal">NULL</span>);</span><br><span class="line">    arenaobj = unused_arena_objects;</span><br><span class="line">    unused_arena_objects = arenaobj-&gt;nextarena;</span><br><span class="line">    assert(arenaobj-&gt;address == <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//[5]：申请arena管理的内存</span></span><br><span class="line">    address = _PyObject_Arena.alloc(_PyObject_Arena.ctx, ARENA_SIZE);</span><br><span class="line">    <span class="keyword">if</span> (address == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        arenaobj-&gt;nextarena = unused_arena_objects;</span><br><span class="line">        unused_arena_objects = arenaobj;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    arenaobj-&gt;address = (<span class="type">uintptr_t</span>)address;</span><br><span class="line">    <span class="comment">//调整个数</span></span><br><span class="line">    ++narenas_currently_allocated;</span><br><span class="line">    ++ntimes_arena_allocated;</span><br><span class="line">    <span class="keyword">if</span> (narenas_currently_allocated &gt; narenas_highwater)</span><br><span class="line">        narenas_highwater = narenas_currently_allocated;</span><br><span class="line">    <span class="comment">//[6]：设置poo集合的相关信息，这是设置为NULL</span></span><br><span class="line">    arenaobj-&gt;freepools = <span class="literal">NULL</span>;</span><br><span class="line">    arenaobj-&gt;pool_address = (block*)arenaobj-&gt;address;</span><br><span class="line">    arenaobj-&gt;nfreepools = MAX_POOLS_IN_ARENA;</span><br><span class="line">    <span class="comment">//将pool的起始地址调整为系统页的边界</span></span><br><span class="line">    excess = (uint)(arenaobj-&gt;address &amp; POOL_SIZE_MASK);</span><br><span class="line">    <span class="keyword">if</span> (excess != <span class="number">0</span>) &#123;</span><br><span class="line">        --arenaobj-&gt;nfreepools;</span><br><span class="line">        arenaobj-&gt;pool_address += POOL_SIZE - excess;</span><br><span class="line">    &#125;</span><br><span class="line">    arenaobj-&gt;ntotalpools = arenaobj-&gt;nfreepools;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arenaobj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>因此我们可以看到，Python首先会检查当前”未使用”链表中是否还有”未使用”arena，检查的结果将决定后续的动作。</strong></p>
<p><strong>如果在”未使用”链表中还存在未使用的arena，那么Python会从”未使用”arena链表中抽取一个arena，接着调整”未使用”链表，让它和抽取的arena断绝一切联系。然后Python申请了一块256KB大小的内存，将申请的内存地址赋给抽取出来的arena的address。我们已经知道，arena中维护的是pool集合，这块256KB的内存就是pool的容身之处，这时候arena就已经和pool集合建立联系了。这个arena已经具备了成为”可用”内存的条件，该arena和”未使用”arena链表脱离了关系，就等着被”可用”arena链表接收了，不过什么时候接收呢？先别急。</strong></p>
<p><strong>随后，python在代码的[6]处设置了一些arena用于维护pool集合的信息。需要注意的是，Python将申请到的256KB内存进行了处理，主要是放弃了一些内存，并将可使用的内存边界(pool_address)调整到了与系统页对齐。然后通过<code>arenaobj-&gt;freepools = NULL;</code>将freepools设置为NULL，这不奇怪，基于对freeblock的了解，我们知道要等到释放一个pool时，这个freepools才会有用。最后我们看到，pool集合占用的256KB内存在进行边界对齐后，实际是交给pool_address来维护了。</strong></p>
<p><strong>回到new_arena中的[1]处，如果unused_arena_objects为NULL，则表明目前系统中已经没有”未使用”arena了，那么Python首先会扩大系统的arena集合(小块内存内存池)。Python在内部通过一个maxarenas的变量维护了存储arena的数组的个数，然后在[2]处将待申请的arena的个数设置为当然arena个数(maxarenas)的2倍。当然首次初始化的时候maxarenas为0，此时为16。</strong></p>
<p><strong>在获得了新的maxarenas后，Python会检查这个新得到的值是否溢出了。如果检查顺利通过，Python就会在[3]处通过realloc扩大arenas指向的内存，并对新申请的arena_object进行设置，特别是那个不起眼的address，要将新申请的address一律设置为0。实际上，这是一个标识arena是出于”未使用”状态还是”可用”状态的重要标记。而一旦arena(arena_object)和pool集合建立了联系，这个address就变成了非0，看代码的[6]处。当然别忘记我们为什么会走到[3]这里，是因为<code>unused_arena_objects == NULL</code>了，而且最后还设置了unused_arena_objects，这样系统中又有了”未使用”的arena了，接下来Python就在[4]处对一个arena进行初始化了。</strong></p>
<h4 id="内存池"><a href="#内存池" class="headerlink" title="内存池"></a>内存池</h4><p><strong>通过<code>#define SMALL_REQUEST_THRESHOLD 512</code>我们知道Python内部默认的小块内存与大块内存的分界点为512个字节。也就是说，当申请的内存小于512个字节，pymalloc_alloc会在内存池中申请内存，而当申请的内存超过了512字节，那么pymalloc_alloc将退化为malloc，通过操作系统来申请内存。当然，通过修改Python源代码我们可以改变这个值，从而改变Python的默认内存管理行为。</strong></p>
<p><strong>当申请的内存小于512字节时，Python会使用area所维护的内存空间。那么Python内部对于area的个数是否有限制呢？换句话说，Python对于这个小块空间内存池的大小是否有限制？其实这个决策取决于用户，Python提供了一个编译符号，用于控制是否限制内存池的大小，不过这里不是重点，只需要知道就行。</strong></p>
<p><strong>尽管我们在前面花了不少篇幅介绍arena，同时也看到arena是Python小块内存池的最上层结构，其实所有arena的集合就是小块内存池。然而在实际的使用中，Python并不直接与arenas和arena数组打交道。当Python申请内存时，最基本的操作单元并不是arena，而是pool。估计到这里懵了，别急，慢慢来。</strong></p>
<p><strong>举个例子，当我们申请一个28字节的内存时，Python内部会在内存池寻找一块能够满足需求的pool，从中取出一个block返回，而不会去寻找arena。这实际上是由pool和arena的属性决定的，在Python中，pool是一个有size概念的内存管理抽象体，一个pool中的block总是有确定的大小，这个pool总是和某个size class  index对应，还记得pool_header中的那个szidx么？而arena是没有size概念的内存管理抽象体。这就意味着，同一个arena在某个时刻，其内部的pool集合管理的可能都是相同字节的block，比如：32字节；而到了另一个时刻，由于系统需要，这个arena可能被重新划分，其中的pool集合管理的block可能变成是64字节了，甚至pool集合中一半的pool管理的是32字节block，另一半管理64字节block。这就决定了在进行内存分配和销毁时，所有的动作都是在pool上完成的。</strong></p>
<blockquote>
<p><strong>所以一个arena，并不要求pool集合中所有pool管理的block必须一样；可以有管理16字节block的pool，也可以有管理32字节block的pool，等等。</strong></p>
</blockquote>
<p><strong>当然内存池中的pool不仅仅是一个有size概念的内存管理抽象体，更进一步的，它还是一个有状态的内存管理抽象体。正如我们之前说的，一个pool在Python运行的任何一个时刻，总是处于以下三种状态中的一种：</strong></p>
<ul>
<li><code>empty状态：pool中所有的block都未被使用</code></li>
<li><code>used状态：pool中至少有一个block已经被使用，并且至少有一个block未被使用</code></li>
<li><code>full状态：pool中所有的block都已经被使用，这种状态的pool在arena中，但是不在arena的freepools链表中。</code></li>
</ul>
<p><strong>而且pool处于不同的状态，也会得到Python不同的对待：</strong></p>
<ul>
<li><code>如果pool完全空闲，那么Python会将它占用的内存页归还给操作系统、或者缓存起来，后续需要重新分配时直接拿来用。</code></li>
<li><code>如果pool完全用满，Python就无需关注它了，直接丢在一边。</code></li>
<li><code>如果pool只是部分使用，说明它还有内存块未分配，Python会将它们以双向链表的形式组织起来；</code></li>
</ul>
<p><strong>可用pool链表</strong></p>
<p><strong>由于used状态的pool只是部分使用，内部还有内存块未分配，将它们组织起来可供后续分配。Python通过pool_header中的nextpool和prevpool指针，将它们连成一个双向循环链表。</strong></p>
<p><img src="https://img2020.cnblogs.com/blog/1229382/202009/1229382-20200919125705521-1922371939.png" alt="img"></p>
<p><strong>注意到，同个可用pool链表中的内存块大小规格都是一样的，我们还以16字节为例。另外，为了简化链表处理逻辑，Python引入了一个虚拟节点，这是一个常见的C语言链表实现技巧。一个空的pool链表是这样的，判断条件是：<code>pool -&gt; nextpool == pool</code>：</strong></p>
<p><img src="https://img2020.cnblogs.com/blog/1229382/202009/1229382-20200919125712421-1081485272.png" alt="img"></p>
<p><strong>虚拟节点只参与链表维护，并不实际管理内存块。因为无需为虚拟节点分配一个完整的4k内存页，64字节pool_header结构体足以。然而实际上Python作者们更抠，只分配刚好足够nextpool和prevpool指针用的内存，手法非常精妙，后续会体现。</strong></p>
<p><strong>Python优先从链表的第一个pool中分配内存块，如果pool的可用内存块用完了，就将其从可用pool链表中剔除。</strong><br> <img src="https://img2020.cnblogs.com/blog/1229382/202009/1229382-20200919125720390-1296515696.png" alt="img"></p>
<p><strong>当一个内存块(block)被回收，Python根据块地址计算得到距离该块最近的pool边界地址，计算方式就是我们上面说的那个宏：POOL_ADDR，将块(block)地址对齐为内存页(pool)尺寸的整数倍，便得到pool地址。</strong></p>
<p><strong>得到pool地址后，Python将空闲内存块插入到空闲内存块链表的头部，如果pool状态是由full变成used，那么Python还会将它插回到可用pool链表的头部。</strong></p>
<p><img src="https://img2020.cnblogs.com/blog/1229382/202009/1229382-20200919125727553-202377014.png" alt="img"></p>
<p><strong>插入到可用pool链表头部是为了保证较满的pool在链表的前面，以便优先使用。位于尾部的pool被使用的概率很低，随着时间的推移，更多的内存块被释放出来，慢慢变空。因此可用pool链表很明显头重脚轻，靠前的pool比较慢，靠后的pool比较空。</strong></p>
<p><strong>当一个pool中所有的内存块(block)都被释放，状态就变成了empty，那么Python就会将它移除可用pool链表，内存页可能直接归还给操作系统，或者缓存起来备用：</strong></p>
<p><img src="https://img2020.cnblogs.com/blog/1229382/202009/1229382-20200919125735866-1825560716.png" alt="img"></p>
<p><strong>实际上，pool链表任一节点均有机会完全空闲下来，这由概率决定，尾部节点概率最高。</strong></p>
<p><strong>可用pool链表数组</strong></p>
<p><strong>Python内存池管理内存块，按照尺寸分门别类进行。因此每种规格都需要维护一个独立可执行的可用pool链表，以8直接为梯度，那么会有64中pool链表。</strong></p>
<p><strong>那么如何组织这么多pool链表呢？最直接的办法就是分配一个长度为64的虚拟节点数组，这个虚拟节点数组就是我们上面提到过的usedpools。Python内部维护的usedpools数组是一个非常巧妙的实现，该数组维护着所有的处于used状态的pool。当申请内存时，Python就会通过usedpools寻找到一个可用的pool<code>(处于used状态)</code>，从中分配一个block。因此我们想，一定有一个usedpools相关联的机制，完成从申请的内存的大小到size class  index之间的转换，否则Python就无法找到最合适的pool了。这种机制和usedpools的结构有着密切的关系，而usedpools也藏身于 *Objects&#x2F;obmalloc.c* 中。但是我们暂时先不看它的结构，因为还缺少一个东西，我们后面会说。</strong></p>
<p><strong>然后如果程序请求 *5* 字节，*Python* 将分配 *8* 字节内存块，通过数组第 *0* 个虚拟节点即可找到 *8* 字节 *pool* 链表；如果程序请求 *56* 字节，*Python* 将分配 *64* 字节内存块，则需要从数组第 *7* 个虚拟节点出发；其他以此类推。</strong></p>
<p><img src="https://img2020.cnblogs.com/blog/1229382/202009/1229382-20200919125744109-301358749.png" alt="img"></p>
<p><strong>那么，虚拟节点数组需要占用多少内存呢？很好计算：48 * 64 &#x3D; 3072字节，也就是3KB的内存，0.75个内存页。</strong></p>
<p><strong>话说3KB的内存，你们觉得多吗？对于现在的机器来说，3KB可以忽略不计吧。但是高级程序猿对内存的精打细算，完全堪比、甚至凌驾于菜市场买菜的大妈，所以Python的作者从中还扣掉了三分之二。相当于只给虚拟机节点原来的三分之一、也就是1KB的内存，那么这是如何做到的呢？</strong></p>
<p><strong>事实上我们在前面已经埋下伏笔了，虚拟节点只参与维护链表结构，并不管了内存页。因此虚拟节点其实只使用pool_header结构体中参与链表维护的nextpool和prevpool两个指针字段。</strong></p>
<p><img src="https://img2020.cnblogs.com/blog/1229382/202009/1229382-20200919125751082-1101271502.png" alt="img"></p>
<p><strong>为避免浅蓝色部分内存浪费，*Python* 作者们将虚拟节点想象成一个个卡片，将深蓝色部分首尾相接，最终转换成一个纯指针数组。</strong></p>
<p><img src="https://img2020.cnblogs.com/blog/1229382/202009/1229382-20200919125756178-1820000253.png" alt="img"></p>
<p><strong>而这个纯指针数组就是在 *Objects&#x2F;obmalloc.c* 中定义的 *usedpools* ，每个虚拟节点对应数组里面的两个指针。所以之前我们说先不看 *usedpools* 的结构体定义，就是因为直接看的话绝对会一脸懵，因为不知道数组里面存的是啥，但是现在我们知道了数组里面存的就是一堆指针：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">uint8_t</span> block;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTA(x)  ((poolp )((uint8_t *)&amp;(usedpools[2*(x)]) - 2*sizeof(block *)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT(x)   PTA(x), PTA(x)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//NB_SMALL_SIZE_CLASSES之前好像出现过，但是不用说也知道这表示当前配置下有多少个不同size的块</span></span><br><span class="line"><span class="comment">//在我当前的机器就是512/8=64个，对应的size class index就是从0到63</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NB_SMALL_SIZE_CLASSES   (SMALL_REQUEST_THRESHOLD / ALIGNMENT)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> poolp usedpools[<span class="number">2</span> * ((NB_SMALL_SIZE_CLASSES + <span class="number">7</span>) / <span class="number">8</span>) * <span class="number">8</span>] = &#123;</span><br><span class="line">    PT(<span class="number">0</span>), PT(<span class="number">1</span>), PT(<span class="number">2</span>), PT(<span class="number">3</span>), PT(<span class="number">4</span>), PT(<span class="number">5</span>), PT(<span class="number">6</span>), PT(<span class="number">7</span>)</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> NB_SMALL_SIZE_CLASSES &gt; 8</span></span><br><span class="line">    , PT(<span class="number">8</span>), PT(<span class="number">9</span>), PT(<span class="number">10</span>), PT(<span class="number">11</span>), PT(<span class="number">12</span>), PT(<span class="number">13</span>), PT(<span class="number">14</span>), PT(<span class="number">15</span>)</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> NB_SMALL_SIZE_CLASSES &gt; 16</span></span><br><span class="line">    , PT(<span class="number">16</span>), PT(<span class="number">17</span>), PT(<span class="number">18</span>), PT(<span class="number">19</span>), PT(<span class="number">20</span>), PT(<span class="number">21</span>), PT(<span class="number">22</span>), PT(<span class="number">23</span>)</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> NB_SMALL_SIZE_CLASSES &gt; 24</span></span><br><span class="line">    , PT(<span class="number">24</span>), PT(<span class="number">25</span>), PT(<span class="number">26</span>), PT(<span class="number">27</span>), PT(<span class="number">28</span>), PT(<span class="number">29</span>), PT(<span class="number">30</span>), PT(<span class="number">31</span>)</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> NB_SMALL_SIZE_CLASSES &gt; 32</span></span><br><span class="line">    , PT(<span class="number">32</span>), PT(<span class="number">33</span>), PT(<span class="number">34</span>), PT(<span class="number">35</span>), PT(<span class="number">36</span>), PT(<span class="number">37</span>), PT(<span class="number">38</span>), PT(<span class="number">39</span>)</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> NB_SMALL_SIZE_CLASSES &gt; 40</span></span><br><span class="line">    , PT(<span class="number">40</span>), PT(<span class="number">41</span>), PT(<span class="number">42</span>), PT(<span class="number">43</span>), PT(<span class="number">44</span>), PT(<span class="number">45</span>), PT(<span class="number">46</span>), PT(<span class="number">47</span>)</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> NB_SMALL_SIZE_CLASSES &gt; 48</span></span><br><span class="line">    , PT(<span class="number">48</span>), PT(<span class="number">49</span>), PT(<span class="number">50</span>), PT(<span class="number">51</span>), PT(<span class="number">52</span>), PT(<span class="number">53</span>), PT(<span class="number">54</span>), PT(<span class="number">55</span>)</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> NB_SMALL_SIZE_CLASSES &gt; 56</span></span><br><span class="line">    , PT(<span class="number">56</span>), PT(<span class="number">57</span>), PT(<span class="number">58</span>), PT(<span class="number">59</span>), PT(<span class="number">60</span>), PT(<span class="number">61</span>), PT(<span class="number">62</span>), PT(<span class="number">63</span>)</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> NB_SMALL_SIZE_CLASSES &gt; 64</span></span><br><span class="line"><span class="meta">#<span class="keyword">error</span> <span class="string">&quot;NB_SMALL_SIZE_CLASSES should be less than 64&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* NB_SMALL_SIZE_CLASSES &gt; 64 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* NB_SMALL_SIZE_CLASSES &gt; 56 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* NB_SMALL_SIZE_CLASSES &gt; 48 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* NB_SMALL_SIZE_CLASSES &gt; 40 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* NB_SMALL_SIZE_CLASSES &gt; 32 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* NB_SMALL_SIZE_CLASSES &gt; 24 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* NB_SMALL_SIZE_CLASSES &gt; 16 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* NB_SMALL_SIZE_CLASSES &gt;  8 */</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>然后将对应的两个指针的前后空间都想象成是自己的，这样就能够得到一个虚无缥缈、但又非常完整的pool_header结构体。尽管它们前后的空间不是自己的，但是不妨碍精神层面上YY一下，不过由于我们不会访问除了nextpool和prevpool指针之外的其它字段，所以虽然有内存越界，但也无伤大雅。</strong></p>
<p><strong>以一个代表空链表的虚拟节点为例，*nextpool* 和 *prevpool* 指针均指向 *pool_header* 自己。虽然实际上 *nextpool* 和 *prevpool* 都指向了数组中的其他虚拟节点，但逻辑上可以想象成指向当前的 *pool_header* 结构体：</strong></p>
<p><img src="https://img2020.cnblogs.com/blog/1229382/202009/1229382-20200919125802713-934784644.png" alt="img"></p>
<p><strong>经过这番优化，数组只需要 16 * 64 &#x3D; 1024  字节的内存空间即可，也就是1KB，所以节省了三分之二。然而为了节省这三分之二的内存，代码变得难以理解。当然Python诞生的那个年代，内存还是比较精贵的，所以秉承着能省则省的策略，然后这个优良传统一直保持到了现在。</strong></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><strong>对于一个用C开发的庞大的软件<code>(python是一门高级语言，但是执行对应代码的解释器则可以看成是c的一个软件)</code>，其中的内存管理可谓是最复杂、最繁琐的地方了。不同尺度的内存会有不同的抽象，这些抽象在各种情况下会组成各式各样的链表，非常复杂。但是我们还是有可能从一个整体的尺度上把握整个内存池，尽管不同的链表变幻无常，但我们只需记住，所有的内存都在arenas<code>(或者说那个存放多个arena的数组)</code>的掌握之中 。</strong></p>
<p><strong>更详细的内容可以自己进入 *Objects&#x2F;obmalloc.c* 中查看对应源码，主要看两个函数：</strong></p>
<ul>
<li><code>pymalloc_alloc: 负责内存分配</code></li>
<li><code>pymalloc_free: 负责内存释放</code></li>
</ul>
<p><strong>关于内存管理和内存池我们就说到这里，下一篇介绍Python中的垃圾回收。</strong></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Lin Li</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/04/25/27-Python%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%EF%BC%9A%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90Python%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9E%B6%E6%9E%84%E3%80%81%E5%86%85%E5%AD%98%E6%B1%A0%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">http://example.com/2023/04/25/27-Python%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%EF%BC%9A%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90Python%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9E%B6%E6%9E%84%E3%80%81%E5%86%85%E5%AD%98%E6%B1%A0%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">LinLi's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/CPython/">CPython</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/04/25/28-Python%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%EF%BC%9A%E6%BA%90%E7%A0%81%E8%A7%A3%E5%AF%86Python%E4%B8%AD%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/" title="28-Python内存管理与垃圾回收(第二部分)：源码解密Python中的垃圾回收机制"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">28-Python内存管理与垃圾回收(第二部分)：源码解密Python中的垃圾回收机制</div></div></a></div><div class="next-post pull-right"><a href="/2023/04/20/26-%E8%A7%A3%E5%AF%86Python%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%89%EF%BC%9A%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90Python%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E3%80%81%E9%94%80%E6%AF%81%E3%80%81%E8%B0%83%E5%BA%A6%E3%80%81%E4%BB%A5%E5%8F%8AGIL%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" title="26-解密Python中的多线程（第二部分）：源码剖析Python线程的创建、销毁、调度、以及GIL的实现原理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">26-解密Python中的多线程（第二部分）：源码剖析Python线程的创建、销毁、调度、以及GIL的实现原理</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/03/29/01-%E7%BC%96%E8%AF%91Cpython/" title="01-编译Cpython"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">01-编译Cpython</div></div></a></div><div><a href="/2023/03/29/02-%E4%B8%80%E5%88%87%E5%AF%B9%E8%B1%A1%E7%9A%86PyObject/" title="02-一切对象皆PyObject"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">02-一切对象皆PyObject</div></div></a></div><div><a href="/2023/03/29/04-%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/" title="04-浮点数的底层实现"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">04-浮点数的底层实现</div></div></a></div><div><a href="/2023/03/29/06-Bytes%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BA%95%E5%B1%82%E6%93%8D%E4%BD%9C/" title="06-Bytes对象的底层操作"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">06-Bytes对象的底层操作</div></div></a></div><div><a href="/2023/03/29/03-Python%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E5%99%A8%E5%92%8C%E5%BA%95%E5%B1%82%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86/" title="03-Python引用计数器和底层对象管理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">03-Python引用计数器和底层对象管理</div></div></a></div><div><a href="/2023/03/29/05-Python%E6%95%B4%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/" title="05-Python整数的底层实现"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">05-Python整数的底层实现</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Lin Li</div><div class="author-info__description">今日事，今日毕</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">122</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#27-Python%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%EF%BC%9A%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90Python%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9E%B6%E6%9E%84%E3%80%81%E5%86%85%E5%AD%98%E6%B1%A0%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">27-Python内存管理与垃圾回收(第一部分)：深度剖析Python内存管理架构、内存池的实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A5%94%E5%AD%90"><span class="toc-number">2.</span> <span class="toc-text">楔子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9E%B6%E6%9E%84"><span class="toc-number">3.</span> <span class="toc-text">内存管理架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E5%9D%97%E7%A9%BA%E9%97%B4%E7%9A%84%E5%86%85%E5%AD%98%E6%B1%A0"><span class="toc-number">4.</span> <span class="toc-text">小块空间的内存池</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%BC%95%E5%85%A5%E5%86%85%E5%AD%98%E6%B1%A0"><span class="toc-number">4.1.</span> <span class="toc-text">为什么要引入内存池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#block"><span class="toc-number">4.2.</span> <span class="toc-text">block</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pool"><span class="toc-number">4.3.</span> <span class="toc-text">pool</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#arena"><span class="toc-number">4.4.</span> <span class="toc-text">arena</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B1%A0"><span class="toc-number">4.5.</span> <span class="toc-text">内存池</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">5.</span> <span class="toc-text">小结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/08/%E8%A7%A3%E5%86%B3Camera-ready-%E2%9C%98-Problem-Not-all-fonts-are-embedded-%E9%97%AE%E9%A2%98/" title="解决Camera ready ✘ Problem: Not all fonts are embedded. 问题">解决Camera ready ✘ Problem: Not all fonts are embedded. 问题</a><time datetime="2025-04-08T14:19:21.000Z" title="发表于 2025-04-08 22:19:21">2025-04-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/21/Sequence-Oriented-DBMS-Fuzzing/" title="Sequence-Oriented DBMS Fuzzing">Sequence-Oriented DBMS Fuzzing</a><time datetime="2025-02-21T09:35:08.000Z" title="发表于 2025-02-21 17:35:08">2025-02-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/18/AGENTLESS-Demystifying-LLM-based-Software-Engineering-Agents/" title="AGENTLESS: Demystifying LLM-based Software Engineering Agents">AGENTLESS: Demystifying LLM-based Software Engineering Agents</a><time datetime="2025-02-18T12:16:29.000Z" title="发表于 2025-02-18 20:16:29">2025-02-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/01/DeepSeek-R1-Incentivizing-Reasoning-Capability-in-LLMs-via-Reinforcement-Learning/" title="DeepSeek-R1: Incentivizing Reasoning Capability in LLMs via Reinforcement Learning">DeepSeek-R1: Incentivizing Reasoning Capability in LLMs via Reinforcement Learning</a><time datetime="2025-02-01T11:11:48.000Z" title="发表于 2025-02-01 19:11:48">2025-02-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/01/DeepSeek-Coder-When-the-Large-Language-Model-Meets-Programming-The-Rise-of-Code-Intelligence/" title="DeepSeek-Coder: When the Large Language Model Meets Programming - The Rise of Code Intelligence">DeepSeek-Coder: When the Large Language Model Meets Programming - The Rise of Code Intelligence</a><time datetime="2025-02-01T02:43:19.000Z" title="发表于 2025-02-01 10:43:19">2025-02-01</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Lin Li</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>