<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>19-Python类机制深度解析：自定义类的底层实现以及Metaclass | LinLi's Blog</title><meta name="author" content="Lin Li"><meta name="copyright" content="Lin Li"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="19-Python类机制深度解析：自定义类的底层实现以及metaclass楔子Python除了给我提供了很多的类之外，还支持我们定义属于自己的类，那么Python底层是如何做的呢？我们下面就来看看。 自定义class老规矩，如果想知道底层是怎么做的，那么就必须要通过观察字节码来实现。 12345678910111213141516171819202122class Girl:    name &#x3D;">
<meta property="og:type" content="article">
<meta property="og:title" content="19-Python类机制深度解析：自定义类的底层实现以及Metaclass">
<meta property="og:url" content="http://example.com/2023/04/10/19-Python%E7%B1%BB%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E4%BB%A5%E5%8F%8AMetaclass/index.html">
<meta property="og:site_name" content="LinLi&#39;s Blog">
<meta property="og:description" content="19-Python类机制深度解析：自定义类的底层实现以及metaclass楔子Python除了给我提供了很多的类之外，还支持我们定义属于自己的类，那么Python底层是如何做的呢？我们下面就来看看。 自定义class老规矩，如果想知道底层是怎么做的，那么就必须要通过观察字节码来实现。 12345678910111213141516171819202122class Girl:    name &#x3D;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2023-04-10T01:37:16.000Z">
<meta property="article:modified_time" content="2023-04-12T02:39:16.575Z">
<meta property="article:author" content="Lin Li">
<meta property="article:tag" content="CPython">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/04/10/19-Python%E7%B1%BB%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E4%BB%A5%E5%8F%8AMetaclass/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '19-Python类机制深度解析：自定义类的底层实现以及Metaclass',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-04-12 10:39:16'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">113</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="LinLi's Blog"><span class="site-name">LinLi's Blog</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">19-Python类机制深度解析：自定义类的底层实现以及Metaclass</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-04-10T01:37:16.000Z" title="发表于 2023-04-10 09:37:16">2023-04-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-04-12T02:39:16.575Z" title="更新于 2023-04-12 10:39:16">2023-04-12</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="19-Python类机制深度解析：自定义类的底层实现以及Metaclass"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="19-Python类机制深度解析：自定义类的底层实现以及metaclass"><a href="#19-Python类机制深度解析：自定义类的底层实现以及metaclass" class="headerlink" title="19-Python类机制深度解析：自定义类的底层实现以及metaclass"></a>19-Python类机制深度解析：自定义类的底层实现以及metaclass</h2><h3 id="楔子"><a href="#楔子" class="headerlink" title="楔子"></a>楔子</h3><p><strong>Python除了给我提供了很多的类之外，还支持我们定义属于自己的类，那么Python底层是如何做的呢？我们下面就来看看。</strong></p>
<h3 id="自定义class"><a href="#自定义class" class="headerlink" title="自定义class"></a>自定义class</h3><p><strong>老规矩，如果想知道底层是怎么做的，那么就必须要通过观察字节码来实现。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span>:</span><br><span class="line"></span><br><span class="line">    name = <span class="string">&quot;夏色祭&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;__init__&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;f&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">g</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        <span class="built_in">print</span>(self.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">girl = Girl()</span><br><span class="line">girl.f()</span><br><span class="line">girl.g(<span class="string">&quot;神乐mea&quot;</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">__init__</span></span><br><span class="line"><span class="string">f</span></span><br><span class="line"><span class="string">神乐mea</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>通过之前对函数机制的分析中，我们知道对于一个包含函数定义的Python源文件，在编译之后会得到一个和源文件对应的PyCodeObject对象，其内部的常量池中存储了函数编译之后的PyCodeObject对象。那么对于包含类的Python源文件，编译之后的结果又是怎么样的呢？</strong></p>
<p><strong>显然我们可以照葫芦画瓢，根据以前的经验我们可以猜测模块对应的PyCodeObject对象的常量池中肯定存储了类对应的PyCodeObject对象，类对应的PyCodeObject对象的常量池中则存储了__init__、f、g三个函数对应的PyCodeObject对象。然而事实也确实如此。</strong></p>
<p><img src="/2023/04/10/19-Python%E7%B1%BB%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E4%BB%A5%E5%8F%8AMetaclass/1229382-20200901005722023-2010359374.png" alt="img"></p>
<p><strong>在介绍函数的时候，我们看到函数的声明(def语句)和函数的实现代码虽然是一个逻辑整体，但是它们的字节码指令却是分离在两个PyCodeObject对象中的。在类中，同样存在这样的分离现象。声明类的class语句，编译后的字节码指令存储在模块对应的PyCodeObject中，而类的实现、也就是类里面的逻辑，编译后的字节码指令序列则存储在类对应的的PyCodeObject中。所以我们在模块级别中只能找到类，无法直接找到类里面的成员。</strong></p>
<p><strong>另外还可以看到，类的成员函数和一般的函数相同，也会有这种声明和实现分离的现象。其实也很好理解，就把类和函数想象成变量就行了，类名、函数名就是变量名，而类、函数里面的逻辑想象成值，一个变量对应一个值。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;&quot;&quot;class Girl:</span></span><br><span class="line"><span class="string">    name = &quot;夏色祭&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    def __init__(self):</span></span><br><span class="line"><span class="string">        print(&quot;__init__&quot;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    def f(self):</span></span><br><span class="line"><span class="string">        print(&quot;f&quot;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    def g(self, name):</span></span><br><span class="line"><span class="string">        self.name = name</span></span><br><span class="line"><span class="string">        print(self.name)&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时的code显然是模块对应的PyCodeObject对象</span></span><br><span class="line">code = <span class="built_in">compile</span>(s, <span class="string">&quot;class&quot;</span>, <span class="string">&quot;exec&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(code)  <span class="comment"># &lt;code object &lt;module&gt; at 0x000001B588101450, file &quot;class&quot;, line 1&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 常量池里面存储了Girl对应的PyCodeObject对象</span></span><br><span class="line"><span class="built_in">print</span>(code.co_consts[<span class="number">0</span>])  <span class="comment"># &lt;code object Girl at 0x0000024BB6C7ABE0, file &quot;class&quot;, line 1&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Girl的PyCodeObject对象的常量池里面存储了几个函数的PyCodeObject对象</span></span><br><span class="line"><span class="comment"># 至于它们的位置我们暂时不需要关心</span></span><br><span class="line"><span class="built_in">print</span>(code.co_consts[<span class="number">0</span>].co_consts[<span class="number">6</span>])  <span class="comment"># &lt;code object g at 0x000001FAC40A82F0, file &quot;class&quot;, line 10&gt;</span></span><br><span class="line"><span class="built_in">print</span>(code.co_consts[<span class="number">0</span>].co_consts[<span class="number">6</span>].co_varnames)  <span class="comment"># (&#x27;self&#x27;, &#x27;name&#x27;)</span></span><br></pre></td></tr></table></figure>

<h4 id="class对象的动态元信息"><a href="#class对象的动态元信息" class="headerlink" title="class对象的动态元信息"></a>class对象的动态元信息</h4><p><strong>class对象(class关键字创建的类)的元信息指的就是关于class的信息，比如说class的名称、它所拥有的的属性、方法，该class实例化时要为实例对象申请的内存空间大小等。对于模块中定义的class Girl来说，我们必须知道相应的信息：比如在class  Girl中，有一个符号f，这个f对应一个函数；还有一个符号g，这个g也对应了一个函数。有了这些元信息，才能创建class对象，否则我们是没办法创建的。元信息是一个非常重要的概念，比如说Hive，数据的元信息就是存储在MySQL里面的，而在编程语言中，正是通过元信息才实现了反射等动态特性。而在Python中，元信息的概念被发挥的淋漓尽致，因此Python也提供了其他编程语言所不具备的高度灵活的动态特征。</strong></p>
<p><strong>老规矩，下面还是看一下字节码：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span>:</span><br><span class="line"></span><br><span class="line">    name = <span class="string">&quot;夏色祭&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;__init__&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;f&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">g</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        <span class="built_in">print</span>(self.name)</span><br></pre></td></tr></table></figure>

<p><strong>这里我们先不涉及调用，只看类的创建。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">1</span>           <span class="number">0</span> LOAD_BUILD_CLASS</span><br><span class="line">              <span class="number">2</span> LOAD_CONST               <span class="number">0</span> (&lt;code object Girl at <span class="number">0x0000026FB0B3ABE0</span>, file <span class="string">&quot;class&quot;</span>, line <span class="number">1</span>&gt;)</span><br><span class="line">              <span class="number">4</span> LOAD_CONST               <span class="number">1</span> (<span class="string">&#x27;Girl&#x27;</span>)</span><br><span class="line">              <span class="number">6</span> MAKE_FUNCTION            <span class="number">0</span></span><br><span class="line">              <span class="number">8</span> LOAD_CONST               <span class="number">1</span> (<span class="string">&#x27;Girl&#x27;</span>)</span><br><span class="line">             <span class="number">10</span> CALL_FUNCTION            <span class="number">2</span></span><br><span class="line">             <span class="number">12</span> STORE_NAME               <span class="number">0</span> (Girl)</span><br><span class="line">             <span class="number">14</span> LOAD_CONST               <span class="number">2</span> (None)</span><br><span class="line">             <span class="number">16</span> RETURN_VALUE</span><br><span class="line"></span><br><span class="line">Disassembly of &lt;code object Girl at <span class="number">0x0000026FB0B3ABE0</span>, file <span class="string">&quot;class&quot;</span>, line <span class="number">1</span>&gt;:</span><br><span class="line">  <span class="number">1</span>           <span class="number">0</span> LOAD_NAME                <span class="number">0</span> (__name__)</span><br><span class="line">              <span class="number">2</span> STORE_NAME               <span class="number">1</span> (__module__)</span><br><span class="line">              <span class="number">4</span> LOAD_CONST               <span class="number">0</span> (<span class="string">&#x27;Girl&#x27;</span>)</span><br><span class="line">              <span class="number">6</span> STORE_NAME               <span class="number">2</span> (__qualname__)</span><br><span class="line"></span><br><span class="line">  <span class="number">3</span>           <span class="number">8</span> LOAD_CONST               <span class="number">1</span> (<span class="string">&#x27;夏色祭&#x27;</span>)</span><br><span class="line">             <span class="number">10</span> STORE_NAME               <span class="number">3</span> (name)</span><br><span class="line"></span><br><span class="line">  <span class="number">4</span>          <span class="number">12</span> LOAD_CONST               <span class="number">2</span> (&lt;code object __init__ at <span class="number">0x0000026FB0961450</span>, file <span class="string">&quot;class&quot;</span>, line <span class="number">4</span>&gt;)</span><br><span class="line">             <span class="number">14</span> LOAD_CONST               <span class="number">3</span> (<span class="string">&#x27;Girl.__init__&#x27;</span>)</span><br><span class="line">             <span class="number">16</span> MAKE_FUNCTION            <span class="number">0</span></span><br><span class="line">             <span class="number">18</span> STORE_NAME               <span class="number">4</span> (__init__)</span><br><span class="line"></span><br><span class="line">  <span class="number">7</span>          <span class="number">20</span> LOAD_CONST               <span class="number">4</span> (&lt;code object f at <span class="number">0x0000026FB095AB30</span>, file <span class="string">&quot;class&quot;</span>, line <span class="number">7</span>&gt;)</span><br><span class="line">             <span class="number">22</span> LOAD_CONST               <span class="number">5</span> (<span class="string">&#x27;Girl.f&#x27;</span>)</span><br><span class="line">             <span class="number">24</span> MAKE_FUNCTION            <span class="number">0</span></span><br><span class="line">             <span class="number">26</span> STORE_NAME               <span class="number">5</span> (f)</span><br><span class="line"></span><br><span class="line"> <span class="number">10</span>          <span class="number">28</span> LOAD_CONST               <span class="number">6</span> (&lt;code object g at <span class="number">0x0000026FB0B472F0</span>, file <span class="string">&quot;class&quot;</span>, line <span class="number">10</span>&gt;)</span><br><span class="line">             <span class="number">30</span> LOAD_CONST               <span class="number">7</span> (<span class="string">&#x27;Girl.g&#x27;</span>)</span><br><span class="line">             <span class="number">32</span> MAKE_FUNCTION            <span class="number">0</span></span><br><span class="line">             <span class="number">34</span> STORE_NAME               <span class="number">6</span> (g)</span><br><span class="line">             <span class="number">36</span> LOAD_CONST               <span class="number">8</span> (None)</span><br><span class="line">             <span class="number">38</span> RETURN_VALUE</span><br><span class="line"></span><br><span class="line">Disassembly of &lt;code object __init__ at <span class="number">0x0000026FB0961450</span>, file <span class="string">&quot;class&quot;</span>, line <span class="number">4</span>&gt;:</span><br><span class="line">  <span class="number">5</span>           <span class="number">0</span> LOAD_GLOBAL              <span class="number">0</span> (print)</span><br><span class="line">              <span class="number">2</span> LOAD_CONST               <span class="number">1</span> (<span class="string">&#x27;__init__&#x27;</span>)</span><br><span class="line">              <span class="number">4</span> CALL_FUNCTION            <span class="number">1</span></span><br><span class="line">              <span class="number">6</span> POP_TOP</span><br><span class="line">              <span class="number">8</span> LOAD_CONST               <span class="number">0</span> (None)</span><br><span class="line">             <span class="number">10</span> RETURN_VALUE</span><br><span class="line"></span><br><span class="line">Disassembly of &lt;code object f at <span class="number">0x0000026FB095AB30</span>, file <span class="string">&quot;class&quot;</span>, line <span class="number">7</span>&gt;:</span><br><span class="line">  <span class="number">8</span>           <span class="number">0</span> LOAD_GLOBAL              <span class="number">0</span> (print)</span><br><span class="line">              <span class="number">2</span> LOAD_CONST               <span class="number">1</span> (<span class="string">&#x27;f&#x27;</span>)</span><br><span class="line">              <span class="number">4</span> CALL_FUNCTION            <span class="number">1</span></span><br><span class="line">              <span class="number">6</span> POP_TOP</span><br><span class="line">              <span class="number">8</span> LOAD_CONST               <span class="number">0</span> (None)</span><br><span class="line">             <span class="number">10</span> RETURN_VALUE</span><br><span class="line"></span><br><span class="line">Disassembly of &lt;code object g at <span class="number">0x0000026FB0B472F0</span>, file <span class="string">&quot;class&quot;</span>, line <span class="number">10</span>&gt;:</span><br><span class="line"> <span class="number">11</span>           <span class="number">0</span> LOAD_FAST                <span class="number">1</span> (name)</span><br><span class="line">              <span class="number">2</span> LOAD_FAST                <span class="number">0</span> (self)</span><br><span class="line">              <span class="number">4</span> STORE_ATTR               <span class="number">0</span> (name)</span><br><span class="line"></span><br><span class="line"> <span class="number">12</span>           <span class="number">6</span> LOAD_GLOBAL              <span class="number">1</span> (print)</span><br><span class="line">              <span class="number">8</span> LOAD_FAST                <span class="number">0</span> (self)</span><br><span class="line">             <span class="number">10</span> LOAD_ATTR                <span class="number">0</span> (name)</span><br><span class="line">             <span class="number">12</span> CALL_FUNCTION            <span class="number">1</span></span><br><span class="line">             <span class="number">14</span> POP_TOP</span><br><span class="line">             <span class="number">16</span> LOAD_CONST               <span class="number">0</span> (None)</span><br><span class="line">             <span class="number">18</span> RETURN_VALUE</span><br></pre></td></tr></table></figure>

<p><strong>字节码比较长，我们逐行分析，当然很多字节码我们都见过了，因此有的字节码介绍的时候就不会特别详细了。我们仔细观察一下字节码，会发现分为五个部分：模块的字节码、class Girl的字节码、class的三个函数的字节码。</strong></p>
<p><strong>我们先来看看模块的字节码</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>           <span class="number">0</span> LOAD_BUILD_CLASS</span><br><span class="line">            <span class="number">2</span> LOAD_CONST               <span class="number">0</span> (&lt;code object Girl at <span class="number">0x0000026FB0B3ABE0</span>, file <span class="string">&quot;class&quot;</span>, line <span class="number">1</span>&gt;)</span><br><span class="line">            <span class="number">4</span> LOAD_CONST               <span class="number">1</span> (<span class="string">&#x27;Girl&#x27;</span>)</span><br><span class="line">            <span class="number">6</span> MAKE_FUNCTION            <span class="number">0</span></span><br><span class="line">            <span class="number">8</span> LOAD_CONST               <span class="number">1</span> (<span class="string">&#x27;Girl&#x27;</span>)</span><br><span class="line">           <span class="number">10</span> CALL_FUNCTION            <span class="number">2</span></span><br><span class="line">           <span class="number">12</span> STORE_NAME               <span class="number">0</span> (Girl)</span><br><span class="line">           <span class="number">14</span> LOAD_CONST               <span class="number">2</span> (None)</span><br><span class="line">           <span class="number">16</span> RETURN_VALUE</span><br></pre></td></tr></table></figure>

<ul>
<li><code>0 LOAD_BUILD_CLASS: 我们注意到这又是一条我们没见过的新指令，从名字也能看出来这是要构建一个类;</code></li>
<li><code>2 LOAD_CONST: 加载Girl对应的PyCodeObject对象;</code></li>
<li><code>4 LOAD_CONST: 加载字符串&quot;Girl&quot;</code></li>
<li><code>6 MAKE_FUNCTION: 问题来了, 我们看到出现了MAKE_FUNCTION, 不是说要构建类吗? 为什么是MAKE_FUNCTION呢? 别急, 往下看;</code></li>
<li><code>8 LOAD_CONST: 再次加载字符串&quot;Girl&quot;;</code></li>
<li><code>10 CALL_FUNCTION: 你看到了什么?函数调用?是的, 这个CALL_FUNCTION是用来构建类的, 至于怎么构建我们后面会说;</code></li>
<li><code>12 STORE_NAME: 将上一步构建好的类使用符号Girl保存;</code></li>
</ul>
<p><strong>我们看一下LOAD_BUILD_CLASS这个指令都干了哪些事情吧。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="title function_">TARGET</span><span class="params">(LOAD_BUILD_CLASS)</span>: &#123;</span><br><span class="line">    _Py_IDENTIFIER(__build_class__);</span><br><span class="line"></span><br><span class="line">    PyObject *bc;</span><br><span class="line">    <span class="keyword">if</span> (PyDict_CheckExact(f-&gt;f_builtins)) &#123;</span><br><span class="line">        <span class="comment">//从f_builtins里面获取PyId___build_class__</span></span><br><span class="line">        bc = _PyDict_GetItemIdWithError(f-&gt;f_builtins, &amp;PyId___build_class__);</span><br><span class="line">        <span class="keyword">if</span> (bc == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!_PyErr_Occurred(tstate)) &#123;</span><br><span class="line">                _PyErr_SetString(tstate, PyExc_NameError,</span><br><span class="line">                                 <span class="string">&quot;__build_class__ not found&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">        &#125;</span><br><span class="line">        Py_INCREF(bc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        PyObject *build_class_str = _PyUnicode_FromId(&amp;PyId___build_class__);</span><br><span class="line">        <span class="keyword">if</span> (build_class_str == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">        bc = PyObject_GetItem(f-&gt;f_builtins, build_class_str);</span><br><span class="line">        <span class="keyword">if</span> (bc == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (_PyErr_ExceptionMatches(tstate, PyExc_KeyError))</span><br><span class="line">                _PyErr_SetString(tstate, PyExc_NameError,</span><br><span class="line">                                 <span class="string">&quot;__build_class__ not found&quot;</span>);</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//入栈</span></span><br><span class="line">    PUSH(bc);</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>LOAD_BUILD_CLASS做的事情很简单，就是从Python的内置函数中取得__build_class__将其入栈，然后下面的几个指令很好理解，但是却出现了一个CALL_FUNCTION，显然它是调用__build_class__创建类的。我们看到它的参数个数是2个，这两个参数分别是：A的PyFunctionObject、字符串”A”，因此：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在底层将会被翻译成</span></span><br><span class="line">A = __build_class__(&lt;PyFunctionObject A&gt;, <span class="string">&quot;A&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果是</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">int</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在底层将会被翻译成</span></span><br><span class="line">A = __build_class__(&lt;PyFunctionObject A&gt;, <span class="string">&quot;A&quot;</span>, <span class="built_in">int</span>)</span><br></pre></td></tr></table></figure>

<p><strong>我们实际操作一下：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在Python中我们可以导入 builtins 来调用__build_class__，也可以直接使用</span></span><br><span class="line"><span class="keyword">import</span> builtins</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建一个类, 叫MyInt, 继承自int</span></span><br><span class="line">c = builtins.__build_class__(<span class="keyword">lambda</span>: <span class="literal">None</span>, <span class="string">&quot;MyInt&quot;</span>, <span class="built_in">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(c.__name__)  <span class="comment"># MyInt</span></span><br><span class="line"><span class="built_in">print</span>(c.__base__)  <span class="comment"># &lt;class &#x27;int&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(c(<span class="number">3</span>) * c(<span class="number">5</span>))  <span class="comment"># 15</span></span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/10/19-Python%E7%B1%BB%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E4%BB%A5%E5%8F%8AMetaclass/1229382-20200901005728755-1725864266.png" alt="img"></p>
<p><strong>如果参数类型不正确的话，就会报出如下错误：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> builtins</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    builtins.__build_class__()</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    exc_type, exc_value, _ = sys.exc_info()</span><br><span class="line">    <span class="built_in">print</span>(exc_type, exc_value)  <span class="comment"># &lt;class &#x27;TypeError&#x27;&gt; __build_class__: not enough arguments</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    builtins.__build_class__(<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    exc_type, exc_value, _ = sys.exc_info()</span><br><span class="line">    <span class="built_in">print</span>(exc_type, exc_value)  <span class="comment"># &lt;class &#x27;TypeError&#x27;&gt; __build_class__: func must be a function</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    builtins.__build_class__(<span class="keyword">lambda</span>: <span class="number">123</span>, <span class="number">123</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    exc_type, exc_value, _ = sys.exc_info()</span><br><span class="line">    <span class="built_in">print</span>(exc_type, exc_value)  <span class="comment"># &lt;class &#x27;TypeError&#x27;&gt; __build_class__: name is not a string</span></span><br></pre></td></tr></table></figure>

<p><strong>记住这几个报错信息，后面马上就会看到。此外我们也看到，这个函数的一个参数叫func、第二个参数叫name。</strong></p>
<p><strong>所以现在就明白为什么会出现CALL_FUNCTION这条指令，__build_class__就是用来将一个函数对象变成一个class对象。</strong></p>
<p><strong>class对象的字节码</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span>           <span class="number">0</span> LOAD_NAME                <span class="number">0</span> (__name__)</span><br><span class="line">             <span class="number">2</span> STORE_NAME               <span class="number">1</span> (__module__)</span><br><span class="line">             <span class="number">4</span> LOAD_CONST               <span class="number">0</span> (<span class="string">&#x27;Girl&#x27;</span>)</span><br><span class="line">             <span class="number">6</span> STORE_NAME               <span class="number">2</span> (__qualname__)</span><br><span class="line"></span><br><span class="line"> <span class="number">3</span>           <span class="number">8</span> LOAD_CONST               <span class="number">1</span> (<span class="string">&#x27;夏色祭&#x27;</span>)</span><br><span class="line">            <span class="number">10</span> STORE_NAME               <span class="number">3</span> (name)</span><br><span class="line"></span><br><span class="line"> <span class="number">4</span>          <span class="number">12</span> LOAD_CONST               <span class="number">2</span> (&lt;code object __init__ at <span class="number">0x0000026FB0961450</span>, file <span class="string">&quot;class&quot;</span>, line <span class="number">4</span>&gt;)</span><br><span class="line">            <span class="number">14</span> LOAD_CONST               <span class="number">3</span> (<span class="string">&#x27;Girl.__init__&#x27;</span>)</span><br><span class="line">            <span class="number">16</span> MAKE_FUNCTION            <span class="number">0</span></span><br><span class="line">            <span class="number">18</span> STORE_NAME               <span class="number">4</span> (__init__)</span><br><span class="line"></span><br><span class="line"> <span class="number">7</span>          <span class="number">20</span> LOAD_CONST               <span class="number">4</span> (&lt;code object f at <span class="number">0x0000026FB095AB30</span>, file <span class="string">&quot;class&quot;</span>, line <span class="number">7</span>&gt;)</span><br><span class="line">            <span class="number">22</span> LOAD_CONST               <span class="number">5</span> (<span class="string">&#x27;Girl.f&#x27;</span>)</span><br><span class="line">            <span class="number">24</span> MAKE_FUNCTION            <span class="number">0</span></span><br><span class="line">            <span class="number">26</span> STORE_NAME               <span class="number">5</span> (f)</span><br><span class="line"></span><br><span class="line"><span class="number">10</span>          <span class="number">28</span> LOAD_CONST               <span class="number">6</span> (&lt;code object g at <span class="number">0x0000026FB0B472F0</span>, file <span class="string">&quot;class&quot;</span>, line <span class="number">10</span>&gt;)</span><br><span class="line">            <span class="number">30</span> LOAD_CONST               <span class="number">7</span> (<span class="string">&#x27;Girl.g&#x27;</span>)</span><br><span class="line">            <span class="number">32</span> MAKE_FUNCTION            <span class="number">0</span></span><br><span class="line">            <span class="number">34</span> STORE_NAME               <span class="number">6</span> (g)</span><br><span class="line">            <span class="number">36</span> LOAD_CONST               <span class="number">8</span> (None)</span><br><span class="line">            <span class="number">38</span> RETURN_VALUE</span><br></pre></td></tr></table></figure>

<p><strong>对于一个类而言，调用其__module__属性，可以获取所在的模块。所以开始的LOAD_NAME和STORE_NAME是将符号__module__和全局命名空间中符号__name__的值关联了起来，并放入到该类的local名字空间中。</strong></p>
<p><strong>需要说明的是，我们在介绍函数的时候提过，当时我们说：”函数的局部变量是不可变的，在编译的时候就已经确定了，是以一种静态方式放在了运行时栈前面的那段内存中，并没有放在f_locals中，f_locals其实是一个NULL，我们通过locals()拿到的只是对运行时栈前面的内存的一个拷贝，函数里面的局部变量是通过静态方式来访问的”。但是类则不一样，类是可以动态修改的，可以随时增加属性、方法，这就意味着类是不可能通过静态方式来查找属性的。而事实上也确实如此，类也有一个f_locals，但它指向的就不再是NULL了，而和f_globals一样，也是一个PyDictObject对象。然后是LOAD_CONST，将字符串”Girl”加载进来，和__qualname__组成一个entry存储在Girl的local空间中。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span>:</span><br><span class="line"></span><br><span class="line">    name = <span class="string">&quot;夏色祭&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;__init__&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;f&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">g</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        <span class="built_in">print</span>(self.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(__name__)  <span class="comment"># __main__</span></span><br><span class="line"><span class="built_in">print</span>(Girl.__module__)  <span class="comment"># __main__</span></span><br><span class="line"><span class="built_in">print</span>(Girl.__qualname__)  <span class="comment"># Girl</span></span><br></pre></td></tr></table></figure>

<p><strong>所以整体过程就是：先将PyCodeObject构建成函数，再通过__build_class__将函数变成一个类，当然__build_class__结束之后我们的Girl这个类就横空出世了。</strong></p>
<p><strong>因此剩下的来问题就是__build_class__是如何将一个函数变成类的，想要知道答案，那么只能去源码中一探究竟了。不过在看源码之前，我们还需要了解一样东西：metaclass。</strong></p>
<h4 id="回顾metaclass"><a href="#回顾metaclass" class="headerlink" title="回顾metaclass"></a>回顾metaclass</h4><p><strong>元类，被誉为是深度的魔法，但是个人觉得有点夸张了。首先元类是做什么的，它是用来控制我们类的生成过程的，默认情况下，我们自定义的类都是由type创建的。但是我们可以手动指定某个类的元类，但是在介绍元类之前，我们还需要看一下Python中的两个特殊的魔法方法：__new__和__init__。</strong></p>
<h5 id="new-和-init"><a href="#new-和-init" class="headerlink" title="new__和__init"></a><strong>new__和__init</strong></h5><p><strong>类在实例化的时候会自动调用__init__，但其实在调用__init__之前会先调用__new__。</strong></p>
<ul>
<li><code>__new__: 为实例对象申请一片内存;</code></li>
<li><code>__init__: 为实例对象设置属性;</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;__new__&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;__init__&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">A()  <span class="comment"># __new__</span></span><br></pre></td></tr></table></figure>

<p><strong>然而我们看到只有__new__被调用了，__init__则没有。原因就在于__new__中必须将A的实例对象返回，才会执行__init__，并且执行的时候会自动将__new__的返回值作为参数传给self。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;__new__&quot;</span>)</span><br><span class="line">        <span class="comment"># 这里的参数cls就表示A这个类本身</span></span><br><span class="line">        <span class="comment"># object.__new__(cls) 便是根据cls创建cls的实例对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">object</span>.__new__(cls)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 然后执行__init__, 里面的self指的就是实例对象</span></span><br><span class="line">        <span class="comment"># 在执行__init__的时候, __new__的返回值会自动作为参数传递给这里的self</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;__init__&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">A()  </span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">__new__</span></span><br><span class="line"><span class="string">__init__</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>所以一个对象是什么，取决于其类型对象的__new__返回了什么。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;__new__&quot;</span>)</span><br><span class="line">        <span class="comment"># 这里必须返回A的实例对象, 否则__init__函数是不会执行的</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;__init__&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line"><span class="built_in">print</span>(a + <span class="number">1</span>)  </span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">__new__</span></span><br><span class="line"><span class="string">124</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看到A在实例化之后得到的是一个整型，原因就是__new__返回了123。最后一个就是参数问题，首先我们说__new__是创建实例对象的，__init__是为实例对象绑定属性的。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, name, age</span>):</span><br><span class="line">        <span class="comment"># __new__里面的参数一定要和__init__是匹配的, 除了第一个参数之外</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">object</span>.__new__(cls)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = A(<span class="string">&quot;夏色祭&quot;</span>, -<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 我们这里传入了两个参数, 那么: A、&quot;夏色祭&quot;、-1 就会组合起来, 分别传给__new__的 cls、name、age</span></span><br><span class="line"><span class="comment"># 然后__new__里面返回了一个实例对象</span></span><br><span class="line"><span class="comment"># 那么: object.__new__(cls)、__new__接收的name、__new__接收的age 会组合起来, 分别传给__init__的 self、name、age</span></span><br></pre></td></tr></table></figure>

<h5 id="创建类的另一种方式"><a href="#创建类的另一种方式" class="headerlink" title="创建类的另一种方式"></a>创建类的另一种方式</h5><p><strong>创建类的时候可以使用class关键字创建，除了class关键字之外，我们还可以使用type这个古老却又强大的类来创建。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># type这个类里面可以接收一个参数或者三个参数</span></span><br><span class="line"><span class="comment"># 如果接收一个参数, 那么表示查看类型; 如果接收三个参数, 那么表示创建一个类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    A = <span class="built_in">type</span>(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># type() takes 1 or 3 arguments</span></span><br></pre></td></tr></table></figure>

<p><strong>告诉我们type要么接收一个参数，要么接收三个参数。显然接收一个参数查看类型不需要再说了，我们看看怎么用来用type创建一个类。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># type接收的三个参数: 类名、继承的基类、属性</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">list</span>):</span><br><span class="line">    name = <span class="string">&quot;夏色祭&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面这个类翻译过来就是</span></span><br><span class="line">val = <span class="built_in">type</span>(<span class="string">&quot;A&quot;</span>, (<span class="built_in">list</span>, ), &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;夏色祭&quot;</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(val)  <span class="comment"># &lt;class &#x27;__main__.A&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(val.__name__)  <span class="comment"># A</span></span><br><span class="line"><span class="built_in">print</span>(val.__base__)  <span class="comment"># &lt;class &#x27;list&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(val.name)  <span class="comment"># 夏色祭</span></span><br></pre></td></tr></table></figure>

<p><strong>所以还是很简单的，我们还可以自定义一个类继承自type。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyType</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">mcs, name, bases, attr</span>):</span><br><span class="line">        <span class="built_in">print</span>(name)</span><br><span class="line">        <span class="built_in">print</span>(bases)</span><br><span class="line">        <span class="built_in">print</span>(attr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定metaclass, 表示A这个类由MyType创建</span></span><br><span class="line"><span class="comment"># 我们说__new__是为实例对象开辟内存的, 那么MyType的实例对象是谁呢? 显然就是这里的A</span></span><br><span class="line"><span class="comment"># 因为A指定了metaclass为MyType, 所以A的类型就是MyType</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(<span class="built_in">int</span>, <span class="built_in">object</span>, metaclass=MyType):</span><br><span class="line">    name = <span class="string">&quot;夏色祭&quot;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">A</span></span><br><span class="line"><span class="string">(&lt;class &#x27;int&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;)</span></span><br><span class="line"><span class="string">&#123;&#x27;__module__&#x27;: &#x27;__main__&#x27;, &#x27;__qualname__&#x27;: &#x27;A&#x27;, &#x27;name&#x27;: &#x27;夏色祭&#x27;&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们看到一个类在创建的时候会向元类的__new__中传递三个值</span></span><br><span class="line"><span class="comment"># 分别是类名、继承的基类、类的属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 但是此时A并没有被创建出来</span></span><br><span class="line"><span class="built_in">print</span>(A)  <span class="comment"># None</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">我们说__new__一定要将创建的实例对象返回才可以, 这里的MyType是元类</span></span><br><span class="line"><span class="string">所以类对象A就等于MyType的实例对象, MyType的__new__就负责为类对象A分配空间</span></span><br><span class="line"><span class="string">但是显然我们这里并没有分配, 而且返回的还是一个None, 如果我们返回的是123, 那么print(a)就是123</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>所以元类和类之间的关系 和 类与实例对象的关系，之间是很相似的，因为完全可以把类对象看成是元类的实例对象。因此A既然指定了metaclass为MyType，表示A这个类由MyType创建，那么MyType的__new__函数返回了什么，A就是什么。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyType</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">mcs, name, bases, attr</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;嘿嘿嘿&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(metaclass=MyType):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(A + <span class="string">&quot;哟哟哟&quot;</span>)  <span class="comment"># 嘿嘿嘿哟哟哟</span></span><br></pre></td></tr></table></figure>

<p><strong>这便是Python语言具备的高度动态特性，那么问题来了，如果我想把A创建出来、像普通的类一样使用的话，该咋办呢？因为默认情况下是由type创建，底层帮你做好了，但是现在是我们手动指定元类，那么一切就需要我们来手动指定了。显然，这里创建还是要依赖于type，只不过需要我们手动指定，而且在手动指定的同时我们还可以增加一些我们自己的操作。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyType</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">mcs, name, bases, attr</span>):</span><br><span class="line">        name = name * <span class="number">2</span></span><br><span class="line">        bases = (<span class="built_in">list</span>,)</span><br><span class="line">        attr.update(&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;神乐mea&quot;</span>, <span class="string">&quot;nickname&quot;</span>: <span class="string">&quot;屑女仆&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 这里直接交给type即可, 然后type来负责创建</span></span><br><span class="line">        <span class="comment"># 所以super().__new__实际上会调用type.__new__</span></span><br><span class="line">        <span class="comment"># type(name, bases, attr) 等价于 type.__new__(type, name, bases, attr)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>().__new__(mcs, name, bases, attr)</span><br><span class="line">        <span class="comment"># 但是这里我们将__new__的第一个参数换成了mcs, 也就是这里的MyType</span></span><br><span class="line">        <span class="comment"># 等价于type.__new__(mcs, name, bases, attr)表示将元类设置成MyType</span></span><br><span class="line">        <span class="comment"># 注意: 不能写type(name, bases, attr), 因为这样的话类还是由type创建的</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span>(metaclass=MyType):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们看到类的名字变了, 默认情况下是Girl, 但是我们在创建的时候将name成了个2</span></span><br><span class="line"><span class="built_in">print</span>(Girl.__name__)  <span class="comment"># GirlGirl</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 那么显然Girl这里也要继承自list</span></span><br><span class="line"><span class="built_in">print</span>(Girl(<span class="string">&quot;你好呀&quot;</span>))  <span class="comment"># [&#x27;你&#x27;, &#x27;好&#x27;, &#x27;呀&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 同理Girl还有两个属性</span></span><br><span class="line"><span class="built_in">print</span>(Girl.name, Girl.nickname)  <span class="comment"># 神乐mea 屑女仆</span></span><br></pre></td></tr></table></figure>

<p><strong>我们之前还说过，一个类在没有指定的metaclass的时候，如果它的父类指定了，那么这个类的metaclass等于父类的metaclass。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyType</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">mcs, name, bases, attr</span>):</span><br><span class="line">        name = name * <span class="number">2</span></span><br><span class="line">        bases = (<span class="built_in">list</span>,)</span><br><span class="line">        attr.update(&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;神乐mea&quot;</span>, <span class="string">&quot;nickname&quot;</span>: <span class="string">&quot;屑女仆&quot;</span>&#125;)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>().__new__(mcs, name, bases, attr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span>(metaclass=MyType):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">Girl</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(A.__class__)  <span class="comment"># &lt;class &#x27;__main__.MyType&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(A.__name__)  <span class="comment"># AA</span></span><br></pre></td></tr></table></figure>

<p><strong>我们之前还举了个flask的例子，一种更加优雅的写法。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyType</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">mcs, name, bases, attr</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>().__new__(mcs, name, bases, attr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">with_metaclass</span>(<span class="params">meta, bases</span>):</span><br><span class="line">    <span class="keyword">return</span> meta(<span class="string">&quot;tmp&quot;</span>, bases, &#123;<span class="string">&quot;gender&quot;</span>: <span class="string">&quot;female&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># with_metaclass(MyType, (list,))便会返回一个类</span></span><br><span class="line"><span class="comment"># 这个类由MyType创建, 并且继承自list</span></span><br><span class="line"><span class="comment"># 那么Girl再继承这个类, 等价于Girl也是有MyType创建, 并且也会继承自list</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span>(with_metaclass(MyType, (<span class="built_in">list</span>,))):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(Girl.__class__)  <span class="comment"># &lt;class &#x27;__main__.MyType&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(Girl.__bases__)  <span class="comment"># (&lt;class &#x27;__main__.tmp&#x27;&gt;,)</span></span><br><span class="line"><span class="built_in">print</span>(Girl.__mro__)  <span class="comment"># (&lt;class &#x27;__main__.Girl&#x27;&gt;, &lt;class &#x27;__main__.tmp&#x27;&gt;, &lt;class &#x27;list&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 所以with_metaclass(meta, bases)只是为了帮助我们找到元类和继承的类</span></span><br><span class="line"><span class="comment"># 至于其本身并没有太大的意义, 但我们毕竟继承它了, 就意味着我们也可以找到它的属性</span></span><br><span class="line"><span class="built_in">print</span>(Girl.gender)  <span class="comment"># female</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：我们说创建类的对象是元类，元类要么是type、要么是继承自type的子类。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyType</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">mcs, name, bases, attr</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>().__new__(mcs, name, bases, attr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># type直接加括号表示由type创建, 我们需要通过__new__手动指定</span></span><br><span class="line">Girl = <span class="built_in">type</span>.__new__(MyType, <span class="string">&quot;GirlGirlGirl&quot;</span>, (<span class="built_in">list</span>,), &#123;<span class="string">&quot;foo&quot;</span>: <span class="keyword">lambda</span> self, value: value + <span class="number">123</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(Girl.__name__)  <span class="comment"># GirlGirlGirl</span></span><br><span class="line"></span><br><span class="line">g = Girl()</span><br><span class="line"><span class="built_in">print</span>(g.foo(<span class="number">123</span>))  <span class="comment"># 246</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">type</span>.__new__(<span class="built_in">int</span>, <span class="string">&quot;A&quot;</span>, (<span class="built_in">object</span>,), &#123;&#125;)</span><br><span class="line"><span class="keyword">except</span> TypeError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="comment"># 指定为int则报错, 告诉我们int不是type的子类</span></span><br><span class="line">    <span class="comment"># 因为只有两种情况: 要么是type、要么是type的子类</span></span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># type.__new__(int): int is not a subtype of type</span></span><br></pre></td></tr></table></figure>

<p><strong>怎么样，是不是觉得元类很简单呢？其实元类没有什么复杂的。</strong></p>
<p><strong>再举个例子：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyType</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">mcs, name, bases, attr</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;f&quot;</span> <span class="keyword">in</span> attr:</span><br><span class="line">            attr.pop(<span class="string">&quot;f&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>().__new__(mcs, name, bases, attr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span>(metaclass=MyType):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;f&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">g</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;g&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(Girl().g())  <span class="comment"># g</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(Girl().f())</span><br><span class="line"><span class="keyword">except</span> AttributeError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># &#x27;Girl&#x27; object has no attribute &#x27;f&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">惊了, 我们看到居然没有f这个属性, 我们明显定义了啊, 原因就是我们在创建类的时候将其pop掉了</span></span><br><span class="line"><span class="string">首先创建一个类需要三个元素: 类名、继承的基类、类的一些属性(以字典的形式, 属性名: 属性值)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">然后会将这三个元素交给元类进行创建, 但是我们在创建的时候偷偷地将f从attr里面给pop掉了</span></span><br><span class="line"><span class="string">因此创建出来的类是没有f这个函数的 </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span> </span><br></pre></td></tr></table></figure>

<p><strong>元类确实蛮有趣的，而且也没有想象中的那么难，可以多了解一下。</strong></p>
<h5 id="特殊的魔法函数"><a href="#特殊的魔法函数" class="headerlink" title="特殊的魔法函数"></a>特殊的魔法函数</h5><p><strong>此外我们再来看两个和元类有关的魔法函数：</strong></p>
<p><strong><strong>prepared</strong></strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyType</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__prepare__</span>(<span class="params">mcs, name, bases</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;__prepared__&quot;</span>)</span><br><span class="line">        <span class="comment"># 必须返回一个mapping, 至于它是干什么的我们后面说</span></span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">mcs, name, bases, attr</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;__new__&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>().__new__(mcs, name, bases, attr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span>(metaclass=MyType):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">__prepared__</span></span><br><span class="line"><span class="string">__new__</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看到__prepare__会在__new__方法之前被调用，那么它是做什么的呢？答案是添加属性的，我们解释一下。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyType</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__prepare__</span>(<span class="params">mcs, name, bases</span>):</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;夏色祭&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">mcs, name, bases, attr</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>().__new__(mcs, name, bases, attr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span>(metaclass=MyType):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;f&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">g</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;g&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(Girl.name)  <span class="comment"># 夏色祭</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 现在你应该知道__prepare__是干什么的了吧, 它接收一个name、一个bases, 返回有个mapping</span></span><br><span class="line"><span class="comment"># 我们说name、bases、attr会传递给__new__, 但是在__new__之前会先经过__prepared__</span></span><br><span class="line"><span class="comment"># __prepared__返回一个字典(mapping), 假设叫m吧, 那会将attr和m合并, 相当于执行了attr.update(m)</span></span><br><span class="line"><span class="comment"># 然后再将 name、bases、attr交给__new__</span></span><br></pre></td></tr></table></figure>

<p><strong>此外__prepared__这个方法是被classmethod装饰的，另外里面一定要返回一个mapping，否则报错：TypeError: MyType.<strong>prepare</strong>() must return a mapping, not xxx</strong></p>
<p><strong><strong>init_subclass</strong></strong></p>
<p><strong>它类似于一个钩子函数，在一些简单地场景下可以代替元类。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init_subclass__</span>(<span class="params">cls, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(cls, kwargs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当A被创建的时候, 会触发其父类的__init_subclass__</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">Base</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;class &#x27;__main__.A&#x27;&gt; &#123;&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(Base, name=<span class="string">&quot;夏色祭&quot;</span>, age=-<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;class &#x27;__main__.B&#x27;&gt; &#123;&#x27;name&#x27;: &#x27;夏色祭&#x27;, &#x27;age&#x27;: -1&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>所以父类的__init_subclass__里面的cls并不是父类本身，而是继承它的类。kwargs，就是额外设置的一些属性。因此我们可以实现一个属性添加器。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init_subclass__</span>(<span class="params">cls, **kwargs</span>):</span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> kwargs.items():</span><br><span class="line">            <span class="built_in">setattr</span>(cls, k, v)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(Base, name=<span class="string">&quot;夏色祭&quot;</span>, age=-<span class="number">1</span>, __str__=<span class="keyword">lambda</span> self: <span class="string">&quot;__str__&quot;</span> ):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(A.name, A.age)  <span class="comment"># 夏色祭 -1</span></span><br><span class="line"><span class="built_in">print</span>(A())  <span class="comment"># __str__</span></span><br></pre></td></tr></table></figure>

<p><strong>除了属性添加器，我们还可以实现一个属性拦截器。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init_subclass__</span>(<span class="params">cls, **kwargs</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">hasattr</span>(cls, <span class="string">&quot;yoyoyo&quot;</span>) <span class="keyword">and</span> <span class="built_in">hasattr</span>(cls.yoyoyo, <span class="string">&quot;__code__&quot;</span>):</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">f&quot;<span class="subst">&#123;cls.__name__&#125;</span>不允许定义&#x27;yoyoyo&#x27;函数&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">Base</span>):</span><br><span class="line">    yoyoyo = <span class="number">123</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 由于在创建类的时候就会触发, 所以必须加上try语句</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">Base</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">yoyoyo</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># B不允许定义&#x27;yoyoyo&#x27;函数</span></span><br></pre></td></tr></table></figure>

<p><strong>有了这些元类相关的知识，我们后面在分析源码的时候就会轻松一些。</strong></p>
<h4 id="源码分析类机制与metaclass"><a href="#源码分析类机制与metaclass" class="headerlink" title="源码分析类机制与metaclass"></a>源码分析类机制与metaclass</h4><p><strong>我们说LOAD_BUILD_CLASS是将一个PyFunctionObject变成一个类，尽管它写在最前面，但实际上是需要将class  A对应的PyCodeObject对象包装成一个PyFunctionObject对象之后才能执行。我们说__build_class__是用来将PyFunctionObject变成类的函数，我们来看看它长什么样子。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//python/bltinmodule.c</span></span><br><span class="line"><span class="type">static</span> PyMethodDef builtin_methods[] = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;__build_class__&quot;</span>, (PyCFunction)(<span class="type">void</span>(*)(<span class="type">void</span>))builtin___build_class__,</span><br><span class="line">     METH_FASTCALL | METH_KEYWORDS, build_class_doc&#125;,</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line">builtin___build_class__(PyObject *self, PyObject *<span class="type">const</span> *args, Py_ssize_t nargs,</span><br><span class="line">                        PyObject *kwnames)</span><br><span class="line">&#123;</span><br><span class="line">    PyObject *func, *name, *bases, *mkw, *meta, *winner, *prep, *ns, *orig_bases;</span><br><span class="line">    PyObject *cls = <span class="literal">NULL</span>, *cell = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> isclass = <span class="number">0</span>;   <span class="comment">/* initialize to prevent gcc warning */</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">//我们说了底层调用的是builtin___build_class__</span></span><br><span class="line">    <span class="comment">//class A: 会被翻译成builtin.__build_class__(PyFunctionObject, &quot;class name&quot;)</span></span><br><span class="line">    <span class="comment">//所以这个函数至少需要两个参数</span></span><br><span class="line">    <span class="keyword">if</span> (nargs &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">//参数不足，报错，还记的这个报错信息吗？上面测试过的</span></span><br><span class="line">        PyErr_SetString(PyExc_TypeError,</span><br><span class="line">                        <span class="string">&quot;__build_class__: not enough arguments&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//类对应的PyFunctionObject</span></span><br><span class="line">    func = args[<span class="number">0</span>];   <span class="comment">/* Better be callable */</span></span><br><span class="line">    <span class="keyword">if</span> (!PyFunction_Check(func)) &#123;</span><br><span class="line">        <span class="comment">//如果不是PyFunctionObject，报错，这个信息有印象吗？</span></span><br><span class="line">        PyErr_SetString(PyExc_TypeError,</span><br><span class="line">                        <span class="string">&quot;__build_class__: func must be a function&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//类对应的名字，__build_class__的时候 总要给类起一个名字吧</span></span><br><span class="line">    name = args[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (!PyUnicode_Check(name)) &#123;</span><br><span class="line">        <span class="comment">//如果不是一个PyUnicodeObject，报错，这个有印象吗？</span></span><br><span class="line">        PyErr_SetString(PyExc_TypeError,</span><br><span class="line">                        <span class="string">&quot;__build_class__: name is not a string&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//原始基类</span></span><br><span class="line">    orig_bases = _PyTuple_FromArray(args + <span class="number">2</span>, nargs - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (orig_bases == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//获取class的基类列表</span></span><br><span class="line">    bases = update_bases(orig_bases, args + <span class="number">2</span>, nargs - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (bases == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Py_DECREF(orig_bases);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">if</span> (kwnames == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        meta = <span class="literal">NULL</span>;</span><br><span class="line">        mkw = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        mkw = _PyStack_AsDict(args + nargs, kwnames);</span><br><span class="line">        <span class="keyword">if</span> (mkw == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            Py_DECREF(bases);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//这里获取meta</span></span><br><span class="line">        meta = _PyDict_GetItemIdWithError(mkw, &amp;PyId_metaclass);</span><br><span class="line">        <span class="keyword">if</span> (meta != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            Py_INCREF(meta);</span><br><span class="line">            <span class="keyword">if</span> (_PyDict_DelItemId(mkw, &amp;PyId_metaclass) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                Py_DECREF(meta);</span><br><span class="line">                Py_DECREF(mkw);</span><br><span class="line">                Py_DECREF(bases);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* metaclass is explicitly given, check if it&#x27;s indeed a class */</span></span><br><span class="line">            isclass = PyType_Check(meta);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (PyErr_Occurred()) &#123;</span><br><span class="line">            Py_DECREF(mkw);</span><br><span class="line">            Py_DECREF(bases);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果meta为NULL，这意味着用户没有指定metaclass</span></span><br><span class="line">    <span class="keyword">if</span> (meta == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//然后尝试获取基类，如果没有基类</span></span><br><span class="line">        <span class="keyword">if</span> (PyTuple_GET_SIZE(bases) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//指定metaclass为type</span></span><br><span class="line">            meta = (PyObject *) (&amp;PyType_Type);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//否则获取第一个继承的基类的metaclass</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            PyObject *base0 = PyTuple_GET_ITEM(bases, <span class="number">0</span>);<span class="comment">//拿到第一个基类</span></span><br><span class="line">            meta = (PyObject *) (base0-&gt;ob_type);<span class="comment">//拿到第一个基类的__class__</span></span><br><span class="line">        &#125;</span><br><span class="line">        Py_INCREF(meta);<span class="comment">//meta也是一个类</span></span><br><span class="line">        isclass = <span class="number">1</span>;  <span class="comment">/* meta is really a class */</span></span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//如果设置了元类, 那么isclass为1, 会执行下面的代码</span></span><br><span class="line">    <span class="keyword">if</span> (isclass) &#123;</span><br><span class="line">        <span class="comment">//既然已经选择出了元类, 那么这一步是做什么的呢?</span></span><br><span class="line">        <span class="comment">//这一步是为了解决元类冲突的, 假设有两个继承type的元类MyType1和MyType2, 然后Base1的元类是MyType1、Base2的元类是MyType2</span></span><br><span class="line">        <span class="comment">//那么如果class A(Base1, Base2)的话, 就会报错</span></span><br><span class="line">        <span class="comment">//在Python中有一个要求, 假设class A(Base1, Base2, ..., BaseN), Base1的元类叫Type1、BaseN的元类叫TypeN</span></span><br><span class="line">        <span class="comment">//那么必须满足：</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        Type1是Type2的子类或者父类;</span></span><br><span class="line"><span class="comment">        Type1是Type3的子类或者父类;</span></span><br><span class="line"><span class="comment">        Type1是Type4的子类或者父类;</span></span><br><span class="line"><span class="comment">        ....</span></span><br><span class="line"><span class="comment">        Type1是TypeN的子类或者父类;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//而之所以存在这一限制, 原因就是为了避免属性冲突</span></span><br><span class="line">        winner = (PyObject *)_PyType_CalculateMetaclass((PyTypeObject *)meta,</span><br><span class="line">                                                        bases);</span><br><span class="line">        <span class="keyword">if</span> (winner == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            Py_DECREF(meta);</span><br><span class="line">            Py_XDECREF(mkw);</span><br><span class="line">            Py_DECREF(bases);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (winner != meta) &#123;</span><br><span class="line">            Py_DECREF(meta);</span><br><span class="line">            meta = winner;</span><br><span class="line">            Py_INCREF(meta);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* else: meta is not a class, so we cannot do the metaclass</span></span><br><span class="line"><span class="comment">       calculation, so we will use the explicitly given object as it is */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//寻找__prepare__方法</span></span><br><span class="line">    <span class="keyword">if</span> (_PyObject_LookupAttrId(meta, &amp;PyId___prepare__, &amp;prep) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ns = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这个__prepare__方法必须返回一个mapping，如果返回None，那么默认返回一个空字典</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (prep == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ns = PyDict_New();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//否则将字典返回</span></span><br><span class="line">        PyObject *pargs[<span class="number">2</span>] = &#123;name, bases&#125;;</span><br><span class="line">        <span class="comment">//我们看到这里涉及到了一个函数调用, 这个函数应该有印象吧</span></span><br><span class="line">        ns = _PyObject_FastCallDict(prep, pargs, <span class="number">2</span>, mkw);</span><br><span class="line">        Py_DECREF(prep);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ns == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Py_DECREF(meta);</span><br><span class="line">        Py_XDECREF(mkw);</span><br><span class="line">        Py_DECREF(bases);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!PyMapping_Check(ns)) &#123;</span><br><span class="line">        <span class="comment">//如果返回的不是一个字典，那么报错，这个错误等信息我们也见过了</span></span><br><span class="line">        PyErr_Format(PyExc_TypeError,</span><br><span class="line">                     <span class="string">&quot;%.200s.__prepare__() must return a mapping, not %.200s&quot;</span>,</span><br><span class="line">                     isclass ? ((PyTypeObject *)meta)-&gt;tp_name : <span class="string">&quot;&lt;metaclass&gt;&quot;</span>,</span><br><span class="line">                     Py_TYPE(ns)-&gt;tp_name);</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>可以看到，一个简单的类定义，Python底层究竟做了多少事情啊，不过显然这还没完。</strong></p>
<p><strong>我们前面说，Python虚拟机获得了关于class的属性表(动态元信息)，比如所有的方法、属性，所以我们可以说，class的动态元信息包含了class的所有属性。但是对于这个class对象的类型是什么，应该如何创建、要分配多少内存，却没有任何的信息。而在<code>builtin___build_class__</code>中，metaclass正是关于class对象的另一部分元信息，我们称之为静态元信息。在静态元信息中，隐藏着所有的类对象应该如何创建的信息，注意：是所有的类对象。</strong></p>
<p><strong>从源码中我们可以看到，如果用户指定了metaclass，那么会选择指定的metaclass，如果没有指定，那么会使用第一个继承的基类的__class__作为该class的metaclass。</strong></p>
<p><strong>对于PyLongObject、PyDictObject这些Python中的实例对象，所有的元信息存储在对应的类对象中(PyLong_Type，PyDict_Type)。但是对于类对象来说，其元信息的静态元信息存储在对应的元类(PyType_Type)中，动态元信息则存储在本身的local名字空间中。但是为什么这么做呢？为什么对于类对象来说，其元信息要游离成两部分呢？都存在metaclass里面不香吗？这是因为，用户在.py文件中可以定义不同的class，这个元信息必须、且只能是动态的，所以它是不适合保存在metaclass中的，因此类对象的创建策略等这些所有class都会共用的元信息，会存储在metaclass里面。</strong></p>
<p><strong>像Python的内建对象都是Python静态提供的，它们都具备相同的接口集合(底层都是PyTypeObject结构体实例)，支持什么操作一开始就定义好了。只不过有的可以用，有的不能用。比如PyLongObject可以使用nb_add，但是PyDictObject不能。而PyDictObject可以使用mp_subscript，但是PyLongObject不可以。尽管如此，但这不影响它们的所有元信息都可以完全存储在类型对象中。但是用户自定义的class对象，接口是动态的，不可能在metaclass中静态指定。</strong></p>
<p><strong>既然创建了元类，那么下面显然就开始调用了。通过函数 *PyObject_Call* 调用。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Objects/call.c</span></span><br><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyObject_Call</span><span class="params">(PyObject *callable, PyObject *args, PyObject *kwargs)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//调用了tp_call，指向type_call</span></span><br><span class="line">        call = callable-&gt;ob_type-&gt;tp_call;</span><br><span class="line">        <span class="keyword">if</span> (call == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            PyErr_Format(PyExc_TypeError, <span class="string">&quot;&#x27;%.200s&#x27; object is not callable&quot;</span>,</span><br><span class="line">                         callable-&gt;ob_type-&gt;tp_name);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Objects/typeobject.c</span></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">type_call</span><span class="params">(PyTypeObject *type, PyObject *args, PyObject *kwds)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyObject *obj;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">if</span> (type-&gt;tp_new == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        PyErr_Format(PyExc_TypeError,</span><br><span class="line">                     <span class="string">&quot;cannot create &#x27;%.100s&#x27; instances&quot;</span>,</span><br><span class="line">                     type-&gt;tp_name);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调用tp_new申请内存</span></span><br><span class="line">    obj = type-&gt;tp_new(type, args, kwds);</span><br><span class="line">    obj = _Py_CheckFunctionResult((PyObject*)type, obj, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果是PyType_Type, 那么执行完__new__之后直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (type == &amp;PyType_Type &amp;&amp;</span><br><span class="line">        PyTuple_Check(args) &amp;&amp; PyTuple_GET_SIZE(args) == <span class="number">1</span> &amp;&amp;</span><br><span class="line">        (kwds == <span class="literal">NULL</span> ||</span><br><span class="line">         (PyDict_Check(kwds) &amp;&amp; PyDict_GET_SIZE(kwds) == <span class="number">0</span>)))</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//还记得我们之前说过, __new__里面一定要返回类的实例对象, 否则是不会执行__init__函数的</span></span><br><span class="line">    <span class="comment">//从这里我们也看到了, 如果obj的类型不是对应的类、或者其子类, 那么直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (!PyType_IsSubtype(Py_TYPE(obj), type))</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//然后获取obj的类型</span></span><br><span class="line">    type = Py_TYPE(obj);</span><br><span class="line">    <span class="comment">//如果存在__init__函数, 那么执行构造函数</span></span><br><span class="line">    <span class="keyword">if</span> (type-&gt;tp_init != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="type">int</span> res = type-&gt;tp_init(obj, args, kwds);</span><br><span class="line">        <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            assert(PyErr_Occurred());</span><br><span class="line">            Py_DECREF(obj);</span><br><span class="line">            obj = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            assert(!PyErr_Occurred());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//执行完构造函数之后, 再将实例对象返回</span></span><br><span class="line">    <span class="comment">//注意: 执行了__init__说明obj是实例对象, 如果obj是类对象, 那么是不会走到这里来的</span></span><br><span class="line">    <span class="comment">//执行完元类的__new__之后就返回了</span></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>tp_new指向type_new，这个type_new是我们创建class对象的第一案发现场。我们看一下type_new的源码，位于 *Objects&#x2F;typeobject.c* 中，这个函数的代码比较长，我们会有删减，像那些检测的代码我们就省略掉了。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">type_new</span><span class="params">(PyTypeObject *metatype, PyObject *args, PyObject *kwds)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//都是类的一些动态元信息</span></span><br><span class="line">    PyObject *name, *bases = <span class="literal">NULL</span>, *orig_dict, *dict = <span class="literal">NULL</span>;</span><br><span class="line">    PyObject *qualname, *slots = <span class="literal">NULL</span>, *tmp, *newslots, *cell;</span><br><span class="line">    PyTypeObject *type = <span class="literal">NULL</span>, *base, *tmptype, *winner;</span><br><span class="line">    PyHeapTypeObject *et;</span><br><span class="line">    PyMemberDef *mp;</span><br><span class="line">    Py_ssize_t i, nbases, nslots, slotoffset, name_size;</span><br><span class="line">    <span class="type">int</span> j, may_add_dict, may_add_weak, add_dict, add_weak;</span><br><span class="line">    _Py_IDENTIFIER(__qualname__);</span><br><span class="line">    _Py_IDENTIFIER(__slots__);</span><br><span class="line">    _Py_IDENTIFIER(__classcell__);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//如果metaclass是type的话</span></span><br><span class="line">    <span class="keyword">if</span> (metatype == &amp;PyType_Type) &#123;</span><br><span class="line">        <span class="comment">//获取位置参数和关键字参数个数</span></span><br><span class="line">        <span class="type">const</span> Py_ssize_t nargs = PyTuple_GET_SIZE(args);</span><br><span class="line">        <span class="type">const</span> Py_ssize_t nkwds = kwds == <span class="literal">NULL</span> ? <span class="number">0</span> : PyDict_GET_SIZE(kwds);</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//位置参数为1，关键字参数为0，你想到了什么</span></span><br><span class="line">        <span class="comment">//type(xxx)，是不是这个呀</span></span><br><span class="line">        <span class="keyword">if</span> (nargs == <span class="number">1</span> &amp;&amp; nkwds == <span class="number">0</span>) &#123;</span><br><span class="line">            PyObject *x = PyTuple_GET_ITEM(args, <span class="number">0</span>);</span><br><span class="line">            Py_INCREF(Py_TYPE(x));</span><br><span class="line">            <span class="comment">//这显然是初学Python的时候，就知道的，查看一个变量的类型。</span></span><br><span class="line">            <span class="comment">//获取类型之后直接返回</span></span><br><span class="line">            <span class="keyword">return</span> (PyObject *) Py_TYPE(x);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果上面的if不满足，会走这里，表示现在不再是查看类型了，而是创建类</span></span><br><span class="line">        <span class="comment">//而这里要求位置参数必须是3个，否则报错。</span></span><br><span class="line">        <span class="comment">//我们知道type查看类型，输入一个参数即可，但是创建类需要3个</span></span><br><span class="line">        <span class="keyword">if</span> (nargs != <span class="number">3</span>) &#123;</span><br><span class="line">            PyErr_SetString(PyExc_TypeError,</span><br><span class="line">                            <span class="string">&quot;type() takes 1 or 3 arguments&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check arguments: (name, bases, dict) */</span></span><br><span class="line">    <span class="comment">//现在显然是确定参数类型，对于type来说，你传递了三个参数，但是这三个参数是有类型要求的</span></span><br><span class="line">    <span class="comment">//必须是PyUnicodeObject、PyTupleObject、PyDictObject</span></span><br><span class="line">    <span class="keyword">if</span> (!PyArg_ParseTuple(args, <span class="string">&quot;UO!O!:type.__new__&quot;</span>, &amp;name, &amp;PyTuple_Type,</span><br><span class="line">                          &amp;bases, &amp;PyDict_Type, &amp;orig_dict))</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    type(123, (object, ), &#123;&#125;)  # TypeError: type.__new__() argument 1 must be str, not int</span></span><br><span class="line"><span class="comment">    type(&quot;xx&quot;, [object], &#123;&#125;)  # TypeError: type.__new__() argument 2 must be tuple, not list</span></span><br><span class="line"><span class="comment">    type(&quot;xx&quot;, (object, ), [])  # TypeError: type.__new__() argument 3 must be dict, not list</span></span><br><span class="line"><span class="comment">    */</span>        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理bases为空的情况，另外我们使用class关键字定义类，本质上会转为type定义类的方式</span></span><br><span class="line">    nbases = PyTuple_GET_SIZE(bases);</span><br><span class="line">    <span class="keyword">if</span> (nbases == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果发现我们没有继承基类，那么在Python3中会默认继承object</span></span><br><span class="line">        base = &amp;PyBaseObject_Type; <span class="comment">//base设置为object</span></span><br><span class="line">        bases = PyTuple_Pack(<span class="number">1</span>, base); <span class="comment">//bases设置为(object,)</span></span><br><span class="line">        <span class="keyword">if</span> (bases == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        nbases = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        _Py_IDENTIFIER(__mro_entries__);</span><br><span class="line">        <span class="comment">//如果我们继承了基类</span></span><br><span class="line">        <span class="comment">//那么循环遍历bases</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nbases; i++) &#123;</span><br><span class="line">            <span class="comment">//拿到每一个基类</span></span><br><span class="line">            tmp = PyTuple_GET_ITEM(bases, i);</span><br><span class="line">            <span class="comment">//如果是PyType_Type类型，进行下一次循环</span></span><br><span class="line">            <span class="keyword">if</span> (PyType_Check(tmp)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (_PyObject_LookupAttrId(tmp, &amp;PyId___mro_entries__, &amp;tmp) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (tmp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                PyErr_SetString(PyExc_TypeError,</span><br><span class="line">                                <span class="string">&quot;type() doesn&#x27;t support MRO entry resolution; &quot;</span></span><br><span class="line">                                <span class="string">&quot;use types.new_class()&quot;</span>);</span><br><span class="line">                Py_DECREF(tmp);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Search the bases for the proper metatype to deal with this: */</span></span><br><span class="line">        <span class="comment">//寻找父类的metaclass, 就是我们之前说的解决元类冲突所采取的策略</span></span><br><span class="line">        winner = _PyType_CalculateMetaclass(metatype, bases);</span><br><span class="line">        <span class="keyword">if</span> (winner == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (winner != metatype) &#123;</span><br><span class="line">            <span class="keyword">if</span> (winner-&gt;tp_new != type_new) <span class="comment">/* Pass it to the winner */</span></span><br><span class="line">                <span class="keyword">return</span> winner-&gt;tp_new(winner, args, kwds);</span><br><span class="line">            metatype = winner;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Calculate best base, and check that all bases are type objects */</span></span><br><span class="line">        <span class="comment">//确定最佳base，存储在PyTypeObject *base中</span></span><br><span class="line">        base = best_base(bases);</span><br><span class="line">        <span class="keyword">if</span> (base == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Py_INCREF(bases);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Use &quot;goto error&quot; from this point on as we now own the reference to &quot;bases&quot;. */</span></span><br><span class="line"></span><br><span class="line">    dict = PyDict_Copy(orig_dict);</span><br><span class="line">    <span class="keyword">if</span> (dict == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理用户定义了__slots__属性的逻辑，一旦程序猿定义了__slots__, 那么类的实例对象就没有属性字典了</span></span><br><span class="line">    slots = _PyDict_GetItemIdWithError(dict, &amp;PyId___slots__);</span><br><span class="line">    nslots = <span class="number">0</span>;</span><br><span class="line">    add_dict = <span class="number">0</span>;</span><br><span class="line">    add_weak = <span class="number">0</span>;</span><br><span class="line">    may_add_dict = base-&gt;tp_dictoffset == <span class="number">0</span>;</span><br><span class="line">    may_add_weak = base-&gt;tp_weaklistoffset == <span class="number">0</span> &amp;&amp; base-&gt;tp_itemsize == <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (slots == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//.....</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//.....</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocate the type object */</span></span><br><span class="line">    <span class="comment">//为class对象申请内存</span></span><br><span class="line">    type = (PyTypeObject *)metatype-&gt;tp_alloc(metatype, nslots);</span><br><span class="line">    <span class="keyword">if</span> (type == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Keep name and slots alive in the extended type object */</span></span><br><span class="line">    et = (PyHeapTypeObject *)type;</span><br><span class="line">    Py_INCREF(name);</span><br><span class="line">    et-&gt;ht_name = name;</span><br><span class="line">    et-&gt;ht_slots = slots;</span><br><span class="line">    slots = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化tp_flags */</span></span><br><span class="line">    type-&gt;tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HEAPTYPE |</span><br><span class="line">        Py_TPFLAGS_BASETYPE;</span><br><span class="line">    <span class="keyword">if</span> (base-&gt;tp_flags &amp; Py_TPFLAGS_HAVE_GC)</span><br><span class="line">        type-&gt;tp_flags |= Py_TPFLAGS_HAVE_GC;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//设置PyTypeObject中的各个域</span></span><br><span class="line">    type-&gt;tp_as_async = &amp;et-&gt;as_async;</span><br><span class="line">    type-&gt;tp_as_number = &amp;et-&gt;as_number;</span><br><span class="line">    type-&gt;tp_as_sequence = &amp;et-&gt;as_sequence;</span><br><span class="line">    type-&gt;tp_as_mapping = &amp;et-&gt;as_mapping;</span><br><span class="line">    type-&gt;tp_as_buffer = &amp;et-&gt;as_buffer;</span><br><span class="line">    type-&gt;tp_name = PyUnicode_AsUTF8AndSize(name, &amp;name_size);</span><br><span class="line">    <span class="keyword">if</span> (!type-&gt;tp_name)</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(type-&gt;tp_name) != (<span class="type">size_t</span>)name_size) &#123;</span><br><span class="line">        PyErr_SetString(PyExc_ValueError,</span><br><span class="line">                        <span class="string">&quot;type name must not contain null characters&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置基类和基类列表 */</span></span><br><span class="line">    type-&gt;tp_bases = bases;</span><br><span class="line">    bases = <span class="literal">NULL</span>;</span><br><span class="line">    Py_INCREF(base);</span><br><span class="line">    type-&gt;tp_base = base;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置属性表 */</span></span><br><span class="line">    Py_INCREF(dict);</span><br><span class="line">    type-&gt;tp_dict = dict;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置__module__</span></span><br><span class="line">    <span class="keyword">if</span> (_PyDict_GetItemIdWithError(dict, &amp;PyId___module__) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (PyErr_Occurred()) &#123;</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp = PyEval_GetGlobals();</span><br><span class="line">        <span class="keyword">if</span> (tmp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            tmp = _PyDict_GetItemIdWithError(tmp, &amp;PyId___name__);</span><br><span class="line">            <span class="keyword">if</span> (tmp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (_PyDict_SetItemId(dict, &amp;PyId___module__,</span><br><span class="line">                                      tmp) &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">goto</span> error;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (PyErr_Occurred()) &#123;</span><br><span class="line">                <span class="keyword">goto</span> error;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//设置__qualname__，即&quot;全限定名&quot;</span></span><br><span class="line">    qualname = _PyDict_GetItemIdWithError(dict, &amp;PyId___qualname__);</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果自定义的class中重写了__new__方法，将__new__对应的函数改造为static函数</span></span><br><span class="line">    tmp = _PyDict_GetItemIdWithError(dict, &amp;PyId___new__);</span><br><span class="line">    <span class="keyword">if</span> (tmp != <span class="literal">NULL</span> &amp;&amp; PyFunction_Check(tmp)) &#123;</span><br><span class="line">        tmp = PyStaticMethod_New(tmp);</span><br><span class="line">        <span class="keyword">if</span> (tmp == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">        <span class="keyword">if</span> (_PyDict_SetItemId(dict, &amp;PyId___new__, tmp) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            Py_DECREF(tmp);</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">        &#125;</span><br><span class="line">        Py_DECREF(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (tmp == <span class="literal">NULL</span> &amp;&amp; PyErr_Occurred()) &#123;</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置__init_subclass__，如果子类继承了父类，那么会触发父类的__init_subclass__方法</span></span><br><span class="line">    tmp = _PyDict_GetItemIdWithError(dict, &amp;PyId___init_subclass__);</span><br><span class="line">    <span class="keyword">if</span> (tmp != <span class="literal">NULL</span> &amp;&amp; PyFunction_Check(tmp)) &#123;</span><br><span class="line">        tmp = PyClassMethod_New(tmp);</span><br><span class="line">        <span class="keyword">if</span> (tmp == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">        <span class="keyword">if</span> (_PyDict_SetItemId(dict, &amp;PyId___init_subclass__, tmp) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            Py_DECREF(tmp);</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">        &#125;</span><br><span class="line">        Py_DECREF(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (tmp == <span class="literal">NULL</span> &amp;&amp; PyErr_Occurred()) &#123;</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//设置__class_getitem__，这个是什么？类似于__getitem__</span></span><br><span class="line">    <span class="comment">//__class_getitem__支持通过 类[&quot;xxx&quot;] 的方式访问</span></span><br><span class="line">    tmp = _PyDict_GetItemIdWithError(dict, &amp;PyId___class_getitem__);</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//为class对象对应的instance对象设置内存大小信息 </span></span><br><span class="line">    type-&gt;tp_basicsize = slotoffset;</span><br><span class="line">    type-&gt;tp_itemsize = base-&gt;tp_itemsize;</span><br><span class="line">    type-&gt;tp_members = PyHeapType_GET_MEMBERS(et);</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用PyType_Ready对class对象进行初始化</span></span><br><span class="line">    <span class="keyword">if</span> (PyType_Ready(type) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Put the proper slots in place */</span></span><br><span class="line">    fixup_slot_dispatchers(type);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (type-&gt;tp_dictoffset) &#123;</span><br><span class="line">        et-&gt;ht_cached_keys = _PyDict_NewKeysForClass();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (set_names(type) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (init_subclass(type, kwds) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">    Py_DECREF(dict);</span><br><span class="line">    <span class="keyword">return</span> (PyObject *)type;</span><br><span class="line"></span><br><span class="line">error:</span><br><span class="line">    Py_XDECREF(dict);</span><br><span class="line">    Py_XDECREF(bases);</span><br><span class="line">    Py_XDECREF(slots);</span><br><span class="line">    Py_XDECREF(type);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Python虚拟机首先会将类名、基类列表和属性表从tuple对象中解析出来，然后会基于基类列表及传入的metaclass(参数metatype)确定最佳的metaclass和base。</strong></p>
<p><strong>随后，python虚拟机会调用<code>metatype-&gt;tp_alloc</code>尝试为要创建的类对象分配内存。这里需要注意的是，在PyType_Type中，我们发现tp_alloc是一个NULL，这显然不正常。但是不要忘记，我们之前提到，在Python进行初始化时，会对所有的内建对象通过PyType_Ready进行初始化，在这个初始化过程中，有一项动作就是从基类继承各种操作。由于type.__bases__中的第一个基类是object，所以type会继承object中的tp_alloc操作，即 *PyType_GenericAlloc* 。对于我们的任意继承自object的class对象来说， *PyType_GenericAlloc* 将申请<code>metatype-&gt;tp_basicsize + metatype-&gt;tp_itemsize</code>大小的内存空间。从PyType_Type的定义中我们看到，这个大小实际就是 *sizeof(PyHeapTypeObject) + sizeof(PyMemerDef)* 。因此在这里应该就明白了PyHeapTypeObject这个老铁到底是干嘛用的了，之前因为偏移量的问题，折腾了不少功夫，甚至让人觉得这有啥用啊，但是现在意识到了，这个老铁是为用户自定义class准备的。</strong></p>
<p><strong>接下来就是设置class对象的各个域，其中包括了在tp_dict上设置属性表，也就是__dict__。另外注意的是，这里还计算了类对象对应的实例对象所需要的内存大小信息，换言之，我们类创建一个实例对象时，需要为这个实例对象申请多大的内存空间呢？对于任意继承object的class对象来说，这个大小为<code>PyBaseObject_Type-&gt;tp_basicsize + 16</code>。其中的16是2 * sizeof(PyObject *)。为什么后面要跟着两个PyObject *的空间，因为这些空间的地址被设置给了 *tp_dictoffset* 和 *tp_weaklistoffset* 了呢？这一点将在下一篇博客中进行解析，它是和实例对象的属性字典密切相关的。</strong></p>
<p><strong>最后，Python虚拟机还会调用PyType_Ready对class定义的类对象<code>(这里简称class对象)</code>进行和内建对象一样的初始化动作，到此class对象才算正式创建完毕。那么内建对象和class对象在内存布局上面有什么区别呢？毕竟都是类对象。</strong></p>
<p><img src="/2023/04/10/19-Python%E7%B1%BB%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E4%BB%A5%E5%8F%8AMetaclass/1229382-20200901005736206-1581059838.png" alt="img"></p>
<p><strong>本质上，无论用户自定义的class对象还是内建对象，在Python虚拟机内部，都可以用一个PyTypeObject来表示。但不同的是，内建对象的PyTypeObject以及与其关联的PyNumberMethods等属性的内存位置都是在编译时确定的，它们在内存中的位置是分离的。而用户自定义的class对象的PyTypeObject和PyNumberMethods等内存位置是连续的，必须在运行时动态分配内存。</strong></p>
<p><strong>现在我们算是对python中可调用(callable)这个概念有一个感性认识了，在python中可调用这个概念是一个相当通用的概念，不拘泥于对象、大小，只要类型对象定义了tp_call操作，就能进行调用操作。我们已经看到，python中的对象class对象是调用metaclass创建。那么显然，调用class对象就能得到实例对象。</strong></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><strong>这一次我们介绍了自定义的类在底层是如何实现的，但是关于类的知识点还有很多，比如：魔法方法、描述符等等，我们可能还需要两到三篇来进行介绍。</strong></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Lin Li</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/04/10/19-Python%E7%B1%BB%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E4%BB%A5%E5%8F%8AMetaclass/">http://example.com/2023/04/10/19-Python%E7%B1%BB%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E4%BB%A5%E5%8F%8AMetaclass/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">LinLi's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/CPython/">CPython</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/04/11/What-the-Fork-Finding-Hidden-Code-Clones-in-npm/" title="What the Fork Finding Hidden Code Clones in npm"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">What the Fork Finding Hidden Code Clones in npm</div></div></a></div><div class="next-post pull-right"><a href="/2023/04/10/18-Python%E7%B1%BB%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90-%E7%B1%BB%E7%9A%84%E5%A4%9A%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%B1%9E%E6%80%A7%E6%9F%A5%E6%89%BE/" title="18-Python类机制深度解析-类的多继承与属性查找"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">18-Python类机制深度解析-类的多继承与属性查找</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/03/29/01-%E7%BC%96%E8%AF%91Cpython/" title="01-编译Cpython"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">01-编译Cpython</div></div></a></div><div><a href="/2023/03/29/02-%E4%B8%80%E5%88%87%E5%AF%B9%E8%B1%A1%E7%9A%86PyObject/" title="02-一切对象皆PyObject"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">02-一切对象皆PyObject</div></div></a></div><div><a href="/2023/03/29/04-%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/" title="04-浮点数的底层实现"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">04-浮点数的底层实现</div></div></a></div><div><a href="/2023/03/29/06-Bytes%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BA%95%E5%B1%82%E6%93%8D%E4%BD%9C/" title="06-Bytes对象的底层操作"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">06-Bytes对象的底层操作</div></div></a></div><div><a href="/2023/03/29/03-Python%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E5%99%A8%E5%92%8C%E5%BA%95%E5%B1%82%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86/" title="03-Python引用计数器和底层对象管理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">03-Python引用计数器和底层对象管理</div></div></a></div><div><a href="/2023/03/29/05-Python%E6%95%B4%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/" title="05-Python整数的底层实现"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">05-Python整数的底层实现</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Lin Li</div><div class="author-info__description">今日事，今日毕</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">113</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#19-Python%E7%B1%BB%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E4%BB%A5%E5%8F%8Ametaclass"><span class="toc-number">1.</span> <span class="toc-text">19-Python类机制深度解析：自定义类的底层实现以及metaclass</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A5%94%E5%AD%90"><span class="toc-number">1.1.</span> <span class="toc-text">楔子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89class"><span class="toc-number">1.2.</span> <span class="toc-text">自定义class</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#class%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8A%A8%E6%80%81%E5%85%83%E4%BF%A1%E6%81%AF"><span class="toc-number">1.2.1.</span> <span class="toc-text">class对象的动态元信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E9%A1%BEmetaclass"><span class="toc-number">1.2.2.</span> <span class="toc-text">回顾metaclass</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#new-%E5%92%8C-init"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">new__和__init</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%B1%BB%E7%9A%84%E5%8F%A6%E4%B8%80%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">创建类的另一种方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E7%9A%84%E9%AD%94%E6%B3%95%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">特殊的魔法函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%B1%BB%E6%9C%BA%E5%88%B6%E4%B8%8Emetaclass"><span class="toc-number">1.2.3.</span> <span class="toc-text">源码分析类机制与metaclass</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">1.3.</span> <span class="toc-text">小结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/27/Explaining-Structured-Queries-in-Natural-Language/" title="Explaining Structured Queries in Natural Language">Explaining Structured Queries in Natural Language</a><time datetime="2024-12-27T09:15:17.000Z" title="发表于 2024-12-27 17:15:17">2024-12-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/24/Fuzzing-JavaScript-Interpreters-with-Coverage-Guided-Reinforcement-Learning-for-LLM-Based-Mutation/" title="Fuzzing JavaScript Interpreters with Coverage-Guided Reinforcement Learning for LLM-Based Mutation">Fuzzing JavaScript Interpreters with Coverage-Guided Reinforcement Learning for LLM-Based Mutation</a><time datetime="2024-12-24T10:16:03.000Z" title="发表于 2024-12-24 18:16:03">2024-12-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/15/Finding-Logic-Bugs-in-Spatial-Database-Engines-via-Affine-Equivalent-Inputs/" title="Finding Logic Bugs in Spatial Database Engines via  Affine Equivalent Inputs">Finding Logic Bugs in Spatial Database Engines via  Affine Equivalent Inputs</a><time datetime="2024-12-15T08:36:36.000Z" title="发表于 2024-12-15 16:36:36">2024-12-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/02/ClDiff-Generating-Concise-Linked-Code-Differences/" title="ClDiff: Generating Concise Linked Code Differences">ClDiff: Generating Concise Linked Code Differences</a><time datetime="2024-12-02T02:37:55.000Z" title="发表于 2024-12-02 10:37:55">2024-12-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/30/Drowzee-Metamorphic-Testing-for-Fact-Conflicting-Hallucination-Detection-in-Large-Language-Models/" title="Drowzee Metamorphic Testing for Fact-Conflicting Hallucination Detection in Large Language Models">Drowzee Metamorphic Testing for Fact-Conflicting Hallucination Detection in Large Language Models</a><time datetime="2024-11-30T08:49:19.000Z" title="发表于 2024-11-30 16:49:19">2024-11-30</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Lin Li</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>