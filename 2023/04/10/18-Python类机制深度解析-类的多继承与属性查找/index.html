<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>18-Python类机制深度解析-类的多继承与属性查找 | LinLi's Blog</title><meta name="author" content="Lin Li"><meta name="copyright" content="Lin Li"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="18-Python类机制深度解析-类的多继承与属性查找楔子这次我们来看一下Python中类的继承与属性查找机制，我们说Python是支持类的多继承的，在查找属性的时候会沿着继承链不断找下去。那么下面我们就来深入地考察一下类的继承与属性查找在底层是如何实现的。 深入class我们知道Python里面有很多以双下划线开头、双下划线结尾的方法，我们称之为魔法方法。Python中的每一个操作符，都被抽象成">
<meta property="og:type" content="article">
<meta property="og:title" content="18-Python类机制深度解析-类的多继承与属性查找">
<meta property="og:url" content="http://example.com/2023/04/10/18-Python%E7%B1%BB%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90-%E7%B1%BB%E7%9A%84%E5%A4%9A%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%B1%9E%E6%80%A7%E6%9F%A5%E6%89%BE/index.html">
<meta property="og:site_name" content="LinLi&#39;s Blog">
<meta property="og:description" content="18-Python类机制深度解析-类的多继承与属性查找楔子这次我们来看一下Python中类的继承与属性查找机制，我们说Python是支持类的多继承的，在查找属性的时候会沿着继承链不断找下去。那么下面我们就来深入地考察一下类的继承与属性查找在底层是如何实现的。 深入class我们知道Python里面有很多以双下划线开头、双下划线结尾的方法，我们称之为魔法方法。Python中的每一个操作符，都被抽象成">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2023-04-10T01:30:42.000Z">
<meta property="article:modified_time" content="2023-04-12T02:39:06.977Z">
<meta property="article:author" content="Lin Li">
<meta property="article:tag" content="CPython">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/04/10/18-Python%E7%B1%BB%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90-%E7%B1%BB%E7%9A%84%E5%A4%9A%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%B1%9E%E6%80%A7%E6%9F%A5%E6%89%BE/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '18-Python类机制深度解析-类的多继承与属性查找',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-04-12 10:39:06'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">122</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="LinLi's Blog"><span class="site-name">LinLi's Blog</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">18-Python类机制深度解析-类的多继承与属性查找</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-04-10T01:30:42.000Z" title="发表于 2023-04-10 09:30:42">2023-04-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-04-12T02:39:06.977Z" title="更新于 2023-04-12 10:39:06">2023-04-12</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="18-Python类机制深度解析-类的多继承与属性查找"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="18-Python类机制深度解析-类的多继承与属性查找"><a href="#18-Python类机制深度解析-类的多继承与属性查找" class="headerlink" title="18-Python类机制深度解析-类的多继承与属性查找"></a>18-Python类机制深度解析-类的多继承与属性查找</h2><h3 id="楔子"><a href="#楔子" class="headerlink" title="楔子"></a>楔子</h3><p><strong>这次我们来看一下Python中类的继承与属性查找机制，我们说Python是支持类的多继承的，在查找属性的时候会沿着继承链不断找下去。那么下面我们就来深入地考察一下类的继承与属性查找在底层是如何实现的。</strong></p>
<h3 id="深入class"><a href="#深入class" class="headerlink" title="深入class"></a>深入class</h3><p><strong>我们知道Python里面有很多以双下划线开头、双下划线结尾的方法，我们称之为魔法方法。Python中的每一个操作符，都被抽象成了一个魔法方法。比如整数3，整数可以相减，这就代表int这个类里面肯定定义了__sub__函数。字符串不能相减，代表str这个类里面没有__sub__函数；而整数和字符串都可以执行加法操作，显然int、str内部都定义了__add__函数。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyInt</span>(<span class="title class_ inherited__">int</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__sub__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>.__sub__(self, other) * <span class="number">3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = MyInt(<span class="number">4</span>)</span><br><span class="line">b = MyInt(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(a - b)  <span class="comment"># 9</span></span><br></pre></td></tr></table></figure>

<p><strong>我们自己实现了一个类，继承自int。当我执行a -  b的时候，肯定执行对应的__sub__方法，然后调用int的__sub__方法，得到结果之后再乘上3，逻辑上没有问题。但是问题来了，首先调用int.__sub__的时候，我们知道Python肯定是调用long_as_number中的long_sub指向的函数，这些在之前已经说过了，但我想问的是<code>int.__sub__(self, other)</code>里面的参数类型显然都应该是int，但是我们传递的是MyInt，那么Python虚拟机是怎么做的呢？</strong></p>
<p><strong>目前带着这些疑问，先来看一张草图，我们后面会一点一点揭开：</strong></p>
<p><img src="/2023/04/10/18-Python%E7%B1%BB%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90-%E7%B1%BB%E7%9A%84%E5%A4%9A%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%B1%9E%E6%80%A7%E6%9F%A5%E6%89%BE/1229382-20200830184211047-206605120.png" alt="img"></p>
<p><strong>图中的”<strong>sub</strong>“对应的value并不是一个直接指向long_sub函数的指针，而是一个别的什么东西，对其进行调用，调用的结果指向long_sub函数。至于这个东西是什么，以及具体细节，我们后面会详细说。</strong></p>
<p><strong>另外我们知道，一个对象能否被调用，取决于它的类型对象中是否定义了__call__函数。因此：所谓调用，就是执行类型对象中的tp_call指向的函数。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;我是CALL，我被尻了&quot;</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">a = A()</span><br><span class="line"><span class="built_in">print</span>(a())  <span class="comment"># 我是CALL，我被尻了</span></span><br></pre></td></tr></table></figure>

<p><strong>在Python底层，实际上是通过一个PyObject_Call函数对实例对象a进行操作。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line">a()</span><br><span class="line"><span class="comment"># TypeError: &#x27;int&#x27; object is not callable</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看到一个整数对象是不可调用的，这显然意味着int这个类里面没有__call__函数，换言之PyLongObject结构体对应的ob_type域里面的tp_call为NULL。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 但是我们通过反射打印的时候,发现int是有__call__函数的啊</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hasattr</span>(<span class="built_in">int</span>, <span class="string">&quot;__call__&quot;</span>))  <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 但其实这个__call__不是int里面的,而是type的</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;__call__&quot;</span> <span class="keyword">in</span> <span class="built_in">dir</span>(<span class="built_in">int</span>))  <span class="comment"># False</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;__call__&quot;</span> <span class="keyword">in</span> <span class="built_in">dir</span>(<span class="built_in">type</span>))  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>.__call__)  <span class="comment"># &lt;method-wrapper &#x27;__call__&#x27; of type object at 0x00007FFAE22C0D10&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># hasattr和类的属性查找一样，如果找不到会自动到对应的类型对象里面去找</span></span><br><span class="line"><span class="comment"># int的类型是type, 而type里面有__call__, 因此即便int里面没有, hasattr(int, &quot;__call__&quot;)依旧是True</span></span><br><span class="line">a1 = <span class="built_in">int</span>(<span class="string">&quot;123&quot;</span>)</span><br><span class="line">a2 = <span class="built_in">int</span>.__call__(<span class="string">&quot;123&quot;</span>)</span><br><span class="line">a3 = <span class="built_in">type</span>.__call__(<span class="built_in">int</span>, <span class="string">&quot;123&quot;</span>)</span><br><span class="line"><span class="comment"># 以上三者的本质是一样的</span></span><br><span class="line"><span class="built_in">print</span>(a1, a2, a3)  <span class="comment"># 123 123 123</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 之前说过, 当一个对象加上括号的时候, 本质上调用其类型对象里面的__call__函数</span></span><br><span class="line"><span class="comment"># a = 3</span></span><br><span class="line"><span class="comment"># 那么a()就相当于调用int里面的__call__函数，但是int里面没有，就直接报错了</span></span><br><span class="line"><span class="comment"># 可能这里就有人问了, 难道不会到type里面找吗？答案是不会的，因为type是元类, 是用来生成类的</span></span><br><span class="line"><span class="comment"># 如果还能到type里面找, 那么调用type的__call__生成的结果到底算什么呢？是类对象？可它又明明是实例对象加上括号调用的。显然这样就乱套了</span></span><br><span class="line"><span class="comment"># 因此实例对象找不到, 会到类对象里面找, 如果类对象再找不到, 就不会再去元类里面找了, 而是会去父类里面找</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(self)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;我被尻了&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">A</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(<span class="title class_ inherited__">B</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">c = C()</span><br><span class="line"><span class="built_in">print</span>(c())</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;__main__.C object at 0x000002282F3D9B80&gt;</span></span><br><span class="line"><span class="string">我被尻了</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 此时我们看到, 给C的实例对象加括号的时候, C里面没有__call__函数, 这个时候是不会到元类里面找的</span></span><br><span class="line"><span class="comment"># 还是之前的结论,实例对象找不到属性,会去类对象里面找,然而即便此时类对象里面也没有,也不会到元类type里面找,这时候就看父类了</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们看对于我们上面的例子，给C的实例对象加括号的时候，会执行C这个类里面的__call__</span></span><br><span class="line"><span class="comment"># 但是它没有，所以找不到。然而它继承的父类里面有__call__</span></span><br><span class="line"><span class="comment"># 因此会执行继承的父类的__call__方法, 并且里面的self还是C的实例对象</span></span><br></pre></td></tr></table></figure>

<p><strong>因此一个对象的属性查找，我们可以得到如下规律：首先从对象本身进行查找，没有的话会从该对象的类型对象中进行查找，还没有的话就从类型对象所继承的父类中进行查找。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(self)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;我被尻了&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">A</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(<span class="title class_ inherited__">B</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">c = C()</span><br><span class="line"><span class="built_in">print</span>(c())</span><br></pre></td></tr></table></figure>

<p><strong>还是以这段代码为例：当调用类型对象C的时候，本质上是执行类型对象C的类型对象(type)里面的__call__函数。当调用实例对象c的时候，本质上是执行类型对象C里面的__call__函数，但是C里面没有，这个时候怎么做？显然是沿着继承链进行属性查找，去找C继承的类里面的__call__函数。</strong></p>
<p><img src="/2023/04/10/18-Python%E7%B1%BB%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90-%E7%B1%BB%E7%9A%84%E5%A4%9A%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%B1%9E%E6%80%A7%E6%9F%A5%E6%89%BE/1229382-20200830184220438-2140987487.png" alt="img"></p>
<p><strong>可能有人好奇，为什么没有object？答案是object内部没有__call__函数，所以object.__call__实际上就是type.__call__。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">object</span>.__call__)  <span class="comment"># &lt;method-wrapper &#x27;__call__&#x27; of type object at 0x00007FFD0A896B50&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>因为object的类型是type，所以调用object的时候，实际上执行的是type.<strong>call</strong>(object)。</strong></p>
<p><strong>所以所有的类对象都是可以调用的，因为type是它们的类型对象，而type内部是有__call__函数的。但是默认情况下实例对象是不可调用的，如果实例对象的类型对象、以及该类型对象所继承的类中没有定义__call__函数的话，因为沿着继承链查找的时候，会挨个进行搜索，当搜索到object时发现还没有__call__函数的话，那么就报错了。</strong></p>
<p><strong>所以一个整数对象是不可调用的，但是我们发现这并不是在编译的时候就能够检测出来的错误，而是在运行时才能检测出来、会在运行时通过函数 *PyObject_CallFunctionObjArgs* 确定。所以<code>a = 1;a()</code>明明会报错，但Python还是成功编译了。</strong></p>
<p><strong>为什么会是这样呢？我们知道一个对象对应的类型对象都会有tp_dict这个域，这个域指向一个PyDictObject，表示这个对象支持哪些操作，而这个PyDictObject对象必须要在运行时动态构建。所以都说Python效率慢，一个原因是所有对象都分配在堆上，还有一个原因就是一个对象很多属性或者操作、甚至是该对象是什么类型都需要在运行时动态构建，从而也就造成了Python运行时效率不高。</strong></p>
<p><strong>而且我们发现，像int、str、dict等内建对象可以直接使用。这是因为Python解释器在启动时，会对这些内建对象进行初始化的动作。这个初始化的动作会动态地在这些内建对象对应的PyTypeObject中填充一些重要的东西，其中当然也包括填充tp_dict，从而让这些内建对象具备生成实例对象的能力。这个对内建对象进行初始化的动作就从函数 *PyType_Ready* 拉开序幕。</strong></p>
<p><strong>Python底层通过调用函数 *PyType_Ready* 对内建对象进行初始化，实际上， *PyType_Ready* 不仅仅是处理内建对象，还会处理class对象，并且 *PyType_Ready* 对于内建对象和class对象的作用还不同。比如PyList_Type，它在底层是已经被定义好了的，所以在解释器启动的时候就直接创建，并且是全局对象。只不过我们说它还是不够完善，还需要再打磨一下，而这一步就交给了 *PyType_Ready* 。</strong></p>
<p><strong>但是对于我们自定义的类就不同了，我们说内建的类在底层都是定义好了的，随着解释器启动的时候就已经创建了，已经具备了绝大部分功能，然后再交给 *PyType_Ready* 完善一下，内建的类就形成了；但是对于我们自定义的类来说， *PyType_Ready* 做的工作只是很小的一部分，因为我们使用class定义的类、假设是class  A，Python一开始是并不知道的。Python解释器在启动的时候，不可能直接就创建一个PyA_Type出来，因此对于我们自定义的类来说，需要在解释执行的时候进行申请内存、创建、初始化整个动作序列等等一系列步骤。</strong></p>
<p><strong>下面我们就以Python中的type类型对象入手，因为它比较特殊。Python中的type在底层对应PyType_Type，我们说Python中type是int、str、dict、object、type等内建对象的元类。但是在底层，这些所有的内建类型都是一个PyTypeObject对象。</strong></p>
<ul>
<li><code>int: PyLong_Type</code></li>
<li><code>str: PyUnicode_Type</code></li>
<li><code>tuple: PyTuple_Type</code></li>
<li><code>dict: PyDict_Type</code></li>
<li><code>type: PyType_Type</code></li>
</ul>
<p><strong>从名字也能看出来规律，这些内建对象在Python底层中，都是一个PyTypeObject对象、或者说一个PyTypeObject结构体实例。尽管在Python中说type是所有类对象<code>(所有内建对象+class对象)</code>的元类，但是在Python底层它们都是同一个类型、也就是同一个结构体的不同实例。</strong></p>
<h3 id="处理基类和type信息"><a href="#处理基类和type信息" class="headerlink" title="处理基类和type信息"></a>处理基类和type信息</h3><p><strong>我们来看一下 *PyType_Ready* ，它位于 *Objects &#x2F; typeobject.c* 中。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">PyType_Ready</span><span class="params">(PyTypeObject *type)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//这里的参数显然是类型对象, 以&lt;class &#x27;type&#x27;&gt;为例</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//__dict__和__bases__, 因为可以继承多个类, 所以是bases, 当然不用想这些基类也都是PyTypeObject对象</span></span><br><span class="line">    PyObject *dict, *bases;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//还是继承的基类，显然这个是object，对应PyBaseObject_Type，因为py3中，所有的类都是默认继承的</span></span><br><span class="line">    PyTypeObject *base;</span><br><span class="line">    Py_ssize_t i, n;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取类型对象中tp_base域指定的基类</span></span><br><span class="line">    base = type-&gt;tp_base;</span><br><span class="line">    <span class="keyword">if</span> (base == <span class="literal">NULL</span> &amp;&amp; type != &amp;PyBaseObject_Type) &#123;</span><br><span class="line">        <span class="comment">//如果基类为空、并且该类本身不是object, 那么将该类的基类设置为object、即PyBaseObject_Type</span></span><br><span class="line">        <span class="comment">//所以我们之前看一些类型对象的底层定义的时候, 发现源码中tp_base域对应的是0, 因为tp_base是在这里进行设置的</span></span><br><span class="line">        base = type-&gt;tp_base = &amp;PyBaseObject_Type;</span><br><span class="line">        Py_INCREF(base);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果基类不是NULL, 但是基类的属性字典是NULL</span></span><br><span class="line">    <span class="keyword">if</span> (base != <span class="literal">NULL</span> &amp;&amp; base-&gt;tp_dict == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//那么对基类进行初始化, 所以这里是一个是一个递归调用</span></span><br><span class="line">        <span class="keyword">if</span> (PyType_Ready(base) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果该类型对象的ob_type为空NULL但是基类不为NULL, 那么将该类型对象的ob_type设置为基类的ob_type</span></span><br><span class="line">    <span class="comment">//为什么要做这一步, 我们后面会详细说</span></span><br><span class="line">    <span class="comment">//但其实base != NULL是没必要的, 因为只有当类型为PyBaseObject_type时, base才为NULL</span></span><br><span class="line">    <span class="keyword">if</span> (Py_TYPE(type) == <span class="literal">NULL</span> &amp;&amp; base != <span class="literal">NULL</span>)</span><br><span class="line">        Py_TYPE(type) = Py_TYPE(base);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里是设置__bases__, 后面说</span></span><br><span class="line">    bases = type-&gt;tp_bases;</span><br><span class="line">    <span class="keyword">if</span> (bases == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (base == <span class="literal">NULL</span>)</span><br><span class="line">            bases = PyTuple_New(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            bases = PyTuple_Pack(<span class="number">1</span>, base);</span><br><span class="line">        <span class="keyword">if</span> (bases == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">        type-&gt;tp_bases = bases;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造属性字典, 后面说</span></span><br><span class="line">    dict = type-&gt;tp_dict;</span><br><span class="line">    <span class="keyword">if</span> (dict == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        dict = PyDict_New();</span><br><span class="line">        <span class="keyword">if</span> (dict == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">        type-&gt;tp_dict = dict;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>对于指定了tb_base的类对象，当然就使用指定的基类，而对于没有指定tp_base的类对象，Python将为其指定一个默认的基类： *PyBaseObject_Type*  ，当然这个东西就是Python中的object。现在我们看到PyType_Type的tp_base指向了PyBaseObject_Type，这在Python中体现的就是type继承自object、或者说object是type的父类。但是所有的类底层对应的结构体的ob_type域又都指向了PyType_Type，包括object，因此我们又说type是包括object在内的所有类的类<code>(元类)</code>。</strong></p>
<p><strong>在获得了基类之后，就会判断基类是否被初始化，如果没有，则需要先对基类进行初始化。可以看到， 判断初始化是否完成的条件是<code>base-&gt;tp_dict</code>是否为NULL，这符合之前的描述。对于内建对象的初始化来说，在Python解释器启动的时候，就已经作为全局对象存在了，剩下的就是小小的完善一下，比如对tp_dict进行填充。</strong></p>
<p><strong>然后设置ob_type信息，实际上这个ob_type就是__class__返回的信息。首先 *PyType_Ready* 函数里面接收的是一个PyTypeObject对象，我们知道这个在Python中就是类对象。因此这里是设置这些类对象的ob_type，那么对应的ob_type显然就是元类metaclass，我们自然会想象到Python中的type。但是我们发现<code>Py_TYPE(type) = Py_TYPE(base);</code>这一行代码是把父类的ob_type设置成了当前类的ob_type，那么这一步的意义何在呢？我们使用Python来演示一下。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyType</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(metaclass=MyType):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">A</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(A))  <span class="comment"># &lt;class &#x27;__main__.MyType&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(B))  <span class="comment"># &lt;class &#x27;__main__.MyType&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看到B继承了A，而A的类型是MyType，那么B的类型也成了MyType。也就是说A类是由<code>XX</code>生成的，那么B在继承A的时候，B也会由<code>XX</code>生成，所以源码中的那一步就是用来做这件事情的。另外，这里之所以用<code>XX</code>代替，是因为Python中不仅仅type可以是元类，那些继承了type的子类也可以是元类。</strong></p>
<p><strong>而且如果你熟悉flask的话，你会发现flask源码里面就有类似于这样的操作：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyType</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">mcs, name, bases, attrs</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        关于第一个参数我们需要说一下, 对于一般的类来说这里应该是cls</span></span><br><span class="line"><span class="string">        但我们这里是元类, 所以用mcs代替</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 我们额外设置一些属性吧, 关于元类我们后续会介绍</span></span><br><span class="line">        <span class="comment"># 不过个人觉得既然要学习解释器, 那么首先至少应该在Python层面上知道用法</span></span><br><span class="line">        <span class="comment"># 尽管不知道底层实现, 但至少使用方法应该知道</span></span><br><span class="line">        <span class="keyword">if</span> name.startswith(<span class="string">&quot;G&quot;</span>):</span><br><span class="line">            <span class="comment"># 如果类名以G开头, 那么就设置一些属性吧</span></span><br><span class="line">            attrs.update(&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;夏色祭&quot;</span>&#125;)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>().__new__(mcs, name, bases, attrs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">with_metaclass</span>(<span class="params">meta, bases=(<span class="params"><span class="built_in">object</span>, </span>)</span>):</span><br><span class="line">    <span class="keyword">return</span> meta(<span class="string">&quot;&quot;</span>, bases, &#123;&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span>(with_metaclass(MyType, (<span class="built_in">int</span>,))):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(Girl))  <span class="comment"># &lt;class &#x27;__main__.MyType&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">getattr</span>(Girl, <span class="string">&quot;name&quot;</span>))  <span class="comment"># 夏色祭</span></span><br></pre></td></tr></table></figure>

<p><strong>所以个位应该明白下面的代码是做什么的了，Python虚拟机就是将基类的metaclass设置为子类的metaclass。对于当前的PyType_Type来说，其metaclass就是object的metaclass，也是它自己，而在源码的PyBaseObject_Type中可以看到其ob_type是被设置成了PyType_Type的。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置type信息</span></span><br><span class="line">   <span class="keyword">if</span> (Py_TYPE(type) == <span class="literal">NULL</span> &amp;&amp; base != <span class="literal">NULL</span>)</span><br><span class="line">       Py_TYPE(type) = Py_TYPE(base);</span><br></pre></td></tr></table></figure>

<p><strong>既然继承了PyBaseObject_Type，那么便会首先初始化PyBaseObject_Type，我们下面来看看这个PyBaseObject_Type、Python中的object是怎么被初始化的。</strong></p>
<h3 id="处理基类列表"><a href="#处理基类列表" class="headerlink" title="处理基类列表"></a>处理基类列表</h3><p><strong>接下来，Python虚拟机会处理类型的基类列表，因为Python支持多重继承，所以每一个Python的类对象都会有一个基类、或者说父类列表。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">PyType_Ready</span><span class="params">(PyTypeObject *type)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyObject *dict, *bases;</span><br><span class="line">    PyTypeObject *base;</span><br><span class="line">    Py_ssize_t i, n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取tp_base中指定的基类</span></span><br><span class="line">    base = type-&gt;tp_base;</span><br><span class="line">    <span class="keyword">if</span> (base == <span class="literal">NULL</span> &amp;&amp; type != &amp;PyBaseObject_Type) &#123;</span><br><span class="line">        base = type-&gt;tp_base = &amp;PyBaseObject_Type;</span><br><span class="line">        Py_INCREF(base);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    ...    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理bases：基类列表</span></span><br><span class="line">    bases = type-&gt;tp_bases;</span><br><span class="line">    <span class="comment">//如果bases为空</span></span><br><span class="line">    <span class="keyword">if</span> (bases == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//如果base也为空，说明这个类型对象一定是PyBaseObject_Type</span></span><br><span class="line">        <span class="comment">//因为Python中任何类都继承自object，除了object自身</span></span><br><span class="line">        <span class="keyword">if</span> (base == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="comment">//那么这时候bases就是个空元组，元素个数为0</span></span><br><span class="line">            bases = PyTuple_New(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//否则的话，就申请只有一个空间的元素，然后将PyBaseObject_Type塞进去</span></span><br><span class="line">            bases = PyTuple_Pack(<span class="number">1</span>, base);</span><br><span class="line">        <span class="keyword">if</span> (bases == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">        <span class="comment">//设置bases</span></span><br><span class="line">        type-&gt;tp_bases = bases;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>因此我们看到有两个属性，一个是tp_base，一个是tp_bases，我们看看这俩在Python中的区别。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">A</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>(B, C):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(D.__base__)  <span class="comment"># &lt;class &#x27;__main__.B&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(D.__bases__)  <span class="comment"># (&lt;class &#x27;__main__.B&#x27;&gt;, &lt;class &#x27;__main__.C&#x27;&gt;)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(C.__base__)  <span class="comment"># &lt;class &#x27;object&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(C.__bases__)  <span class="comment"># (&lt;class &#x27;object&#x27;&gt;,)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(B.__base__)  <span class="comment"># &lt;class &#x27;__main__.A&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(B.__bases__)  <span class="comment"># (&lt;class &#x27;__main__.A&#x27;&gt;,)</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看到D同时继承多个类，那么tp_base就是先出现的那个基类，而tp_bases则是继承的所有基类，但是基类的基类是不会出现的，比如object。对于class B也是一样的。然后我们看看class  C，因为C没有显式地继承任何类，那么tp_bases就是NULL，但是Python3中所有的类都默认继承了object，所以tp_base就是PyBaseObject_Type，那么就会把tp_base拷贝到tp_bases里面，因此也就出现了这个结果。</strong></p>
<h3 id="填充tp-dict"><a href="#填充tp-dict" class="headerlink" title="填充tp_dict"></a>填充tp_dict</h3><p><strong>在设置完类型和基类之后，下面Python虚拟机就进入了激动人心的tp_dict的填充阶段，也就是设置属性字典，这是一个极其繁复、极其繁复、极其繁复的过程。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">PyType_Ready</span><span class="params">(PyTypeObject *type)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyObject *dict, *bases;</span><br><span class="line">    PyTypeObject *base;</span><br><span class="line">    Py_ssize_t i, n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//......   </span></span><br><span class="line">    <span class="comment">//初始化tp_dict</span></span><br><span class="line">    dict = type-&gt;tp_dict;</span><br><span class="line">    <span class="keyword">if</span> (dict == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        dict = PyDict_New();</span><br><span class="line">        <span class="keyword">if</span> (dict == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">        type-&gt;tp_dict = dict;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将与type相关的操作加入到tp_dict中</span></span><br><span class="line">    <span class="comment">//注意: 这里的type是PyType_Ready的参数中的type, 所以它可以是Python中的&lt;class &#x27;type&#x27;&gt;、也可以是&lt;class &#x27;int&#x27;&gt;</span></span><br><span class="line">    <span class="keyword">if</span> (add_operators(type) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    <span class="keyword">if</span> (type-&gt;tp_methods != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (add_methods(type, type-&gt;tp_methods) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (type-&gt;tp_members != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (add_members(type, type-&gt;tp_members) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (type-&gt;tp_getset != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (add_getset(type, type-&gt;tp_getset) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在这个阶段，完成了将<code>(&quot;__sub__&quot;, &amp;long_sub)</code>加入tp_dict的过程，里面的 *add_operators* 、 *add_methods* 、 *add_members* 、 *add_getset* 都是完成填充tp_dict的动作。那么这时候一个问题就出现了，Python是如何知道__add__和long_add之间存在关联的呢？其实这种关联显然是一开始就已经定好了的，而且存放在一个名为 *slotdefs* 的数组中。</strong></p>
<h4 id="slot与操作排序"><a href="#slot与操作排序" class="headerlink" title="slot与操作排序"></a>slot与操作排序</h4><p><strong>在进入填充tp_dict的复杂操作之前，我们先来看一下Python中的一个概念：slot。在Python内部，slot可以视为表示PyTypeObject中定义的操作，一个操作对应一个slot，但是slot又不仅仅包含一个函数指针，它还包含一些其它信息，我们看看它的结构。在Python内部，slot是通过slotdef这个结构体来实现的。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//typeobject.c</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">wrapperbase</span> <span class="title">slotdef</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//descrobject.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">wrapperbase</span> &#123;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">int</span> offset;</span><br><span class="line">    <span class="type">void</span> *function;</span><br><span class="line">    wrapperfunc wrapper;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *doc;</span><br><span class="line">    <span class="type">int</span> flags;</span><br><span class="line">    PyObject *name_strobj;</span><br><span class="line">&#125;;  <span class="comment">//从定义上看, 我们发现slot不是一个PyObject</span></span><br></pre></td></tr></table></figure>

<p><strong>在一个slot中，就存储着PyTypeObject中一种操作对应的各种信息，比如：int实例对象<code>(PyLongObject)</code>支持哪些行为，就看类型对象int<code>(PyLong_Type)</code>定义了哪些操作，而PyTypeObject对象中的一个操作就会有一个slot与之对应。slot里面的name就是操作对应的名称，比如字符串__sub__，offset则是操作的函数地址在PyHeapTypeObject中的偏移量，而function则指向一种名为slot function的函数。</strong></p>
<p><strong>Python中提供了多个宏来定义一个slot，其中最基本是TPSLOT和ETSLOT。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//typeobject.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TPSLOT(NAME, SLOT, FUNCTION, WRAPPER, DOC) \</span></span><br><span class="line"><span class="meta">    &#123;NAME, offsetof(PyTypeObject, SLOT), (void *)(FUNCTION), WRAPPER, \</span></span><br><span class="line"><span class="meta">     PyDoc_STR(DOC)&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ETSLOT(NAME, SLOT, FUNCTION, WRAPPER, DOC) \</span></span><br><span class="line"><span class="meta">    &#123;NAME, offsetof(PyHeapTypeObject, SLOT), (void *)(FUNCTION), WRAPPER, \</span></span><br><span class="line"><span class="meta">     PyDoc_STR(DOC)&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>我们发现 *PyHeapTypeObject* 的第一个域就是 *PyTypeObject* ，因此可以发现TPSLOT计算出的也是 *PyHeapTypeObject* 的偏移量。</strong></p>
<p><strong>对于一个 *PyTypeObject* 来说，有的操作，比如long_add，其函数指针是在 *PyNumberMethods* 里面存放的，而 *PyTypeObject* 中却是通过一个tp_as_number指针指向另一个 *PyNumberMethods* 结构，因此这种情况是没办法计算出long_add在 *PyTypeObject* 中的偏移量的，只能计算出在 *PyHeapTypeObject* 中的偏移量，这种时候TPSLOT就失效了。</strong></p>
<p><strong>因此与long_add对应的slot必须是通过ETSLOT来定义的，但是我们说 *PyHeapTypeObject* 里面的offset表示的是基于 *PyHeapTypeObject* 得到的偏移量，而PyLong_Type却是一个 *PyTypeObject* 对象，那么通过这个偏移量显然无法得到PyLong_Type中为int准备的long_add，那~~~这个offset有什么用呢？</strong></p>
<p><strong>答案非常诡异，这个offset是用来对操作进行排序的。排序？我整个人都不好了，不过在理解为什么需要对操作进行排序之前，需要先看看Python底层预先定义的slot集合–slotdefs。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//typeobject.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SQSLOT(NAME, SLOT, FUNCTION, WRAPPER, DOC) \</span></span><br><span class="line"><span class="meta">    ETSLOT(NAME, as_sequence.SLOT, FUNCTION, WRAPPER, DOC)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> slotdef slotdefs[] = &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//不同操作名(__add__、__radd__)对象, 对应相同操作nb_add</span></span><br><span class="line">    <span class="comment">//这个nb_add在PyLong_Type就是long_add,表示 +</span></span><br><span class="line">    BINSLOT(<span class="string">&quot;__add__&quot;</span>, nb_add, slot_nb_add,</span><br><span class="line">           <span class="string">&quot;+&quot;</span>),</span><br><span class="line">    RBINSLOT(<span class="string">&quot;__radd__&quot;</span>, nb_add, slot_nb_add,</span><br><span class="line">           <span class="string">&quot;+&quot;</span>),</span><br><span class="line">    BINSLOT(<span class="string">&quot;__sub__&quot;</span>, nb_subtract, slot_nb_subtract,</span><br><span class="line">           <span class="string">&quot;-&quot;</span>),</span><br><span class="line">    RBINSLOT(<span class="string">&quot;__rsub__&quot;</span>, nb_subtract, slot_nb_subtract,</span><br><span class="line">           <span class="string">&quot;-&quot;</span>),</span><br><span class="line">    BINSLOT(<span class="string">&quot;__mul__&quot;</span>, nb_multiply, slot_nb_multiply,</span><br><span class="line">           <span class="string">&quot;*&quot;</span>),</span><br><span class="line">    RBINSLOT(<span class="string">&quot;__rmul__&quot;</span>, nb_multiply, slot_nb_multiply,</span><br><span class="line">           <span class="string">&quot;*&quot;</span>),</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//相同操作名(__getitem__)对应不同操作(mp_subscript、mp_ass_subscript)</span></span><br><span class="line">    MPSLOT(<span class="string">&quot;__getitem__&quot;</span>, mp_subscript, slot_mp_subscript,</span><br><span class="line">           wrap_binaryfunc,</span><br><span class="line">           <span class="string">&quot;__getitem__($self, key, /)\n--\n\nReturn self[key].&quot;</span>),</span><br><span class="line">    SQSLOT(<span class="string">&quot;__getitem__&quot;</span>, sq_item, slot_sq_item, wrap_sq_item,</span><br><span class="line">           <span class="string">&quot;__getitem__($self, key, /)\n--\n\nReturn self[key].&quot;</span>),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>其中BINSLOT，SQSLOT等这些宏实际上都是对ETSLOT的一个简单包装，并且在slotdefs中可以发现，操作名<code>(比如__add__)</code>和操作并不是一一对应的，存在多个操作对应同一个操作名、或者多个操作名对应同一个操作的情况，那么在填充tp_dict时，就会出现问题，比如对于__getitem__，在tp_dict中与其对应的是mp_subscript还是sq_item呢？</strong></p>
<p><strong>为了解决这个问题，就需要利用slot中的offset信息对slot(也就是操作)进行排序。回顾一下前面列出的 *PyHeapTypeObject* 的代码，它与一般的struct定义不同，其中定义中各个域的顺序是非常关键的，在顺序中隐含着操作优先级的问题。比如在 *PyHeapTypeObject* 中，*PyMappingMethods* 的位置在 *PySequenceMethods* 之前，mp_subscript是 *PyMappingMethods* 中的一个域：PyObject *，而sq_item又是 *PySequenceMethods* 中的的一个域：PyObject *，那么最终计算出的偏移量就存在如下关系：<code>offset(mp_subscript) &lt; offset(sq_item)</code>。因此如果在一个PyTypeObject中，既定义了mp_subscript，又定义了sq_item，那么Python虚拟机将选择mp_subscript与__getitem__发生关系。</strong></p>
<p><strong>而对slotdefs的排序在init_slotdefs中完成：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//typeobject.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> slotdefs_initialized = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">init_slotdefs</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    slotdef *p;</span><br><span class="line">    <span class="comment">//init_slotdefs只会进行一次</span></span><br><span class="line">    <span class="keyword">if</span> (slotdefs_initialized)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (p = slotdefs; p-&gt;name; p++) &#123;</span><br><span class="line">        <span class="comment">/* Slots must be ordered by their offset in the PyHeapTypeObject. */</span></span><br><span class="line">        <span class="comment">//注释也表名：slots一定要通过它们在PyHeapTypeObject中的offset进行排序</span></span><br><span class="line">        <span class="comment">//而且是从小到大排</span></span><br><span class="line">        assert(!p[<span class="number">1</span>].name || p-&gt;offset &lt;= p[<span class="number">1</span>].offset);</span><br><span class="line">        p-&gt;name_strobj = PyUnicode_InternFromString(p-&gt;name);</span><br><span class="line">        <span class="keyword">if</span> (!p-&gt;name_strobj || !PyUnicode_CHECK_INTERNED(p-&gt;name_strobj))</span><br><span class="line">            Py_FatalError(<span class="string">&quot;Out of memory interning slotdef names&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//排完序之后将值赋为1, 这样的话下次执行的时候, 执行到上面的if时,由于条件为真就直接return了</span></span><br><span class="line">    slotdefs_initialized = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="从slot到descriptor"><a href="#从slot到descriptor" class="headerlink" title="从slot到descriptor"></a>从slot到descriptor</h4><p><strong>在slot中，包含了很多关于一个操作的信息，但是很可惜，在tp_dict中，与”<strong>getitem</strong>“关联在一起的，一定不会是slot，因为它不是一个PyObject，无法将其指针放在dict对象中。当然如果再深入思考一下，会发现slot也无法被调用。因为slot不是一个PyObject，那么它就没有ob_type这个域，也就无从谈起什么tp_call了，所以slot是无论如也无法满足Python中的可调用这一条件的。前面我们说过，Python虚拟机在tp_dict找到__getitem__对应的操作后，会调用该操作，所以tp_dict中与__getitem__对应的只能是包装了slot的PyObject。在Python中，我们称之为descriptor。</strong></p>
<p><strong>在Python内部，存在多种descriptor，与descriptor相对应的是 *PyWrapperDescrObject* 。在后面的描述中也会直接使用descriptor代表 *PyWrapperDescrObject* 。一个descriptor包含一个slot，其创建是通过 *PyDescr_NewWrapper* 完成的。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//descrobject.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PyDescr_COMMON PyDescrObject d_common</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    PyTypeObject *d_type;</span><br><span class="line">    PyObject *d_name;</span><br><span class="line">    PyObject *d_qualname;</span><br><span class="line">&#125; PyDescrObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyDescr_COMMON;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">wrapperbase</span> *<span class="title">d_base</span>;</span></span><br><span class="line">    <span class="type">void</span> *d_wrapped; <span class="comment">/* This can be any function pointer */</span></span><br><span class="line">&#125; PyWrapperDescrObject;</span><br><span class="line"><span class="comment">//descrobject.c</span></span><br><span class="line"><span class="type">static</span> PyDescrObject *</span><br><span class="line"><span class="title function_">descr_new</span><span class="params">(PyTypeObject *descrtype, PyTypeObject *type, <span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyDescrObject *descr;</span><br><span class="line"></span><br><span class="line">    descr = (PyDescrObject *)PyType_GenericAlloc(descrtype, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (descr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Py_XINCREF(type);</span><br><span class="line">        descr-&gt;d_type = type;</span><br><span class="line">        descr-&gt;d_name = PyUnicode_InternFromString(name);</span><br><span class="line">        <span class="keyword">if</span> (descr-&gt;d_name == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            Py_DECREF(descr);</span><br><span class="line">            descr = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            descr-&gt;d_qualname = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> descr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyDescr_NewWrapper</span><span class="params">(PyTypeObject *type, <span class="keyword">struct</span> wrapperbase *base, <span class="type">void</span> *wrapped)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyWrapperDescrObject *descr;</span><br><span class="line"></span><br><span class="line">    descr = (PyWrapperDescrObject *)descr_new(&amp;PyWrapperDescr_Type,</span><br><span class="line">                                             type, base-&gt;name);</span><br><span class="line">    <span class="keyword">if</span> (descr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        descr-&gt;d_base = base;</span><br><span class="line">        descr-&gt;d_wrapped = wrapped;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (PyObject *)descr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Python内部的各种descriptor都将包含 *PyDescr_COMMON* ，其中的d_type被设置为PyDescr_NewWrapper的参数type，而d_wrapped则存放着最重要的信息：操作对应的函数指针，比如对于PyList_Type来说，其<code>tp_dict[&quot;__getitem__&quot;].d_wrapped</code>就是&amp;mp_subscript。而slot则被存放在了d_base中。</strong></p>
<p><strong>当然， *PyWrapperDescrObject* 里面的type是 *PyWrapperDescr_Type* ，其中的tp_call是 *wrapperdescr_call* ，当Python虚拟机调用一个descriptor时，也就会调用 *wrapperdescr_call* 。对于descriptor的调用过程，我们将在后面详细介绍。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>.__sub__)  <span class="comment"># &lt;slot wrapper &#x27;__sub__&#x27; of &#x27;int&#x27; objects&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>.__add__)  <span class="comment"># &lt;slot wrapper &#x27;__add__&#x27; of &#x27;str&#x27; objects&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>.__getitem__)  <span class="comment"># &lt;slot wrapper &#x27;__getitem__&#x27; of &#x27;str&#x27; objects&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看到它们都是一个slot wrapper，也就是对slot包装之后的descriptor(描述符)。</strong></p>
<h4 id="建立联系"><a href="#建立联系" class="headerlink" title="建立联系"></a>建立联系</h4><p><strong>排序后的结果仍然存放在slotdefs中，python虚拟机这下就可以从头到尾遍历slotdefs，基于每一个slot建立一个descriptor，然后在tp_dict中建立从操作名到descriptor的关联，这个过程是在add_operators中完成的。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">add_operators</span><span class="params">(PyTypeObject *type)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyObject *dict = type-&gt;tp_dict;</span><br><span class="line">    slotdef *p;</span><br><span class="line">    PyObject *descr;</span><br><span class="line">    <span class="type">void</span> **ptr;</span><br><span class="line">    <span class="comment">//对slotdefs进行排序</span></span><br><span class="line">    init_slotdefs();</span><br><span class="line">    <span class="keyword">for</span> (p = slotdefs; p-&gt;name; p++) &#123;</span><br><span class="line">        <span class="comment">//如果slot中没有指定wrapper，则无需处理</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;wrapper == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">//获得slot对应的操作在PyTypeObject中的函数指针</span></span><br><span class="line">        ptr = slotptr(type, p-&gt;offset);</span><br><span class="line">        <span class="keyword">if</span> (!ptr || !*ptr)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">//如果tp_dict中已经存在操作名，则放弃</span></span><br><span class="line">        <span class="keyword">if</span> (PyDict_GetItemWithError(dict, p-&gt;name_strobj))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (PyErr_Occurred()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (*ptr == (<span class="type">void</span> *)PyObject_HashNotImplemented) &#123;</span><br><span class="line">            <span class="comment">/* Classes may prevent the inheritance of the tp_hash</span></span><br><span class="line"><span class="comment">               slot by storing PyObject_HashNotImplemented in it. Make it</span></span><br><span class="line"><span class="comment">               visible as a None value for the __hash__ attribute. */</span></span><br><span class="line">            <span class="keyword">if</span> (PyDict_SetItem(dict, p-&gt;name_strobj, Py_None) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//创建descriptor</span></span><br><span class="line">            descr = PyDescr_NewWrapper(type, p, *ptr);</span><br><span class="line">            <span class="keyword">if</span> (descr == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            <span class="comment">//将(操作名，descriptor)放入tp_dict中</span></span><br><span class="line">            <span class="keyword">if</span> (PyDict_SetItem(dict, p-&gt;name_strobj, descr) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                Py_DECREF(descr);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Py_DECREF(descr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (type-&gt;tp_new != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (add_tp_new_wrapper(type) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在add_operators中，首先调用前面剖析过的init_slotdefs对操作进行排序，然后遍历排序完成后的slotdefs结构体数组，对其中的每一个slot(slotdef)，通过slotptr获得该slot对应的操作在PyTypeObject中的函数指针，，并接着创建descriptor，在tp_dict中建立从操作名(slotdef.name_strobj)到操作(descriptor)的关联。</strong></p>
<p><strong>但是需要注意的是，在创建descriptor之前，Python虚拟机会检查在tp_dict中操作名是否存在，如果存在了，则不会再次建立从操作名到操作的关联。不过也正是这种检查机制与排序机制相结合，Python虚拟机在能在拥有相同操作名的多个操作中选择优先级最高的操作。</strong></p>
<p><em><em>在add_operators中，上面的动作都很简单、直观，而最难的动作隐藏在slotptr这个函数当中。它的功能是完成从slot到slot对应操作的真实函数指针的转换。我们知道，在slot中存放着用来操作的offset，但不幸的是，这个offset是相对于 *PyHeapTypeObject* 的偏移，而操作的真实函数指针却是在 *PyTypeObject* 中指定的，而且 *PyTypeObject* 和 *PyHeapTypeObject* 不是同构的，因为 *PyHeapTypeObject* 中包含了 *PyNumberMethods* 结构体，但 *PyTypeObject* 只包含了 *PyNumberMethods *</em> 指针。所以slot中存储的关于操作的offset对 *PyTypeObject* 来说，不能直接用，必须通过转换。</em>*</p>
<blockquote>
<p><strong>举个栗子，假如说调用<code>slotptr(&amp;PyList_Type, offset(PyHeapTypeObject, mp_subscript))</code>，首先判断这个偏移量大于<code>offset(PyHeapTypeObject, as_mapping)</code>，所以会先从PyTypeObject对象中获得as_mapping指针p，然后在p的基础上进行偏移就可以得到实际的函数地址。</strong></p>
<p><strong>所以偏移量delta为：<code>offset(PyHeapTypeObject, mp_subscript) - offset(PyHeapTypeObject, as_mapping)</code>。</strong></p>
</blockquote>
<p><strong>而这个复杂的过程就在slotptr中完成：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> **</span><br><span class="line"><span class="title function_">slotptr</span><span class="params">(PyTypeObject *type, <span class="type">int</span> ioffset)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *ptr;</span><br><span class="line">    <span class="type">long</span> offset = ioffset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Note: this depends on the order of the members of PyHeapTypeObject! */</span></span><br><span class="line">    assert(offset &gt;= <span class="number">0</span>);</span><br><span class="line">    assert((<span class="type">size_t</span>)offset &lt; offsetof(PyHeapTypeObject, as_buffer));</span><br><span class="line">    <span class="comment">//从PyHeapTypeObject中排在后面的PySequenceMethods开始判断,然后向前,依次判断PyMappingMethods和PyNumberMethods呢。</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    为什么要这么做呢？假设我们首先从PyNumberMethods开始判断</span></span><br><span class="line"><span class="comment">    如果一个操作的offset大于在PyHeapTypeObject中的as_numbers在PyNumberMethods的偏移量，那么我们还是没办法确认这个操作到底是属于谁的。只有从后往前进行判断,才能解决这个问题。</span></span><br><span class="line"><span class="comment">    */</span>    </span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">size_t</span>)offset &gt;= offsetof(PyHeapTypeObject, as_sequence)) &#123;</span><br><span class="line">        ptr = (<span class="type">char</span> *)type-&gt;tp_as_sequence;</span><br><span class="line">        offset -= offsetof(PyHeapTypeObject, as_sequence);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="type">size_t</span>)offset &gt;= offsetof(PyHeapTypeObject, as_mapping)) &#123;</span><br><span class="line">        ptr = (<span class="type">char</span> *)type-&gt;tp_as_mapping;</span><br><span class="line">        offset -= offsetof(PyHeapTypeObject, as_mapping);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="type">size_t</span>)offset &gt;= offsetof(PyHeapTypeObject, as_number)) &#123;</span><br><span class="line">        ptr = (<span class="type">char</span> *)type-&gt;tp_as_number;</span><br><span class="line">        offset -= offsetof(PyHeapTypeObject, as_number);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="type">size_t</span>)offset &gt;= offsetof(PyHeapTypeObject, as_async)) &#123;</span><br><span class="line">        ptr = (<span class="type">char</span> *)type-&gt;tp_as_async;</span><br><span class="line">        offset -= offsetof(PyHeapTypeObject, as_async);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ptr = (<span class="type">char</span> *)type;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ptr != <span class="literal">NULL</span>)</span><br><span class="line">        ptr += offset;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span> **)ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>好了，我想到现在我们应该能够摸清楚Python在改造PyTypeObject对象时对tp_dict做了什么了，我们以PyList_Type举例说明：</strong></p>
<p><img src="/2023/04/10/18-Python%E7%B1%BB%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90-%E7%B1%BB%E7%9A%84%E5%A4%9A%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%B1%9E%E6%80%A7%E6%9F%A5%E6%89%BE/1229382-20200830184229028-495891242.png" alt="img"></p>
<p><strong>在add_operators完成之后，PyList_Type如图所示。从PyList_Type.tp_as_mapping中延伸出去的部分是在编译时就已经确定好了的，而从tp_dict中延伸出去的部分则是在Python运行时环境初始化的时候才建立的。</strong></p>
<p><strong>另外， *PyType_Ready* 在通过add_operators添加了 *PyTypeObject* 对象中定义的一些operator后，还会通过add_methods、add_numbers和add_getsets添加 *PyTypeObject* 中定义的tp_methods、tp_members和tp_getset函数集。这些过程和add_operators类似，不过最后添加到tp_dict中descriptor就不再是 *PyWrapperDescrObject* ，而分别是 *PyMethodDescrObject* 、*PyMemberDescrObject* 、 *PyGetSetDescrObject* 。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>.__add__)  <span class="comment"># &lt;slot wrapper &#x27;__add__&#x27; of &#x27;str&#x27; objects&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>.__add__)  <span class="comment"># &lt;slot wrapper &#x27;__add__&#x27; of &#x27;list&#x27; objects&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>.__getitem__)  <span class="comment"># &lt;slot wrapper &#x27;__getitem__&#x27; of &#x27;str&#x27; objects&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>.__getitem__)  <span class="comment"># &lt;method &#x27;__getitem__&#x27; of &#x27;list&#x27; objects&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们看到对于list的__getitem__来说, 就不再是PyWrapperDescrObject(slot wrapper)了</span></span><br><span class="line"><span class="comment"># 而是一个PyMethodDescrObject</span></span><br></pre></td></tr></table></figure>

<p><strong>从目前来看，基本上算是解析完了，但是还有一点：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">list</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;xxx&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># xxx</span></span><br></pre></td></tr></table></figure>

<p><strong>显然当我们print(a)的时候，应该调用A.tp_repr函数，对照PyList_Type的布局，应该调用list_repr这个函数，然而事实却并非如此，Python虚拟机调用的是我们在A中重写的__repr__方法。这意味着Python在初始化A的时候，对tp_repr进行了特殊处理。为什么Python虚拟机会知道要对tp_repr进行特殊处理呢？当然肯定有人会说：这是因为我们重写了__repr__方法啊，确实如此，但这是Python层面上的，在底层的话，答案还是在slot身上。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//typeobject.c</span></span><br><span class="line"><span class="type">static</span> slotdef slotdefs[] = &#123;</span><br><span class="line">    ...</span><br><span class="line">    TPSLOT(<span class="string">&quot;__repr__&quot;</span>, tp_repr, slot_tp_repr, wrap_unaryfunc,</span><br><span class="line">           <span class="string">&quot;__repr__($self, /)\n--\n\nReturn repr(self).&quot;</span>),</span><br><span class="line">    ...</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p><strong>Python虚拟机在初始化A时，会检查A的tp_dict中是否存在__repr__，在后面剖析自定义class对象的创建时会看到，因为在定义class  A的时候，重写了__repr__这个操作。所以在A.tp_dict中，__repr__一开始就会存在，Python虚拟机会检测到，然后会根据__repr__对应的slot顺藤摸瓜，找到tp_repr，并且将这个函数指针替换为slot中指定的&amp;slot_tp_repr。所以当后来虚拟机找A.tp_repr的时候，实际上找的是slot_tp_repr。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//typeobject.c</span></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">slot_tp_repr</span><span class="params">(PyObject *self)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyObject *func, *res;</span><br><span class="line">    _Py_IDENTIFIER(__repr__);</span><br><span class="line">    <span class="type">int</span> unbound;</span><br><span class="line">    <span class="comment">//查找__repr__属性</span></span><br><span class="line">    func = lookup_maybe_method(self, &amp;PyId___repr__, &amp;unbound);</span><br><span class="line">    <span class="keyword">if</span> (func != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//调用__repr__对应的对象</span></span><br><span class="line">        res = call_unbound_noarg(unbound, func, self);</span><br><span class="line">        Py_DECREF(func);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    PyErr_Clear();</span><br><span class="line">    <span class="keyword">return</span> PyUnicode_FromFormat(<span class="string">&quot;&lt;%s object at %p&gt;&quot;</span>,</span><br><span class="line">                               Py_TYPE(self)-&gt;tp_name, self);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在slot_tp_repr中，会寻找__repr__属性对应的对象，正好就会找到在A中重写的函数，后面会看到，这个对象实际上就一个PyFunctionObject对象。这样一来，就完成了对默认的list的repr行为的替换。所以对于A来说，内存布局就是下面这样。</strong></p>
<p><img src="/2023/04/10/18-Python%E7%B1%BB%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90-%E7%B1%BB%E7%9A%84%E5%A4%9A%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%B1%9E%E6%80%A7%E6%9F%A5%E6%89%BE/1229382-20200830184238908-954719114.png" alt="img"></p>
<p><strong>当然这仅仅是针对于__repr__，对于其他的操作还是会指向PyList_Type中指定的函数，比如tp_iter还是会指向list_iter。因为我们的类A继承list，所以如果某个函数在A里面没有的话，那么会 从PyList_Type中寻找。</strong></p>
<p><strong>对于A来说，这个变化是在 *fixup_slot_dispatchers* 这个函数中完成的，对于内建对象则不会进行此操作，因为内建对象是被静态初始化的，它不允许属性的动态设置。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//typeobject.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">fixup_slot_dispatchers</span><span class="params">(PyTypeObject *type)</span></span><br><span class="line">&#123;</span><br><span class="line">    slotdef *p;</span><br><span class="line"></span><br><span class="line">    init_slotdefs();</span><br><span class="line">    <span class="keyword">for</span> (p = slotdefs; p-&gt;name; )</span><br><span class="line">        p = update_one_slot(type, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="确定MRO"><a href="#确定MRO" class="headerlink" title="确定MRO"></a>确定MRO</h4><p><strong>MRO，即method resolve  order，说白了就是类继承之后、属性或方法的查找顺序。如果Python是单继承的话，那么这就不是问题了，直接一层一层网上找就可以了。但是Python是支持多继承的，那么在多继承时，继承的顺序就成为了一个必须考虑的问题。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;A&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">A</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;B&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(<span class="title class_ inherited__">A</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;C&quot;</span>)</span><br><span class="line">        self.bar()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bar</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;bar C&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>(C, B):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bar</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;bar D&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">d = D()</span><br><span class="line">d.foo()</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">C</span></span><br><span class="line"><span class="string">bar D</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>首先我们看到，打印的是C，说明调用的是C的foo函数，这说明把C写在前面，会调用C的方法。但是下面打印了bar  D，这是因为C里面的self，实际上是D的实例对象。D在找不到foo函数的时候，会到父类里面找，但是同时也会将self传递过去，所以调用self.bar的时候，还是会先到D里面找，如果找不到再去父类里面找。</strong></p>
<p><strong>在底层则是先在PyType_Ready中通过mro_internal确定mro的顺序，Python虚拟机将创建一个PyTupleObject对象，里面存放一组类对象，这些类对象的顺序就是虚拟机确定的mro的顺序，最终这个PyTuple对象会被保存在PyTypeObject.tp_mro中。</strong></p>
<p><strong>由于mro_internal内部的实现机制相当复杂，所以我们将会只从python的代码层面来理解。首先我们说python早期有经典类和新式类两种类，现在则只存在新式类。而经典类的类搜索方式采用的是深度优先，而新式类则是广度优先<code>(当然现在用的是新的算法，具体什么算法后面说，暂时理解为广度优先即可)</code>，举个例子：</strong></p>
<p><img src="/2023/04/10/18-Python%E7%B1%BB%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90-%E7%B1%BB%E7%9A%84%E5%A4%9A%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%B1%9E%E6%80%A7%E6%9F%A5%E6%89%BE/1229382-20200830184248486-285345738.png" alt="img"></p>
<p><strong>图中的箭头表示继承关系，比如：A继承B和C、B继承D、C继承E。</strong></p>
<p><strong>对于上图来说，经典类和新式类的查找方式是一样的：先从A找到I，再从C找到G。对于上图这种继承结构，经典类和新式类是一样的，至于两边是否一样多则不重要。我们实际演示一下，由于经典类只在Python2中存在，所以下面我们演示新式类。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里是python3.8 新式类</span></span><br><span class="line">I = <span class="built_in">type</span>(<span class="string">&quot;I&quot;</span>, (), &#123;&#125;)</span><br><span class="line">H = <span class="built_in">type</span>(<span class="string">&quot;H&quot;</span>, (I,), &#123;&#125;)</span><br><span class="line">F = <span class="built_in">type</span>(<span class="string">&quot;F&quot;</span>, (H,), &#123;&#125;)</span><br><span class="line">G = <span class="built_in">type</span>(<span class="string">&quot;G&quot;</span>, (), &#123;&#125;)</span><br><span class="line">D = <span class="built_in">type</span>(<span class="string">&quot;D&quot;</span>, (F,), &#123;&#125;)</span><br><span class="line">E = <span class="built_in">type</span>(<span class="string">&quot;E&quot;</span>, (G,), &#123;&#125;)</span><br><span class="line">B = <span class="built_in">type</span>(<span class="string">&quot;B&quot;</span>, (D,), &#123;&#125;)</span><br><span class="line">C = <span class="built_in">type</span>(<span class="string">&quot;C&quot;</span>, (E,), &#123;&#125;)</span><br><span class="line">A = <span class="built_in">type</span>(<span class="string">&quot;A&quot;</span>, (B, C), &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> A.__mro__:</span><br><span class="line">    <span class="built_in">print</span>(_)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;class &#x27;__main__.A&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;__main__.B&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;__main__.D&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;__main__.F&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;__main__.H&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;__main__.I&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;__main__.C&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;__main__.E&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;__main__.G&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;object&#x27;&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>对于A继承两个类，这个两个类分别继续继承，如果最终没有继承公共的类<code>(暂时先忽略object)</code>，那么经典类和新式类是一样的。像这种泾渭分明、各自继承各自的，都是先一条路找到黑，然后再去另外一条路去找。</strong></p>
<p><strong>但如果是下面这种，最终分久必合、两者最终又继承了同一个类，那么经典类还是跟以前一样，按照每一条路都走到黑的方式。但是对于新式类，则是先从A找到H，而I这个两边最终继承的类不找了，然后从C找到I，也就是在另一条路找到头。</strong></p>
<p><img src="/2023/04/10/18-Python%E7%B1%BB%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90-%E7%B1%BB%E7%9A%84%E5%A4%9A%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%B1%9E%E6%80%A7%E6%9F%A5%E6%89%BE/1229382-20200830184256704-1205529691.png" alt="img"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新式类</span></span><br><span class="line">I = <span class="built_in">type</span>(<span class="string">&quot;I&quot;</span>, (), &#123;&#125;)</span><br><span class="line">H = <span class="built_in">type</span>(<span class="string">&quot;H&quot;</span>, (I,), &#123;&#125;)</span><br><span class="line">F = <span class="built_in">type</span>(<span class="string">&quot;F&quot;</span>, (H,), &#123;&#125;)</span><br><span class="line">G = <span class="built_in">type</span>(<span class="string">&quot;G&quot;</span>, (I,), &#123;&#125;)   <span class="comment"># 这里让G继承I</span></span><br><span class="line">D = <span class="built_in">type</span>(<span class="string">&quot;D&quot;</span>, (F,), &#123;&#125;)</span><br><span class="line">E = <span class="built_in">type</span>(<span class="string">&quot;E&quot;</span>, (G,), &#123;&#125;)</span><br><span class="line">B = <span class="built_in">type</span>(<span class="string">&quot;B&quot;</span>, (D,), &#123;&#125;)</span><br><span class="line">C = <span class="built_in">type</span>(<span class="string">&quot;C&quot;</span>, (E,), &#123;&#125;)</span><br><span class="line">A = <span class="built_in">type</span>(<span class="string">&quot;A&quot;</span>, (B, C), &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> A.__mro__:</span><br><span class="line">    <span class="built_in">print</span>(_)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;class &#x27;__main__.A&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;__main__.B&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;__main__.D&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;__main__.F&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;__main__.H&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;__main__.C&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;__main__.E&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;__main__.G&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;__main__.I&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;object&#x27;&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>因此对于最下面的类继承两个类，然后继承的两个类再次继承的时候，向上只继承一个类，对于这种模式，那么结论、也就是mro顺序就是我们上面分析的那样。不过对新式类来说，因为所有类默认都是继承object，所以第一张图中，即使我们没画完，但是也能想到，两条泾渭分明的继承链的上方最终应该都指向object。那么我们依旧可以用刚才的理论来解释，在第一条继承链中找到object的前一个类不找了，然后在第二条继承链中一直找到object。</strong></p>
<p><strong>但是Python的多继承远比我们想象的要复杂，原因就在于可以任意继承，如果B和C再分别继承两个类呢？那么我们这里的线路就又要多出两条了，不过既然要追求刺激，就贯彻到底喽。但是下面我们就只会介绍新式类了，经典类了解一下就可以了。</strong></p>
<p><strong>另外我们之前说新式类采用的是广度优先，但是实际上这样有一个问题：</strong></p>
<p><img src="/2023/04/10/18-Python%E7%B1%BB%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90-%E7%B1%BB%E7%9A%84%E5%A4%9A%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%B1%9E%E6%80%A7%E6%9F%A5%E6%89%BE/1229382-20200830184305360-627592971.png" alt="img"></p>
<p><strong>假设我们调用A的foo方法，但是A里面没有，那么理所应当会去B里面找，但是B里面也没有，而C和D里面有，那么这个时候是去C里面找还是去D里面找呢？根据我们之前的结论，显然是去D里面找，可如果按照广度优先的逻辑来说，那么应该是去C里面找啊。所以广度优先理论在这里就不适用了，因为B继承了D，而B和C并没有直接关系，我们应该把B和D看成一个整体。因此Python中的广度优先实际上是采用了一种叫做C3的算法。</strong></p>
<p><strong>这个C3算法比较复杂(其实也不算复杂)，只不过我个人总结出一个更加好记的结论，如下：</strong></p>
<blockquote>
<p><strong>当沿着一条继承链寻找类时，默认会沿着该继承链一直找下去，但如果发现某个类出现在了另一条继承链当中，那么当前的继承链的搜索就会结束，然后在”最开始”出现分歧的地方转向下一条继承链的搜索。</strong></p>
</blockquote>
<p><strong>这是我个人总结的，或许光看字面意思的话会比较难理解，但是通过例子就能明白了。</strong></p>
<p><img src="/2023/04/10/18-Python%E7%B1%BB%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90-%E7%B1%BB%E7%9A%84%E5%A4%9A%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%B1%9E%E6%80%A7%E6%9F%A5%E6%89%BE/1229382-20200830184314745-606414853.png" alt="img"></p>
<p><strong>这个箭头表示继承关系，继承顺序是从左到右，比如这里的A就相当于<code>class A(B, C)</code>，下面我们来从头到尾分析一下。</strong></p>
<ul>
<li><code>1. 首先最开始的顺序是A, 如果我们获取A的mro的话;</code></li>
<li><code>2. 然后A继承B和C, 由于是两条路, 因此我们说A这里就是一个分歧点。但是由于B在前, 所以接下来是B, 所以现在mro的顺序是A B;</code></li>
<li><code>3. 但是B这里也出现了分歧点, 不过不用管, 因为我们说会沿着继承链不断往下搜索, 现在mro的顺序是A B D;</code></li>
<li><code>4. 然后从D开始寻找, 这里注意了, 按理说会找G的, 但是G不止被一个类继承, 也就是意味着沿着当前的继承链查找G时, G还出现在了其它的继承链当中。怎么办？显然要回到最初的分歧点, 转向下一条继承链的搜索;</code></li>
<li><code>5. 最初的分歧点是A, 那么该去找C了, 现在mro的顺序就是A B D C;</code></li>
<li><code>6. 注意C这里出现了分歧点, 而A的两条分支已经结束了, 所以现在C就是最初的分歧点了。而C继承自E和F, 显然要搜索E, 那么此时mro的顺序就是A B D C E;</code></li>
<li><code>7. 然后从E开始搜索, 显然要搜索G, 此时mro顺序是A B D C E G;</code></li>
<li><code>8. 从G要搜索I, 此时mro顺序是A B D C E G I;</code></li>
<li><code>9. 从I开始搜索谁呢？由于J出现在了其它的继承链中, 那么要回到最初分歧的地方, 也就是C, 那么下面显然要找F, 此时mro顺序是A B D C E G I F;</code></li>
<li><code>10. F只继承了H, 那么肯定要找H, 此时mro顺序是 A B D C E G I F H;</code></li>
<li><code>11. H显然只能找J了, 因此最终A的mro顺序就是A B D C E G I F H J object;</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">J = <span class="built_in">type</span>(<span class="string">&quot;J&quot;</span>, (<span class="built_in">object</span>, ), &#123;&#125;)</span><br><span class="line">I = <span class="built_in">type</span>(<span class="string">&quot;I&quot;</span>, (J, ), &#123;&#125;)</span><br><span class="line">H = <span class="built_in">type</span>(<span class="string">&quot;H&quot;</span>, (J, ), &#123;&#125;)</span><br><span class="line">G = <span class="built_in">type</span>(<span class="string">&quot;G&quot;</span>, (I, ), &#123;&#125;)</span><br><span class="line">F = <span class="built_in">type</span>(<span class="string">&quot;F&quot;</span>, (H, ), &#123;&#125;)</span><br><span class="line">E = <span class="built_in">type</span>(<span class="string">&quot;E&quot;</span>, (G, H), &#123;&#125;)</span><br><span class="line">D = <span class="built_in">type</span>(<span class="string">&quot;D&quot;</span>, (G, ), &#123;&#125;)</span><br><span class="line">C = <span class="built_in">type</span>(<span class="string">&quot;C&quot;</span>, (E, F), &#123;&#125;)</span><br><span class="line">B = <span class="built_in">type</span>(<span class="string">&quot;B&quot;</span>, (D, E), &#123;&#125;)</span><br><span class="line">A = <span class="built_in">type</span>(<span class="string">&quot;A&quot;</span>, (B, C), &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># A B D C E G I F H J</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> A.__mro__:</span><br><span class="line">    <span class="built_in">print</span>(_)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;class &#x27;__main__.A&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;__main__.B&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;__main__.D&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;__main__.C&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;__main__.E&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;__main__.G&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;__main__.I&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;__main__.F&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;__main__.H&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;__main__.J&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;object&#x27;&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>我们再看一个复杂的例子感受一下：</strong></p>
<p><img src="/2023/04/10/18-Python%E7%B1%BB%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90-%E7%B1%BB%E7%9A%84%E5%A4%9A%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%B1%9E%E6%80%A7%E6%9F%A5%E6%89%BE/1229382-20200830184324735-2139321706.png" alt="img"></p>
<p><strong>看起来很花里胡哨的，但其实很简单，就按照之前说的那个结论不断推导下去即可。</strong></p>
<ul>
<li><code>1. 首先是A, A继承B1、B2、B3, 会先走B1, 此时mro是A B1, 注意现在A是分歧点;</code></li>
<li><code>2. 从B1本来该找C1, 但是C1还被其他类继承, 也就是出现在了其它的继承链当中, 因此要回到最初分歧点A, 从下一条继承链开始找, 显然要找B2, 此时mro就是A B1 B2;</code></li>
<li><code>3. 从B2开始, 显然要找C1, 此时mro顺序就是A B1 B2 C1;</code></li>
<li><code>4. 从C1开始, 显然要找D1, 因为D1只被C1继承, 所以它没有出现在另一条继承链当中, 因此此时mro顺序是A B1 B2 C1 D1;</code></li>
<li><code>5. 从D1显然不会找E的, 咋办? 回到最初的分歧点, 注意这里显然还是A, 因为A的分支还没有走完。显然此时要走B3, 那么mro顺序就是A B1 B2 C1 D1 B3;</code></li>
<li><code>6. 从B3开始找, 显然要找C2, 注意: A的分支已经走完, 此时B3就成了新的最初分歧点。现在mro顺序是A B1 B2 C1 D1 B3 C2;</code></li>
<li><code>7. C2会找D2吗? 显然不会, 因为它还被C3继承, 所以它出现在了其他的继承链中。所以要回到最初分歧点, 这里是B3, 显然下面要找C3, 另外由于B3的分支也已经走完, 所以现在C3就成了新的最初分歧点。此时mro顺序是A B1 B2 C1 D1 B3 C2  C3;</code></li>
<li><code>8. 从C3开始, 显然要找D2, 此时mro顺序是A B1 B2 C1 D1 B3 C2 C3 D2;</code></li>
<li><code>9. 但是D2不会找E, 因此回到最初分歧点C3, 下面就找D3, 然后显然只能再找E了, 显然最终mro顺序A B1 B2 C1 D1 B3 C2 C3 D2 D3 E object;</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">E = <span class="built_in">type</span>(<span class="string">&quot;E&quot;</span>, (), &#123;&#125;)</span><br><span class="line">D1 = <span class="built_in">type</span>(<span class="string">&quot;D1&quot;</span>, (E,), &#123;&#125;)</span><br><span class="line">D2 = <span class="built_in">type</span>(<span class="string">&quot;D2&quot;</span>, (E,), &#123;&#125;)</span><br><span class="line">D3 = <span class="built_in">type</span>(<span class="string">&quot;D3&quot;</span>, (E,), &#123;&#125;)</span><br><span class="line">C1 = <span class="built_in">type</span>(<span class="string">&quot;C1&quot;</span>, (D1, D2), &#123;&#125;)</span><br><span class="line">C2 = <span class="built_in">type</span>(<span class="string">&quot;C2&quot;</span>, (D2,), &#123;&#125;)</span><br><span class="line">C3 = <span class="built_in">type</span>(<span class="string">&quot;C3&quot;</span>, (D2, D3), &#123;&#125;)</span><br><span class="line">B1 = <span class="built_in">type</span>(<span class="string">&quot;B1&quot;</span>, (C1,), &#123;&#125;)</span><br><span class="line">B2 = <span class="built_in">type</span>(<span class="string">&quot;B2&quot;</span>, (C1, C2), &#123;&#125;)</span><br><span class="line">B3 = <span class="built_in">type</span>(<span class="string">&quot;B3&quot;</span>, (C2, C3), &#123;&#125;)</span><br><span class="line">A = <span class="built_in">type</span>(<span class="string">&quot;A&quot;</span>, (B1, B2, B3), &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> A.__mro__:</span><br><span class="line">    <span class="built_in">print</span>(_)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;class &#x27;__main__.A&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;__main__.B1&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;__main__.B2&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;__main__.C1&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;__main__.D1&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;__main__.B3&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;__main__.C2&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;__main__.C3&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;__main__.D2&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;__main__.D3&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;__main__.E&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;object&#x27;&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>因此Python的多继承并没有我们想象的那么复杂，当然底层源码我们就不再看了，这个东西分析起来没什么太大必要，有兴趣可以自己去看一下。个人觉得，关于多继承从目前这个层面上来理解已经足够了。</strong></p>
<p><strong>不过需要注意的是，在执行父类函数时传入的self参数，这一点是很多初学者容易犯的错误。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;A: foo&quot;</span>)</span><br><span class="line">        self.bar()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bar</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;A: bar&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bar</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;B: bar&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(A, B):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bar</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;C: bar&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">C().foo()</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">A: foo</span></span><br><span class="line"><span class="string">C: bar</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>首先C的实例对象在调用foo的时候，首先会去C里面查找，但是C没有，所以按照mro顺序会去A里面找。而A里面存在，所以调用，但是：调用时传递的self是C的实例对象，因为是C的实例对象调用的。所以里面的self.bar，这个self还是C的实例对象，那么调用bar的时候，会去哪里找呢？显然还是从C里面找，所以 self.bar() 的时候打印的是”C: bar”，而不是”A: bar”。</strong></p>
<p><strong>同理再来看看一个关于super的栗子：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(A, self).foo()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;B: foo&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(A, B):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    A().foo()</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># &#x27;super&#x27; object has no attribute &#x27;foo&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 首先A的父类是object, 所以super(A, self).foo()的时候回去执行object的foo</span></span><br><span class="line"><span class="comment"># 但是object没有foo, 所以报错了, 报错信息中的&#x27;super&#x27;指的就是A的父类</span></span><br><span class="line"><span class="comment"># 但是, 是的, 我要说但是了</span></span><br><span class="line">C().foo()  <span class="comment"># B: foo</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">如果是C()调用foo的话, 最终却执行了B的foo函数, 这是什么原因呢?</span></span><br><span class="line"><span class="string">首先C里面里面没有foo, 那么会去执行A的foo, 但是执行时候的self是C的实例对象, super里面的self也是C里面的self</span></span><br><span class="line"><span class="string">然后我们知道对于C而言, 其mro是 C、A、B、object</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">所以super(A, self).foo() 就表示: 沿着继承链 C、A、B、object的顺序去找foo函数</span></span><br><span class="line"><span class="string">但是super里面有一个A, 表示不要从头开始找, 而是从A的后面开始找, 所以下一个就找到B了</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>所以说super不一定就是父类，而是要看里面的self是谁。总之：<code>super(xxx, self)</code>一定是type(self)对应的mro中，xxx的下一个类。</strong></p>
<h4 id="继承基类操作"><a href="#继承基类操作" class="headerlink" title="继承基类操作"></a>继承基类操作</h4><p><strong>python虚拟机确定了mro顺序列表之后，就会遍历mro列表(第一个类对象会是其自身，比如A.__mro__的第一个元素就是A本身，所以遍历是从第二项开始的)。在mro列表中实际上存储的就是类对象的所有直接基类、间接基类，Python虚拟机会将自身没有、但是基类<code>(注意：包括间接基类，比如基类的基类)</code>中存在的操作拷贝到该类当中，从而完成对基类操作的继承动作。</strong></p>
<p><strong>而这个继承操作的动作是发生在inherit_slots中</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//typeobject.c</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">PyType_Ready</span><span class="params">(PyTypeObject *type)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//...    </span></span><br><span class="line">    bases = type-&gt;tp_mro;</span><br><span class="line">    assert(bases != <span class="literal">NULL</span>);</span><br><span class="line">    assert(PyTuple_Check(bases));</span><br><span class="line">    n = PyTuple_GET_SIZE(bases);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        PyObject *b = PyTuple_GET_ITEM(bases, i);</span><br><span class="line">        <span class="keyword">if</span> (PyType_Check(b))</span><br><span class="line">            inherit_slots(type, (PyTypeObject *)b);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    ...   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在inherit_slots中会拷贝相当多的操作，这里就拿nb_add<code>(整型则对应long_add)</code>来举个栗子:</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">inherit_slots</span><span class="params">(PyTypeObject *type, PyTypeObject *base)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyTypeObject *basebase;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> SLOTDEFINED</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> COPYSLOT</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> COPYNUM</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> COPYSEQ</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> COPYMAP</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> COPYBUF</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SLOTDEFINED(SLOT) \</span></span><br><span class="line"><span class="meta">    (base-&gt;SLOT != 0 &amp;&amp; \</span></span><br><span class="line"><span class="meta">     (basebase == NULL || base-&gt;SLOT != basebase-&gt;SLOT))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COPYSLOT(SLOT) \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (!type-&gt;SLOT &amp;&amp; SLOTDEFINED(SLOT)) type-&gt;SLOT = base-&gt;SLOT</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COPYASYNC(SLOT) COPYSLOT(tp_as_async-&gt;SLOT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COPYNUM(SLOT) COPYSLOT(tp_as_number-&gt;SLOT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COPYSEQ(SLOT) COPYSLOT(tp_as_sequence-&gt;SLOT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COPYMAP(SLOT) COPYSLOT(tp_as_mapping-&gt;SLOT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COPYBUF(SLOT) COPYSLOT(tp_as_buffer-&gt;SLOT)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This won&#x27;t inherit indirect slots (from tp_as_number etc.)</span></span><br><span class="line"><span class="comment">       if type doesn&#x27;t provide the space. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (type-&gt;tp_as_number != <span class="literal">NULL</span> &amp;&amp; base-&gt;tp_as_number != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        basebase = base-&gt;tp_base;</span><br><span class="line">        <span class="keyword">if</span> (basebase-&gt;tp_as_number == <span class="literal">NULL</span>)</span><br><span class="line">            basebase = <span class="literal">NULL</span>;</span><br><span class="line">        COPYNUM(nb_add);</span><br><span class="line">        COPYNUM(nb_subtract);</span><br><span class="line">        COPYNUM(nb_multiply);</span><br><span class="line">        COPYNUM(nb_remainder);</span><br><span class="line">        COPYNUM(nb_divmod);</span><br><span class="line">        COPYNUM(nb_power);</span><br><span class="line">        COPYNUM(nb_negative);</span><br><span class="line">        COPYNUM(nb_positive);</span><br><span class="line">        COPYNUM(nb_absolute);</span><br><span class="line">        COPYNUM(nb_bool);</span><br><span class="line">        COPYNUM(nb_invert);</span><br><span class="line">        COPYNUM(nb_lshift);</span><br><span class="line">        COPYNUM(nb_rshift);</span><br><span class="line">        COPYNUM(nb_and);</span><br><span class="line">        COPYNUM(nb_xor);</span><br><span class="line">        COPYNUM(nb_or);</span><br><span class="line">        COPYNUM(nb_int);</span><br><span class="line">        COPYNUM(nb_float);</span><br><span class="line">        COPYNUM(nb_inplace_add);</span><br><span class="line">        COPYNUM(nb_inplace_subtract);</span><br><span class="line">        COPYNUM(nb_inplace_multiply);</span><br><span class="line">        COPYNUM(nb_inplace_remainder);</span><br><span class="line">        COPYNUM(nb_inplace_power);</span><br><span class="line">        COPYNUM(nb_inplace_lshift);</span><br><span class="line">        COPYNUM(nb_inplace_rshift);</span><br><span class="line">        COPYNUM(nb_inplace_and);</span><br><span class="line">        COPYNUM(nb_inplace_xor);</span><br><span class="line">        COPYNUM(nb_inplace_or);</span><br><span class="line">        COPYNUM(nb_true_divide);</span><br><span class="line">        COPYNUM(nb_floor_divide);</span><br><span class="line">        COPYNUM(nb_inplace_true_divide);</span><br><span class="line">        COPYNUM(nb_inplace_floor_divide);</span><br><span class="line">        COPYNUM(nb_index);</span><br><span class="line">        COPYNUM(nb_matrix_multiply);</span><br><span class="line">        COPYNUM(nb_inplace_matrix_multiply);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//......</span></span><br></pre></td></tr></table></figure>

<p><strong>我们在里面看到很多熟悉的东西，如果你常用魔法方法的话。而且我们知道PyBool_Type中并没有设置nb_add，但是PyLong_Type中却设置了nb_add操作，而bool继承int。所以对布尔类型是可以直接进行运算的，当然和整型、浮点型运算也是可以的。所以在numpy中，判断一个数组中多少个满足条件的元素，可以使用numpy提供的机制进行比较，会得到一个同样长度的数组，里面的每一个元素为是否满足条件所对应的布尔值。然后直接通过sum运算即可，因为运算的时候，True会被解释成1，False会被解释成0。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">arr = np.array([<span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>])</span><br><span class="line"><span class="built_in">print</span>(arr &gt; <span class="number">4</span>)  <span class="comment"># [False False  True False  True]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>(arr &gt; <span class="number">4</span>))  <span class="comment"># 2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="number">2.2</span> + <span class="literal">True</span>)  <span class="comment"># 3.2</span></span><br></pre></td></tr></table></figure>

<p><strong>所以在python中，整型是可以和布尔类型进行运算的，看似不可思议，但又在情理之中。</strong></p>
<h4 id="填充基类中的子类列表"><a href="#填充基类中的子类列表" class="headerlink" title="填充基类中的子类列表"></a>填充基类中的子类列表</h4><p><strong>到这里，PyType_Ready还剩下最后一个重要的动作了：设置基类中的子类列表。在每一个PyTypeObject中，有一个tp_subclasses，这个东西在PyType_Ready完成之后，将会是一个list对象。其中存放着所有直接继承自类的类对象，PyType_Ready是通过调用add_subclass完成向这个tp_subclasses中填充子类的动作。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">PyType_Ready</span><span class="params">(PyTypeObject *type)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyObject *dict, *bases;</span><br><span class="line">    PyTypeObject *base;</span><br><span class="line">    Py_ssize_t i, n;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//填充基类的子类列表</span></span><br><span class="line">    bases = type-&gt;tp_bases;</span><br><span class="line">    n = PyTuple_GET_SIZE(bases);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        PyObject *b = PyTuple_GET_ITEM(bases, i);</span><br><span class="line">        <span class="keyword">if</span> (PyType_Check(b) &amp;&amp;</span><br><span class="line">            add_subclass((PyTypeObject *)b, type) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">print(object.__subclasses__())</span><br><span class="line"># [&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">type</span>&#x27;&gt;</span>, &lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">weakref</span>&#x27;&gt;</span>, &lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">weakcallableproxy</span>&#x27;&gt;</span>, </span><br><span class="line"># &lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">weakproxy</span>&#x27;&gt;</span>, &lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">int</span>&#x27;&gt;</span>, &lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">bytearray</span>&#x27;&gt;</span>, &lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">bytes</span>&#x27;&gt;</span>, </span><br><span class="line"># &lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">list</span>&#x27;&gt;</span>, &lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">NoneType</span>&#x27;&gt;</span>, &lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">NotImplementedType</span>&#x27;&gt;</span>, </span><br><span class="line"># &lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">traceback</span>&#x27;&gt;</span>, &lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">super</span>&#x27;&gt;</span>, ... ... ...</span><br></pre></td></tr></table></figure>

<p><strong>果然，python里面的object不愧是万物之父，这么多的内建对象都是继承自object的。到了这里，我们才算是完整的剖析了PyType_Ready的动作，可以看到，python虚拟机对python的内建对象对应的PyTypeObject进行了多种繁杂的改造工作，可以包括以下几部分：</strong></p>
<ul>
<li><code>设置type信息，基类及基类列表;</code></li>
<li><code>填充tp_dict;</code></li>
<li><code>确定mro列表;</code></li>
<li><code>基于mro列表从基类继承操作;</code></li>
<li><code>设置子类列表;</code></li>
</ul>
<p><strong>不同的类型，有些操作也会有一些不同的行为，但整体是一致的。因此具体某个特定类型，可以自己跟踪PyType_Ready的操作。</strong></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><strong>我们看到类的属性查找虽然看起来简单，但是底层实现起来还是很复杂的。当然关于自定义的类是如何构建的，我们将在下一篇博客中进行剖析。</strong></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Lin Li</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/04/10/18-Python%E7%B1%BB%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90-%E7%B1%BB%E7%9A%84%E5%A4%9A%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%B1%9E%E6%80%A7%E6%9F%A5%E6%89%BE/">http://example.com/2023/04/10/18-Python%E7%B1%BB%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90-%E7%B1%BB%E7%9A%84%E5%A4%9A%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%B1%9E%E6%80%A7%E6%9F%A5%E6%89%BE/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">LinLi's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/CPython/">CPython</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/04/10/19-Python%E7%B1%BB%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E4%BB%A5%E5%8F%8AMetaclass/" title="19-Python类机制深度解析：自定义类的底层实现以及Metaclass"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">19-Python类机制深度解析：自定义类的底层实现以及Metaclass</div></div></a></div><div class="next-post pull-right"><a href="/2023/04/10/17-Python%E7%B1%BB%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90-%E5%9B%9E%E9%A1%BEPython%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/" title="17-Python类机制深度解析-回顾Python中的对象模型"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">17-Python类机制深度解析-回顾Python中的对象模型</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/03/29/01-%E7%BC%96%E8%AF%91Cpython/" title="01-编译Cpython"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">01-编译Cpython</div></div></a></div><div><a href="/2023/03/29/02-%E4%B8%80%E5%88%87%E5%AF%B9%E8%B1%A1%E7%9A%86PyObject/" title="02-一切对象皆PyObject"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">02-一切对象皆PyObject</div></div></a></div><div><a href="/2023/03/29/04-%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/" title="04-浮点数的底层实现"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">04-浮点数的底层实现</div></div></a></div><div><a href="/2023/03/29/06-Bytes%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BA%95%E5%B1%82%E6%93%8D%E4%BD%9C/" title="06-Bytes对象的底层操作"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">06-Bytes对象的底层操作</div></div></a></div><div><a href="/2023/03/29/03-Python%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E5%99%A8%E5%92%8C%E5%BA%95%E5%B1%82%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86/" title="03-Python引用计数器和底层对象管理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">03-Python引用计数器和底层对象管理</div></div></a></div><div><a href="/2023/03/29/05-Python%E6%95%B4%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/" title="05-Python整数的底层实现"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">05-Python整数的底层实现</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Lin Li</div><div class="author-info__description">今日事，今日毕</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">122</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#18-Python%E7%B1%BB%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90-%E7%B1%BB%E7%9A%84%E5%A4%9A%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%B1%9E%E6%80%A7%E6%9F%A5%E6%89%BE"><span class="toc-number">1.</span> <span class="toc-text">18-Python类机制深度解析-类的多继承与属性查找</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A5%94%E5%AD%90"><span class="toc-number">1.1.</span> <span class="toc-text">楔子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5class"><span class="toc-number">1.2.</span> <span class="toc-text">深入class</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%9F%BA%E7%B1%BB%E5%92%8Ctype%E4%BF%A1%E6%81%AF"><span class="toc-number">1.3.</span> <span class="toc-text">处理基类和type信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%9F%BA%E7%B1%BB%E5%88%97%E8%A1%A8"><span class="toc-number">1.4.</span> <span class="toc-text">处理基类列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A1%AB%E5%85%85tp-dict"><span class="toc-number">1.5.</span> <span class="toc-text">填充tp_dict</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#slot%E4%B8%8E%E6%93%8D%E4%BD%9C%E6%8E%92%E5%BA%8F"><span class="toc-number">1.5.1.</span> <span class="toc-text">slot与操作排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8Eslot%E5%88%B0descriptor"><span class="toc-number">1.5.2.</span> <span class="toc-text">从slot到descriptor</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B%E8%81%94%E7%B3%BB"><span class="toc-number">1.5.3.</span> <span class="toc-text">建立联系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AE%E5%AE%9AMRO"><span class="toc-number">1.5.4.</span> <span class="toc-text">确定MRO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E5%9F%BA%E7%B1%BB%E6%93%8D%E4%BD%9C"><span class="toc-number">1.5.5.</span> <span class="toc-text">继承基类操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A1%AB%E5%85%85%E5%9F%BA%E7%B1%BB%E4%B8%AD%E7%9A%84%E5%AD%90%E7%B1%BB%E5%88%97%E8%A1%A8"><span class="toc-number">1.5.6.</span> <span class="toc-text">填充基类中的子类列表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">1.6.</span> <span class="toc-text">小结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/08/%E8%A7%A3%E5%86%B3Camera-ready-%E2%9C%98-Problem-Not-all-fonts-are-embedded-%E9%97%AE%E9%A2%98/" title="解决Camera ready ✘ Problem: Not all fonts are embedded. 问题">解决Camera ready ✘ Problem: Not all fonts are embedded. 问题</a><time datetime="2025-04-08T14:19:21.000Z" title="发表于 2025-04-08 22:19:21">2025-04-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/21/Sequence-Oriented-DBMS-Fuzzing/" title="Sequence-Oriented DBMS Fuzzing">Sequence-Oriented DBMS Fuzzing</a><time datetime="2025-02-21T09:35:08.000Z" title="发表于 2025-02-21 17:35:08">2025-02-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/18/AGENTLESS-Demystifying-LLM-based-Software-Engineering-Agents/" title="AGENTLESS: Demystifying LLM-based Software Engineering Agents">AGENTLESS: Demystifying LLM-based Software Engineering Agents</a><time datetime="2025-02-18T12:16:29.000Z" title="发表于 2025-02-18 20:16:29">2025-02-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/01/DeepSeek-R1-Incentivizing-Reasoning-Capability-in-LLMs-via-Reinforcement-Learning/" title="DeepSeek-R1: Incentivizing Reasoning Capability in LLMs via Reinforcement Learning">DeepSeek-R1: Incentivizing Reasoning Capability in LLMs via Reinforcement Learning</a><time datetime="2025-02-01T11:11:48.000Z" title="发表于 2025-02-01 19:11:48">2025-02-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/01/DeepSeek-Coder-When-the-Large-Language-Model-Meets-Programming-The-Rise-of-Code-Intelligence/" title="DeepSeek-Coder: When the Large Language Model Meets Programming - The Rise of Code Intelligence">DeepSeek-Coder: When the Large Language Model Meets Programming - The Rise of Code Intelligence</a><time datetime="2025-02-01T02:43:19.000Z" title="发表于 2025-02-01 10:43:19">2025-02-01</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Lin Li</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>