<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>33-为什么 obj == obj 为 False、[obj] == [obj] 为 True | LinLi's Blog</title><meta name="author" content="Lin Li"><meta name="copyright" content="Lin Li"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="33-为什么 obj &#x3D;&#x3D; obj 为 False、[obj] &#x3D;&#x3D; [obj] 为 True楔子今天同事在用 pandas 做数据处理的时候，不小心被 nan 坑了一下，他当时被坑的原因类似下面： 1234import numpy as npprint(np.nan &#x3D;&#x3D; np.nan)  # Falseprint([np.nan] &#x3D;&#x3D; [np.nan]">
<meta property="og:type" content="article">
<meta property="og:title" content="33-为什么 obj &#x3D;&#x3D; obj 为 False、[obj] &#x3D;&#x3D; [obj] 为 True">
<meta property="og:url" content="http://example.com/2023/04/26/33-%E4%B8%BA%E4%BB%80%E4%B9%88-obj-obj-%E4%B8%BA-False%E3%80%81-obj-obj-%E4%B8%BA-True/index.html">
<meta property="og:site_name" content="LinLi&#39;s Blog">
<meta property="og:description" content="33-为什么 obj &#x3D;&#x3D; obj 为 False、[obj] &#x3D;&#x3D; [obj] 为 True楔子今天同事在用 pandas 做数据处理的时候，不小心被 nan 坑了一下，他当时被坑的原因类似下面： 1234import numpy as npprint(np.nan &#x3D;&#x3D; np.nan)  # Falseprint([np.nan] &#x3D;&#x3D; [np.nan]">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2023-04-26T13:26:41.000Z">
<meta property="article:modified_time" content="2023-04-26T13:27:04.774Z">
<meta property="article:author" content="Lin Li">
<meta property="article:tag" content="CPython">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/04/26/33-%E4%B8%BA%E4%BB%80%E4%B9%88-obj-obj-%E4%B8%BA-False%E3%80%81-obj-obj-%E4%B8%BA-True/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '33-为什么 obj == obj 为 False、[obj] == [obj] 为 True',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-04-26 21:27:04'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">64</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="LinLi's Blog"><span class="site-name">LinLi's Blog</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">33-为什么 obj == obj 为 False、[obj] == [obj] 为 True</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-04-26T13:26:41.000Z" title="发表于 2023-04-26 21:26:41">2023-04-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-04-26T13:27:04.774Z" title="更新于 2023-04-26 21:27:04">2023-04-26</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="33-为什么 obj == obj 为 False、[obj] == [obj] 为 True"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="33-为什么-obj-x3D-x3D-obj-为-False、-obj-x3D-x3D-obj-为-True"><a href="#33-为什么-obj-x3D-x3D-obj-为-False、-obj-x3D-x3D-obj-为-True" class="headerlink" title="33-为什么 obj &#x3D;&#x3D; obj 为 False、[obj] &#x3D;&#x3D; [obj] 为 True"></a>33-为什么 obj &#x3D;&#x3D; obj 为 False、[obj] &#x3D;&#x3D; [obj] 为 True</h2><h3 id="楔子"><a href="#楔子" class="headerlink" title="楔子"></a>楔子</h3><p><strong>今天同事在用 pandas 做数据处理的时候，不小心被 nan 坑了一下，他当时被坑的原因类似下面：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(np.nan == np.nan)  <span class="comment"># False</span></span><br><span class="line"><span class="built_in">print</span>([np.nan] == [np.nan])  <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<p><strong>为了严谨，我们再举个栗子：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__eq__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a1 = A()</span><br><span class="line">a2 = A()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a1 == a1, a2 == a2)  <span class="comment"># False False</span></span><br><span class="line"><span class="built_in">print</span>([a1, a2] == [a1, a2])  <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<p><strong>为什么会出现这个结果呢？我们知道两个列表（元组也是同理）如果相等，那么首先列表里面的元素个数要相同、并且相同索引对应的元素也要相等。但问题是这里的 a1 不等于 a1、a2 也不等于 a2，那为啥 [a1, a2] 和 [a1, a2] 就相等了呢？</strong></p>
<p><strong>其实原因很好想，那就是 Python  解释器在比较两个列表中的元素的时候，会先比较它们的引用的对象的地址是否相等，也就是看它们是否引用了同一个对象，如果是同一个对象，那么直接得到  True，然后比较下一个，如果不是同一个对象，那么再比较对应的值是否相同。所以这里 a1 &#x3D;&#x3D; a1 明明返回  False，但是放在列表中就变成了 True，原因就在于它们引用的是同一个对象。</strong></p>
<p><strong>那么下面就来从解释器源代码的角度来验证这一结论（版本为 3.9.0），其实后续涉及到的内容在之前就已经说过了，只不过因为比较简单就一笔带过了，所以这次就针对这个例子专门分析一下。</strong></p>
<h3 id="Python-的列表之间是如何比较的"><a href="#Python-的列表之间是如何比较的" class="headerlink" title="Python 的列表之间是如何比较的"></a>Python 的列表之间是如何比较的</h3><p><strong>要想知道底层是如何比较的，那么最好的办法就是先看一下字节码。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> dis</span><br><span class="line"></span><br><span class="line">code = <span class="string">&quot;[] == []&quot;</span></span><br><span class="line">dis.dis(<span class="built_in">compile</span>(code, <span class="string">&quot;&lt;file&gt;&quot;</span>, <span class="string">&quot;exec&quot;</span>))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">  1           0 BUILD_LIST               0</span></span><br><span class="line"><span class="string">              2 BUILD_LIST               0</span></span><br><span class="line"><span class="string">              4 COMPARE_OP               2 (==)</span></span><br><span class="line"><span class="string">              6 POP_TOP</span></span><br><span class="line"><span class="string">              8 LOAD_CONST               0 (None)</span></span><br><span class="line"><span class="string">             10 RETURN_VALUE</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>第一列：表示源代码的行号，我们这里只有一行代码。</strong></p>
<p><strong>第二列：表示指令的偏移量，每一条指令都占两个字节，第一个字节存放指令序列本身，第二个字节存放指令所需要的参数。所以指令从上到下的偏移量是 0 2 4 6 8 ……。</strong></p>
<p><strong>第三列：表示指令序列，在 C 中就是一个宏，会被替换为一个整数。Python 底层总共定义 120 多个指令序列，可以在 *Include&#x2F;opcode.h* 头文件中查看。</strong></p>
<p><img src="/2023/04/26/33-%E4%B8%BA%E4%BB%80%E4%B9%88-obj-obj-%E4%B8%BA-False%E3%80%81-obj-obj-%E4%B8%BA-True/1229382-20210821134015525-325179387.png" alt="img"></p>
<p><strong>第四列：表示指令参数。</strong></p>
<p><strong>所以开头的两个 BUILD_LIST 表示构建列表，后面的指令参数表示元素个数，因为是空列表，所以为 0。两个列表构建完毕显然就要进行比较了，因此指令序列是 COMPARE_OP，而后面的指令参数是 2，代表啥含义呢？</strong></p>
<p><img src="/2023/04/26/33-%E4%B8%BA%E4%BB%80%E4%B9%88-obj-obj-%E4%B8%BA-False%E3%80%81-obj-obj-%E4%B8%BA-True/1229382-20210821134026508-902648107.png" alt="img"></p>
<p><strong>COMPARE_OP  表示比较，但是比较也分为：小于、小于等于、等于、不等于、大于、大于等于，那么到底是哪一种呢？显然要通过指零参数给出，而这里指定的是等于，所以指令参数是 2。至于指令参数后面的 (&#x3D;&#x3D;) 则是 dis 模块帮你添加的，告诉你该指令参数的含义，方便理解。</strong></p>
<p><strong>因此我们的关注点就在 COMPARE_OP 这条指令序列对应的实现当中，而 Python 底层的指令序列对应的实现都位于 *Python&#x2F;ceval.c* 中，在里面有一个 _PyEval_EvalFrameDefault 函数，以栈帧（PyFrameObject）为单位。该函数里面有一个无限的 for  循环，会不断地循环取出字节码中每一条指令序列和指令参数进行执行，直到将该栈帧内部的字节码全部执行完毕，然后退出循环。因此执行逻辑也是在这个  for 循环里面的，没错，for 循环里面有一个巨型的 switch，每一个指令序列都对应一个 case 语句，所以这个 switch 里面有  120 多个 case 语句，然后不同的指令序列走不同的 case，因此 _PyEval_EvalFrameDefault  这个函数非常长，总共多达 3000 行。</strong></p>
<p><strong>那么下面我们就来看看 COMPARE_OP 对应的指令实现，不过这里多提一句：不光是列表，其它对象进行比较的时候对应的指令序列也是 COMPARE_OP。</strong></p>
<p><img src="/2023/04/26/33-%E4%B8%BA%E4%BB%80%E4%B9%88-obj-obj-%E4%B8%BA-False%E3%80%81-obj-obj-%E4%B8%BA-True/1229382-20210821134035158-926311510.png" alt="img"></p>
<p><strong>我们来分析一下：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="title function_">TARGET</span><span class="params">(COMPARE_OP)</span>: &#123;</span><br><span class="line">    <span class="comment">// 这里的 oparg 表示的就是指令参数，显然它和指令序列（opcode）在进入 switch 语句之前就已经被获取</span></span><br><span class="line">    <span class="comment">// 然后这里断言 oparg 必须要小于等于 Py_GE，因为比较操作符中最大的就是 Py_GE，而我们这里是 ==，所以 oparg 的值等于 2</span></span><br><span class="line">    assert(oparg &lt;= Py_GE);</span><br><span class="line">    <span class="comment">// BUILD_LIST 构建的两个列表（指针）会被压入运行时栈，然后这里再将其获取</span></span><br><span class="line">    <span class="comment">// 当然这里只是以列表为例，但我们说进行比较的不一定是列表，可以是任意对象</span></span><br><span class="line">    <span class="comment">// 因此 right 就是比较操作符（我们这里是 ==）右边的变量，left 就是左边的变量</span></span><br><span class="line">    PyObject *right = POP();  <span class="comment">// 元素会从栈中弹出</span></span><br><span class="line">    PyObject *left = TOP();   <span class="comment">// 注意这里是 TOP()，不是 POP()，所以操作符左边的变量还留在栈里面</span></span><br><span class="line">    <span class="comment">// 调用 PyObject_RichCompare，传入 left、right、oparg 进行调用，得到返回结果 res</span></span><br><span class="line">    <span class="comment">// 显然具体的比较逻辑就在 PyObject_RichCompare 里面</span></span><br><span class="line">    PyObject *res = PyObject_RichCompare(left, right, oparg);</span><br><span class="line">    <span class="comment">// 用 res 将栈顶的元素替换掉，所以操作符左边的变量不需要从栈里面弹出，直接将结果与之替换即可</span></span><br><span class="line">    <span class="comment">// 最后再返回</span></span><br><span class="line">    SET_TOP(res);</span><br><span class="line">    Py_DECREF(left);</span><br><span class="line">    Py_DECREF(right);</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    PREDICT(POP_JUMP_IF_FALSE);</span><br><span class="line">    PREDICT(POP_JUMP_IF_TRUE);</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这里涉及到了运行时栈，具体细节就不再赘述了，总之运行时栈是必不可少的，因为 Python 的指令只能有一个指令参数，但是 PyObject_RichCompare 函数需要三个参数，因此其它的参数只能通过运行时栈给出。</strong></p>
<p><strong>我们这里只需要知道，Python 中的比较，在底层会调用 PyObject_RichCompare 函数即可：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a == b  <span class="comment"># PyObject_RichCompare(a, b, Py_EQ)</span></span><br><span class="line">a &gt;= b  <span class="comment"># PyObject_RichCompare(a, b, Py_GE)</span></span><br><span class="line">a != b  <span class="comment"># PyObject_RichCompare(a, b, Py_NE)</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><strong>下面来看看 PyObject_RichCompare 里面的逻辑，该函数藏身于 *Objects&#x2F;object.c* 中。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyObject_RichCompare</span><span class="params">(PyObject *v, PyObject *w, <span class="type">int</span> op)</span></span><br><span class="line">&#123;   <span class="comment">// 参数 v 就是上面的 left、w 就是 right、op 就是 oparg</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取线程状态对象，这里不需要关注</span></span><br><span class="line">    PyThreadState *tstate = _PyThreadState_GET();</span><br><span class="line">    <span class="comment">// 0 &lt;= op &lt;= 5</span></span><br><span class="line">    assert(Py_LT &lt;= op &amp;&amp; op &lt;= Py_GE);</span><br><span class="line">    <span class="comment">// 如果有一方为 NULL，则调用失败</span></span><br><span class="line">    <span class="keyword">if</span> (v == <span class="literal">NULL</span> || w == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!_PyErr_Occurred(tstate)) &#123;</span><br><span class="line">            PyErr_BadInternalCall();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里的 _Py_EnterRecursiveCall 和结尾的 _Py_LeaveRecursiveCall 会成对出现，主要是用于递归比较的，举个栗子</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        a = [None]</span></span><br><span class="line"><span class="comment">        a.append(a)</span></span><br><span class="line"><span class="comment">        print(a)  # [None, [...]]</span></span><br><span class="line"><span class="comment">        print(a[1][1][1][1][1][1][1][1][1][1])  # [None, [...]]</span></span><br><span class="line"><span class="comment">        print(a[1][1][1][1][1][1][1][1][1][0])  # None</span></span><br><span class="line"><span class="comment">        print(a == a)  # True</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 显然 a 后面无论接多少个 [1] 都是合法的，因此就意味着要无限地比较下去，而 Python 显然不会允许这种情况发生</span></span><br><span class="line">    <span class="comment">// 因此这一步就是为了应对这种情况出现</span></span><br><span class="line">    <span class="keyword">if</span> (_Py_EnterRecursiveCall(tstate, <span class="string">&quot; in comparison&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用 do_richcompare，得到返回结果</span></span><br><span class="line">    PyObject *res = do_richcompare(tstate, v, w, op);</span><br><span class="line">    _Py_LeaveRecursiveCall(tstate);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>可以看到 PyObject_RichCompare 里面也不是真正负责执行比较逻辑的，该函数相当于做了一些检测，而比较的结果是调用 do_richcompare 得到的，显然我们需要到这个函数中查看，该函数同样位于 *Objects&#x2F;object.c* 中。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">do_richcompare</span><span class="params">(PyThreadState *tstate, PyObject *v, PyObject *w, <span class="type">int</span> op)</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="comment">// richcmpfunc f 相当于声明一个比较函数，因为 Python 将每个比较操作都抽象成了一个魔法方法，比如：__ge__、__eq__ 等等</span></span><br><span class="line">    <span class="comment">// 虽然在 Python 中不同的比较操作对应不同的魔法方法，但底层对应的都是 PyTypeObject 的 tp_richcompare 成员</span></span><br><span class="line">    <span class="comment">// 该成员负责所有的比较操作，至于到底是哪一种，则由参数来控制</span></span><br><span class="line">    <span class="comment">/* 因此我们看到具体的比较逻辑，还是定义在对应的类对象中</span></span><br><span class="line"><span class="comment">       比如：</span></span><br><span class="line"><span class="comment">           list 对象的比较逻辑定义在 PyList_Type -&gt; tp_richcompare 中</span></span><br><span class="line"><span class="comment">           tuple 对象的比较逻辑定义在 PyTuple_Type -&gt; tp_richcompare 中</span></span><br><span class="line"><span class="comment">           Dict 对象的比较逻辑定义在 PyDict_Type -&gt; tp_richcompare 中</span></span><br><span class="line"><span class="comment">           Set 对象的比较逻辑定义在 PySet_Type -&gt; tp_richcompare 中</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    richcmpfunc f;</span><br><span class="line">    <span class="comment">// 用于存储比较之后的结果</span></span><br><span class="line">    PyObject *res;</span><br><span class="line">    <span class="type">int</span> checked_reverse_op = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Py_TYPE(obj) 表示获取 obj 的类型；</span></span><br><span class="line"><span class="comment">       Py_IS_TYPE(obj, cls) 则是判断 obj 的类型是否为 cls</span></span><br><span class="line"><span class="comment">       PyType_IsSubtype(cls1, cls2) 负责判断 cls1 是否是 cls2 的子类</span></span><br><span class="line"><span class="comment">       所以下面 if 语句的含义就是：当 v 和 w 的类型不同、并且 w 的类型是 v 的类型的子类、</span></span><br><span class="line"><span class="comment">       并且 w 的类型对象内部的 tp_richcompare 成员不为 NULL，然后走这个分支。</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">       直接说的话，可能不是很好解释这个 if 语句到底在做什么，我们可以用一个 Python 测试用例解释一下：</span></span><br><span class="line"><span class="comment">       class A:</span></span><br><span class="line"><span class="comment">           def __eq__(self, other):</span></span><br><span class="line"><span class="comment">               return &quot;A&quot;</span></span><br><span class="line"><span class="comment">       class B(A):</span></span><br><span class="line"><span class="comment">           def __eq__(self, other):</span></span><br><span class="line"><span class="comment">               return &quot;B&quot;</span></span><br><span class="line"><span class="comment">       print(A() == B())  # B</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">       我们知道默认情况下，如果操作符左边的两个对象之间没有任何关系，那么比较的时候优先会找操作符左边的对象的魔法方法</span></span><br><span class="line"><span class="comment">       所以如果 B 不继承 A，也就是 A 和 B 自己没有任何关系，那么按照优先级，A() == B() 就会返回字符串 &quot;A&quot;</span></span><br><span class="line"><span class="comment">       但如果操作符 &quot;右侧的对象的类对象&quot; 是 &quot;左侧的对象的类对象&quot; 的子类，那么这个规则就会被打破</span></span><br><span class="line"><span class="comment">       解释器就会执行操作符右侧的对象的魔法方法，所以这里 B 继承 A，A() == B() 返回了字符串 &quot;B&quot;</span></span><br><span class="line"><span class="comment">       这个 if 语句就是来干这件事的，因此这里的 f 等于 Py_TYPE(w)-&gt;tp_richcompare</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (!Py_IS_TYPE(v, Py_TYPE(w)) &amp;&amp;</span><br><span class="line">        PyType_IsSubtype(Py_TYPE(w), Py_TYPE(v)) &amp;&amp;</span><br><span class="line">        (f = Py_TYPE(w)-&gt;tp_richcompare) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        checked_reverse_op = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 会取出 w 对应的 tp_richcompare，将参数传递进去，进行调用</span></span><br><span class="line">        <span class="comment">// 其中 _Py_SwappedOp[op] 是负责将 op 以宏的形式传递，比如 op 是 2，那么 _Py_SwappedOp[op] 就是 Py_EQ，不过结果也是 2</span></span><br><span class="line">        <span class="comment">// 调用之后将结果保存起来</span></span><br><span class="line">        res = (*f)(w, v, _Py_SwappedOp[op]);</span><br><span class="line">        <span class="comment">/* 然后这里对 res 有一个判断，它是做什么的呢？</span></span><br><span class="line"><span class="comment">        首先我们上面说了，==、!=、&gt;=、&lt;=、&lt;、&gt; 在 Python 中对应不同的魔法方法</span></span><br><span class="line"><span class="comment">        但在底层解释器的角度而言，对应的都是类型对象的 tp_richcompare</span></span><br><span class="line"><span class="comment">        至于底层执行这个函数的时候，到底执行哪一个比较操作，则是由参数控制</span></span><br><span class="line"><span class="comment">        比如我们上面实现了 __eq__，意味着 tp_richcompare 不为 NULL，那么进行比较的时候毫无疑问肯定会走这个分支</span></span><br><span class="line"><span class="comment">        但如果我们执行的不是 A() == B()，而是 A() != B()，那么这里的 res 就返回 Py_NotImplemented</span></span><br><span class="line"><span class="comment">        因为 A 和 B 内部都没有定义 __ne__，因此 tp_richcompare 内部也就不包含处理比较操作为 != 时的逻辑</span></span><br><span class="line"><span class="comment">        所以这个分支一定会走，但返回的 res 会等于 Py_NotImplemented</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (res != Py_NotImplemented)</span><br><span class="line">            <span class="comment">// 返回了 res，并且不等于 Py_NotImplemented，才会返回</span></span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        Py_DECREF(res);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果不是上面那种情况，那么就看 v 是否定义了相应的魔法方法，也就是 Py_TYPE(v) 的 tp_richcompare 成员是否不为 NULL</span></span><br><span class="line">    <span class="comment">// 如果有的话就取出，然后传递参数进行调用，其它逻辑类似</span></span><br><span class="line">    <span class="keyword">if</span> ((f = Py_TYPE(v)-&gt;tp_richcompare) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        res = (*f)(v, w, op);</span><br><span class="line">        <span class="keyword">if</span> (res != Py_NotImplemented)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        Py_DECREF(res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 Py_TYPE(v) 的 tp_richcompare 成员为 NULL，或者 res 为 Py_NotImplemented</span></span><br><span class="line">    <span class="comment">// 就意味着在 Python 的层面，操作符左边的对象内部没有定义该操作符对应的魔法方法（可能定义了别的）</span></span><br><span class="line">    <span class="comment">// 那么此时会去看操作符右侧的对象内部是否有相应的魔法方法，所以这里会看 Py_TYPE(w) 的 tp_richcompare 是否不为 NULL</span></span><br><span class="line">    <span class="keyword">if</span> (!checked_reverse_op &amp;&amp; (f = Py_TYPE(w)-&gt;tp_richcompare) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        res = (*f)(w, v, _Py_SwappedOp[op]);</span><br><span class="line">        <span class="keyword">if</span> (res != Py_NotImplemented)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        Py_DECREF(res);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 走到这里说明，要么上面的三个 if 分支一个都没有通过，即操作两边的对象的内部都没有定义任何关于比较操作的魔法方法</span></span><br><span class="line"><span class="comment">    或者通过了，但返回的 res 等于 Py_NotImplemented，也就是定义了比较操作的魔法方法，</span></span><br><span class="line"><span class="comment">    但是当前执行的操作符对应的魔法方法没有实现 */</span></span><br><span class="line">    <span class="comment">// 不过对于 Python 而言，== 和 != 是永远不会报错的，所以还要检测操作符是不是 == 或 !=</span></span><br><span class="line">    <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">    <span class="comment">/* 尽管指定的操作符没有实现，但如果操作符是 == 或者 !=，也就是 op 为 Py_EQ 或者 Py_NE 时</span></span><br><span class="line"><span class="comment">    那么就比较两个对象的内存地址，比如 class A: pass</span></span><br><span class="line"><span class="comment">    A 里面没有实现任何的魔法方法，但 a = A(); a == a 就是 True，因为对象的内存地址是一样的</span></span><br><span class="line"><span class="comment">    这里说明一下，Python 中的变量在 C 的层面就是一个泛型指针（PyObject *），它存储的不是对象（PyObject），而是对象的地址</span></span><br><span class="line"><span class="comment">    变量在传递的时候会传递地址，但是在操作一个变量时会自动操作变量指向的内存</span></span><br><span class="line"><span class="comment">    所以在判断两个变量是否指向同一个对象的时候（相当于 is），在 C 的层面只需要比较两个指针是否相等即可</span></span><br><span class="line"><span class="comment">    而在比较两个变量指向的对象是否相等（也就是 == ），那么会将两个变量指向的对象所维护的值取出来，调用 PyObject_RichCompare 进行比较</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">case</span> Py_EQ:</span><br><span class="line">        <span class="comment">// 这里的 v 和 w 显然就相当于 Python 中的变量，就是一个指针</span></span><br><span class="line">        <span class="comment">// 因此判断两个变量是否指向同一个对象，直接判断这两个指针存的地址是否相等即可</span></span><br><span class="line">        res = (v == w) ? Py_True : Py_False;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Py_NE:</span><br><span class="line">        <span class="comment">// 同理</span></span><br><span class="line">        res = (v != w) ? Py_True : Py_False;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 如果比较操作符不是 == 或者 !=，那么就不好意思了，这两个实例之间不允许执行当前的比较操作</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        _PyErr_Format(tstate, PyExc_TypeError,</span><br><span class="line">                      <span class="string">&quot;&#x27;%s&#x27; not supported between instances of &#x27;%.100s&#x27; and &#x27;%.100s&#x27;&quot;</span>,</span><br><span class="line">                      opstrings[op],</span><br><span class="line">                      Py_TYPE(v)-&gt;tp_name,</span><br><span class="line">                      Py_TYPE(w)-&gt;tp_name);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 增加引用计数，返回</span></span><br><span class="line">    Py_INCREF(res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>以上就是 do_richcompare 的逻辑，它里面干了哪些事情呢？我们说里面三个 if 语句，主要用于确定到底该执行谁的魔法方法，比如 A 和 B 的实例进行比较：</strong></p>
<ul>
<li><code>1. 如果 A 和 B 是不同的类、并且 B 还是 A 的子类，那么 &quot;A() 操作符 B()&quot; 会优先去 B 中查找操作符对应的魔法方法</code></li>
<li><code>2. 否则的话，会按照优先级，先找 A（操作符左边）的魔法方法</code></li>
<li><code>3. 如果左边没有，那么就最后再找右边</code></li>
</ul>
<p><strong>如果成功执行则直接返回，否则的话再对操作符进行判定，如果是 &#x3D;&#x3D; 或者 !&#x3D; ，那么就比较两个对象是否是同一个对象。</strong></p>
<p><strong>虽然花了一定的笔墨解释完了比较操作在底层的逻辑，但是我们上面的问题本质上依旧没有得到解决，我们还是不知道列表是如何比较的。因为很明显，比较的核心在于类型对象的 tp_richcompare 中，它返回的结果就是这里的 res，所以如果我们想知道列表是如何比较的，那么就去 PyList_Type  的 tp_richcompare 成员中查看即可。</strong></p>
<p><img src="/2023/04/26/33-%E4%B8%BA%E4%BB%80%E4%B9%88-obj-obj-%E4%B8%BA-False%E3%80%81-obj-obj-%E4%B8%BA-True/1229382-20210821134048797-1008013922.png" alt="img"></p>
<p><strong>而 PyList_Type 的 tp_richcompare 成员对应的是 list_richcompare 函数，我们来看一下，其藏身于 *Objects&#x2F;listobject.c* 中。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">list_richcompare</span><span class="params">(PyObject *v, PyObject *w, <span class="type">int</span> op)</span></span><br><span class="line">&#123;    </span><br><span class="line">    PyListObject *vl, *wl;</span><br><span class="line">    Py_ssize_t i;</span><br><span class="line">    <span class="comment">// v 和 w 一定是 PyListObject *</span></span><br><span class="line">    <span class="keyword">if</span> (!PyList_Check(v) || !PyList_Check(w))</span><br><span class="line">        Py_RETURN_NOTIMPLEMENTED;</span><br><span class="line">    <span class="comment">// 将 PyObject * 转成 PyListObject *</span></span><br><span class="line">    vl = (PyListObject *)v;</span><br><span class="line">    wl = (PyListObject *)w;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 快分支：如果两个列表连长度都不相等，那么当比较操作符是 == 或 != 的时候可以直接出结果</span></span><br><span class="line">    <span class="keyword">if</span> (Py_SIZE(vl) != Py_SIZE(wl) &amp;&amp; (op == Py_EQ || op == Py_NE)) &#123;</span><br><span class="line">        <span class="comment">// op 是 ==，返回 False</span></span><br><span class="line">        <span class="comment">// op 是 !=，返回 True</span></span><br><span class="line">        <span class="keyword">if</span> (op == Py_EQ)</span><br><span class="line">            Py_RETURN_FALSE;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            Py_RETURN_TRUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当列表长度相等，或者操作不是 == 或者 !=，那么就需要将两个列表中的元素进行逐个比较了</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; Py_SIZE(vl) &amp;&amp; i &lt; Py_SIZE(wl); i++) &#123;</span><br><span class="line">        PyObject *vitem = vl-&gt;ob_item[i];</span><br><span class="line">        PyObject *witem = wl-&gt;ob_item[i];</span><br><span class="line">        <span class="comment">/*我们说 Python 中变量本质上是一个指针，当然不光是变量，列表、元组、字典等容器里面容纳的也是指针</span></span><br><span class="line"><span class="comment">        如果 vitem == witem，说明这两个列表存储的是同一个对象的指针（在 Python 里面也可以说引用）</span></span><br><span class="line"><span class="comment">        所以直接就 continue 了，说明当前位置的两个元素是相等的</span></span><br><span class="line"><span class="comment">        因此我们就解释了在最开始的问题中，为什么 a1 != a1、np.nan != np.nan，但 [a1] == [a1] 和 [np.nan] == [np.nan] 却都是成立的</span></span><br><span class="line"><span class="comment">        再比如 None &gt; None 会报错，但是 [None] &gt; [None] 却不会，原因就在于 None 是单例的，地址相同</span></span><br><span class="line"><span class="comment">        而地址相同，那么就不比了（不管这两个对象能不能比），而是直接看下一个元素 */</span></span><br><span class="line">        <span class="keyword">if</span> (vitem == witem) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 增加引用计数</span></span><br><span class="line">        Py_INCREF(vitem);</span><br><span class="line">        Py_INCREF(witem);</span><br><span class="line">        <span class="comment">/*当不是同一个对象时，那就比较对象维护的值是否相同，这里又出现了一个 PyObject_RichCompareBool</span></span><br><span class="line"><span class="comment">        它在底层会调用之前说的 PyObject_RichCompare，只不过在调用之前会先检测对象的地址是否相同</span></span><br><span class="line"><span class="comment">        如果是同一个对象，并且操作符是 ==、!=，那么会直接根据对象的地址判断</span></span><br><span class="line"><span class="comment">        如果不是同一个对象，或者操作符不是 == 或者 !=，再调用 PyObject_RichCompare 比较对象维护的值之间的关系，</span></span><br><span class="line"><span class="comment">        此外该函数返回的是整型，为真返回 1、为假返回 0，报错了返回 -1 */</span></span><br><span class="line">        <span class="type">int</span> k = PyObject_RichCompareBool(vitem, witem, Py_EQ);</span><br><span class="line">        Py_DECREF(vitem);</span><br><span class="line">        Py_DECREF(witem);</span><br><span class="line">        <span class="keyword">if</span> (k &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">// 为假直接 break，否则继续下一轮循环</span></span><br><span class="line">        <span class="keyword">if</span> (!k)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 两个列表如果长度不相等，那么不断遍历的话，肯定有一方先结束</span></span><br><span class="line">    <span class="comment">// 下面逻辑就是处理长度不相等的情况，比较简单，可以自己看一下</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= Py_SIZE(vl) || i &gt;= Py_SIZE(wl)) &#123;</span><br><span class="line">        <span class="comment">/* No more items to compare -- compare sizes */</span></span><br><span class="line">        Py_RETURN_RICHCOMPARE(Py_SIZE(vl), Py_SIZE(wl), op);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We have an item that differs -- shortcuts for EQ/NE */</span></span><br><span class="line">    <span class="keyword">if</span> (op == Py_EQ) &#123;</span><br><span class="line">        Py_RETURN_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (op == Py_NE) &#123;</span><br><span class="line">        Py_RETURN_TRUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Compare the final item again using the proper operator */</span></span><br><span class="line">    <span class="keyword">return</span> PyObject_RichCompare(vl-&gt;ob_item[i], wl-&gt;ob_item[i], op);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>因此到这里我们才算真正解释了最开始的问题，在调用  PyObject_RichCompare 进行比较的时候，a1 &#x3D;&#x3D; a1 会走内部的 __eq__，而在里面返回的 False。而 [a1]  &#x3D;&#x3D; [a1] 会走列表的 __eq__，而里面在比较元素的时候会先比较地址是否一样，如果一样直接就过了，根本不会走 type(a1) 里面的  __eq__。</strong></p>
<p><strong>Python 中的 in 也是同理，我们知道 a in b 等价于  b.<strong>contains</strong>(a)，逻辑就是不断地对 b 进行迭代，将得到的元素依次和 a 进行比较，如果相等则直接返回  True；如果迭代结束时一直没有找到和 a 相等的元素，那么返回  False。所以逻辑很简单，但我想说的是，这里比较相等的逻辑也会先比较对象的地址是否相同，如果地址相同直接为  True，当地址不同时，才会比较值是否一致。而从底层来看的话，这里的比较会调用 PyObject_RichCompareBool，而我们知道在这个函数里面会先比较地址是否一样，地址不一样再比较维护的值是否一样（调用对应的 __eq__）。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__eq__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line"><span class="comment"># 底层调用 PyObject_RichCompare，然后调用 __eq__</span></span><br><span class="line"><span class="built_in">print</span>(a == a)  <span class="comment"># False</span></span><br><span class="line"><span class="comment"># 底层会调用 PyObject_RichCompareBool，会先判断两者是不是同一个对象</span></span><br><span class="line"><span class="built_in">print</span>(a <span class="keyword">in</span> (a,))  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(a <span class="keyword">in</span> [a])  <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<p><strong>以上就是由 nan 引发的一些思考，当然还是比较简单的，因为是一些之前说过的内容。</strong></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Lin Li</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/04/26/33-%E4%B8%BA%E4%BB%80%E4%B9%88-obj-obj-%E4%B8%BA-False%E3%80%81-obj-obj-%E4%B8%BA-True/">http://example.com/2023/04/26/33-%E4%B8%BA%E4%BB%80%E4%B9%88-obj-obj-%E4%B8%BA-False%E3%80%81-obj-obj-%E4%B8%BA-True/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">LinLi's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/CPython/">CPython</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/04/26/34-%E4%BE%B5%E5%85%A5-Python-%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%8C%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6/" title="34-侵入 Python 虚拟机，动态修改底层数据结构和运行时"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">34-侵入 Python 虚拟机，动态修改底层数据结构和运行时</div></div></a></div><div class="next-post pull-right"><a href="/2023/04/26/32-Python-%E5%92%8C-Go-%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/" title="32-Python 和 Go 联合编程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">32-Python 和 Go 联合编程</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/03/29/01-%E7%BC%96%E8%AF%91Cpython/" title="01-编译Cpython"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">01-编译Cpython</div></div></a></div><div><a href="/2023/03/29/02-%E4%B8%80%E5%88%87%E5%AF%B9%E8%B1%A1%E7%9A%86PyObject/" title="02-一切对象皆PyObject"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">02-一切对象皆PyObject</div></div></a></div><div><a href="/2023/03/29/04-%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/" title="04-浮点数的底层实现"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">04-浮点数的底层实现</div></div></a></div><div><a href="/2023/03/29/06-Bytes%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BA%95%E5%B1%82%E6%93%8D%E4%BD%9C/" title="06-Bytes对象的底层操作"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">06-Bytes对象的底层操作</div></div></a></div><div><a href="/2023/03/29/03-Python%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E5%99%A8%E5%92%8C%E5%BA%95%E5%B1%82%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86/" title="03-Python引用计数器和底层对象管理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">03-Python引用计数器和底层对象管理</div></div></a></div><div><a href="/2023/03/29/05-Python%E6%95%B4%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/" title="05-Python整数的底层实现"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">05-Python整数的底层实现</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Lin Li</div><div class="author-info__description">今日事，今日毕</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">64</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#33-%E4%B8%BA%E4%BB%80%E4%B9%88-obj-x3D-x3D-obj-%E4%B8%BA-False%E3%80%81-obj-x3D-x3D-obj-%E4%B8%BA-True"><span class="toc-number">1.</span> <span class="toc-text">33-为什么 obj &#x3D;&#x3D; obj 为 False、[obj] &#x3D;&#x3D; [obj] 为 True</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A5%94%E5%AD%90"><span class="toc-number">1.1.</span> <span class="toc-text">楔子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Python-%E7%9A%84%E5%88%97%E8%A1%A8%E4%B9%8B%E9%97%B4%E6%98%AF%E5%A6%82%E4%BD%95%E6%AF%94%E8%BE%83%E7%9A%84"><span class="toc-number">1.2.</span> <span class="toc-text">Python 的列表之间是如何比较的</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/17/Testing-database-engines-via-pivoted-query-synthesis/" title="Testing database engines via pivoted query synthesis">Testing database engines via pivoted query synthesis</a><time datetime="2023-07-17T02:42:50.000Z" title="发表于 2023-07-17 10:42:50">2023-07-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/09/History-Driven-Build-Failure-Fixing-How-Far-Are-We/" title="History-Driven Build Failure Fixing: How Far Are We?">History-Driven Build Failure Fixing: How Far Are We?</a><time datetime="2023-07-09T07:58:11.000Z" title="发表于 2023-07-09 15:58:11">2023-07-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/09/HireBuild-An-Automatic-Approach-to-History-Driven-Repair-of-Build-Scripts/" title="HireBuild: An Automatic Approach to History-Driven Repair of Build Scripts">HireBuild: An Automatic Approach to History-Driven Repair of Build Scripts</a><time datetime="2023-07-09T07:57:05.000Z" title="发表于 2023-07-09 15:57:05">2023-07-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/07/Automated-API-Usage-Update-for-Android-Apps/" title="Automated API-Usage Update for Android Apps">Automated API-Usage Update for Android Apps</a><time datetime="2023-07-07T08:20:20.000Z" title="发表于 2023-07-07 16:20:20">2023-07-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/07/Automated-Deprecated-API-Usage-Update-for-Android-Apps-How-Far-Are-We/" title="Automated Deprecated-API Usage Update for Android Apps How Far Are We">Automated Deprecated-API Usage Update for Android Apps How Far Are We</a><time datetime="2023-07-07T08:19:22.000Z" title="发表于 2023-07-07 16:19:22">2023-07-07</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Lin Li</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>