<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>34-侵入 Python 虚拟机，动态修改底层数据结构和运行时 | LinLi's Blog</title><meta name="author" content="Lin Li"><meta name="copyright" content="Lin Li"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="34-侵入 Python 虚拟机，动态修改底层数据结构和运行时楔子之前分析了那么久的虚拟机，多少会有点无聊，那么本次我们来介绍一个好玩的，看看如何修改 Python 解释器的底层数据结构和运行时。了解虚拟机除了可以让我们写出更好的代码之外，还可以对 Python 进行改造。举个栗子：  是不是很有趣呢？通过 Python 内置的 ctypes 模块即可做到，而具体实现方式我们一会儿说。所以本次我们">
<meta property="og:type" content="article">
<meta property="og:title" content="34-侵入 Python 虚拟机，动态修改底层数据结构和运行时">
<meta property="og:url" content="http://example.com/2023/04/26/34-%E4%BE%B5%E5%85%A5-Python-%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%8C%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6/index.html">
<meta property="og:site_name" content="LinLi&#39;s Blog">
<meta property="og:description" content="34-侵入 Python 虚拟机，动态修改底层数据结构和运行时楔子之前分析了那么久的虚拟机，多少会有点无聊，那么本次我们来介绍一个好玩的，看看如何修改 Python 解释器的底层数据结构和运行时。了解虚拟机除了可以让我们写出更好的代码之外，还可以对 Python 进行改造。举个栗子：  是不是很有趣呢？通过 Python 内置的 ctypes 模块即可做到，而具体实现方式我们一会儿说。所以本次我们">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2023-04-26T13:27:13.000Z">
<meta property="article:modified_time" content="2023-04-26T13:27:35.080Z">
<meta property="article:author" content="Lin Li">
<meta property="article:tag" content="CPython">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/04/26/34-%E4%BE%B5%E5%85%A5-Python-%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%8C%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '34-侵入 Python 虚拟机，动态修改底层数据结构和运行时',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-04-26 21:27:35'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">122</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="LinLi's Blog"><span class="site-name">LinLi's Blog</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">34-侵入 Python 虚拟机，动态修改底层数据结构和运行时</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-04-26T13:27:13.000Z" title="发表于 2023-04-26 21:27:13">2023-04-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-04-26T13:27:35.080Z" title="更新于 2023-04-26 21:27:35">2023-04-26</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="34-侵入 Python 虚拟机，动态修改底层数据结构和运行时"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="34-侵入-Python-虚拟机，动态修改底层数据结构和运行时"><a href="#34-侵入-Python-虚拟机，动态修改底层数据结构和运行时" class="headerlink" title="34-侵入 Python 虚拟机，动态修改底层数据结构和运行时"></a>34-侵入 Python 虚拟机，动态修改底层数据结构和运行时</h2><h3 id="楔子"><a href="#楔子" class="headerlink" title="楔子"></a>楔子</h3><p><strong>之前分析了那么久的虚拟机，多少会有点无聊，那么本次我们来介绍一个好玩的，看看如何修改 Python 解释器的底层数据结构和运行时。了解虚拟机除了可以让我们写出更好的代码之外，还可以对 Python 进行改造。举个栗子：</strong></p>
<p><img src="/2023/04/26/34-%E4%BE%B5%E5%85%A5-Python-%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%8C%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6/1229382-20211031134842860-1005929349.png" alt="img"></p>
<p><strong>是不是很有趣呢？通过 Python 内置的 ctypes 模块即可做到，而具体实现方式我们一会儿说。所以本次我们的工具就是 ctypes 模块（Python 版本为 3.8），需要你对它已经或多或少有一些了解，哪怕只有一点点也是没关系的。</strong></p>
<blockquote>
<p><strong>注意：本次介绍的内容绝不能用于生产环境，仅仅只是为了更好地理解 Python 虚拟机、或者做测试的时候使用，用于生产环境是绝对的大忌。</strong></p>
<p><strong>不可用于生产环境！！！</strong></p>
<p><strong>不可用于生产环境！！！</strong></p>
<p><strong>不可用于生产环境！！！</strong></p>
</blockquote>
<p><strong>那么废话不多说，下面就开始吧。</strong></p>
<h3 id="使用-Python-表示-C-的数据结构"><a href="#使用-Python-表示-C-的数据结构" class="headerlink" title="使用 Python 表示 C 的数据结构"></a>使用 Python 表示 C 的数据结构</h3><p><strong>Python 是用 C 实现的，如果想在 Python 的层面修改底层逻辑，那么我们肯定要能够将 C 的数据结构用 Python 表示出来。而 ctypes 提供了大量的类，专门负责做这件事情，下面按照类型属性分别介绍。</strong></p>
<h4 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h4><p><strong>C 语言的数值类型分为如下：</strong></p>
<ul>
<li><code>int：整型</code></li>
<li><code>unsigned int：无符号整型</code></li>
<li><code>short：短整型</code></li>
<li><code>unsigned short：无符号短整型</code></li>
<li><code>long：长整形</code></li>
<li><code>unsigned long：无符号长整形</code></li>
<li><code>long long：64 位机器上等同于 long</code></li>
<li><code>unsigned long long：64 位机器上等同于 unsigned long</code></li>
<li><code>float：单精度浮点型</code></li>
<li><code>double：双精度浮点型</code></li>
<li><code>long double：看成是 double 即可</code></li>
<li><code>_Bool：布尔类型</code></li>
<li><code>ssize_t：等同于 long 或者 long long</code></li>
<li><code>size_t：等同于 unsigned long 或者 unsigned long long</code></li>
</ul>
<p><strong>和 Python 以及 ctypes 之间的对应关系如下：</strong></p>
<p><img src="/2023/04/26/34-%E4%BE%B5%E5%85%A5-Python-%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%8C%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6/1229382-20211031134851148-1943662743.png" alt="img"></p>
<p><strong>下面来演示一下：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面都是 ctypes 中提供的类，将 Python 中的数据传进去，就可以转换为 C 的数据</span></span><br><span class="line"><span class="built_in">print</span>(ctypes.c_int(<span class="number">1</span>))  <span class="comment"># c_long(1)</span></span><br><span class="line"><span class="built_in">print</span>(ctypes.c_uint(<span class="number">1</span>))  <span class="comment"># c_ulong(1)</span></span><br><span class="line"><span class="built_in">print</span>(ctypes.c_short(<span class="number">1</span>))  <span class="comment"># c_short(1)</span></span><br><span class="line"><span class="built_in">print</span>(ctypes.c_ushort(<span class="number">1</span>))  <span class="comment"># c_ushort(1)</span></span><br><span class="line"><span class="built_in">print</span>(ctypes.c_long(<span class="number">1</span>))  <span class="comment"># c_long(1)</span></span><br><span class="line"><span class="built_in">print</span>(ctypes.c_ulong(<span class="number">1</span>))  <span class="comment"># c_ulong(1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># c_longlong 等价于 c_long，c_ulonglong 等价于 c_ulong</span></span><br><span class="line"><span class="built_in">print</span>(ctypes.c_longlong(<span class="number">1</span>))  <span class="comment"># c_longlong(1)</span></span><br><span class="line"><span class="built_in">print</span>(ctypes.c_ulonglong(<span class="number">1</span>))  <span class="comment"># c_ulonglong(1)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(ctypes.c_float(<span class="number">1.1</span>))  <span class="comment"># c_float(1.100000023841858)</span></span><br><span class="line"><span class="built_in">print</span>(ctypes.c_double(<span class="number">1.1</span>))  <span class="comment"># c_double(1.1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在64位机器上，c_longdouble等于c_double</span></span><br><span class="line"><span class="built_in">print</span>(ctypes.c_longdouble(<span class="number">1.1</span>))  <span class="comment"># c_double(1.1)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(ctypes.c_bool(<span class="literal">True</span>))  <span class="comment"># c_bool(True)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 相当于c_longlong和c_ulonglong</span></span><br><span class="line"><span class="built_in">print</span>(ctypes.c_ssize_t(<span class="number">10</span>))  <span class="comment"># c_longlong(10)</span></span><br><span class="line"><span class="built_in">print</span>(ctypes.c_size_t(<span class="number">10</span>))  <span class="comment"># c_ulonglong(10)</span></span><br></pre></td></tr></table></figure>

<p><strong>而 C 的数据转成 Python 的数据也非常容易，只需要在此基础上调用一下 value 即可。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(ctypes.c_int(<span class="number">1024</span>).value)  <span class="comment"># 1024</span></span><br><span class="line"><span class="built_in">print</span>(ctypes.c_int(<span class="number">1024</span>).value == <span class="number">1024</span>)  <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<h4 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h4><p><strong>C 语言的字符类型分为如下：</strong></p>
<ul>
<li><code>char：一个 ascii 字符或者 -128~127 的整型</code></li>
<li><code>wchar：一个 unicode 字符</code></li>
<li><code>unsigned char：一个 ascii 字符或者 0~255 的一个整型</code></li>
</ul>
<p><strong>和 Python 以及 ctypes 之间的对应关系如下：</strong></p>
<p><img src="/2023/04/26/34-%E4%BE%B5%E5%85%A5-Python-%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%8C%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6/1229382-20211031134901625-1142939073.png" alt="img"></p>
<p><strong>举个栗子：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 必须传递一个字节（里面是 ascii 字符），或者一个 int，来代表 C 里面的字符</span></span><br><span class="line"><span class="built_in">print</span>(ctypes.c_char(<span class="string">b&quot;a&quot;</span>))  <span class="comment"># c_char(b&#x27;a&#x27;)</span></span><br><span class="line"><span class="built_in">print</span>(ctypes.c_char(<span class="number">97</span>))  <span class="comment"># c_char(b&#x27;a&#x27;)</span></span><br><span class="line"><span class="comment"># 和 c_char 类似，但是 c_char 既可以传入单个字节、也可以传整型</span></span><br><span class="line"><span class="comment"># 而这里的 c_byte 和则要求必须传递整型</span></span><br><span class="line"><span class="built_in">print</span>(ctypes.c_byte(<span class="number">97</span>))  <span class="comment"># c_byte(97)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 传递一个 unicode 字符，当然 ascii 字符也是可以的，并且不是字节形式</span></span><br><span class="line"><span class="built_in">print</span>(ctypes.c_wchar(<span class="string">&quot;憨&quot;</span>))  <span class="comment"># c_wchar(&#x27;憨&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 同样只能传递整型，</span></span><br><span class="line"><span class="built_in">print</span>(ctypes.c_ubyte(<span class="number">97</span>))  <span class="comment"># c_ubyte(97)</span></span><br></pre></td></tr></table></figure>

<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p><strong>下面看看如何构造一个 C 中的数组：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"></span><br><span class="line"><span class="comment"># C 里面创建数组的方式如下：int a[5] = &#123;1, 2, 3, 4, 5&#125;</span></span><br><span class="line"><span class="comment"># 使用 ctypes 的话</span></span><br><span class="line">array = (ctypes.c_int * <span class="number">5</span>)(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="comment"># (ctypes.c_int * N) 等价于 int a[N]，相当于构造出了一个类型，然后再通过类似函数调用的方式指定数组的元素即可</span></span><br><span class="line"><span class="comment"># 这里指定元素的时候直接输入数字即可，会自动转成 C 中的 int，当然我们也可以使用 c_int 手动包装</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(array))  <span class="comment"># 5</span></span><br><span class="line"><span class="built_in">print</span>(array)  <span class="comment"># &lt;__main__.c_int_Array_5 object at 0x7f96276fd4c0&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(array)):</span><br><span class="line">    <span class="built_in">print</span>(array[i], end=<span class="string">&quot; &quot;</span>)  <span class="comment"># 1 2 3 4 5</span></span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">array = (ctypes.c_char * <span class="number">3</span>)(<span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(array))  <span class="comment"># [b&#x27;a&#x27;, b&#x27;b&#x27;, b&#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看一下数组在 Python 里面的类型，因为数组存储的元素类型为  c_int、数组长度为 5，所以这个数组在 Python 里面的类型就是 c_int_Array_5，而打印的时候则显示为  c_int_Array_5 的实例对象。我们可以调用 len  方法获取长度，也可以通过索引的方式去指定的元素，并且由于内部实现了迭代器协议，我们还可以使用 for 循环去遍历，或者使用 list  直接转成列表等等，都是可以的。</strong></p>
<h4 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h4><p><strong>结构体应该是 C 里面最重要的结构之一了，假设 C 里面有这样一个结构体：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> field1;</span><br><span class="line">    <span class="type">float</span> field2;</span><br><span class="line">    <span class="type">long</span> field3[<span class="number">5</span>];</span><br><span class="line">&#125; MyStruct;</span><br></pre></td></tr></table></figure>

<p><strong>要如何在 Python 里面表示它呢？</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># C 中的结构体在 Python 里面显然通过类来实现，但是这个类一定要继承 ctypes.Structure</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyStruct</span>(ctypes.Structure):</span><br><span class="line">    <span class="comment"># 结构体的每一个成员对应一个元组，第一个元素为字段名，第二个元素为类型</span></span><br><span class="line">    <span class="comment"># 然后多个成员放在一个列表中，并用变量 _fields_ 指定</span></span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">&quot;field1&quot;</span>, ctypes.c_int),</span><br><span class="line">        (<span class="string">&quot;field2&quot;</span>, ctypes.c_float),</span><br><span class="line">        (<span class="string">&quot;field3&quot;</span>, (ctypes.c_long * <span class="number">5</span>)),</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># field1、field2、field3 就类似函数参数一样，可以通过位置参数、关键字参数指定</span></span><br><span class="line">s = MyStruct(field1=ctypes.c_int(<span class="number">123</span>),</span><br><span class="line">             field2=ctypes.c_float(<span class="number">3.14</span>),</span><br><span class="line">             field3=(ctypes.c_long * <span class="number">5</span>)(<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">55</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(s)  <span class="comment"># &lt;__main__.MyStruct object at 0x7ff9701d0c40&gt;</span></span><br><span class="line"><span class="built_in">print</span>(s.field1)  <span class="comment"># 123</span></span><br><span class="line"><span class="built_in">print</span>(s.field2)  <span class="comment"># 3.140000104904175</span></span><br><span class="line"><span class="built_in">print</span>(s.field3)  <span class="comment"># &lt;__main__.c_long_Array_5 object at 0x7ffa3a5f84c0&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>就像实例化一个普通的类一样，然后也可以像获取实例属性一样获取结构体成员。这里获取之后会自动转成 Python 中的数据，比如 c_int 类型会自动转成 int，c_float 会自动转成 float，而数组由于 Python  没有内置，所以直接打印为 “c_long_Array_5 的实例对象”。</strong></p>
<h4 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h4><p><strong>指针是 C 语言灵魂，而且绝大部分的 Bug 也都是指针所引起的，那么指针类型在 Python 里面如何表示呢？非常简单，通过 ctypes.POINTER 即可表示 C 的指针类型，比如：</strong></p>
<ul>
<li><code>C 中的 int *，在 Python 里面就是 ctypes.POINTER(c_int)</code></li>
<li><code>C 中的 float *，在 Python 里面就是 ctypes.POINTER(c_float)</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyStruct</span>(<span class="title class_ inherited__">Structure</span>):</span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">&quot;field1&quot;</span>, POINTER(c_long)),</span><br><span class="line">        (<span class="string">&quot;field2&quot;</span>, POINTER(c_double)),</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure>

<p><strong>所以通过 POINTER(类型) 即可表示对应类型的指针，而获取指针则是通过 pointer 函数。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 C 里面就相当于，long a = 1024; long *p = &amp;a;</span></span><br><span class="line">p = pointer(c_long(<span class="number">1024</span>))</span><br><span class="line"><span class="built_in">print</span>(p)  <span class="comment"># &lt;__main__.LP_c_long object at 0x7ff3639d0dc0&gt;</span></span><br><span class="line"><span class="built_in">print</span>(p.__class__)  <span class="comment"># &lt;class &#x27;__main__.LP_c_long&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pointer 可以获取任意类型的指针</span></span><br><span class="line"><span class="built_in">print</span>(pointer(c_float(<span class="number">3.14</span>)).__class__)  <span class="comment"># &lt;class &#x27;__main__.LP_c_float&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(pointer(c_double(<span class="number">2.71</span>)).__class__)  <span class="comment"># &lt;class &#x27;__main__.LP_c_double&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>同理，我们也可以通过指针获取指向的值，也就是对指针进行解引用。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p = pointer(c_long(<span class="number">123</span>))</span><br><span class="line"><span class="comment"># 调用 contents 即可获取指向的值，相当于对指针进行解引用</span></span><br><span class="line"><span class="built_in">print</span>(p.contents)  <span class="comment"># c_long(123)</span></span><br><span class="line"><span class="built_in">print</span>(p.contents.value)  <span class="comment"># 123</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果对 p 再使用一次 pointer 函数，那么相当于获取 p 的指针</span></span><br><span class="line"><span class="comment"># 此时相当于二级指针 long **，所以类型为 LP_LP_c_long</span></span><br><span class="line"><span class="built_in">print</span>(pointer(pointer_p))  <span class="comment"># &lt;__main__.LP_LP_c_long object at 0x7fe6121d0bc0&gt;</span></span><br><span class="line"><span class="comment"># 三级指针，类型为 LP_LP_LP_c_long</span></span><br><span class="line"><span class="built_in">print</span>(pointer(pointer(pointer_p)))  <span class="comment"># &lt;__main__.LP_LP_LP_c_long object at 0x7fb2a29d0bc0&gt;</span></span><br><span class="line"><span class="comment"># 三次解引用，获取对应的值</span></span><br><span class="line"><span class="built_in">print</span>(pointer(pointer(pointer_p)).contents.contents.contents)  <span class="comment"># c_long(123)</span></span><br><span class="line"><span class="built_in">print</span>(pointer(pointer(pointer_p)).contents.contents.contents.value)  <span class="comment"># 123</span></span><br></pre></td></tr></table></figure>

<p><strong>总的来说，还是比较好理解的。但我们知道，在 C 中数组等于数组首元素的地址，我们除了传一个指针过去之外，传数组也是可以的。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyStruct</span>(<span class="title class_ inherited__">Structure</span>):</span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">&quot;field1&quot;</span>, POINTER(c_long)),</span><br><span class="line">        (<span class="string">&quot;field2&quot;</span>, POINTER(c_double)),</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结构体也可以先创建，再实例化成员</span></span><br><span class="line">s = MyStruct()</span><br><span class="line">s.field1 = pointer(c_long(<span class="number">1024</span>))</span><br><span class="line">s.field2 = (c_double * <span class="number">3</span>)(<span class="number">3.14</span>, <span class="number">1.732</span>, <span class="number">2.71</span>)</span><br></pre></td></tr></table></figure>

<p><strong>数组在作为参数传递的时候会退化为指针，所以此时数组的长度信息就丢失了，使用 sizeof 计算出来的结果就是一个指针的大小。因此将数组作为参数传递的时候，应该将当前数组的长度信息也传递过去，否则可能会访问非法的内存。</strong></p>
<p><strong>然后在 C 里面还有 char *、wchar_t *、void *，这些指针在 ctypes 里面专门提供了几个类与之对应。</strong></p>
<p><img src="/2023/04/26/34-%E4%BE%B5%E5%85%A5-Python-%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%8C%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6/1229382-20211031134909949-514832209.png" alt="img"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># c_char_p 就是 c 里面字符数组了，其实我们可以把它看成是 Python 中的 bytes 对象</span></span><br><span class="line"><span class="comment"># char *s = &quot;hello world&quot;;</span></span><br><span class="line"><span class="comment"># 那么这里面也要传递一个 bytes 类型的字符串，返回一个地址</span></span><br><span class="line"><span class="built_in">print</span>(c_char_p(<span class="string">b&quot;hello world&quot;</span>))  <span class="comment"># c_char_p(140451925798832)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接传递一个字符串，同样返回一个地址</span></span><br><span class="line"><span class="built_in">print</span>(c_wchar_p(<span class="string">&quot;古明地觉&quot;</span>))  <span class="comment"># c_wchar_p(140451838245008)</span></span><br></pre></td></tr></table></figure>

<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p><strong>最后看一下如何在 Python 中表示 C 的函数，首先 C 的函数可以有多个参数，但只有一个返回值。举个栗子：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">add</span><span class="params">(<span class="type">long</span> *a, <span class="type">long</span> *b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> *a + *b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这个函数接收两个 long *、返回一个 long，那么这种函数类型要如何表示呢？答案是通过 ctypes.CFUNCTYPE。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一个参数是函数的返回值类型，然后函数的参数写在后面，有多少写多少</span></span><br><span class="line"><span class="comment"># 比如这里的函数返回一个 long，接收两个 long *，所以就是</span></span><br><span class="line">t = CFUNCTYPE(c_long, POINTER(c_long), POINTER(c_long))</span><br><span class="line"><span class="comment"># 如果函数不需要返回值，那么写一个 None 即可</span></span><br><span class="line"><span class="comment"># 然后得到一个类型 t，此时的类型 t 就等同于 C 中的 typedef long (*t)(long*, long*);</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个 Python 函数，a、b 为 long *，返回值为 c_long</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a.contents.value + b.contents.value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将我们自定义的函数传进去，就得到了 C 语言可以识别的函数</span></span><br><span class="line">c_add = t(add)</span><br><span class="line"><span class="built_in">print</span>(c_add)  <span class="comment"># &lt;CFunctionType object at 0x7fa52fa29040&gt;</span></span><br><span class="line"><span class="built_in">print</span>(</span><br><span class="line">    c_add(pointer(c_long(<span class="number">22</span>)),</span><br><span class="line">          pointer(c_long(<span class="number">33</span>)))</span><br><span class="line">)  <span class="comment"># 55</span></span><br></pre></td></tr></table></figure>

<h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p><strong>以上就是 C 中常见的数据结构，然后再说一下类型转化，ctypes 提供了一个 cast 函数，可以将指针的类型进行转化。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># cast 的第一个参数接收的必须是某种指针的 ctypes 对象，第二个参数是 ctypes 指针类型</span></span><br><span class="line"><span class="comment"># 这里相当于将 long * 转成了 float *</span></span><br><span class="line">p1 = pointer(c_long(<span class="number">123</span>))</span><br><span class="line">p2 = cast(p1, POINTER(c_float))</span><br><span class="line"><span class="built_in">print</span>(p2)  <span class="comment"># &lt;__main__.LP_c_float object at 0x7f91be201dc0&gt;</span></span><br><span class="line"><span class="built_in">print</span>(p2.contents)  <span class="comment"># c_float(1.723597111119525e-43)</span></span><br></pre></td></tr></table></figure>

<p><strong>指针在转换之后，还是引用相同的内存块，所以整型指针转成浮点型指针之后，打印的结果乱七八糟。当然数组也可以转化，我们举个栗子：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">t1 = (c_int * <span class="number">3</span>)(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment"># 将 int * 转成 long *</span></span><br><span class="line">t2 = cast(t1, POINTER(c_long))</span><br><span class="line"><span class="built_in">print</span>(t2[<span class="number">0</span>])  <span class="comment"># 8589934593</span></span><br></pre></td></tr></table></figure>

<p><strong>原来数组元素是 int 类型（4 字节），现在转成了 long（8 字节），但是内存块并没有变。因此 t2 获取元素时会一次性获取 8 字节，所以 t1[0] 和 t1[1] 组合起来等价于 t2[0]。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">t1 = (c_int * <span class="number">3</span>)(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">t2 = cast(t1, POINTER(c_long))</span><br><span class="line"><span class="built_in">print</span>(t2[<span class="number">0</span>])  <span class="comment"># 8589934593</span></span><br><span class="line"><span class="built_in">print</span>((<span class="number">2</span> &lt;&lt; <span class="number">32</span> &amp; <span class="number">0xFFFFFFFFFFFFFFFF</span>) + (<span class="number">1</span> &amp; <span class="number">0xFFFFFFFFFFFFFFFF</span>))  <span class="comment"># 8589934593</span></span><br></pre></td></tr></table></figure>

<h3 id="模拟底层数据结构，观察运行时表现"><a href="#模拟底层数据结构，观察运行时表现" class="headerlink" title="模拟底层数据结构，观察运行时表现"></a>模拟底层数据结构，观察运行时表现</h3><p><strong>我们说 Python 的对象本质上就是 C 的 malloc  函数为结构体实例在堆区申请的一块内存，比如整数是 PyLongObject、浮点数是 PyFloatObject、列表是  PyListObject，以及所有的类型都是 PyTypeObject 等等。那么在介绍完 ctypes  的基本用法之后，下面就来构造这些数据结构来观察 Python 对象在运行时的表现。</strong></p>
<h4 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h4><p><strong>这里先说浮点数，因为浮点数比整数要简单，先来看看底层的定义。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    <span class="type">double</span> ob_fval;</span><br><span class="line">&#125; PyFloatObject;</span><br></pre></td></tr></table></figure>

<p><strong>除了 PyObject 这个公共的头部信息之外，只有一个额外的 ob_fval，用于存储具体的值，而且直接使用的 C 中的 double。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PyObject</span>(<span class="title class_ inherited__">Structure</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;PyObject，所有对象底层都会有这个结构体&quot;&quot;&quot;</span></span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">&quot;ob_refcnt&quot;</span>, c_ssize_t),</span><br><span class="line">        (<span class="string">&quot;ob_type&quot;</span>, c_void_p)  <span class="comment"># 类型对象一会说，这里就先用 void * 模拟</span></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PyFloatObject</span>(<span class="title class_ inherited__">PyObject</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;定义 PyFloatObject，继承 PyObject&quot;&quot;&quot;</span></span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">&quot;ob_fval&quot;</span>, c_double)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个浮点数</span></span><br><span class="line">f = <span class="number">3.14</span></span><br><span class="line"><span class="comment"># 构造 PyFloatObject，可以通过对象的地址进行构造</span></span><br><span class="line"><span class="comment"># float_obj 就是浮点数 f 在底层的表现形式</span></span><br><span class="line">float_obj = PyFloatObject.from_address(<span class="built_in">id</span>(f))</span><br><span class="line"><span class="built_in">print</span>(float_obj.ob_fval)  <span class="comment"># 3.14</span></span><br><span class="line"><span class="comment"># 修改一下</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;f = <span class="subst">&#123;f&#125;</span>，id(f) = <span class="subst">&#123;<span class="built_in">id</span>(f)&#125;</span>&quot;</span>)  <span class="comment"># f = 3.14，id(f) = 140625653765296</span></span><br><span class="line">float_obj.ob_fval = <span class="number">1.73</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;f = <span class="subst">&#123;f&#125;</span>，id(f) = <span class="subst">&#123;<span class="built_in">id</span>(f)&#125;</span>&quot;</span>)  <span class="comment"># f = 1.73，id(f) = 140625653765296</span></span><br></pre></td></tr></table></figure>

<p><strong>我们修改 float_obj.ob_fval 也会影响 f，并且修改前后 f 的地址没有发生改变。同时我们也可以观察一个对象的引用计数，举个栗子：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="number">3.14</span></span><br><span class="line">float_obj = PyFloatObject.from_address(<span class="built_in">id</span>(f))</span><br><span class="line"><span class="comment"># 此时 3.14 这个浮点数对象被 3 个变量所引用</span></span><br><span class="line"><span class="built_in">print</span>(float_obj.ob_refcnt)  <span class="comment"># 3</span></span><br><span class="line"><span class="comment"># 再来一个</span></span><br><span class="line">f2 = f</span><br><span class="line"><span class="built_in">print</span>(float_obj.ob_refcnt)  <span class="comment"># 4</span></span><br><span class="line">f3 = f</span><br><span class="line"><span class="built_in">print</span>(float_obj.ob_refcnt)  <span class="comment"># 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除变量</span></span><br><span class="line"><span class="keyword">del</span> f2, f3</span><br><span class="line"><span class="built_in">print</span>(float_obj.ob_refcnt)  <span class="comment"># 3</span></span><br></pre></td></tr></table></figure>

<p><strong>所以这就是引用计数机制，当对象被引用，引用计数加 1；当引用该对象的变量被删除，引用计数减 1；当对象的引用计数为 0 时，对象被销毁。</strong></p>
<h4 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h4><p><strong>再来看看整数，我们知道 Python 中的整数是不会溢出的，换句话说，它可以计算无穷大的数。那么问题来了，它是怎么办到的呢？想要知道答案，只需看底层的结构体定义即可。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    digit ob_digit[<span class="number">1</span>];  <span class="comment">// digit 等价于 unsigned int</span></span><br><span class="line">&#125; PyLongObject;</span><br></pre></td></tr></table></figure>

<p><strong>明白了，原来 Python 的整数在底层是用数组存储的，通过串联多个无符号 32 位整数来表示更大的数。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PyVarObject</span>(<span class="title class_ inherited__">Structure</span>):</span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">&quot;ob_refcnt&quot;</span>, c_ssize_t),</span><br><span class="line">        (<span class="string">&quot;ob_type&quot;</span>, c_void_p),</span><br><span class="line">        (<span class="string">&quot;ob_size&quot;</span>, c_ssize_t)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PyLongObject</span>(<span class="title class_ inherited__">PyVarObject</span>):</span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">&quot;ob_digit&quot;</span>, (c_uint32 * <span class="number">1</span>))</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">num = <span class="number">1024</span></span><br><span class="line">long_obj = PyLongObject.from_address(<span class="built_in">id</span>(num))</span><br><span class="line"><span class="built_in">print</span>(long_obj.ob_digit[<span class="number">0</span>])  <span class="comment"># 1024</span></span><br><span class="line"><span class="comment"># PyLongObject 的 ob_size 除了表示 ob_digit 数组的长度，此时显然为 1</span></span><br><span class="line"><span class="built_in">print</span>(long_obj.ob_size)  <span class="comment"># 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 但是在介绍整型的时候说过，ob_size 除了表示 ob_digit 数组的长度之外，还表示整数的符号</span></span><br><span class="line"><span class="comment"># 我们将 ob_size 改成 -1，再打印 num</span></span><br><span class="line">long_obj.ob_size = -<span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(num)  <span class="comment"># -1024</span></span><br><span class="line"><span class="comment"># 我们悄悄地将 num 改成了负数</span></span><br></pre></td></tr></table></figure>

<p><strong>当然我们也可以修改值：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">1024</span></span><br><span class="line">long_obj = PyLongObject.from_address(<span class="built_in">id</span>(num))</span><br><span class="line">long_obj.ob_digit[<span class="number">0</span>] = <span class="number">4096</span></span><br><span class="line"><span class="built_in">print</span>(num)  <span class="comment"># 4096</span></span><br></pre></td></tr></table></figure>

<p><strong>digit 是 32 位无符号整型，不过虽然占 32 个位，但是只用 30 个位，这也意味着一个 digit 能存储的最大整数就是 2 的 30 次方减 1。如果数值再大一些，那么就需要两个 digit 来存储，第二个 digit 的最低位从 31 开始。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 此时一个 digit 能够存储的下，所以 ob_size 为 1</span></span><br><span class="line">num1 = <span class="number">2</span> ** <span class="number">30</span> - <span class="number">1</span></span><br><span class="line">long_obj1 = PyLongObject.from_address(<span class="built_in">id</span>(num1))</span><br><span class="line"><span class="built_in">print</span>(long_obj1.ob_size)  <span class="comment"># 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时一个 digit 存不下了，所以需要两个 digit，因此 ob_size 为 2</span></span><br><span class="line">num2 = <span class="number">2</span> ** <span class="number">30</span></span><br><span class="line">long_obj2 = PyLongObject.from_address(<span class="built_in">id</span>(num2))</span><br><span class="line"><span class="built_in">print</span>(long_obj2.ob_size)  <span class="comment"># 2</span></span><br></pre></td></tr></table></figure>

<p><strong>当然了，用整数数组实现大整数的思路其实平白无奇，但难点在于大整数 数学运算 的实现，它们才是重点，也是也比较考验编程功底的地方。</strong></p>
<h4 id="字节串"><a href="#字节串" class="headerlink" title="字节串"></a>字节串</h4><p><strong>字节串也就是 Python 中的 bytes 对象，在存储或网络通讯时，传输的都是字节串。bytes 对象在底层的结构体为 PyBytesObject，看一下相关定义。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    Py_hash_t ob_shash;</span><br><span class="line">    <span class="type">char</span> ob_sval[<span class="number">1</span>];</span><br><span class="line">&#125; PyBytesObject;</span><br></pre></td></tr></table></figure>

<p><strong>我们解释一下里面的成员对象：</strong></p>
<ul>
<li><code>PyObject_VAR_HEAD：变长对象的公共头部</code></li>
<li><code>ob_shash：保存该字节序列的哈希值，之所以选择保存是因为在很多场景都需要 bytes 对象的哈希值。而 Python  在计算字节序列的哈希值的时候，需要遍历每一个字节，因此开销比较大。所以会提前计算一次并保存起来，这样以后就不需要算了，可以直接拿来用，并且  bytes 对象是不可变的，所以哈希值是不变的</code></li>
<li><code>ob_sval：这个和 PyLongObject 中的 ob_digit 的声明方式是类似的，虽然声明的时候长度是 1,  但具体是多少则取决于 bytes 对象的字节数量。这是 C 语言中定义&quot;变长数组&quot;的技巧, 虽然写的长度是 1, 但是你可以当成 n 来用, n 可取任意值。显然这个 ob_sval 存储的是所有的字节，因此 Python 中的 bytes  对象在底层是通过字符数组存储的。而且数组会多申请一个空间，用于存储 \0，因为 C 中是通过 \0 来表示一个字符数组的结束，但是计算  ob_size 的时候不包括 \0</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PyVarObject</span>(<span class="title class_ inherited__">Structure</span>):</span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">&quot;ob_refcnt&quot;</span>, c_ssize_t),</span><br><span class="line">        (<span class="string">&quot;ob_type&quot;</span>, c_void_p),</span><br><span class="line">        (<span class="string">&quot;ob_size&quot;</span>, c_ssize_t)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PyBytesObject</span>(<span class="title class_ inherited__">PyVarObject</span>):</span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">&quot;ob_shash&quot;</span>, c_ssize_t),</span><br><span class="line">        <span class="comment"># 这里我们就将长度声明为 100</span></span><br><span class="line">        (<span class="string">&quot;ob_sval&quot;</span>, (c_char * <span class="number">100</span>))</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">b = <span class="string">b&quot;hello&quot;</span></span><br><span class="line">bytes_obj = PyBytesObject.from_address(<span class="built_in">id</span>(b))</span><br><span class="line"><span class="comment"># 长度</span></span><br><span class="line"><span class="built_in">print</span>(bytes_obj.ob_size, <span class="built_in">len</span>(b))  <span class="comment"># 5 5</span></span><br><span class="line"><span class="comment"># 哈希值</span></span><br><span class="line"><span class="built_in">print</span>(bytes_obj.ob_shash)  <span class="comment"># 967846336661272849</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hash</span>(b))  <span class="comment"># 967846336661272849</span></span><br><span class="line"><span class="comment"># 修改哈希值，再调用 hash 函数会发现结果变了</span></span><br><span class="line"><span class="comment"># 说明 hash(b) 会直接获取底层已经计算好的 ob_shash 成员的值</span></span><br><span class="line">bytes_obj.ob_shash = <span class="number">666</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hash</span>(b))  <span class="comment"># 666</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改 ob_sval</span></span><br><span class="line">bytes_obj.ob_sval = <span class="string">b&quot;hello world&quot;</span></span><br><span class="line"><span class="built_in">print</span>(b)  <span class="comment"># b&#x27;hello&#x27;</span></span><br><span class="line"><span class="comment"># 我们看到打印的依旧是 &quot;hello&quot;，原因是 ob_size 为 5，只会选择前 5 个字节</span></span><br><span class="line"><span class="comment"># 修改之后再次打印</span></span><br><span class="line">bytes_obj.ob_size = <span class="number">11</span></span><br><span class="line"><span class="built_in">print</span>(b)  <span class="comment"># b&#x27;hello world&#x27;</span></span><br><span class="line">bytes_obj.ob_size = <span class="number">15</span></span><br><span class="line"><span class="built_in">print</span>(b)  <span class="comment"># b&#x27;hello world\x00\x00\x00\x00&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>除了 bytes 对象之外，Python 中还有一个 bytearray 对象，它和 bytes 对象类似，只不过 bytes 对象是不可变的，而 bytearray 对象是可变的。</strong></p>
<h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><p><strong>Python 中的列表可以说使用的非常广泛了，在初学列表的时候，有人会告诉你列表就是一个大仓库，什么都可以存放。但我们知道，列表中存放的元素其实都是泛型指针 PyObject *。</strong></p>
<p><strong>下面来看看列表的底层结构：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    PyObject **ob_item;</span><br><span class="line">    Py_ssize_t allocated;</span><br><span class="line">&#125; PyListObject;</span><br></pre></td></tr></table></figure>

<p><strong>我们看到里面有如下成员：</strong></p>
<ul>
<li><code>PyObject_VAR_HEAD: 变长对象的公共头部信息</code></li>
<li><code>ob_item：一个二级指针，指向一个 PyObject * 类型的指针数组，这个指针数组保存的便是对象的指针，而操作底层数组都是通过 ob_item 来进行操作的。</code></li>
<li><code>allocated：容量, 我们知道列表底层是使用了 C 的数组, 而底层数组的长度就是列表的容量</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PyVarObject</span>(<span class="title class_ inherited__">Structure</span>):</span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">&quot;ob_refcnt&quot;</span>, c_ssize_t),</span><br><span class="line">        (<span class="string">&quot;ob_type&quot;</span>, c_void_p),</span><br><span class="line">        (<span class="string">&quot;ob_size&quot;</span>, c_ssize_t)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PyListObject</span>(<span class="title class_ inherited__">PyVarObject</span>):</span><br><span class="line">    _fields_ = [</span><br><span class="line">        <span class="comment"># ctypes 下面有一个 py_object 类，它等价于底层的 PyObject *</span></span><br><span class="line">        <span class="comment"># 但 ob_item 类型为 **PyObject，所以这里类型声明为 POINTER(py_object)</span></span><br><span class="line">        (<span class="string">&quot;ob_item&quot;</span>, POINTER(py_object)),</span><br><span class="line">        (<span class="string">&quot;allocated&quot;</span>, c_ssize_t)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">list_obj = PyListObject.from_address(<span class="built_in">id</span>(lst))</span><br><span class="line"><span class="comment"># 列表在计算长度的时候，会直接获取 ob_size 成员的值，该值负责维护列表的长度</span></span><br><span class="line"><span class="comment"># 对元素进行增加、删除，ob_size 也会动态变化</span></span><br><span class="line"><span class="built_in">print</span>(list_obj.ob_size)  <span class="comment"># 5</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(lst))  <span class="comment"># 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改 ob_size 为 2，打印列表只会显示两个元素</span></span><br><span class="line">list_obj.ob_size = <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># [1, 2]</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    lst[<span class="number">2</span>]  <span class="comment"># 访问索引为 2 的元素会越界</span></span><br><span class="line"><span class="keyword">except</span> IndexError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># list index out of range</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改元素，注意：ob_item 里面的元素是 PyObject*，所以这里需要调用 py_object 转一下</span></span><br><span class="line">list_obj.ob_item[<span class="number">0</span>] = py_object(<span class="string">&quot;😂&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># [&#x27;😂&#x27;, 2]</span></span><br></pre></td></tr></table></figure>

<h4 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h4><p><strong>下面来看看元组，我们可以把元素看成不支持元素添加、修改、删除等操作的列表。元组的实现机制非常简单，可以看做是在列表的基础上丢弃了增删改等操作。既然如此，那要元组有什么用呢？毕竟元组的功能只是列表的子集。元组存在的最大一个特点就是，它可以作为字典的  key、以及可以作为集合的元素。因为字典和集合存储数据的原理是哈希表，对于列表这样的可变对象来说是可以动态改变的，而哈希值是一开始就计算好的，显然如果支持动态修改的话，那么哈希值肯定会变，这是不允许的。所以如果我们希望字典的 key 是一个序列，显然元组再适合不过了。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    PyObject *ob_item[<span class="number">1</span>];</span><br><span class="line">&#125; PyTupleObject;</span><br></pre></td></tr></table></figure>

<p><strong>可以看到，对于不可变对象来说，它底层结构体定义也非常简单。一个引用计数、一个类型、一个指针数组。这里的 1 可以想象成 n，我们上面说过它的含义。并且我们发现不像列表，元组没有 allocated，这是因为它是不可变的，不支持扩容操作。</strong></p>
<p><strong>这里再对比一下元组和列表的 ob_item  成员，PyTupleObject 的 ob_item 是一个指针数组，数组里面是泛型指针 PyObject *；而 PyListObject 的 ob_item 是一个二级指针，该指针指向了一个存放 PyObject * 的指针数组的首元素。</strong></p>
<p><strong>所以 Python 中的 “列表本身” 和 “列表里面的值”  在底层是分开存储的，因为 PyListObject  结构体实例并没有存储相应的指针数组，而是存储了指向这个指针数组首元素的二级指针。显然我们添加、删除、修改元素等操作，都是通过这个二级指针来间接操作这个指针数组。这么做的原因就在于对象一旦被创建，那么它在内存中的大小就不可以变了，因此这就意味着那些可以容纳可变长度数据的可变对象，要在内部维护一个指向可变大小的内存区域的指针，遵循这样的规则可以使维护对象的工作变得非常简单。</strong></p>
<blockquote>
<p><strong>试想一下这样一个场景：一旦允许对象的大小可在运行期改变，那么假设在内存中有对象 A，并且其后面紧跟着对象 B。如果运行的某个时候，A 的大小增大了，这就意味着必须将 A 整个移动到内存中的其他位置，否则 A  增大的部分会覆盖掉原本属于 B 的数据。只要将 A 移动到内存的其他位置，那么所有指向 A  的指针就必须立即得到更新。可想而知这样的工作是多么的繁琐，而通过一个指针去操作就变得简单多了。</strong></p>
</blockquote>
<p><strong>可以看到 PyListObject 实例本身和指针数组之间是分离的，两者通过二级指针（ob_item）建立联系；但元组不同，它的大小不允许改变，因此 PyTupleObject 直接存储了指针数组本身（ob_item）。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PyVarObject</span>(<span class="title class_ inherited__">Structure</span>):</span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">&quot;ob_refcnt&quot;</span>, c_ssize_t),</span><br><span class="line">        (<span class="string">&quot;ob_type&quot;</span>, c_void_p),</span><br><span class="line">        (<span class="string">&quot;ob_size&quot;</span>, c_ssize_t)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PyTupleObject</span>(<span class="title class_ inherited__">PyVarObject</span>):</span><br><span class="line">    _fields_ = [</span><br><span class="line">        <span class="comment"># 这里我们假设里面可以存 10 个元素</span></span><br><span class="line">        (<span class="string">&quot;ob_item&quot;</span>, (py_object * <span class="number">10</span>)),</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tpl = (<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>)</span><br><span class="line">tuple_obj = PyTupleObject.from_address(<span class="built_in">id</span>(tpl))</span><br><span class="line"><span class="built_in">print</span>(tuple_obj.ob_size)  <span class="comment"># 3</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(tpl))  <span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里我们修改元组内的元素</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;修改前：id(tpl) = <span class="subst">&#123;<span class="built_in">id</span>(tpl)&#125;</span>，tpl = <span class="subst">&#123;tpl&#125;</span>&quot;</span>)</span><br><span class="line">tuple_obj.ob_item[<span class="number">0</span>] = py_object(<span class="string">&quot;🍑&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;修改后：id(tpl) = <span class="subst">&#123;<span class="built_in">id</span>(tpl)&#125;</span>，tpl = <span class="subst">&#123;tpl&#125;</span>&quot;</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">修改前：id(tpl) = 140570376749888，tpl = (11, 22, 33)</span></span><br><span class="line"><span class="string">修改后：id(tpl) = 140570376749888，tpl = (&#x27;🍑&#x27;, 22, 33)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>此时我们就成功修改了元组里面的元素，并且修改前后元组的地址没有改变。</strong></p>
<blockquote>
<p><strong>要是以后谁跟你说 Python 元组里的元素不能修改，就拿这个例子堵他嘴。好吧，元组就是不可变的，举这个例子有点不太合适。</strong></p>
</blockquote>
<h3 id="给类对象增加属性"><a href="#给类对象增加属性" class="headerlink" title="给类对象增加属性"></a>给类对象增加属性</h3><p><strong>我们知道类对象（或者说类型对象）是有自己的属性字典的，但这个字典不允许修改，因为准确来说它不是字典，而是一个 mappingproxy 对象。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>.__dict__.__class__)  <span class="comment"># &lt;class &#x27;mappingproxy&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">str</span>.__dict__[<span class="string">&quot;嘿&quot;</span>] = <span class="string">&quot;蛤&quot;</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># &#x27;mappingproxy&#x27; object does not support item assignment</span></span><br></pre></td></tr></table></figure>

<p><strong>我们无法通过修改 mappingproxy  对象来给类增加属性，因为它不支持增加、修改以及删除操作。当然对于自定义的类可以通过 setattr  方法实现，但是内置的类是行不通的，内置的类无法通过 setattr 进行属性添加。因此如果想给内置的类增加属性，只能通过  mappingproxy 入手，我们看一下它的底层结构。</strong></p>
<p><img src="/2023/04/26/34-%E4%BE%B5%E5%85%A5-Python-%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%8C%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6/1229382-20211031134918602-366203763.png" alt="img"></p>
<p><strong>所谓的 mappingproxy  就是对字典包了一层，并只提供了查询功能。而且从函数 mappingproxy_len、mappingproxy_getitem  可以看出，mappingproxy 对象的长度就是内部字典的长度，获取 mappingproxy  对象的元素实际上就是获取内部字典的元素，因此操作 mappingproxy 对象就等价于操作其内部的字典。</strong></p>
<p><strong>所以我们只要能拿到 mappingproxy 对象内部的字典，那么可以直接操作字典来修改类属性。而 Python 有一个模块叫 gc，它可以帮我们实现这一点，举个栗子：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gc</span><br><span class="line"></span><br><span class="line">lst = [<span class="string">&quot;hello&quot;</span>, <span class="number">123</span>, <span class="string">&quot;😒&quot;</span>]</span><br><span class="line"><span class="comment"># gc.get_referents(obj) 返回所有被 obj 引用的对象</span></span><br><span class="line"><span class="built_in">print</span>(gc.get_referents(lst))  <span class="comment"># [&#x27;😒&#x27;, 123, &#x27;hello&#x27;]</span></span><br><span class="line"><span class="comment"># 显然 lst 引用的就是内部的三个元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 此外还有 gc.get_referrers(obj)，它是返回所有引用了 obj 的对象</span></span><br></pre></td></tr></table></figure>

<p><strong>那么问题来了，你觉得 mappingproxy 对象引用了谁呢？显然就是内部的字典。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gc</span><br><span class="line"></span><br><span class="line"><span class="comment"># str.__dict__ 是一个 mappingproxy 对象，这里拿到其内部的字典，</span></span><br><span class="line">d = gc.get_referents(<span class="built_in">str</span>.__dict__)[<span class="number">0</span>]</span><br><span class="line"><span class="comment"># 随便增加一个属性</span></span><br><span class="line">d[<span class="string">&quot;嘿&quot;</span>] = <span class="string">&quot;蛤&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>.嘿)  <span class="comment"># 蛤</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;嘿&quot;</span>.嘿)  <span class="comment"># 蛤</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当然我们也可以增加一个函数，记得要有一个 self 参数</span></span><br><span class="line">d[<span class="string">&quot;smile&quot;</span>] = <span class="keyword">lambda</span> self: self + <span class="string">&quot;😊&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;微笑&quot;</span>.smile())  <span class="comment"># 微笑😊</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>.smile(<span class="string">&quot;微笑&quot;</span>))  <span class="comment"># 微笑😊</span></span><br></pre></td></tr></table></figure>

<p><strong>但是需要注意的是，我们上面添加的是之前没有的新属性，如果是覆盖一个已经存在的属性或者函数，那么还缺一步。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gc</span><br><span class="line"></span><br><span class="line">s = <span class="string">&quot;hello world&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s.split())  <span class="comment"># [&#x27;hello&#x27;, &#x27;world&#x27;]</span></span><br><span class="line"></span><br><span class="line">d = gc.get_referents(<span class="built_in">str</span>.__dict__)[<span class="number">0</span>]</span><br><span class="line">d[<span class="string">&quot;split&quot;</span>] = <span class="keyword">lambda</span> self, *args: <span class="string">&quot;我被 split 了&quot;</span>  <span class="comment"># 覆盖 split 函数</span></span><br><span class="line"><span class="comment"># 可以通过 pythonapi 来调用 CPython 对外暴露的 API，后面会说</span></span><br><span class="line"><span class="comment"># 这里需要调用 pythonapi.PyType_Modified 来更新上面所做的修改</span></span><br><span class="line"><span class="comment"># 如果没有这一步，那么是没有效果的，甚至还会出现丑陋的段错误，使得解释器异常退出</span></span><br><span class="line">pythonapi.PyType_Modified(py_object(<span class="built_in">str</span>))</span><br><span class="line"><span class="built_in">print</span>(s.split())  <span class="comment"># 我被 split 了</span></span><br></pre></td></tr></table></figure>

<p><strong>不过上面的代码还有一个缺点，那就是函数的名字没有修改：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gc</span><br><span class="line"></span><br><span class="line">s = <span class="string">&quot;hello world&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s.split.__name__)  <span class="comment"># split</span></span><br><span class="line"></span><br><span class="line">d = gc.get_referents(<span class="built_in">str</span>.__dict__)[<span class="number">0</span>]</span><br><span class="line">d[<span class="string">&quot;split&quot;</span>] = <span class="keyword">lambda</span> self, *args: <span class="string">&quot;我被 split 了&quot;</span>  <span class="comment"># 覆盖 split 函数</span></span><br><span class="line">pythonapi.PyType_Modified(py_object(<span class="built_in">str</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(s.split.__name__)  <span class="comment"># &lt;lambda&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看到函数在修改之后名字就变了，匿名函数的名字就叫 <lambda>，所以我们可以再完善一下。</lambda></strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">patch_builtin_class</span>(<span class="params">cls, name, value</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :param cls: 要修改的类</span></span><br><span class="line"><span class="string">    :param name: 属性名或者函数名</span></span><br><span class="line"><span class="string">    :param value: 值</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(cls) <span class="keyword">is</span> <span class="keyword">not</span> <span class="built_in">type</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;cls 必须是一个内置的类对象&quot;</span>)</span><br><span class="line">    <span class="comment"># 获取 cls.__dict__ 内部的字典</span></span><br><span class="line">    cls_attrs = gc.get_referents(cls.__dict__)[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 如果该属性或函数不存在，结果为 None；否则将值取出来，赋值给 old_value</span></span><br><span class="line">    old_value = cls_attrs.get(name, <span class="literal">None</span>)</span><br><span class="line">    <span class="comment"># 将 name、value 组合起来放到 cls_attrs 中，为 cls 这个类添砖加瓦</span></span><br><span class="line">    cls_attrs[name] = value</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果 old_value 为 None，说明我们添加了的一个新的属性或函数</span></span><br><span class="line">    <span class="comment"># 如果 old_value 不为 None，说明我们覆盖了的一个已存在的属性或函数</span></span><br><span class="line">    <span class="keyword">if</span> old_value <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 将原来函数的 __name__、__qualname__ 赋值给新的函数</span></span><br><span class="line">            <span class="comment"># 如果不是函数，而是普通属性，那么会因为没有 __name__ 而抛出 AttributeError</span></span><br><span class="line">            <span class="comment"># 这里我们直接 pass 掉即可，无需关心</span></span><br><span class="line">            value.__name__ = old_value.__name__</span><br><span class="line">            value.__qualname__ = old_value.__qualname__</span><br><span class="line">        <span class="keyword">except</span> AttributeError:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="comment"># 但是原来的属性或函数最好也不要丢弃，我们可以改一个名字</span></span><br><span class="line">        <span class="comment"># 假设我们修改 split 函数，那么修改之后，原来的 split 就需要通过 _str_split 进行调用</span></span><br><span class="line">        cls_attrs[<span class="string">f&quot;_<span class="subst">&#123;cls.__name__&#125;</span>_<span class="subst">&#123;name&#125;</span>&quot;</span>] = old_value</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 不要忘了最关键的一步</span></span><br><span class="line">    pythonapi.PyType_Modified(py_object(cls))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = <span class="string">&quot;hello world&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s.title())  <span class="comment"># Hello World</span></span><br><span class="line"><span class="comment"># 修改内置属性</span></span><br><span class="line">patch_builtin_class(<span class="built_in">str</span>, <span class="string">&quot;title&quot;</span>, <span class="keyword">lambda</span> self: <span class="string">&quot;我单词首字母大写了&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(s.title())  <span class="comment"># 我单词首字母大写了</span></span><br><span class="line"><span class="built_in">print</span>(s.title.__name__)  <span class="comment"># title</span></span><br><span class="line"><span class="comment"># 而原来的 title 则需要通过 _str_title 进行调用</span></span><br><span class="line"><span class="built_in">print</span>(s._str_title())  <span class="comment"># Hello World</span></span><br></pre></td></tr></table></figure>

<p><strong>很明显，我们不仅可以修改 str，任意的内置的类都是可以修改的。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="comment"># 将 append 函数换成 pop 函数</span></span><br><span class="line">patch_builtin_class(<span class="built_in">list</span>, <span class="string">&quot;append&quot;</span>, <span class="keyword">lambda</span> self: <span class="built_in">list</span>.pop(self))</span><br><span class="line"><span class="comment"># 我们知道 append 需要接收一个参数，但这里我们不需要传，因为函数已经被换掉了</span></span><br><span class="line">lst.append()</span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># [1, 2]</span></span><br><span class="line"><span class="comment"># 而原来的 append 函数，则需要通过 _list_append 进行调用</span></span><br><span class="line">lst._list_append(<span class="number">666</span>)</span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># [1, 2, 666]</span></span><br></pre></td></tr></table></figure>

<p><strong>我们还可以添加一个类方法或静态方法：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">patch_builtin_class(</span><br><span class="line">    <span class="built_in">list</span>,</span><br><span class="line">    <span class="string">&quot;new&quot;</span>,</span><br><span class="line">    <span class="built_in">classmethod</span>(<span class="keyword">lambda</span> cls, n: <span class="built_in">list</span>(<span class="built_in">range</span>(n)))</span><br><span class="line">)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>.new(<span class="number">5</span>))  <span class="comment"># [0, 1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>

<p><strong>还是很有趣的，但需要注意的是，我们目前的 patch_builtin_class 只能为类添加属性或函数，但其 “实例对象” 使用操作符时的表现是无法操控的。什么意思呢？我们举个栗子：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a, b = <span class="number">3</span>, <span class="number">4</span></span><br><span class="line"><span class="comment"># 每一个操作背后都被抽象成了一个魔法方法</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>.__add__(a, b))  <span class="comment"># 7</span></span><br><span class="line"><span class="built_in">print</span>(a.__add__(b))  <span class="comment"># 7</span></span><br><span class="line"><span class="built_in">print</span>(a + b)  <span class="comment"># 7</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重写 __add__</span></span><br><span class="line">patch_builtin_class(<span class="built_in">int</span>, <span class="string">&quot;__add__&quot;</span>, <span class="keyword">lambda</span> self, other: self * other)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>.__add__(a, b))  <span class="comment"># 12</span></span><br><span class="line"><span class="built_in">print</span>(a.__add__(b))  <span class="comment"># 12</span></span><br><span class="line"><span class="built_in">print</span>(a + b)  <span class="comment"># 7 </span></span><br></pre></td></tr></table></figure>

<p><strong>我们看到重写了 <strong>add</strong> 之后，直接调用魔法方法的话是没有问题的，打印的是重写之后的结果。而使用操作符的话（a + b），却没有走我们重写之后的 __add__，所以 a + b 的结果还是 7。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s1, s2 = <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span></span><br><span class="line">patch_builtin_class(<span class="built_in">str</span>, <span class="string">&quot;__sub__&quot;</span>, <span class="keyword">lambda</span> self, other: (self, other))</span><br><span class="line"><span class="built_in">print</span>(s1.__sub__(s2))  <span class="comment"># (&#x27;hello&#x27;, &#x27;world&#x27;)</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    s1 - s2</span><br><span class="line"><span class="keyword">except</span> TypeError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># unsupported operand type(s) for -: &#x27;str&#x27; and &#x27;str&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>我们重写了 <strong>sub</strong> 之后，直接调用魔法方法的话也是没有问题的，但是用操作符（s1 - s2）就会报错，告诉我们字符串不支持减法操作，但我们明明实现了 <strong>sub</strong> 方法啊。想要知道原因并改变它，我们就要先知道类对象在底层是怎么实现的。</strong></p>
<h3 id="类对象的底层结构-PyTypeObject"><a href="#类对象的底层结构-PyTypeObject" class="headerlink" title="类对象的底层结构 PyTypeObject"></a>类对象的底层结构 PyTypeObject</h3><p><strong>首先思考两个问题：</strong></p>
<ul>
<li><code>1. 当在内存中创建对象、分配空间的时候，解释器要给该对象分配多大的空间？显然不能随便分配，那么该对象的内存信息在什么地方？</code></li>
<li><code>2. 一个对象是支持相应的操作的，解释器怎么判断该对象支持哪些操作呢？再比如一个整型可以和一个整型相乘，但是一个列表也可以和一个整型相乘，即使是相同的操作，但不同类型的对象执行也会有不同的结果，那么此时解释器又是如何进行区分的？</code></li>
</ul>
<p><strong>想都不用想，这些信息肯定都在对象所对应的类型对象中。而且占用的空间大小实际上是对象的一个元信息，这样的元信息和其所属类型是密切相关的，因此它一定会出现在与之对应的类型对象当中。至于支持的操作就更不用说了，我们平时自定义类的时候，方法都写在什么地方，显然都是写在类里面，因此一个对象支持的操作显然定义在类型对象当中。</strong></p>
<p><strong>而将一个对象和其类型对象关联起来的，毫无疑问正是该对象内部的 PyObject 中的 ob_type，也就是类型的指针。我们通过对象的 ob_type 成员即可获取指向的类型对象的指针，通过该指针可以获取存储在类型对象中的某些元信息。</strong></p>
<p><strong>下面我们来看看类型对象在底层是怎么定义的：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> &#123;</span></span><br><span class="line">    <span class="comment">// 头部信息，PyVarObject ob_base; 里面包含了 引用计数、类型、ob_size</span></span><br><span class="line">    <span class="comment">// 而创建这个结构体实例的话，Python 提供了一个宏，PyVarObject_HEAD_INIT(type, size)</span></span><br><span class="line">    <span class="comment">// 传入类型和 ob_size 可以直接创建，至于引用计数则默认为 1</span></span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    <span class="comment">// 创建之后的类名</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *tp_name;</span><br><span class="line">    <span class="comment">// 大小，用于申请空间的，注意了，这里是两个成员</span></span><br><span class="line">    Py_ssize_t tp_basicsize, tp_itemsize; </span><br><span class="line">    <span class="comment">// 析构方法__del__，当删除实例对象时会调用这个操作</span></span><br><span class="line">    <span class="comment">// typedef void (*destructor)(PyObject *); 函数接收一个 PyObject *，没有返回值</span></span><br><span class="line">    destructor tp_dealloc;</span><br><span class="line">    <span class="comment">// 打印其实例对象时调用的函数</span></span><br><span class="line">    <span class="comment">// typedef int (*printfunc)(PyObject *, FILE *, int); 函数接收一个PyObject *、FILE * 和 int</span></span><br><span class="line">    printfunc tp_print;</span><br><span class="line">    <span class="comment">// 获取属性，内部的 __getattr__ 方法， typedef PyObject *(*getattrfunc)(PyObject *, char *);</span></span><br><span class="line">    getattrfunc tp_getattr;</span><br><span class="line">    <span class="comment">// 设置属性,内部的 __setattr__ 方法，typedef int (*setattrfunc)(PyObject *, char *, PyObject *);</span></span><br><span class="line">    setattrfunc tp_setattr;</span><br><span class="line">    <span class="comment">// Python3.5 新增，协程对象所拥有的方法</span></span><br><span class="line">    PyAsyncMethods *tp_as_async; </span><br><span class="line">    <span class="comment">// 内部的 __repr__方法，typedef PyObject *(*reprfunc)(PyObject *);</span></span><br><span class="line">    reprfunc tp_repr;</span><br><span class="line">    <span class="comment">// 一个对象作为数值所有拥有的方法</span></span><br><span class="line">    PyNumberMethods *tp_as_number;</span><br><span class="line">    <span class="comment">// 一个对象作为序列所有拥有的方法</span></span><br><span class="line">    PySequenceMethods *tp_as_sequence;</span><br><span class="line">    <span class="comment">// 一个对象作为映射所有拥有的方法</span></span><br><span class="line">    PyMappingMethods *tp_as_mapping;</span><br><span class="line">    <span class="comment">// 内部的 __hash__ 方法，typedef Py_hash_t (*hashfunc)(PyObject *);</span></span><br><span class="line">    hashfunc tp_hash;</span><br><span class="line">    <span class="comment">// 内部的 __call__ 方法， typedef PyObject * (*ternaryfunc)(PyObject *, PyObject *, PyObject *);</span></span><br><span class="line">    ternaryfunc tp_call;</span><br><span class="line">    <span class="comment">// 内部的 __str__ 方法，typedef PyObject *(*reprfunc)(PyObject *);</span></span><br><span class="line">    reprfunc tp_str;</span><br><span class="line">    <span class="comment">// 获取属性，typedef PyObject *(*getattrofunc)(PyObject *, PyObject *);</span></span><br><span class="line">    getattrofunc tp_getattro;</span><br><span class="line">    <span class="comment">// 设置属性，typedef int (*setattrofunc)(PyObject *, PyObject *, PyObject *);</span></span><br><span class="line">    setattrofunc tp_setattro;</span><br><span class="line">    <span class="comment">// 用于实现缓冲区协议，实现了该协议可以和 Numpy 的 array 无缝集成</span></span><br><span class="line">    PyBufferProcs *tp_as_buffer;</span><br><span class="line">    <span class="comment">// 这个类的特点，比如：</span></span><br><span class="line">    <span class="comment">// Py_TPFLAGS_HEAPTYPE：是否在堆区申请空间</span></span><br><span class="line">    <span class="comment">// Py_TPFLAGS_BASETYPE：是否允许这个类被其它类继承</span></span><br><span class="line">    <span class="comment">// Py_TPFLAGS_IS_ABSTRACT：是否为抽象类</span></span><br><span class="line">    <span class="comment">// Py_TPFLAGS_HAVE_GC: 是否被垃圾回收跟踪</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> tp_flags;</span><br><span class="line">    <span class="comment">// 这个类的注释</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *tp_doc; </span><br><span class="line">    <span class="comment">// 用于检测是否出现循环引用，和下面的 tp_clear 是一组</span></span><br><span class="line">    <span class="comment">// typedef int (*traverseproc)(PyObject *, visitproc, void *);</span></span><br><span class="line">    traverseproc tp_traverse;</span><br><span class="line">    <span class="comment">// 清除对包含对象的引用</span></span><br><span class="line">    inquiry tp_clear;</span><br><span class="line">    <span class="comment">// 富比较，typedef PyObject *(*richcmpfunc) (PyObject *, PyObject *, int);</span></span><br><span class="line">    richcmpfunc tp_richcompare;</span><br><span class="line">    <span class="comment">// 弱引用，不需要关心</span></span><br><span class="line">    Py_ssize_t tp_weaklistoffset;</span><br><span class="line">    <span class="comment">// __iter__方法，typedef PyObject *(*getiterfunc) (PyObject *);</span></span><br><span class="line">    getiterfunc tp_iter;</span><br><span class="line">    <span class="comment">// __next__方法，typedef PyObject *(*iternextfunc) (PyObject *);</span></span><br><span class="line">    iternextfunc tp_iternext;</span><br><span class="line">    <span class="comment">// 内部的方法</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PyMethodDef</span> *<span class="title">tp_methods</span>;</span></span><br><span class="line">    <span class="comment">// 内部的成员</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PyMemberDef</span> *<span class="title">tp_members</span>;</span></span><br><span class="line">    <span class="comment">// 用于实现 getset</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PyGetSetDef</span> *<span class="title">tp_getset</span>;</span></span><br><span class="line">    <span class="comment">// 继承的基类</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">tp_base</span>;</span></span><br><span class="line">    <span class="comment">// 内部的属性字典</span></span><br><span class="line">    PyObject *tp_dict;</span><br><span class="line">    <span class="comment">// 描述符，__get__ 方法，typedef PyObject *(*descrgetfunc) (PyObject *, PyObject *, PyObject *);</span></span><br><span class="line">    descrgetfunc tp_descr_get;</span><br><span class="line">    <span class="comment">// 描述符，__set__ 方法</span></span><br><span class="line">    descrsetfunc tp_descr_set;</span><br><span class="line">    <span class="comment">// 生成的实例对象是否有属性字典</span></span><br><span class="line">    Py_ssize_t tp_dictoffset;</span><br><span class="line">    <span class="comment">// 初始化函数，typedef int (*initproc)(PyObject *, PyObject *, PyObject *);</span></span><br><span class="line">    initproc tp_init;</span><br><span class="line">    <span class="comment">// 为实例对象分配空间的函数，typedef PyObject *(*allocfunc)(struct _typeobject *, Py_ssize_t);</span></span><br><span class="line">    allocfunc tp_alloc;</span><br><span class="line">    <span class="comment">// __new__ 方法，typedef PyObject *(*newfunc)(struct _typeobject *, PyObject *, PyObject *);</span></span><br><span class="line">    newfunc tp_new;</span><br><span class="line">    <span class="comment">// 释放一个实例对象，typedef void (*freefunc)(void *); 一般会在析构函数中调用</span></span><br><span class="line">    freefunc tp_free; </span><br><span class="line">    <span class="comment">// typedef int (*inquiry)(PyObject *); 是否被 gc 跟踪</span></span><br><span class="line">    inquiry tp_is_gc; </span><br><span class="line">    <span class="comment">// 继承哪些类，这里可以指定继承多个类</span></span><br><span class="line">    PyObject *tp_bases;</span><br><span class="line">    <span class="comment">// __mro__</span></span><br><span class="line">    PyObject *tp_mro; </span><br><span class="line">    <span class="comment">// 下面的就不用管了</span></span><br><span class="line">    PyObject *tp_cache;</span><br><span class="line">    PyObject *tp_subclasses;</span><br><span class="line">    PyObject *tp_weaklist;</span><br><span class="line">    destructor tp_del;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> tp_version_tag;</span><br><span class="line">    destructor tp_finalize;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> COUNT_ALLOCS</span></span><br><span class="line">    Py_ssize_t tp_allocs;</span><br><span class="line">    Py_ssize_t tp_frees;</span><br><span class="line">    Py_ssize_t tp_maxalloc;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">tp_prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">tp_next</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125; PyTypeObject;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><strong>而 Python 中的类对象（类型对象）在底层就是一个  PyTypeObject 实例，它保存了实例对象的元信息，描述对象的类型。所以 Python  中的实例对象在底层对应不同的结构体实例，而类对象则是对应同一个结构体实例，换句话说无论是 int、str、dict，还是其它的类对象，它们在 C 的层面都是由 PyTypeObject 这个结构体实例化得到的，只不过成员的值不同，PyTypeObject  这个结构体在实例化之后得到的类型对象也不同。</strong></p>
<p><img src="/2023/04/26/34-%E4%BE%B5%E5%85%A5-Python-%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%8C%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6/1229382-20211031134927805-1711522230.png" alt="img"></p>
<p><strong>这里我们重点看一下里面的 tp_as_number、tp_as_sequence、tp_as_mapping  三个成员，它们表示实例对象为数值、序列、映射时所支持的操作。它们都是指向结构体的指针，该结构体中的每一个成员都是一个函数指针，指向的函数便是实例对象可执行的操作。</strong></p>
<p><img src="/2023/04/26/34-%E4%BE%B5%E5%85%A5-Python-%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%8C%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6/1229382-20211031134933886-1744810130.png" alt="img"></p>
<p><strong>我们再看一下类对象 int 在底层的定义：</strong></p>
<p><img src="/2023/04/26/34-%E4%BE%B5%E5%85%A5-Python-%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%8C%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6/1229382-20211031134940314-400340278.png" alt="img"></p>
<p><strong>我们注意到它的类型被设置成了 PyType_Type，所以在 Python 里面 int 的类型为 type。然后重点是 tp_as_number 成员，它被初始化为  &amp;long_as_number，而整型对象不支持序列和映射操作，所以 tp_as_sequence、tp_as_mapping 设置为  0。当然这三者都是指向结构体的指针类型，我们看一下 long_as_number。</strong></p>
<p><img src="/2023/04/26/34-%E4%BE%B5%E5%85%A5-Python-%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%8C%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6/1229382-20211031134947996-1135053741.png" alt="img"></p>
<p><strong>因此 PyNumberMethods 的成员就是整数所有拥有的魔法方法，当然也包括浮点数。</strong></p>
<p><strong>至此，整个结构就很清晰了。</strong></p>
<p><img src="/2023/04/26/34-%E4%BE%B5%E5%85%A5-Python-%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%8C%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6/1229382-20211031134953293-889612449.png" alt="img"></p>
<p><strong>若想改变操作符的表现行为，我们需要修改的是  tp_as_* 里面的成员的值，而不是简单的修改属性字典。比如我们想修改 a + b 的表现行为，那么就将类对象的 tp_as_number  里面的 nb_add 给改掉。如果是整形，那么就覆盖掉 long_add，也就是 “PyLong_Type -&gt;  long_as_number -&gt; nb_add”；同理，如果是浮点型，那么就覆盖掉  float_add，也就是 “PyFloat_Type -&gt; float_as_number -&gt; nb_add”。</strong></p>
<h3 id="重写操作符"><a href="#重写操作符" class="headerlink" title="重写操作符"></a>重写操作符</h3><p><strong>我们说类对象里面有 4 个方法集，分别是 tp_as_number、tp_as_sequence、tp_as_mapping、tp_as_async，如果我们想改变操作符的表现结果，那么就重写里面对应的函数即可。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将这些对象提前声明好，之后再进行成员的初始化</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PyObject</span>(<span class="title class_ inherited__">Structure</span>): <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PyTypeObject</span>(<span class="title class_ inherited__">Structure</span>): <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PyNumberMethods</span>(<span class="title class_ inherited__">Structure</span>): <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PySequenceMethods</span>(<span class="title class_ inherited__">Structure</span>): <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PyMappingMethods</span>(<span class="title class_ inherited__">Structure</span>): <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PyAsyncMethods</span>(<span class="title class_ inherited__">Structure</span>): <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PyFile</span>(<span class="title class_ inherited__">Structure</span>): <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PyObject._fields_ = [(<span class="string">&quot;ob_refcnt&quot;</span>, c_ssize_t),</span><br><span class="line">                     (<span class="string">&quot;ob_type&quot;</span>, POINTER(PyTypeObject))]</span><br><span class="line"></span><br><span class="line">PyTypeObject._fields_ = [</span><br><span class="line">    (<span class="string">&#x27;ob_base&#x27;</span>, PyObject),</span><br><span class="line">    (<span class="string">&#x27;ob_size&#x27;</span>, c_ssize_t),</span><br><span class="line">    (<span class="string">&#x27;tp_name&#x27;</span>, c_char_p),</span><br><span class="line">    (<span class="string">&#x27;tp_basicsize&#x27;</span>, c_ssize_t),</span><br><span class="line">    (<span class="string">&#x27;tp_itemsize&#x27;</span>, c_ssize_t),</span><br><span class="line">    (<span class="string">&#x27;tp_dealloc&#x27;</span>, CFUNCTYPE(<span class="literal">None</span>, py_object)),</span><br><span class="line">    (<span class="string">&#x27;printfunc&#x27;</span>, CFUNCTYPE(c_int, py_object, POINTER(PyFile), c_int)),</span><br><span class="line">    (<span class="string">&#x27;getattrfunc&#x27;</span>, CFUNCTYPE(py_object, py_object, c_char_p)),</span><br><span class="line">    (<span class="string">&#x27;setattrfunc&#x27;</span>, CFUNCTYPE(c_int, py_object, c_char_p, py_object)),</span><br><span class="line">    (<span class="string">&#x27;tp_as_async&#x27;</span>, CFUNCTYPE(PyAsyncMethods)),</span><br><span class="line">    (<span class="string">&#x27;tp_repr&#x27;</span>, CFUNCTYPE(py_object, py_object)),</span><br><span class="line">    (<span class="string">&#x27;tp_as_number&#x27;</span>, POINTER(PyNumberMethods)),</span><br><span class="line">    (<span class="string">&#x27;tp_as_sequence&#x27;</span>, POINTER(PySequenceMethods)),</span><br><span class="line">    (<span class="string">&#x27;tp_as_mapping&#x27;</span>, POINTER(PyMappingMethods)),</span><br><span class="line">    (<span class="string">&#x27;tp_hash&#x27;</span>, CFUNCTYPE(c_int64, py_object)),</span><br><span class="line">    (<span class="string">&#x27;tp_call&#x27;</span>, CFUNCTYPE(py_object, py_object, py_object, py_object)),</span><br><span class="line">    (<span class="string">&#x27;tp_str&#x27;</span>, CFUNCTYPE(py_object, py_object)),</span><br><span class="line">    <span class="comment"># 不需要的可以不用写</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法集就是一个结构体实例，结构体成员都是函数</span></span><br><span class="line"><span class="comment"># 所以这里我们要相关的函数类型声明好</span></span><br><span class="line">inquiry = CFUNCTYPE(c_int, py_object)</span><br><span class="line">unaryfunc = CFUNCTYPE(py_object, py_object)</span><br><span class="line">binaryfunc = CFUNCTYPE(py_object, py_object, py_object)</span><br><span class="line">ternaryfunc = CFUNCTYPE(py_object, py_object, py_object, py_object)</span><br><span class="line">lenfunc = CFUNCTYPE(c_ssize_t, py_object)</span><br><span class="line">ssizeargfunc = CFUNCTYPE(py_object, py_object, c_ssize_t)</span><br><span class="line">ssizeobjargproc = CFUNCTYPE(c_int, py_object, c_ssize_t, py_object)</span><br><span class="line">objobjproc = CFUNCTYPE(c_int, py_object, py_object)</span><br><span class="line">objobjargproc = CFUNCTYPE(c_int, py_object, py_object, py_object)</span><br><span class="line"></span><br><span class="line">PyNumberMethods._fields_ = [</span><br><span class="line">    (<span class="string">&#x27;nb_add&#x27;</span>, binaryfunc),</span><br><span class="line">    (<span class="string">&#x27;nb_subtract&#x27;</span>, binaryfunc),</span><br><span class="line">    (<span class="string">&#x27;nb_multiply&#x27;</span>, binaryfunc),</span><br><span class="line">    (<span class="string">&#x27;nb_remainder&#x27;</span>, binaryfunc),</span><br><span class="line">    (<span class="string">&#x27;nb_divmod&#x27;</span>, binaryfunc),</span><br><span class="line">    (<span class="string">&#x27;nb_power&#x27;</span>, ternaryfunc),</span><br><span class="line">    (<span class="string">&#x27;nb_negative&#x27;</span>, unaryfunc),</span><br><span class="line">    (<span class="string">&#x27;nb_positive&#x27;</span>, unaryfunc),</span><br><span class="line">    (<span class="string">&#x27;nb_absolute&#x27;</span>, unaryfunc),</span><br><span class="line">    (<span class="string">&#x27;nb_bool&#x27;</span>, inquiry),</span><br><span class="line">    (<span class="string">&#x27;nb_invert&#x27;</span>, unaryfunc),</span><br><span class="line">    (<span class="string">&#x27;nb_lshift&#x27;</span>, binaryfunc),</span><br><span class="line">    (<span class="string">&#x27;nb_rshift&#x27;</span>, binaryfunc),</span><br><span class="line">    (<span class="string">&#x27;nb_and&#x27;</span>, binaryfunc),</span><br><span class="line">    (<span class="string">&#x27;nb_xor&#x27;</span>, binaryfunc),</span><br><span class="line">    (<span class="string">&#x27;nb_or&#x27;</span>, binaryfunc),</span><br><span class="line">    (<span class="string">&#x27;nb_int&#x27;</span>, unaryfunc),</span><br><span class="line">    (<span class="string">&#x27;nb_reserved&#x27;</span>, c_void_p),</span><br><span class="line">    (<span class="string">&#x27;nb_float&#x27;</span>, unaryfunc),</span><br><span class="line">    (<span class="string">&#x27;nb_inplace_add&#x27;</span>, binaryfunc),</span><br><span class="line">    (<span class="string">&#x27;nb_inplace_subtract&#x27;</span>, binaryfunc),</span><br><span class="line">    (<span class="string">&#x27;nb_inplace_multiply&#x27;</span>, binaryfunc),</span><br><span class="line">    (<span class="string">&#x27;nb_inplace_remainder&#x27;</span>, binaryfunc),</span><br><span class="line">    (<span class="string">&#x27;nb_inplace_power&#x27;</span>, ternaryfunc),</span><br><span class="line">    (<span class="string">&#x27;nb_inplace_lshift&#x27;</span>, binaryfunc),</span><br><span class="line">    (<span class="string">&#x27;nb_inplace_rshift&#x27;</span>, binaryfunc),</span><br><span class="line">    (<span class="string">&#x27;nb_inplace_and&#x27;</span>, binaryfunc),</span><br><span class="line">    (<span class="string">&#x27;nb_inplace_xor&#x27;</span>, binaryfunc),</span><br><span class="line">    (<span class="string">&#x27;nb_inplace_or&#x27;</span>, binaryfunc),</span><br><span class="line">    (<span class="string">&#x27;nb_floor_divide&#x27;</span>, binaryfunc),</span><br><span class="line">    (<span class="string">&#x27;nb_true_divide&#x27;</span>, binaryfunc),</span><br><span class="line">    (<span class="string">&#x27;nb_inplace_floor_divide&#x27;</span>, binaryfunc),</span><br><span class="line">    (<span class="string">&#x27;nb_inplace_true_divide&#x27;</span>, binaryfunc),</span><br><span class="line">    (<span class="string">&#x27;nb_index&#x27;</span>, unaryfunc),</span><br><span class="line">    (<span class="string">&#x27;nb_matrix_multiply&#x27;</span>, binaryfunc),</span><br><span class="line">    (<span class="string">&#x27;nb_inplace_matrix_multiply&#x27;</span>, binaryfunc)]</span><br><span class="line"></span><br><span class="line">PySequenceMethods._fields_ = [</span><br><span class="line">    (<span class="string">&#x27;sq_length&#x27;</span>, lenfunc),</span><br><span class="line">    (<span class="string">&#x27;sq_concat&#x27;</span>, binaryfunc),</span><br><span class="line">    (<span class="string">&#x27;sq_repeat&#x27;</span>, ssizeargfunc),</span><br><span class="line">    (<span class="string">&#x27;sq_item&#x27;</span>, ssizeargfunc),</span><br><span class="line">    (<span class="string">&#x27;was_sq_slice&#x27;</span>, c_void_p),</span><br><span class="line">    (<span class="string">&#x27;sq_ass_item&#x27;</span>, ssizeobjargproc),</span><br><span class="line">    (<span class="string">&#x27;was_sq_ass_slice&#x27;</span>, c_void_p),</span><br><span class="line">    (<span class="string">&#x27;sq_contains&#x27;</span>, objobjproc),</span><br><span class="line">    (<span class="string">&#x27;sq_inplace_concat&#x27;</span>, binaryfunc),</span><br><span class="line">    (<span class="string">&#x27;sq_inplace_repeat&#x27;</span>, ssizeargfunc)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将这些魔法方法的名字和底层的结构体成员组合起来</span></span><br><span class="line">magic_method_dict = &#123;</span><br><span class="line">    <span class="string">&quot;__add__&quot;</span>: (<span class="string">&quot;tp_as_number&quot;</span>, <span class="string">&quot;nb_add&quot;</span>),</span><br><span class="line">    <span class="string">&quot;__sub__&quot;</span>: (<span class="string">&quot;tp_as_number&quot;</span>, <span class="string">&quot;nb_subtract&quot;</span>),</span><br><span class="line">    <span class="string">&quot;__mul__&quot;</span>: (<span class="string">&quot;tp_as_number&quot;</span>, <span class="string">&quot;nb_multiply&quot;</span>),</span><br><span class="line">    <span class="string">&quot;__mod__&quot;</span>: (<span class="string">&quot;tp_as_number&quot;</span>, <span class="string">&quot;nb_remainder&quot;</span>),</span><br><span class="line">    <span class="string">&quot;__pow__&quot;</span>: (<span class="string">&quot;tp_as_number&quot;</span>, <span class="string">&quot;nb_power&quot;</span>),</span><br><span class="line">    <span class="string">&quot;__neg__&quot;</span>: (<span class="string">&quot;tp_as_number&quot;</span>, <span class="string">&quot;nb_negative&quot;</span>),</span><br><span class="line">    <span class="string">&quot;__pos__&quot;</span>: (<span class="string">&quot;tp_as_number&quot;</span>, <span class="string">&quot;nb_positive&quot;</span>),</span><br><span class="line">    <span class="string">&quot;__abs__&quot;</span>: (<span class="string">&quot;tp_as_number&quot;</span>, <span class="string">&quot;nb_absolute&quot;</span>),</span><br><span class="line">    <span class="string">&quot;__bool__&quot;</span>: (<span class="string">&quot;tp_as_number&quot;</span>, <span class="string">&quot;nb_bool&quot;</span>),</span><br><span class="line">    <span class="string">&quot;__inv__&quot;</span>: (<span class="string">&quot;tp_as_number&quot;</span>, <span class="string">&quot;nb_invert&quot;</span>),</span><br><span class="line">    <span class="string">&quot;__invert__&quot;</span>: (<span class="string">&quot;tp_as_number&quot;</span>, <span class="string">&quot;nb_invert&quot;</span>),</span><br><span class="line">    <span class="string">&quot;__lshift__&quot;</span>: (<span class="string">&quot;tp_as_number&quot;</span>, <span class="string">&quot;nb_lshift&quot;</span>),</span><br><span class="line">    <span class="string">&quot;__rshift__&quot;</span>: (<span class="string">&quot;tp_as_number&quot;</span>, <span class="string">&quot;nb_rshift&quot;</span>),</span><br><span class="line">    <span class="string">&quot;__and__&quot;</span>: (<span class="string">&quot;tp_as_number&quot;</span>, <span class="string">&quot;nb_and&quot;</span>),</span><br><span class="line">    <span class="string">&quot;__xor__&quot;</span>: (<span class="string">&quot;tp_as_number&quot;</span>, <span class="string">&quot;nb_xor&quot;</span>),</span><br><span class="line">    <span class="string">&quot;__or__&quot;</span>: (<span class="string">&quot;tp_as_number&quot;</span>, <span class="string">&quot;nb_or&quot;</span>),</span><br><span class="line">    <span class="string">&quot;__int__&quot;</span>: (<span class="string">&quot;tp_as_number&quot;</span>, <span class="string">&quot;nb_int&quot;</span>),</span><br><span class="line">    <span class="string">&quot;__float__&quot;</span>: (<span class="string">&quot;tp_as_number&quot;</span>, <span class="string">&quot;nb_float&quot;</span>),</span><br><span class="line">    <span class="string">&quot;__iadd__&quot;</span>: (<span class="string">&quot;tp_as_number&quot;</span>, <span class="string">&quot;nb_inplace_add&quot;</span>),</span><br><span class="line">    <span class="string">&quot;__isub__&quot;</span>: (<span class="string">&quot;tp_as_number&quot;</span>, <span class="string">&quot;nb_inplace_subtract&quot;</span>),</span><br><span class="line">    <span class="string">&quot;__imul__&quot;</span>: (<span class="string">&quot;tp_as_number&quot;</span>, <span class="string">&quot;nb_inplace_multiply&quot;</span>),</span><br><span class="line">    <span class="string">&quot;__imod__&quot;</span>: (<span class="string">&quot;tp_as_number&quot;</span>, <span class="string">&quot;nb_inplace_remainder&quot;</span>),</span><br><span class="line">    <span class="string">&quot;__ipow__&quot;</span>: (<span class="string">&quot;tp_as_number&quot;</span>, <span class="string">&quot;nb_inplace_power&quot;</span>),</span><br><span class="line">    <span class="string">&quot;__ilshift__&quot;</span>: (<span class="string">&quot;tp_as_number&quot;</span>, <span class="string">&quot;nb_inplace_lshift&quot;</span>),</span><br><span class="line">    <span class="string">&quot;__irshift__&quot;</span>: (<span class="string">&quot;tp_as_number&quot;</span>, <span class="string">&quot;nb_inplace_rshift&quot;</span>),</span><br><span class="line">    <span class="string">&quot;__iand__&quot;</span>: (<span class="string">&quot;tp_as_number&quot;</span>, <span class="string">&quot;nb_inplace_and&quot;</span>),</span><br><span class="line">    <span class="string">&quot;__ixor__&quot;</span>: (<span class="string">&quot;tp_as_number&quot;</span>, <span class="string">&quot;nb_inplace_xor&quot;</span>),</span><br><span class="line">    <span class="string">&quot;__ior__&quot;</span>: (<span class="string">&quot;tp_as_number&quot;</span>, <span class="string">&quot;nb_inplace_or&quot;</span>),</span><br><span class="line">    <span class="string">&quot;__floordiv__&quot;</span>: (<span class="string">&quot;tp_as_number&quot;</span>, <span class="string">&quot;nb_floor_divide&quot;</span>),</span><br><span class="line">    <span class="string">&quot;__div__&quot;</span>: (<span class="string">&quot;tp_as_number&quot;</span>, <span class="string">&quot;nb_true_divide&quot;</span>),</span><br><span class="line">    <span class="string">&quot;__ifloordiv__&quot;</span>: (<span class="string">&quot;tp_as_number&quot;</span>, <span class="string">&quot;nb_inplace_floor_divide&quot;</span>),</span><br><span class="line">    <span class="string">&quot;__idiv__&quot;</span>: (<span class="string">&quot;tp_as_number&quot;</span>, <span class="string">&quot;nb_inplace_true_divide&quot;</span>),</span><br><span class="line">    <span class="string">&quot;__index__&quot;</span>: (<span class="string">&quot;tp_as_number&quot;</span>, <span class="string">&quot;nb_index&quot;</span>),</span><br><span class="line">    <span class="string">&quot;__matmul__&quot;</span>: (<span class="string">&quot;tp_as_number&quot;</span>, <span class="string">&quot;nb_matrix_multiply&quot;</span>),</span><br><span class="line">    <span class="string">&quot;__imatmul__&quot;</span>: (<span class="string">&quot;tp_as_number&quot;</span>, <span class="string">&quot;nb_inplace_matrix_multiply&quot;</span>),</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;__len__&quot;</span>: (<span class="string">&quot;tp_as_sequence&quot;</span>, <span class="string">&quot;sq_length&quot;</span>),</span><br><span class="line">    <span class="string">&quot;__concat__&quot;</span>: (<span class="string">&quot;tp_as_sequence&quot;</span>, <span class="string">&quot;sq_concat&quot;</span>),</span><br><span class="line">    <span class="string">&quot;__repeat__&quot;</span>: (<span class="string">&quot;tp_as_sequence&quot;</span>, <span class="string">&quot;sq_repeat&quot;</span>),</span><br><span class="line">    <span class="string">&quot;__getitem__&quot;</span>: (<span class="string">&quot;tp_as_sequence&quot;</span>, <span class="string">&quot;sq_item&quot;</span>),</span><br><span class="line">    <span class="string">&quot;__setitem__&quot;</span>: (<span class="string">&quot;tp_as_sequence&quot;</span>, <span class="string">&quot;sq_ass_item&quot;</span>),</span><br><span class="line">    <span class="string">&quot;__contains__&quot;</span>: (<span class="string">&quot;tp_as_sequence&quot;</span>, <span class="string">&quot;sq_contains&quot;</span>),</span><br><span class="line">    <span class="string">&quot;__iconcat__&quot;</span>: (<span class="string">&quot;tp_as_sequence&quot;</span>, <span class="string">&quot;sq_inplace_concat&quot;</span>),</span><br><span class="line">    <span class="string">&quot;__irepeat__&quot;</span>: (<span class="string">&quot;tp_as_sequence&quot;</span>, <span class="string">&quot;sq_inplace_repeat&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">keep_method_alive= &#123;&#125;</span><br><span class="line">keep_method_set_alive= &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以上就准备就绪了，下面再将之前的 patch_builtin_class 函数补充一下即可</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">patch_builtin_class</span>(<span class="params">cls, name, value</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :param cls: 要修改的类</span></span><br><span class="line"><span class="string">    :param name: 属性名或者函数名</span></span><br><span class="line"><span class="string">    :param value: 值</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(cls) <span class="keyword">is</span> <span class="keyword">not</span> <span class="built_in">type</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;cls 必须是一个内置的类对象&quot;</span>)</span><br><span class="line">    cls_attrs = gc.get_referents(cls.__dict__)[<span class="number">0</span>]</span><br><span class="line">    old_value = cls_attrs.get(name, <span class="literal">None</span>)</span><br><span class="line">    cls_attrs[name] = value</span><br><span class="line">    <span class="keyword">if</span> old_value <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            value.__name__ = old_value.__name__</span><br><span class="line">            value.__qualname__ = old_value.__qualname__</span><br><span class="line">        <span class="keyword">except</span> AttributeError:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        cls_attrs[<span class="string">f&quot;_<span class="subst">&#123;cls.__name__&#125;</span>_<span class="subst">&#123;name&#125;</span>&quot;</span>] = old_value</span><br><span class="line">    pythonapi.PyType_Modified(py_object(cls))</span><br><span class="line">    <span class="comment"># 以上逻辑不变，然后对参数 name 进行检测</span></span><br><span class="line">    <span class="comment"># 如果是魔方方法、并且 value 是一个可调用对象，那么修改操作符，否则直接 return</span></span><br><span class="line">    <span class="keyword">if</span> name <span class="keyword">not</span> <span class="keyword">in</span> magic_method_dict <span class="keyword">and</span> <span class="built_in">callable</span>(value):</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 比如 name 是 __sub__，那么 tp_as_name, rewrite == &quot;tp_as_number&quot;, &quot;nb_sub&quot;</span></span><br><span class="line">    tp_as_name, rewrite = magic_method_dict[name]</span><br><span class="line">    <span class="comment"># 获取类对应的底层结构，PyTypeObject 实例</span></span><br><span class="line">    type_obj = PyTypeObject.from_address(<span class="built_in">id</span>(cls))</span><br><span class="line">    <span class="comment"># 根据 tp_as_name 判断到底是哪一个方法集，这里我们没有实现 tp_as_mapping 和 tp_as_async</span></span><br><span class="line">    struct_method_set_class = (PyNumberMethods <span class="keyword">if</span> tp_as_name == <span class="string">&quot;tp_as_number&quot;</span></span><br><span class="line">                               <span class="keyword">else</span> PySequenceMethods <span class="keyword">if</span> tp_as_name == <span class="string">&quot;tp_as_sequence&quot;</span></span><br><span class="line">                               <span class="keyword">else</span> PyMappingMethods <span class="keyword">if</span> tp_as_name == <span class="string">&quot;tp_as_mapping&quot;</span></span><br><span class="line">                               <span class="keyword">else</span> PyAsyncMethods)</span><br><span class="line">    <span class="comment"># 获取具体的方法集（指针）</span></span><br><span class="line">    struct_method_set_ptr = <span class="built_in">getattr</span>(type_obj, tp_as_name, <span class="literal">None</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> struct_method_set_ptr:</span><br><span class="line">        <span class="comment"># 如果不存在此方法集，我们实例化一个，然后设置到里面去</span></span><br><span class="line">        struct_method_set = struct_method_set_class()</span><br><span class="line">        <span class="comment"># 注意我们要传一个指针进去</span></span><br><span class="line">        <span class="built_in">setattr</span>(type_obj, tp_as_name, pointer(struct_method_set))</span><br><span class="line">    <span class="comment"># 然后对指针进行解引用，获取方法集，也就是对应的结构体实例</span></span><br><span class="line">    struct_method_set = struct_method_set_ptr.contents</span><br><span class="line">    <span class="comment"># 遍历 struct_method_set_class，判断到底重写的是哪一个魔法方法</span></span><br><span class="line">    cfunc_type = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">for</span> field, ftype <span class="keyword">in</span> struct_method_set_class._fields_:</span><br><span class="line">        <span class="keyword">if</span> field == rewrite:</span><br><span class="line">            cfunc_type = ftype</span><br><span class="line">    <span class="comment"># 构造新的函数</span></span><br><span class="line">    cfunc = cfunc_type(value)</span><br><span class="line">    <span class="comment"># 更新方法集</span></span><br><span class="line">    <span class="built_in">setattr</span>(struct_method_set, rewrite, cfunc)</span><br><span class="line">    <span class="comment"># 至此我们的功能就完成了，但还有一个非常重要的点，就是上面的 cfunc</span></span><br><span class="line">    <span class="comment"># 虽然它是一个底层可以识别的 C 函数，但它本质上仍然是一个 Python 对象</span></span><br><span class="line">    <span class="comment"># 其内部维护了 C 级数据，赋值之后底层会自动提取，而这一步不会增加引用计数</span></span><br><span class="line">    <span class="comment"># 所以这个函数结束之后，cfunc 就被销毁了（连同内部的 C 级数据）</span></span><br><span class="line">    <span class="comment"># 这样后续再调用相关操作符的时候就会出现段错误，解释器异常退出</span></span><br><span class="line">    <span class="comment"># 因此我们需要在函数结束之前创建一个在外部持有它的引用</span></span><br><span class="line">    keep_method_alive[(cls, name)] = cfunc</span><br><span class="line">    <span class="comment"># 当然还有我们上面的方法集，也是同理</span></span><br><span class="line">    keep_method_set_alive[(cls, name)] = struct_method_set</span><br></pre></td></tr></table></figure>

<p><strong>代码量还是稍微有点多的，但是不难理解，我们将这些代码放在一个单独的文件里面，文件名就叫 unsafe_magic.py，然后导入它。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> unsafe_magic <span class="keyword">import</span> patch_builtin_class</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">patch_builtin_class(<span class="built_in">int</span>, <span class="string">&quot;__getitem__&quot;</span>, <span class="keyword">lambda</span> self, item: <span class="string">&quot;_&quot;</span>.join([<span class="built_in">str</span>(self)] * item))</span><br><span class="line">patch_builtin_class(<span class="built_in">str</span>, <span class="string">&quot;__matmul__&quot;</span>, <span class="keyword">lambda</span> self, other: (self, other))</span><br><span class="line">patch_builtin_class(<span class="built_in">str</span>, <span class="string">&quot;__sub__&quot;</span>, <span class="keyword">lambda</span> self, other: other + self)</span><br></pre></td></tr></table></figure>

<p><strong>你觉得之后会发生什么呢？我们测试一下：</strong></p>
<p><img src="/2023/04/26/34-%E4%BE%B5%E5%85%A5-Python-%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%8C%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6/1229382-20211031135007088-270878613.png" alt="img"></p>
<p><strong>怎么样，是不是很好玩呢？</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> unsafe_magic <span class="keyword">import</span> patch_builtin_class</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">patch_builtin_class(<span class="built_in">tuple</span>, <span class="string">&quot;append&quot;</span>, <span class="keyword">lambda</span> self, item: self + (item, ))</span><br><span class="line">t = ()</span><br><span class="line"><span class="built_in">print</span>(t.append(<span class="number">1</span>).append(<span class="number">2</span>).append(<span class="number">3</span>).append(<span class="number">4</span>))  <span class="comment"># (1, 2, 3, 4)</span></span><br></pre></td></tr></table></figure>

<p><strong>因此 Python 给开发者赋予的权限是非常高的，你可以玩出很多意想不到的新花样。</strong></p>
<p><strong>另外再多说一句，当对象不支持某个操作符的时候，我们能够让它实现该操作符；但如果对象已经实现了某个操作符，那么其逻辑就改不了了，举个栗子：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> unsafe_magic <span class="keyword">import</span> patch_builtin_class</span><br><span class="line"></span><br><span class="line"><span class="comment"># str 没有 __div__，我们可以为其实现，此时字符串便拥有了除法的功能</span></span><br><span class="line">patch_builtin_class(<span class="built_in">str</span>, <span class="string">&quot;__div__&quot;</span>, <span class="keyword">lambda</span> self, other: (self, other))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span> / <span class="string">&quot;world&quot;</span>)  <span class="comment"># (&#x27;hello&#x27;, &#x27;world&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 但 __add__ 是 str 本身就有的，也就是说字符串本身就可以相加</span></span><br><span class="line"><span class="comment"># 而此时我们就无法覆盖加法这个操作符了</span></span><br><span class="line">patch_builtin_class(<span class="built_in">str</span>, <span class="string">&quot;__add__&quot;</span>, <span class="keyword">lambda</span> self, other: (self, other))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;你&quot;</span> + <span class="string">&quot;好&quot;</span>)  <span class="comment"># 你好</span></span><br><span class="line"><span class="comment"># 我们看到使用加号，并没有走我们重写之后的 __add__ 方法，因为字符串本身就支持加法运算</span></span><br><span class="line"><span class="comment"># 但也有例外，就是当出现 TypeError 的时候，那么解释器会执行我们重写的方法</span></span><br><span class="line"><span class="comment"># 字符串和整数相加会出现异常，因此解释器会执行我们重写的 __add__</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;你&quot;</span> + <span class="number">123</span>)  <span class="comment"># (&#x27;你&#x27;, 123)</span></span><br><span class="line"><span class="comment"># 但如果是调用魔方方法，那么会直接走我们重写的 __add__，前面说过的</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;你&quot;</span>.__add__(<span class="string">&quot;好&quot;</span>))  <span class="comment"># (&#x27;你&#x27;, &#x27;好&#x27;)</span></span><br></pre></td></tr></table></figure>

<p><strong>不过上述这个问题在 3.6 版本的时候是没有的，操作符会无条件地执行我们重写的魔法方法。但在 3.8 的时候出现了这个现象，可以自己测试一下。</strong></p>
<p><strong>最后再来说一说 Python&#x2F;C API，Python 解释器暴露了大量的 C 一级的 API 供我们调用，而调用方式可以通过 ctypes.pythonapi 来实现。我们之前用过一次，就是  pythonapi.PyType_Modified。那么再举个例子来感受一下：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="comment"># 函数原型：PyList_SetItem(PyObject *op, Py_ssize_t i, PyObject *newitem)</span></span><br><span class="line"><span class="comment"># 调用的时候类型一定要匹配，否则很容易导致解释器异常退出</span></span><br><span class="line">pythonapi.PyList_SetItem(py_object(lst), <span class="number">1</span>, py_object(<span class="number">666</span>))</span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># [1, 666, 3]</span></span><br></pre></td></tr></table></figure>

<p><strong>ctypes.pythonapi 用的不是很多，像 Python 提供的 C 级 API 一般在编写扩展的时候有用。</strong></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><strong>以上我们就用 ctypes 玩了一些骚操作，内容还是有点单调，当然你也可以玩的再嗨一些。但是无论如何，一定不要在生产上使用，线上不要出现这种会改变解释器运行逻辑的代码。如果只是为了调试、或者想从实践的层面更深入的了解虚拟机，那么没事可以玩一玩。</strong></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Lin Li</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/04/26/34-%E4%BE%B5%E5%85%A5-Python-%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%8C%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6/">http://example.com/2023/04/26/34-%E4%BE%B5%E5%85%A5-Python-%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%8C%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">LinLi's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/CPython/">CPython</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/04/26/35-Numba%E6%98%AF%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3Python%E7%9A%84%E4%B8%89%E5%A4%A7%E6%80%A7%E8%83%BD%E7%93%B6%E9%A2%88%E7%9A%84/" title="35-Numba是如何解决Python的三大性能瓶颈的"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">35-Numba是如何解决Python的三大性能瓶颈的</div></div></a></div><div class="next-post pull-right"><a href="/2023/04/26/33-%E4%B8%BA%E4%BB%80%E4%B9%88-obj-obj-%E4%B8%BA-False%E3%80%81-obj-obj-%E4%B8%BA-True/" title="33-为什么 obj == obj 为 False、[obj] == [obj] 为 True"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">33-为什么 obj == obj 为 False、[obj] == [obj] 为 True</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/03/29/01-%E7%BC%96%E8%AF%91Cpython/" title="01-编译Cpython"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">01-编译Cpython</div></div></a></div><div><a href="/2023/03/29/02-%E4%B8%80%E5%88%87%E5%AF%B9%E8%B1%A1%E7%9A%86PyObject/" title="02-一切对象皆PyObject"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">02-一切对象皆PyObject</div></div></a></div><div><a href="/2023/03/29/04-%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/" title="04-浮点数的底层实现"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">04-浮点数的底层实现</div></div></a></div><div><a href="/2023/03/29/06-Bytes%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BA%95%E5%B1%82%E6%93%8D%E4%BD%9C/" title="06-Bytes对象的底层操作"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">06-Bytes对象的底层操作</div></div></a></div><div><a href="/2023/03/29/03-Python%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E5%99%A8%E5%92%8C%E5%BA%95%E5%B1%82%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86/" title="03-Python引用计数器和底层对象管理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">03-Python引用计数器和底层对象管理</div></div></a></div><div><a href="/2023/03/29/05-Python%E6%95%B4%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/" title="05-Python整数的底层实现"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">05-Python整数的底层实现</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Lin Li</div><div class="author-info__description">今日事，今日毕</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">122</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#34-%E4%BE%B5%E5%85%A5-Python-%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%8C%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6"><span class="toc-number">1.</span> <span class="toc-text">34-侵入 Python 虚拟机，动态修改底层数据结构和运行时</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A5%94%E5%AD%90"><span class="toc-number">1.1.</span> <span class="toc-text">楔子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Python-%E8%A1%A8%E7%A4%BA-C-%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.</span> <span class="toc-text">使用 Python 表示 C 的数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.1.</span> <span class="toc-text">数值类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.2.</span> <span class="toc-text">字符类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">1.2.3.</span> <span class="toc-text">数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">1.2.4.</span> <span class="toc-text">结构体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88"><span class="toc-number">1.2.5.</span> <span class="toc-text">指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.6.</span> <span class="toc-text">函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.2.7.</span> <span class="toc-text">类型转换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%8C%E8%A7%82%E5%AF%9F%E8%BF%90%E8%A1%8C%E6%97%B6%E8%A1%A8%E7%8E%B0"><span class="toc-number">1.3.</span> <span class="toc-text">模拟底层数据结构，观察运行时表现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0"><span class="toc-number">1.3.1.</span> <span class="toc-text">浮点数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B4%E6%95%B0"><span class="toc-number">1.3.2.</span> <span class="toc-text">整数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E4%B8%B2"><span class="toc-number">1.3.3.</span> <span class="toc-text">字节串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%97%E8%A1%A8"><span class="toc-number">1.3.4.</span> <span class="toc-text">列表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%83%E7%BB%84"><span class="toc-number">1.3.5.</span> <span class="toc-text">元组</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%99%E7%B1%BB%E5%AF%B9%E8%B1%A1%E5%A2%9E%E5%8A%A0%E5%B1%9E%E6%80%A7"><span class="toc-number">1.4.</span> <span class="toc-text">给类对象增加属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84-PyTypeObject"><span class="toc-number">1.5.</span> <span class="toc-text">类对象的底层结构 PyTypeObject</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%86%99%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">1.6.</span> <span class="toc-text">重写操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">1.7.</span> <span class="toc-text">小结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/08/%E8%A7%A3%E5%86%B3Camera-ready-%E2%9C%98-Problem-Not-all-fonts-are-embedded-%E9%97%AE%E9%A2%98/" title="解决Camera ready ✘ Problem: Not all fonts are embedded. 问题">解决Camera ready ✘ Problem: Not all fonts are embedded. 问题</a><time datetime="2025-04-08T14:19:21.000Z" title="发表于 2025-04-08 22:19:21">2025-04-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/21/Sequence-Oriented-DBMS-Fuzzing/" title="Sequence-Oriented DBMS Fuzzing">Sequence-Oriented DBMS Fuzzing</a><time datetime="2025-02-21T09:35:08.000Z" title="发表于 2025-02-21 17:35:08">2025-02-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/18/AGENTLESS-Demystifying-LLM-based-Software-Engineering-Agents/" title="AGENTLESS: Demystifying LLM-based Software Engineering Agents">AGENTLESS: Demystifying LLM-based Software Engineering Agents</a><time datetime="2025-02-18T12:16:29.000Z" title="发表于 2025-02-18 20:16:29">2025-02-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/01/DeepSeek-R1-Incentivizing-Reasoning-Capability-in-LLMs-via-Reinforcement-Learning/" title="DeepSeek-R1: Incentivizing Reasoning Capability in LLMs via Reinforcement Learning">DeepSeek-R1: Incentivizing Reasoning Capability in LLMs via Reinforcement Learning</a><time datetime="2025-02-01T11:11:48.000Z" title="发表于 2025-02-01 19:11:48">2025-02-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/01/DeepSeek-Coder-When-the-Large-Language-Model-Meets-Programming-The-Rise-of-Code-Intelligence/" title="DeepSeek-Coder: When the Large Language Model Meets Programming - The Rise of Code Intelligence">DeepSeek-Coder: When the Large Language Model Meets Programming - The Rise of Code Intelligence</a><time datetime="2025-02-01T02:43:19.000Z" title="发表于 2025-02-01 10:43:19">2025-02-01</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Lin Li</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>