<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>32-Python 和 Go 联合编程 | LinLi's Blog</title><meta name="author" content="Lin Li"><meta name="copyright" content="Lin Li"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="32-Python 和 Go 联合编程楔子Python 可以和 C 无缝结合，通过 C 来为 Python  编写扩展可以极大地提升 Python 的效率，但是使用 C 来编程显然不是很方便，于是本人想到了 Go。对比 C 和 Go  会发现两者非常相似，没错，Go 语言具有强烈的 C 语言背景，其设计者以及语言的设计目标都和 C 有着千丝万缕的联系。因为 Go  语言的诞生就是因为 Google">
<meta property="og:type" content="article">
<meta property="og:title" content="32-Python 和 Go 联合编程">
<meta property="og:url" content="http://example.com/2023/04/26/32-Python-%E5%92%8C-Go-%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="LinLi&#39;s Blog">
<meta property="og:description" content="32-Python 和 Go 联合编程楔子Python 可以和 C 无缝结合，通过 C 来为 Python  编写扩展可以极大地提升 Python 的效率，但是使用 C 来编程显然不是很方便，于是本人想到了 Go。对比 C 和 Go  会发现两者非常相似，没错，Go 语言具有强烈的 C 语言背景，其设计者以及语言的设计目标都和 C 有着千丝万缕的联系。因为 Go  语言的诞生就是因为 Google">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2023-04-26T13:25:46.000Z">
<meta property="article:modified_time" content="2023-04-26T13:26:28.965Z">
<meta property="article:author" content="Lin Li">
<meta property="article:tag" content="CPython">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/04/26/32-Python-%E5%92%8C-Go-%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '32-Python 和 Go 联合编程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-04-26 21:26:28'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">98</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="LinLi's Blog"><span class="site-name">LinLi's Blog</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">32-Python 和 Go 联合编程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-04-26T13:25:46.000Z" title="发表于 2023-04-26 21:25:46">2023-04-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-04-26T13:26:28.965Z" title="更新于 2023-04-26 21:26:28">2023-04-26</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="32-Python 和 Go 联合编程"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="32-Python-和-Go-联合编程"><a href="#32-Python-和-Go-联合编程" class="headerlink" title="32-Python 和 Go 联合编程"></a>32-Python 和 Go 联合编程</h2><h3 id="楔子"><a href="#楔子" class="headerlink" title="楔子"></a>楔子</h3><p><strong>Python 可以和 C 无缝结合，通过 C 来为 Python  编写扩展可以极大地提升 Python 的效率，但是使用 C 来编程显然不是很方便，于是本人想到了 Go。对比 C 和 Go  会发现两者非常相似，没错，Go 语言具有强烈的 C 语言背景，其设计者以及语言的设计目标都和 C 有着千丝万缕的联系。因为 Go  语言的诞生就是因为 Google 中的一些开发者觉得 C++ 太复杂了，所以才决定开发一门简单易用的语言，而 Google 的工程师大部分都有 C 的背景，因此在设计 Go 语言的时候保持了 C 语言的风格。</strong></p>
<p><strong>而在 Go 和 C 的交互方面，Go  语言也是提供了非常大的支持（CGO），可以直接通过注释的方式将 C 源代码嵌入在 Go 文件中，这是其它语言所无法比拟的。最初 CGO  是为了能复用 C 资源这一目的而出现的，而现在它已经变成 Go 和 C 之间进行双向通讯的桥梁，也就是 Go 不仅能调用 C  的函数，还能将自己的函数导出给 C 调用。也正因为如此，Python 和 Go 之间才有了交互的可能。因为 Python 和 Go  本身其实是无法交互的，但是它们都可以和 C 勾搭上，所以需要通过 C 充当媒介，来为 Python 和 Go 牵线搭桥。</strong></p>
<p><strong>我们知道 Python 和 C 之间是双向的，也就是可以互相调用，而 Go 和 C 之间也是双向的，那么 Python 和 Go 之间自然仍是双向的。我们可以在 Python 为主导的项目中引入 Go，也可以在 Go  为主导的项目中引入 Python，而对于我本人来说，Python 是我的主语言、或者说老本行，因此这里我只介绍如何在 Python  为主导的项目中引入 Go。</strong></p>
<p><strong>而在 Python 为主导的项目中引入 Go 有以下几种方式：</strong></p>
<ul>
<li><code>将 Go 源文件编译成动态库，然后直接通过 Python 的 ctypes 模块调用</code></li>
<li><code>将 Go 源文件编译成动态库或者静态库，再结合 Cython 生成对应的 Python 扩展模块，然后直接 import 即可</code></li>
<li><code>将 Go 源文件直接编译成 Python 扩展模块，当然这要求在使用 CGO 的时候需要遵循 Python 提供的 C API</code></li>
</ul>
<p><strong>对于第一种方式，使用哪种操作系统无关紧要，操作都是一样的。但是对于第二种和第三种，我只在 Linux 上成功过，当然 Windows 肯定也是可以的，只不过操作方式会复杂一些（个人不是很熟悉）。因此这里我统一使用 Linux  进行演示，下面介绍一下我的相关环境：</strong></p>
<ul>
<li><code>Python 版本：3.6.8，系统自带的 Python，当然 3.7、3.8、3.9 同样是没有问题的（个人最喜欢 3.8）</code></li>
<li><code>Go 版本：1.16.4，一个比较新的版本了，至于其它版本也同样可以</code></li>
<li><code>gcc 版本：4.8.5，系统自带（Windows 系统的话，需要去下载 MingGW）</code></li>
</ul>
<p><img src="/2023/04/26/32-Python-%E5%92%8C-Go-%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/1229382-20210518172801098-1418721316.png" alt="img"></p>
<p><strong>下面我们来介绍一下上面这几种方式。</strong></p>
<h3 id="Go-源文件编译成动态库"><a href="#Go-源文件编译成动态库" class="headerlink" title="Go 源文件编译成动态库"></a>Go 源文件编译成动态库</h3><p><strong>首先如果 Go 想要编译成动态库给 Python 调用，那么必须启用  CGO 特性，并将想要被 Python 调用的函数导出。而启用 CGO 则需要保证环境变量 CGO_ENABLE 的值设置为  1，在本地构建的时候默认是开启的，但是交叉编译（比如在 Windows 上编译 Linux 动态库）的时候，则是禁止的。</strong></p>
<p><strong>下面来看看一个最简单的 CGO 程序是什么样子的。</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件名：file.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;你好，古明地觉，我的公主大人&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>相较于普通的 Go 只是多了一句 import “C”，除此之外没有任何和 CGO 相关的代码，也没有调用 CGO 的相关函数。但是由于这个 import，会使得 go build 命令在编译和链接阶段启动 gcc  编译器，所以这已经是一个完整的 CGO 程序了。</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@satori go_py]<span class="comment"># go run file.go</span></span><br><span class="line">你好，古明地觉，我的公主大人</span><br></pre></td></tr></table></figure>

<p><strong>直接运行，打印输出。当然我们也可以基于 C 标准库函数来输出字符串：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件名：file.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">//#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// C.CString 表示将 Go 的字符串转成 C 的字符串</span></span><br><span class="line">    C.puts(C.CString(<span class="string">&quot;觉大人，你能猜到此刻我在想什么吗&quot;</span>)) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>可能有人好奇  import “C” 上面那段代码是做什么的，答案是导入 C 中的标准库。我们说 Go 里面是可以直接编写 C 代码的，而 C 代码要通过注释的形式写在 import “C”  这行语句上方（中间不可以有空格，这是规定）。而一旦导入，就可以通过 C 这个名字空间进行调用，比如这里的 C.puts、C.CString  等等。</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@satori go_py]<span class="comment"># go run file.go</span></span><br><span class="line">觉大人，你能猜到此刻我在想什么吗</span><br></pre></td></tr></table></figure>

<p><strong>至于这里的  import “C”，它不是导入一个名为 C 的包，我们可以将其理解为一个名字空间，C 语言的所有类型、函数等等都可以通过这个名字空间去调用。</strong></p>
<p><strong>最后注意里面的 C.CString，我们说这是将 Go 的字符串转成 C 的字符串，但是当我们不用了的时候它依旧会停留在内存里，所以我们要将其释放掉，具体做法后面会说。但是对于当前这个小程序来说，这样是没有问题的，因为程序退出后操作系统会回收所有的资源。</strong></p>
<p><strong>我们也可以自己定义一个函数：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件名：file.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt; </span></span><br><span class="line"><span class="comment">void SayWhat(const char *s) &#123;</span></span><br><span class="line"><span class="comment">    puts(s);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="comment">// 上面也可以写多行注释</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 即便是我们自己定义的函数也是需要通过 C 来调用, 不然的话 go 编译器怎么知道这个函数是 C 的函数还是 go 的函数呢</span></span><br><span class="line">    C.SayWhat(C.CString(<span class="string">&quot;少女觉&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>同样是可以执行成功的。</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@satori go_py]<span class="comment"># go run file.go</span></span><br><span class="line">少女觉</span><br></pre></td></tr></table></figure>

<p><strong>除此之外我们还可以将 C 的代码放到单独的文件中，比如：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件名：1.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SayWhat</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s)</span> &#123;</span><br><span class="line">	<span class="built_in">puts</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>然后 Go 源文件如下：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件名：file.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#include &quot;1.c&quot;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    C.SayWhat(C.CString(<span class="string">&quot;古明地恋&quot;</span>))  <span class="comment">// 古明地恋</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>直接执行即可打印出结果，当然我们会更愿意把 C 函数的声明写在头文件当中，具体实现写在C源文件中。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.h</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SayWhat</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SayWhat</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s)</span> &#123;</span><br><span class="line">    <span class="built_in">puts</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>然后在 Go 只需要导入头文件即可使用，比如：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件名：file.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#include &quot;1.h&quot;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    C.SayWhat(C.CString(<span class="string">&quot;恋，对不起，我爱的是你姐姐&quot;</span>))  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>然后重点来了，这个时候如果执行 go run file.go 是会报错的：</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@satori go_py]<span class="comment"># go run file.go</span></span><br><span class="line"><span class="comment"># command-line-arguments</span></span><br><span class="line">/tmp/go-build24597302/b001/_x002.o：在函数‘_cgo_f2c21e79afe5_Cfunc_SayWhat’中：</span><br><span class="line">/tmp/go-build/cgo-gcc-prolog:49：对‘SayWhat’未定义的引用</span><br><span class="line">collect2: 错误：ld 返回 1</span><br></pre></td></tr></table></figure>

<p><strong>虽然文件中出现了 #include “1.h”，但是和 1.h  相关的源文件 1.c 则没有任何体现，除非你在go的注释里面再加上 #include  “1.c”，但这样头文件就没有意义了。因此在编译的时候，我们不能对这个具体的 file.go 源文件进行编译；也就是说不要执行 go build file.go，而是要在这个 Go 文件所在的目录直接执行 go build，会对整个包进行编译，此时就可以找到当前目录中对应的 C  源文件了。</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@satori go_py]<span class="comment"># go build -o a.out</span></span><br><span class="line">[root@satori go_py]<span class="comment"># ./a.out </span></span><br><span class="line">恋，对不起，我爱的是你姐姐</span><br></pre></td></tr></table></figure>

<p><strong>但是需要注意的是：我当前目录为 &#x2F;root&#x2F;go_py，里面的 Go 文件只有一个 file.go，但如果内部有多个 Go文件的话，那么对整个包进行编译的时候，要确保只能有一个文件有 main 函数。</strong></p>
<blockquote>
<p><strong>另外对于 go1.16 而言，需要先通过 go mod init 来初始化项目，否则编译包的时候会失败。</strong></p>
</blockquote>
<h3 id="Go-导出函数给-Python-调用"><a href="#Go-导出函数给-Python-调用" class="headerlink" title="Go 导出函数给 Python 调用"></a>Go 导出函数给 Python 调用</h3><p><strong>上面算是简单介绍了一下 CGO 以及 Go 如何调用 C 函数，但是 Go 调用 C 函数并不是我们的重点，我们的重点是 Go 导出函数给 Python 使用。</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件名：file.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//export SayWhat</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SayWhat</span><span class="params">(s *C.char)</span></span> &#123;</span><br><span class="line">    <span class="comment">// C.GoString 是将 C 的字符串转成 Go 的字符串</span></span><br><span class="line">    fmt.Println(C.GoString(s))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//这个main函数我们不用, 但是必须要写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们看到函数上面有一行注释：&#x2F;&#x2F;export  SayWhat，这一行注释必须要有，即 &#x2F;&#x2F;export 函数名。并且该注释要和函数紧挨着，之间不能有空行，而它的作用就是将 SayWhat  函数导出，然后 Python 才可以调用，如果不导出的话，Python 会调用不到的。而且导出的时候是 C 函数的形式导出的，因为 Python 和 Go 交互需要 C 作为媒介，因此导出函数的参数和返回值都必须是 C 的类型。</strong></p>
<blockquote>
<p><strong>导出函数的名称不要求首字母大写，小写的话依旧可以导出。</strong></p>
</blockquote>
<p><strong>最后是 main 函数，这个 main 函数也是必须要有的，尽管里面可以什么都不写，但是必须要有，否则编译不通过。然后我们来将这个文件编译成动态库：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go build -buildmode=c-shared -o 动态库 [go源文件 go源文件 go源文件 ...]</span><br></pre></td></tr></table></figure>

<p><strong>以当前的 file.go 为例：gcc build -buildmode&#x3D;c-shared -o libgo.so file.go，如果是对整个包编译，那么不指定 go源文件即可。</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@satori go_py]<span class="comment"># go build -buildmode=c-shared -o libgo.so file.go</span></span><br></pre></td></tr></table></figure>

<p><strong>这里我们将 file.go 编译成动态库 libgo.so，然后 Python 来调用一下试试。</strong></p>
<blockquote>
<p><strong>在 Linux 上，动态库的后缀名为 .so；在 Windows  上，动态库的后缀名为 .dll。而 Python 的扩展模块在 Linux 上的后缀名也为 .so，在 Windows 上的的后缀名则是  .pyd（pyd 也可以看做是 dll）。因此我们发现所谓 Python 扩展模块实际上就是对应系统上的一个动态库，如果是遵循标准  Python&#x2F;C API 的 C 源文件生成的动态库，Python 解释器是可以直接识别的，我们可以通过 import  导入；但如果不是，比如我们上面刚生成的 libgo.so，或者 Linux 自带的大量动态库，那么我们就需要通过 ctypes 的方式加载了。</strong></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">libgo = CDLL(<span class="string">&quot;./libgo.so&quot;</span>)</span><br><span class="line"></span><br><span class="line">libgo.SayWhat(c_char_p(<span class="string">&quot;古明地觉&quot;</span>.encode(<span class="string">&quot;utf-8&quot;</span>)))</span><br><span class="line">libgo.SayWhat(c_char_p(<span class="string">&quot;芙兰朵露&quot;</span>.encode(<span class="string">&quot;utf-8&quot;</span>)))</span><br><span class="line">libgo.SayWhat(c_char_p(<span class="string">&quot;雾雨魔理沙&quot;</span>.encode(<span class="string">&quot;utf-8&quot;</span>)))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">古明地觉</span></span><br><span class="line"><span class="string">芙兰朵露</span></span><br><span class="line"><span class="string">雾雨魔理沙</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看到成功打印了，那么打印是哪里来的呢？显然是 Go 里面的 fmt.Println。</strong></p>
<p><strong>以上就实现了 Go 导出 Python 函数给 Python 调用，但是很明显这还不够，我们还需要能够传递参数、以及获取返回值。而想要实现这一点，我们必须要了解一下不同语言之间类型的对应关系。</strong></p>
<h4 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h4><p><strong>在 Go 语言中访问 C 语言的符号时，一般是通过虚拟的 “C”  包访问，比如 C.int 对应 C 语言的 int 类型。但有些 C 语言的类型是由多个关键字组成，而通过虚拟的 “C” 包访问 C  语言类型时名称部分不能有空格字符，比如 unsigned int 不能直接通过 C.unsigned int 访问，这是不合法的。因此 CGO 为 C 语言的基础数值类型都提供了相应转换规则，比如 C.uint 对应 C 语言的 unsigned int。</strong></p>
<p><strong>Go 语言中数值类型和 C 语言数据类型基本上是相似的，以下是它们的对应关系表。</strong></p>
<p><img src="/2023/04/26/32-Python-%E5%92%8C-Go-%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/1229382-20201104000443585-817470338.png" alt="img"></p>
<p><strong>数值类型虽然有很多，但是整型我们直接使用 long、浮点型使用 double 即可，另外我们在 Go 中定义的函数名不可以和 C 中的关键字冲突。</strong></p>
<p><strong>下面我们举个栗子演示一下：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件名：file.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//export Int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Int</span><span class="params">(val C.long)</span></span> C.long &#123;</span><br><span class="line">    <span class="comment">// C 的整型可以直接和 Go 的整型相加</span></span><br><span class="line">    <span class="comment">// 但前提是个常量，如果是变量，那么需要使用 C.long 转化一下</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">    <span class="comment">// Go 对类型的要求很严格，这里需要转化，但如果是 val + 1 是可以的，因为 1 是个常量</span></span><br><span class="line">    <span class="keyword">return</span> val + C.long(a) </span><br><span class="line">    <span class="comment">// 这里函数不能起名为 int，因为 int 是 C 中的关键字</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//export Double</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Double</span><span class="params">(val C.double)</span></span> C.double &#123;</span><br><span class="line">    <span class="comment">// 对于浮点型也是需要转化，但如果是常量，也可以直接相加</span></span><br><span class="line">    <span class="keyword">return</span> val + <span class="number">2.2</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//export boolean</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">boolean</span><span class="params">(val C._Bool)</span></span> C._Bool &#123;</span><br><span class="line">    <span class="comment">// 接收一个 bool 类型，true 返回 false，false 返回 true</span></span><br><span class="line">    <span class="keyword">var</span> flag = <span class="type">bool</span>(val)</span><br><span class="line">    <span class="keyword">return</span> C._Bool(!flag)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//export Char</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Char</span><span class="params">(val C.char)</span></span> C.char &#123;</span><br><span class="line">    <span class="comment">// 接收一个字符，进行大小写转化</span></span><br><span class="line">    <span class="keyword">return</span> val ^ <span class="number">0x20</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// main 函数必须要有</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>然后重新编译生成动态库，交给 Python 调用。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">libgo = CDLL(<span class="string">&quot;./libgo.so&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">注意: Python 在获取返回值的时候，默认都是按照整型解析的，如果 Go 的导出函数返回的不是整型，那么再按照整型解析的话必然会出问题</span></span><br><span class="line"><span class="string">因此我们需要在调用函数之前指定返回值的类型，我们这里调用类 CDLL 返回的就是动态库, 假设里面有一个 xxx 函数, 返回了一个 cgo 中的 C.double</span></span><br><span class="line"><span class="string">那么我们就需要在调用 xxx 函数之前, 通过 go_ext.xxx.restype = c_double 提前指定返回值的类型, 这样才能获取正常的结果</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 因为默认是按照整型解析的，所以对于返回整型的函数我们无需指定返回值类型，当然指定的话也是好的</span></span><br><span class="line"><span class="built_in">print</span>(libgo.Int(c_long(<span class="number">123</span>)))  <span class="comment"># 124</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Float 函数，接收一个浮点数，然后加上 2.2 返回</span></span><br><span class="line">libgo.Double.restype = c_double</span><br><span class="line"><span class="built_in">print</span>(libgo.Double(c_double(<span class="number">2.5</span>)))  <span class="comment"># 4.7</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># boolean: 接收一个布尔值, 返回相反的布尔值</span></span><br><span class="line">libgo.boolean.restype = c_bool</span><br><span class="line"><span class="built_in">print</span>(libgo.boolean(c_bool(<span class="literal">True</span>)))  <span class="comment"># False</span></span><br><span class="line"><span class="built_in">print</span>(libgo.boolean(c_bool(<span class="literal">False</span>)))  <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Char: 接收一个字符，然后进行大小写转换</span></span><br><span class="line">libgo.Char.restype = c_char</span><br><span class="line"><span class="built_in">print</span>(libgo.Char(c_char(<span class="number">97</span>)))  <span class="comment"># b&#x27;A&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(libgo.Char(c_char(<span class="string">b&#x27;v&#x27;</span>)))  <span class="comment"># b&#x27;V&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>怎么样，是不是很简单呢？</strong></p>
<p><strong>我们在生成 libgo.so 的同时，还会自动帮我们生成一个 libgo.h，在里面会为 Go 语言的字符串、切片、字典、接口和管道等特有的数据类型生成对应的 C 语言类型：</strong></p>
<p><img src="/2023/04/26/32-Python-%E5%92%8C-Go-%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/1229382-20210518172901991-935228913.png" alt="img"></p>
<p><strong>不过需要注意的是，其中只有字符串和切片在 CGO  中有一定的使用价值，因为二者可以直接被 C 和 Python 调用。但是 CGO 并未针对其它的类型提供相关的辅助函数，且 Go  语言特有的内存模型导致我们无法保持这些由 Go 语言管理的内存指针，所以它们在编写动态库给 Python 调用这一场景中并无使用价值，比如  channel，这东西在 Python 里面根本没法用，还有 Map 也是同样道理。</strong></p>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p><strong>字符串可以说是用的最为频繁了，而且使用字符串还需要考虑内存泄漏的问题，至于为什么会有内存泄漏以及如何解决它后面会说，目前先来看看如何操作字符串。</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件名：file.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//export unicode</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unicode</span><span class="params">(val *C.char)</span></span> *C.char &#123;</span><br><span class="line">    <span class="comment">// 将 C 的字符串转成 Go 的字符串, 可以使用 C.GoString</span></span><br><span class="line">    <span class="keyword">var</span> s = C.GoString(val)</span><br><span class="line">    s += <span class="string">&quot;古明地觉&quot;</span></span><br><span class="line">    <span class="comment">//然后转成 C 的字符串返回, 字符串无论是从 Go 转 C, 还是 C 转 Go, 都是拷贝一份</span></span><br><span class="line">    <span class="keyword">return</span> C.CString(s)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>还是调用 go build -buildmode&#x3D;c-shared -o libgo.so file.go 将其编译成动态库，然后 Python 进行调用。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">go_ext = CDLL(<span class="string">r&quot;./libgo.so&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># unicode: 接收一个 c_char_p，返回一个 c_char_p，注意 c_char_p 里面的字符串要转成字节</span></span><br><span class="line">go_ext.unicode.restype = c_char_p</span><br><span class="line"><span class="comment"># 调用函数返回的也是一个字节，我们需要再使用 utf-8 转回来</span></span><br><span class="line"><span class="built_in">print</span>(go_ext.unicode(c_char_p(<span class="string">&quot;我永远喜欢🍺&quot;</span>.encode(<span class="string">&quot;utf-8&quot;</span>))).decode(<span class="string">&quot;utf-8&quot;</span>))  <span class="comment"># 我永远喜欢🍺古明地觉</span></span><br></pre></td></tr></table></figure>

<p><strong>同理我们也可以修改传递的字符串，当然与其说修改，倒不如说仍是重新创建一份。</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件名：file.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//export char_array</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">char_array</span><span class="params">(arr *C.char)</span></span> *C.char &#123;</span><br><span class="line">    <span class="comment">// 转成 Go 的 string 之后，我们还需要转成 rune，不然无法修改，因为有的字符需要三字节</span></span><br><span class="line">    r := []<span class="type">rune</span>(C.GoString(arr))</span><br><span class="line">    r[<span class="number">3</span>] = <span class="string">&#x27;恋&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> C.CString(<span class="type">string</span>(r))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>编译之后给 Python 调用：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">go_ext = CDLL(<span class="string">&quot;./libgo.so&quot;</span>)</span><br><span class="line"></span><br><span class="line">go_ext.char_array.restype = c_char_p</span><br><span class="line"><span class="built_in">print</span>(</span><br><span class="line">    go_ext.char_array(c_char_p(<span class="string">&quot;古明地觉&quot;</span>.encode(<span class="string">&quot;utf-8&quot;</span>))).decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">)  <span class="comment"># 古明地恋</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里必须要保证至少传递长度为 4 的字符串, 因为在 go 中我们有一个 r[3] = &#x27;恋&#x27; 的操作</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>字符串操作基本上使用 C.GoString 和 C.CString 就足够了，但是正如我们之前说的，C.CString 存在着内存泄漏问题，后面会解决它。</strong></p>
</blockquote>
<h4 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h4><p><strong>结构体应该算是 Go 中最重要的成员了吧，但是 Go 的结构体是不能作为导出函数的参数或返回值的，我们需要使用C中的结构体。</strong></p>
<blockquote>
<p><strong>如果尝试导出一个参数或返回值为 Go 的结构体的函数，那么会报错：<code>Go type not supported in export: struct</code></strong></p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件名：file.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct Girl&#123;</span></span><br><span class="line"><span class="comment">    char *name;</span></span><br><span class="line"><span class="comment">    long age;</span></span><br><span class="line"><span class="comment">    char *gender;</span></span><br><span class="line"><span class="comment">    char *type;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="comment">// 对于结构体来说, 不要使用 typedef 的方式, 而是直接使用 struct xxx&#123;&#125; 的方式定义, 那么 Go 便可以通过 C.struct_xxx 的方式来访问这个结构体</span></span><br><span class="line"><span class="comment">// 至于为什么要这么写, 我也不知道, 大概这是 Go 的设计原则吧</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//export test_struct</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test_struct</span><span class="params">(g C.struct_Girl)</span></span> *C.char &#123;</span><br><span class="line">    <span class="comment">// 这里的结构体就可以通过C.struct_Girl来访问</span></span><br><span class="line">    name := C.GoString(g.name)</span><br><span class="line">    age := <span class="type">int</span>(g.age)</span><br><span class="line">    gender := C.GoString(g.gender)</span><br><span class="line">    <span class="comment">// type 是 Go 语言中的关键字, 那么访问的时候需要在前面加上一个下划线</span></span><br><span class="line">    _type := C.GoString(g._type)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> C.CString(fmt.Sprintf(<span class="string">&quot;名字: %s 年龄: %d 性别: %s 类型: %s&quot;</span>, name, age, gender, _type))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>对于 Python 而言，我们看看如何在 Python 中创建一个结构体：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">libgo = CDLL(<span class="string">&quot;./libgo.so&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span>(<span class="title class_ inherited__">Structure</span>):</span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">&quot;name&quot;</span>, c_char_p),</span><br><span class="line">        (<span class="string">&quot;age&quot;</span>, c_long),</span><br><span class="line">        (<span class="string">&quot;gender&quot;</span>, c_char_p),</span><br><span class="line">        (<span class="string">&quot;type&quot;</span>, c_char_p)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">libgo.test_struct.restype = c_char_p</span><br><span class="line">g = Girl(c_char_p(<span class="string">&quot;古明地觉&quot;</span>.encode(<span class="string">&quot;utf-8&quot;</span>)),</span><br><span class="line">         c_long(<span class="number">16</span>),</span><br><span class="line">         c_char_p(<span class="string">&quot;女&quot;</span>.encode(<span class="string">&quot;utf-8&quot;</span>)),</span><br><span class="line">         c_char_p(<span class="string">&quot;高冷&quot;</span>.encode(<span class="string">&quot;utf-8&quot;</span>)))</span><br><span class="line"><span class="built_in">print</span>(libgo.test_struct(g).decode(<span class="string">&quot;utf-8&quot;</span>))  <span class="comment"># 名字: 古明地觉 年龄: 16 性别: 女 类型: 高冷</span></span><br></pre></td></tr></table></figure>

<p><strong>还是比较简单的，只不过定义变量的时候最好不要和关键字冲突。但是 Go  给我们提供了一个隐形的转化方式，即便我们在 C 中定义的变量和 Go  关键字冲突了，也可以通过在变量前面加上一个下划线的方式访问。那么问题来了，如果有两个成员：一个成员以 Go  语言关键字命名，另一个成员以下划线加上相同的关键字命名，那么以关键字命名的成员将无法访问（被屏蔽）。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct A &#123;</span></span><br><span class="line"><span class="comment">    int   type;   // type 是 Go 语言的关键字</span></span><br><span class="line"><span class="comment">    float _type;  // 将屏蔽 CGO 对 type 成员的访问</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看到参数只能是 C 的结构体，那么 Go 的结构体就无法使用了吗？答案不是的，只要 Go 的结构体不作为导出函数的参数或者返回值就可以。</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件名：file.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义两个结构体</span></span><br><span class="line"><span class="keyword">type</span> Girl1 <span class="keyword">struct</span> &#123;</span><br><span class="line">    name   <span class="type">string</span></span><br><span class="line">    age    <span class="type">int</span></span><br><span class="line">    gender <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Girl2 <span class="keyword">struct</span> &#123;</span><br><span class="line">    name   *C.char</span><br><span class="line">    age    C.long</span><br><span class="line">    gender *C.char</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//export test_struct1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test_struct1</span><span class="params">(name *C.char, age C.long, gender *C.char)</span></span> *C.char &#123;</span><br><span class="line">    <span class="comment">// 当然，这里有点多此一举了</span></span><br><span class="line">    g := Girl1&#123;C.GoString(name), <span class="type">int</span>(age), C.GoString(gender)&#125;</span><br><span class="line">    <span class="keyword">return</span> C.CString(fmt.Sprintf(<span class="string">&quot;你的名字: %s 你的年龄: %d 你的性别: %s&quot;</span>, g.name, g.age, g.gender))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//export test_struct2</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test_struct2</span><span class="params">(name *C.char, age C.long, gender *C.char)</span></span> *C.char &#123;</span><br><span class="line">    g := Girl2&#123;name, age, gender&#125;</span><br><span class="line">    <span class="keyword">return</span> C.CString(fmt.Sprintf(<span class="string">&quot;你的名字: %s 你的年龄: %d 你的性别: %s&quot;</span>, C.GoString(g.name), C.long(g.age), C.GoString(g.gender)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>然后交给 Python 来访问：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">libgo = CDLL(<span class="string">&quot;./libgo.so&quot;</span>)</span><br><span class="line"></span><br><span class="line">libgo.test_struct1.restype = c_char_p</span><br><span class="line">libgo.test_struct2.restype = c_char_p</span><br><span class="line"><span class="built_in">print</span>(</span><br><span class="line">    libgo.test_struct1(c_char_p(<span class="string">&quot;古明地觉&quot;</span>.encode(<span class="string">&quot;utf-8&quot;</span>)),</span><br><span class="line">                        c_long(<span class="number">16</span>),</span><br><span class="line">                        c_char_p(<span class="string">&quot;女&quot;</span>.encode(<span class="string">&quot;utf-8&quot;</span>))).decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">)  <span class="comment"># 你的名字:古明地觉 年龄: 16 性别: 女</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(</span><br><span class="line">    libgo.test_struct2(c_char_p(<span class="string">&quot;古明地觉&quot;</span>.encode(<span class="string">&quot;utf-8&quot;</span>)),</span><br><span class="line">                        c_long(<span class="number">16</span>),</span><br><span class="line">                        c_char_p(<span class="string">&quot;女&quot;</span>.encode(<span class="string">&quot;utf-8&quot;</span>))).decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">)  <span class="comment"># 你的名字:古明地觉 年龄: 16 性别: 女</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看到 Python 依旧可以正常调用，两个结构体成员的类型可以是 Go 的类型、也可以是 C 的类型，区别就是需要类型转化的地方不同罢了。Go  中的结构体，它没有作为参数和返回的话是可以正常使用的，但是一旦作为参数或者返回值就不可以了，因为 Go 不允许我们这么做，所以我们只能使用 C  中的结构体。</strong></p>
<h5 id="返回一个结构体"><a href="#返回一个结构体" class="headerlink" title="返回一个结构体"></a>返回一个结构体</h5><p><strong>下面来看看如何返回一个结构体：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件名：file.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct Girl&#123;</span></span><br><span class="line"><span class="comment">    char *name;</span></span><br><span class="line"><span class="comment">    long age;</span></span><br><span class="line"><span class="comment">    char *gender;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//export test_struct</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test_struct</span><span class="params">(name *C.char, age C.long, gender *C.char)</span></span> C.struct_Girl &#123;</span><br><span class="line">    g := C.struct_Girl&#123;name, age, gender&#125;</span><br><span class="line">    <span class="keyword">return</span> g</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Python 调用的话依旧很简单：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">libgo = CDLL(<span class="string">&quot;./libgo.so&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span>(<span class="title class_ inherited__">Structure</span>):</span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">&quot;name&quot;</span>, c_char_p),</span><br><span class="line">        (<span class="string">&quot;age&quot;</span>, c_long),</span><br><span class="line">        (<span class="string">&quot;gender&quot;</span>, c_char_p)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定返回值类型</span></span><br><span class="line">libgo.test_struct.restype = Girl</span><br><span class="line">g = libgo.test_struct(c_char_p(<span class="string">&quot;古明地觉&quot;</span>.encode(<span class="string">&quot;utf-8&quot;</span>)), c_long(<span class="number">16</span>), c_char_p(<span class="string">&quot;女&quot;</span>.encode(<span class="string">&quot;utf-8&quot;</span>)))</span><br><span class="line"><span class="built_in">print</span>(g.name.decode(<span class="string">&quot;utf-8&quot;</span>))  <span class="comment"># 古明地觉</span></span><br><span class="line"><span class="built_in">print</span>(g.age)  <span class="comment"># 16</span></span><br><span class="line"><span class="built_in">print</span>(g.gender.decode(<span class="string">&quot;utf-8&quot;</span>))  <span class="comment"># 女</span></span><br></pre></td></tr></table></figure>

<h5 id="传入结构体指针"><a href="#传入结构体指针" class="headerlink" title="传入结构体指针"></a>传入结构体指针</h5><p><strong>结构体指针我们也是可以传递的，举个栗子：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件名：file.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct Girl&#123;</span></span><br><span class="line"><span class="comment">    char *name;</span></span><br><span class="line"><span class="comment">    long age;</span></span><br><span class="line"><span class="comment">    char *gender;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//export test_struct</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test_struct</span><span class="params">(g *C.struct_Girl)</span></span>&#123;</span><br><span class="line">    g.name = C.CString(<span class="string">&quot;古明地恋&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在 Python 中创建一个结构体传进去，然后值会被修改：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">libgo = CDLL(<span class="string">&quot;./libgo.so&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span>(<span class="title class_ inherited__">Structure</span>):</span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">&quot;name&quot;</span>, c_char_p),</span><br><span class="line">        (<span class="string">&quot;age&quot;</span>, c_long),</span><br><span class="line">        (<span class="string">&quot;gender&quot;</span>, c_char_p)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">g = Girl(c_char_p(<span class="string">&quot;古明地觉&quot;</span>.encode(<span class="string">&quot;utf-8&quot;</span>)),</span><br><span class="line">         c_long(<span class="number">16</span>),</span><br><span class="line">         c_char_p(<span class="string">&quot;女&quot;</span>.encode(<span class="string">&quot;utf-8&quot;</span>)))</span><br><span class="line"></span><br><span class="line">libgo.test_struct(pointer(g))</span><br><span class="line"><span class="built_in">print</span>(g.name.decode(<span class="string">&quot;utf-8&quot;</span>))  <span class="comment"># 古明地恋</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：传递一个指针可以，但是返回一个指针不行。因为 Go  语言是类型安全的，比如一个变量究竟该分配在堆上、还是分配在栈上，Go  编译器会进行逃逸分析，是否返回指针便是决定一个变量究竟分配在什么地方的一个主要因素。而一旦返回指针给其他语言，那么 Go  就无法决定这块内存究竟何时该被回收，所以 Go 中不允许返回指针。而且对于 Python 来讲，Go 返回一个值还是指针，对于 Python  而言几乎没什么区别，无非是获取的方式不一样。所以我们不会在 Go 中返回一个指针，但是传递一个指针是可以的。</strong></p>
<h4 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h4><p><strong>函数是 C 语言编程的核心，通过 CGO 技术我们不仅仅可以在 Go 语言中调用 C 语言函数，也可以将 Go 语言函数导出为 C 语言函数。对于一个启用 CGO 特性的程序，CGO 会构造一个虚拟的 C 包，通过这个虚拟的 C 包可以调用 C 语言函数。</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件名：file.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int add(int a, int b) &#123;</span></span><br><span class="line"><span class="comment">    return a + b;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(C.add(<span class="number">1</span>, <span class="number">2</span>))  <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这一点我们之前就见过了，但是 Go 文件里面的 C 函数不仅可以让 Go  自身调用，还可以交给 Python 调用。Go 文件里面的 C 函数和使用 export 导出的 Go 函数（导出之后就变成了 C  函数）是等价的，都是可以被 Python 调用的，我们还是对该文件进行编译得到动态库。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">libgo = CDLL(<span class="string">r&quot;./libgo.so&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(libgo.add(<span class="number">1</span>, <span class="number">2</span>))  <span class="comment"># 3</span></span><br></pre></td></tr></table></figure>

<h5 id="Python-向-C-传递函数"><a href="#Python-向-C-传递函数" class="headerlink" title="Python 向 C 传递函数"></a>Python 向 C 传递函数</h5><p><strong>Python 不能直接向 Go 的导出函数中传递函数，我们需要在里面定义一个 C 的函数，Python 只能向 C 的函数中传递函数。</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件名：file.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int add(int a, int b, int (*f)(int *, int *))&#123;</span></span><br><span class="line"><span class="comment">  return f(&amp;a, &amp;b);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>里面的 add 接收两个整型和一个函数指针，这个函数指针指向的函数接收两个 int *，我们依旧实现两个数相加。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">libgo = CDLL(<span class="string">&quot;./libgo.so&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 动态链接库中的函数接收的函数的参数是两个 int *，所以我们这里的 a 和 b 也是一个 pointer</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="comment"># 调用 pointer.contents 可以得到 C 的变量, 在调用 value 属性可以获取对应值(Python中的)</span></span><br><span class="line">    <span class="keyword">return</span> a.contents.value + b.contents.value</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时我们把 C 中的函数用 Python 表达了, 但是这样肯定是不可能直接传递的, 能传就见鬼了</span></span><br><span class="line"><span class="comment"># 那我们要如何转化呢?</span></span><br><span class="line"><span class="comment"># 可以通过 ctypes 里面的函数 CFUNCTYPE 转化一下, 这个函数接收任意个参数</span></span><br><span class="line"><span class="comment"># 但是第一个参数是函数的返回值类型, 然后函数的参数写在后面, 有多少写多少。</span></span><br><span class="line"><span class="comment"># 比如这里的函数返回一个 int, 接收两个 int *, 所以就是</span></span><br><span class="line">t = CFUNCTYPE(c_int, POINTER(c_int), POINTER(c_int))</span><br><span class="line"><span class="comment"># 如果函数不需要返回值, 那么写一个 None 即可</span></span><br><span class="line"><span class="comment"># 然后得到一个类型 t, 此时的类型 t 就等同于 C 中的 typedef int (*t)(int*, int*);</span></span><br><span class="line"><span class="comment"># 将我们的函数传进去，就得到了 C 语言可以识别的函数 func</span></span><br><span class="line">func = t(add)</span><br><span class="line"><span class="comment"># 然后调用, 别忘了定义返回值类型, 当然这里是 int（long同理）就无所谓了</span></span><br><span class="line">libgo.add.restype = c_int</span><br><span class="line"><span class="built_in">print</span>(libgo.add(<span class="number">88</span>, <span class="number">97</span>, func))</span><br><span class="line"><span class="built_in">print</span>(libgo.add(<span class="number">59</span>, <span class="number">55</span>, func))</span><br><span class="line"><span class="built_in">print</span>(libgo.add(<span class="number">94</span>, <span class="number">105</span>, func))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">184</span></span><br><span class="line"><span class="string">114</span></span><br><span class="line"><span class="string">199</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>当然如果函数比较复杂的话，或者内容比较多的话，我们还可以分成多个源文件来写。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*function)</span> <span class="params">(<span class="type">int</span> *, <span class="type">int</span> *)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>, function)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;1.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, function f)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> f(&amp;a, &amp;b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>此时 Go 源文件的代码就变得简单了；</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件名：file.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#include &quot;1.h&quot;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>然后编译成动态库就不要加上文件名了，直接 <code>go build -buildmode=c-shared -o libgo.so</code> 对整个目录进行编译。那么 Python 可不可以调用呢？我们试一下：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">libgo = CDLL(<span class="string">&quot;./libgo.so&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a.contents.value + b.contents.value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t = CFUNCTYPE(c_int, POINTER(c_int), POINTER(c_int))</span><br><span class="line">func = t(add)</span><br><span class="line">libgo.add.restype = c_int</span><br><span class="line"><span class="built_in">print</span>(libgo.add(<span class="number">11</span>, <span class="number">22</span>, func))  <span class="comment"># 33</span></span><br><span class="line"><span class="built_in">print</span>(libgo.add(<span class="number">22</span>, <span class="number">33</span>, func))  <span class="comment"># 55</span></span><br><span class="line"><span class="built_in">print</span>(libgo.add(<span class="number">33</span>, <span class="number">44</span>, func))  <span class="comment"># 77</span></span><br></pre></td></tr></table></figure>

<p><strong>不仅如此，我们还可以直接使用 Go 中的导出函数作为 C 函数中的一个参数，我们的 .h 和 .c 文件都不变，只修改一下 Go 源文件：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件名：file.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#include &quot;1.h&quot;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//export f</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(a *C.<span class="type">int</span>, b *C.<span class="type">int</span>)</span></span> C.<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> *a + *b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们在 Go 文件中定义相应的函数，不在 Python 中定义了，然后 Python 直接调用：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">libgo = CDLL(<span class="string">&quot;./libgo.so&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(libgo.add(c_int(<span class="number">101</span>), c_int(<span class="number">202</span>), libgo.f))  <span class="comment"># 303</span></span><br></pre></td></tr></table></figure>

<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p><strong>再来看看如何操作数组，这里操作的数组只能是 C 中的数组，因为在 Go 里面不允许导出一个参数或返回值是数组的函数。最关键的是，Go 数组的表达能力没有 C 数组那么丰富。</strong></p>
<blockquote>
<p><strong>在 Go 里面数组的长度也是类型的一部分，这一点完全限制了数组的表达能力。而 C 中的数组类型与长度无关，比如在 C 的结构体中声明一个长度为 1 的数组，但是我们可以把它当成长度为 n 的数组来用。</strong></p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件名：file.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">int sum(int *arr, int size) &#123;</span></span><br><span class="line"><span class="comment">    // 传递一个数组，里面全部是 int 类型，我们把它们加在一起</span></span><br><span class="line"><span class="comment">    // 由于数组在作为参数传递的时候会退化为指针，所以我们不知道数组有多少个元素，因此还必须要指定个数</span></span><br><span class="line"><span class="comment">    int i = 0, values = 0;</span></span><br><span class="line"><span class="comment">    for (; i &lt; size; i++) &#123;</span></span><br><span class="line"><span class="comment">        values += *(arr + i);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    return values;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>然后我们来在 Python 中构建一个数组：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">libgo = CDLL(<span class="string">&quot;./libgo.so&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># (c_int * n) 便是一个长度为 n 的 int 数组类型</span></span><br><span class="line"><span class="comment"># 然后通过类似于函数调用的方式，得到数组</span></span><br><span class="line">v = (c_int * <span class="number">4</span>)(<span class="number">13212</span>, <span class="number">211</span>, <span class="number">22</span>, <span class="number">33</span>)</span><br><span class="line"><span class="built_in">print</span>(libgo.<span class="built_in">sum</span>(v, <span class="number">4</span>))  <span class="comment"># 13478</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">13212</span> + <span class="number">211</span> + <span class="number">22</span> + <span class="number">33</span>)  <span class="comment"># 13478</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>需要注意的是，数组的类型一定要正确，我们之前说对于整数而言，long 和  int 实际上没有太大差别。如果一个函数接收的是 long，那么我们传递一个 int  也是可以的，反之亦然（只要都存的下，不会溢出即可）。但是对于数组而言就不行了，函数中接收的数组里面的元素是 int，我们也必须要传递  int，否则指针在移动的时候会出问题。</strong></p>
</blockquote>
<p><strong>我们往 C 里面传递一个数组是没有问题的，因为内存是在 Python  中申请的，C 拿到的只是一个指针罢了。但是我们不能在 C 中构建一个数组然后返回，因为如果 C  中返回了一个数组，那么它要么是静态数组、要么是堆上申请的数组。但是问题来了，这些数组的内存最终由谁来释放？Python  显然是无能为力的，更何况这些 C 代码还嵌套在 Go 里面。</strong></p>
<p><strong>尽管 C 无法返回一个数组，但是可以对我们传递的数组进行修改。或者说先创建一个普通数组，然后把内容再拷贝到我们传递的数组中，函数结束后 C 中的数组再被释放掉。</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件名：file.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int modify_arr(int *arr, int size) &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int i = 0, values = 0;</span></span><br><span class="line"><span class="comment">    for (; i &lt; size; i++) &#123;</span></span><br><span class="line"><span class="comment">        *(arr + i) += 100;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    return 0;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们将传递过来的数组里面的元素都加上 100：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">libgo = CDLL(<span class="string">&quot;./libgo.so&quot;</span>)</span><br><span class="line"></span><br><span class="line">v = (c_int * <span class="number">6</span>)(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line"><span class="comment"># 此时 v 内部的元素就被修改了，而且该数组是 Python 创建的，与 C 无关，因此不需要担心内存泄露的问题</span></span><br><span class="line">libgo.modify_arr(v, <span class="number">6</span>)</span><br><span class="line"><span class="comment"># 我们将其转成 ndarray</span></span><br><span class="line"><span class="comment"># 参数一：shape</span></span><br><span class="line"><span class="comment"># dtype：元素类型</span></span><br><span class="line"><span class="comment"># buffer：缓冲区，这里的 v</span></span><br><span class="line"><span class="comment"># order：数组是 C 连续还是 Fortran 连续，这里显然是 C 连续，因为是 C 的数组</span></span><br><span class="line"><span class="built_in">print</span>(np.ndarray((<span class="number">6</span>,), dtype=c_int, buffer=v, order=<span class="string">&quot;C&quot;</span>))  <span class="comment"># [101 102 103 104 105 106]</span></span><br><span class="line"><span class="comment"># 当然我们在获取的时候也可以改变形状</span></span><br><span class="line"><span class="built_in">print</span>(np.ndarray((<span class="number">3</span>, <span class="number">2</span>), dtype=c_int, buffer=v, order=<span class="string">&quot;C&quot;</span>))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">[[101 102]</span></span><br><span class="line"><span class="string"> [103 104]</span></span><br><span class="line"><span class="string"> [105 106]]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 我们这里的缓冲区当中有 6 个元素，但是 shape 是 3 行 1 列，所以只拿前三个元素构建 shape 为 (3, 1) 的数组</span></span><br><span class="line"><span class="built_in">print</span>(np.ndarray((<span class="number">3</span>, <span class="number">1</span>), dtype=c_int, buffer=v, order=<span class="string">&quot;C&quot;</span>))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">[[101]</span></span><br><span class="line"><span class="string"> [102]</span></span><br><span class="line"><span class="string"> [103]]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 但是注意：我们指定的元素个数不能超过缓冲区的大小</span></span><br><span class="line"><span class="comment"># 下面表示构建 3 X 3 的数组，也就是有 9 个元素，但是这里的缓冲区中只有 6 个元素</span></span><br><span class="line"><span class="built_in">print</span>(np.ndarray((<span class="number">3</span>, <span class="number">3</span>), dtype=c_int, buffer=v, order=<span class="string">&quot;C&quot;</span>)) </span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    print(np.ndarray((3, 3), dtype=c_int, buffer=v, order=&quot;C&quot;))</span></span><br><span class="line"><span class="string">TypeError: buffer is too small for requested array</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>以上就是 Python 向 C 传递数组，例子比较简单。</strong></p>
<p><strong>但是问题来了，此时貌似压根就没有 Go 什么事情，因为里面根本就没有涉及到 Go。原因就是 Go 无法导出一个参数或者返回值为 Go 数组的函数（由于数组的长度也是类型的一部分，导致灵活性也大大降低），并且我们也不能像 C 一样声明一个 arr *C.int、然后把 arr 当成数组使用，这是不允许的，在 Go 里面该 arr  只能是一个指向整型的指针。于是可能有人想到了切片，在 Go 里面切片可以作为导出函数的参数或返回值，但是 Go  里面的切片比较特殊、它本质上是一个结构体：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/slice.go</span></span><br><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">    array unsafe.Pointer <span class="comment">// 指向底层数组的指针</span></span><br><span class="line">    <span class="built_in">len</span>   <span class="type">int</span> <span class="comment">// 长度</span></span><br><span class="line">    <span class="built_in">cap</span>   <span class="type">int</span> <span class="comment">// 容量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Python 传递一个数组过来的话，我们在操作的时候可能会出问题。我们先举个栗子看看 Go 自身访问是什么情况：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件名：file.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;reflect&quot;</span></span><br><span class="line">    <span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test1</span><span class="params">(s []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    header := (*reflect.SliceHeader)(unsafe.Pointer(&amp;s))</span><br><span class="line">    data := header.Data</span><br><span class="line">    <span class="comment">// 相当于访问第 3 个元素</span></span><br><span class="line">    fmt.Println(*(*<span class="type">int</span>)(unsafe.Pointer(data + <span class="number">2</span>*unsafe.Sizeof(<span class="number">0</span>))))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test2</span><span class="params">(s []C.<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    header := (*reflect.SliceHeader)(unsafe.Pointer(&amp;s))</span><br><span class="line">    data := header.Data</span><br><span class="line">    <span class="comment">// 相当于访问第 3 个元素</span></span><br><span class="line">    fmt.Println(*(*<span class="type">int</span>)(unsafe.Pointer(data + <span class="number">2</span>*unsafe.Sizeof(C.<span class="type">int</span>(<span class="number">0</span>)))))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s1 := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">    s2 := []C.<span class="type">int</span>&#123;C.<span class="type">int</span>(<span class="number">1</span>), C.<span class="type">int</span>(<span class="number">2</span>), C.<span class="type">int</span>(<span class="number">3</span>), C.<span class="type">int</span>(<span class="number">4</span>)&#125;</span><br><span class="line"></span><br><span class="line">    test1(s1)  <span class="comment">// 3</span></span><br><span class="line">    test2(s2)  <span class="comment">// 17179869187</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们看到对于 Go 的 int 而言，结果是正常的，但是对于 C.int 却得到了一个乱七八糟的脏数据。Go 自身访问会得到错误数据，如果是作为导出函数让 Python 访问，那么首先会报错，并且解释器还会异常退出。</strong></p>
<p><strong>那么我们能不能直接通过下标的方式来访问呢？答案是：在 Go 里面是可以的，因为 Go 的导出函数接收的是一个切片，只要我们也传递切片即可。</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件名：file.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//export sum_slice</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum_slice</span><span class="params">(s []C.<span class="type">int</span>)</span></span> C.<span class="type">int</span> &#123;</span><br><span class="line">    sum := C.<span class="type">int</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++&#123;</span><br><span class="line">        sum += s[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(sum_slice([]C.<span class="type">int</span>&#123;C.<span class="type">int</span>(<span class="number">11</span>), C.<span class="type">int</span>(<span class="number">22</span>), C.<span class="type">int</span>(<span class="number">33</span>), C.<span class="type">int</span>(<span class="number">44</span>)&#125;))  <span class="comment">// 110</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>但如果这个函数给 Python 调用的话，会产生如下后果：</strong></p>
<p><img src="/2023/04/26/32-Python-%E5%92%8C-Go-%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/1229382-20210518172915360-1571851068.png" alt="img"></p>
<p><strong>我们看到会出现段错误，此时解释器会直接异常退出，不是使用异常捕获能解决的了的问题。原因就在于操作了一个无效的内存地址，Go 不会出问题是因为它接收的是切片、传递的也是切片，而 Python 传递的是一个数组，对于 Go 而言切片和数组是不同的。</strong></p>
<p><strong>结论：我们可以传递一个数组，但只能向 C 的函数传递，因为 Go 的导出函数的参数或返回值不能是 Go 数组。也不要试图使用切片，很容易造成段错误。</strong></p>
<h4 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h4><p><strong>我们目前的做法是将 Go 的函数导出给 Python  使用，因此就会受到很多限制，比如不能返回指针等等。原因就是我们之前说的，Go 是一个类型安全的语言，一旦返回指针之后给 Python 使用，那么 Go 编译器就无法把控该指针指向的变量的声明周期了。举个栗子：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件名：file.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//export return_pointer</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">return_pointer</span><span class="params">()</span></span> *C.<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a C.<span class="type">int</span> = <span class="number">123</span></span><br><span class="line">    <span class="keyword">return</span> &amp;a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(return_pointer())  <span class="comment">// 0xc00001c084</span></span><br><span class="line">    fmt.Println(*return_pointer()) <span class="comment">// 123</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们看到 return_pointer 返回了一个指针，但是在 Go  里面使用是没有任何问题的，原因就是 Go 编译器会进行逃逸分析，或者说此时对函数的调用仍然是发生在 Go 里面。只要是在 Go  里面，那么编译器就能牢牢地把控，可一旦交给 Python 使用，就意味着它要独立于 Go 了。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">libgo = CDLL(<span class="string">&quot;./libgo.so&quot;</span>)</span><br><span class="line"><span class="comment"># 指定返回值的类型为整型指针</span></span><br><span class="line">libgo.return_pointer.restype = POINTER(c_int)</span><br><span class="line">libgo.return_pointer()</span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/26/32-Python-%E5%92%8C-Go-%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/1229382-20210518172925972-2134322710.png" alt="img"></p>
<p><strong>Python 在调用导出函数的时候直接就异常了，告诉我们 Go  的导出函数中返回了一个指针，所以 Python 在和 Go 交互的时候是会受到很多限制的。但是 C 和 Go  交互的时候是没有限制的，不仅可以返回指针，而且还可以通过 C 来为 Go 创建一个超过 2GB 的切片。因为 Go  的切片是有大小限制的，不能超过 2 GB，但是我们可以通过 C 的 malloc 申请超过 2 GB 的内存，然后再转成 Go 的切片。</strong></p>
<p><strong>Go 和 C 之间的访问是很自由的，主要是 Go  编译器能够把握全局，然而一旦导出函数给别的语言使用，Go 编译器就鞭长莫及了。所以 Python 在访问 Go  的时候才会有这么多限制，毕竟两门语言的内存模型不同，当同一段内存被跨语言操作时肯定会非常危险，因此对于 Go  这种类型安全的语言压根就不允许访问一个返回指针的导出函数。</strong></p>
<p><strong>但我们之前返回一个 *C.char  为什么可以呢？原因就是我们调用了 C.CString，此时返回的字符串是在 C 中申请的，所以它可以返回。而像  var a C.int  这种，此时 a 的内存是在 Go 里面被申请的，因此我们不能返回 &amp;a。举个栗子，如果我们返回字符串不是调用 C.CString  的话，看看会有什么后果：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件名：file.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//export return_string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">return_string</span><span class="params">()</span></span> *C.char &#123;</span><br><span class="line">    <span class="keyword">var</span> s = []<span class="type">byte</span>(<span class="string">&quot;古明地觉&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> (*C.char)(unsafe.Pointer(&amp;s[<span class="number">0</span>]))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(C.GoString(return_string()))  <span class="comment">// 古明地觉</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>假设我们有一个切片，那么我们可以直接将底层数组的地址返回转成 * C.char 返回，注意：此时 C 字符串和 Go 的底层数组之间是共享内存的，因此省去了开销。</strong></p>
<p><strong>但是这个 return_string 不可以给 Python  调用，因为我们将切片对应的底层数组的地址返回了。换句话说内存依旧是在 Go 里面申请的，而我们返回了指向该内存的指针，所以 Python  调用的话依旧会出现 panic: runtime error: cgo result has Go pointer。</strong></p>
<blockquote>
<p><strong>不要试图返回一个指向 Go 申请的内存的指针给 Python。</strong></p>
</blockquote>
<p><strong>问题来了，我们之前就说 C.CString 存在一个巨大的缺陷， 那就是返回的字符串是 C 在堆区申请的，那么这个字符串最后要由谁来释放？</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件名：file.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//export return_string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">return_string</span><span class="params">(s *C.char)</span></span> *C.char &#123;</span><br><span class="line">    s1 := C.GoString(s)</span><br><span class="line">    s1 += <span class="string">&quot;你好呀&quot;</span></span><br><span class="line">    <span class="keyword">return</span> C.CString(s1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>然后我们给 Python 来调用：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">libgo = CDLL(<span class="string">&quot;./libgo.so&quot;</span>)</span><br><span class="line">libgo.return_string.restype = c_char_p</span><br><span class="line"><span class="built_in">print</span>(</span><br><span class="line">    libgo.return_string(c_char_p(<span class="string">&quot;古明地觉&quot;</span>.encode(<span class="string">&quot;utf-8&quot;</span>))).decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">)  <span class="comment"># 古明地觉你好呀</span></span><br></pre></td></tr></table></figure>

<p><strong>这种做法看似没有问题，虽然结果也是正确的，但是却有一个重大的隐患。因为在返回 C 的字符串之后，Python 会拷贝得到一份 bytes 对象，但问题是这个 C  字符串它是不会主动释放的。假设我们的字符串比较长，而且是在一个不间断的服务中调用 Go 编写的动态库，那么后果是很严重的。我们将 Python  的代码改一下：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">libgo = CDLL(<span class="string">&quot;./libgo.so&quot;</span>)</span><br><span class="line">libgo.return_string.restype = c_char_p</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    libgo.return_string(c_char_p((<span class="string">&quot;古明地觉&quot;</span> * <span class="number">100</span>).encode(<span class="string">&quot;utf-8&quot;</span>))).decode(<span class="string">&quot;utf-8&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>你会发现，内存没一会就被占满了，执行的时候可以通过 top 命令看到内存使用率蹭蹭的网上长。</strong></p>
<p><img src="/2023/04/26/32-Python-%E5%92%8C-Go-%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/1229382-20210518172940005-912620905.png" alt="img"></p>
<p><strong>而导致这一点的原因就是返回的 C 字符串没有被释放，每一次执行都会创建这么一个字符串。因此我们一定要将其释放掉，释放的方式是使用 free，但问题是这个 free 要如何使用？下面这种做法可以吗？</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件名：file.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">//#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;unsafe&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//export return_string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">return_string</span><span class="params">(s *C.char)</span></span> *C.char &#123;</span><br><span class="line">    s1 := C.GoString(s)</span><br><span class="line">    s1 += <span class="string">&quot;你好呀&quot;</span></span><br><span class="line">    <span class="comment">// 先使用变量保存</span></span><br><span class="line">    res := C.CString(s1)</span><br><span class="line">    <span class="comment">// 然后通过 C.free 释放, 但是需要导入 stdlib 这个库（完全就像写 C 语言一样）</span></span><br><span class="line">    <span class="comment">// 但是 C.free 接收一个 void *，我们需要调用一下 unsafe.Pointer</span></span><br><span class="line">    C.free(unsafe.Pointer(res))</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如果你编译成动态库之后让 Python 调用的话，你会发现解释器得不到正确结果，而且有可能会异常退出，原因就是我们在将字符串返回给 Python 之前，就已经将其回收了，那么 Python 拿到的就是一块非法的内存。</strong></p>
<p><strong>因此正确的做法是：先正常返回，Python 在获取到值之后 Go  再将其释放掉，不过这样就又产生了一个问题：那就是地址要如何保存。因为必须要确保 Python 能够获取字符串（意味着 Go 中导出的执行函数的  return 语句结束，显然此时该函数也已经结束），然后再将 C 字符串销毁，所以我们肯定还需要一个函数，这个函数接收一个地址、然后专门用来对 C 字符串进行释放。</strong></p>
<p><strong>那么又回到了开始的问题，地址怎么办？由谁来保存，思考一下不难发现应该由  Go 负责保存。因为 Python 获取结果的时候，实际上也是将 C 的字符串拷贝一份得到 Python 的 bytes 对象，因此在  Python 中你是拿不到相应的地址的，使用 id 查看得到也是 Python 对象的地址。所以解决办法是我们可以在 Go  中使用一个全局变量专门负责保存地址，举个栗子：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件名：file.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">//#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> address unsafe.Pointer = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//export return_string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">return_string</span><span class="params">(s *C.char)</span></span> *C.char &#123;</span><br><span class="line">    s1 := C.GoString(s)</span><br><span class="line">    s1 += <span class="string">&quot;你好呀&quot;</span></span><br><span class="line">    res := C.CString(s1)</span><br><span class="line">    <span class="comment">// 将地址使用全局变量进行保存, 注意这里是 res、不是 &amp;res, 因为 res 本身就是个 C 中的char *, 因此不能再取 &amp;, 否则反而会出问题</span></span><br><span class="line">    address = unsafe.Pointer(res)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//export release_memory</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">release_memory</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 释放 C 字符串所占内存</span></span><br><span class="line">    <span class="keyword">if</span> address != <span class="literal">nil</span> &#123;</span><br><span class="line">        C.free(address)</span><br><span class="line">        address = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>然后我们使用 Python 来进行测试，看看是否有效：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">libgo = CDLL(<span class="string">&quot;./libgo.so&quot;</span>)</span><br><span class="line"><span class="comment"># 指定返回值的类型为整型指针</span></span><br><span class="line">libgo.return_string.restype = c_char_p</span><br><span class="line"><span class="built_in">print</span>(</span><br><span class="line">    libgo.return_string(c_char_p(<span class="string">b&quot;komeiji satori&quot;</span>)).decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">)  <span class="comment"># komeiji satori你好呀</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    libgo.return_string(c_char_p((<span class="string">&quot;古明地觉&quot;</span> * <span class="number">10000</span>).encode(<span class="string">&quot;utf-8&quot;</span>))).decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">    libgo.release_memory()</span><br></pre></td></tr></table></figure>

<p><strong>此时不管持续多长时间，内存都不会有太大变化，证明该方法是有效的。</strong></p>
<p><img src="/2023/04/26/32-Python-%E5%92%8C-Go-%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/1229382-20210518173053033-1833359267.png" alt="img"></p>
<p><strong>如果我们将 libgo.release_memory()  给注释掉的话，那么会发现内存使用率再度蹭蹭往上涨。所以对于那些需要回收的数据，我们就可以通过这种方式来释放，每调用一次就释放一次即可。对于数值类型我们无需担心，我们只需要关注字符串即可，至于结构体，如果里面包含 char *，那么同样需要考虑字符串的释放问题，但是不建议返回这种复杂的数据结构。</strong></p>
<p><strong>因此我们更关心字符串，因为它非常容易造成内存泄漏，那么什么时候应该进行回收呢？答案是：如果是使用 C.CString 返回的字符串，我们是一定要进行回收的；如果看一下上面的 Go 代码的话，你会发现参数是一个 char * 类型的变量  s，那么这个变量 s 不需要回收吗？其实是不需要的，还是那句话我们只需要对 C.CString 返回的字符串进行回收即可。</strong></p>
<p><strong>如果 C.CString  返回的字符串作为了返回值，那么显然不能在执行函数的过程中删除，使用 defer 也不可以，因为要确保 Python  能够拿到返回值，就不能在函数执行过程中回收；而解决办法就是我们上面说的定义一个专门用来释放的函数，但是程序中未必只有一个 C.CString  啊。是的，如果不止一个，那么就把不被 Python 接收的C字符串在函数执行过程中释放掉。比如：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//export return_string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">return_string</span><span class="params">(s *C.char)</span></span> *C.char &#123;</span><br><span class="line">    s1 := C.GoString(s)</span><br><span class="line">    s1 += <span class="string">&quot;你好呀&quot;</span></span><br><span class="line">    res1 := C.CString(s1)</span><br><span class="line">    res2 := C.CString(s1)</span><br><span class="line">    res3 := C.CString(s1)</span><br><span class="line">    C.free(unsafe.Pointer(res1))</span><br><span class="line">    C.free(unsafe.Pointer(res2))</span><br><span class="line">    <span class="comment">// 将地址使用全局变量进行保存</span></span><br><span class="line">    address = unsafe.Pointer(res3)</span><br><span class="line">    <span class="keyword">return</span> res3 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们 return 了 res3，那么 res1 和 res2 在用完之后就直接释放掉即可，而 res3 是需要被 Python 接收的，所以它需要使用另一个函数单独释放。还是那句话：只需要释放 C.CString 返回的字符串，如果把上面代码改一下：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//export return_string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">return_string</span><span class="params">(s *C.char)</span></span> *C.char &#123;</span><br><span class="line">    s1 := C.GoString(s)</span><br><span class="line">    s1 += <span class="string">&quot;你好呀&quot;</span></span><br><span class="line">    res1 := C.CString(s1)</span><br><span class="line">    res2 := res1</span><br><span class="line">    res3 := res2</span><br><span class="line">    C.free(unsafe.Pointer(res1))</span><br><span class="line">    C.free(unsafe.Pointer(res2))</span><br><span class="line">    <span class="comment">// 将地址使用全局变量进行保存</span></span><br><span class="line">    address = unsafe.Pointer(res3)</span><br><span class="line">    <span class="keyword">return</span> res3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>那么你会发现 Python 解释器在调用的时候直接就异常退出了，原因是上面 res1、res2、res3 都是指向同一个字符串，而 C.free  对其释放了两次。所以当调用这个执行函数的时候就直接崩溃了，解决办法就是将那两个 C.free 注释掉即可，因为 res3  被返回了，所以它应该由专门的函数进行一次释放即可。当两个 C.free 被注释掉之后，会发现 Python 又调用正常了。</strong></p>
<blockquote>
<p><strong>总结：</strong></p>
<p><strong>1. 关于字符串，我们需要对其进行释放，否则会一直停留在堆区，如果字符串比较大、或者是长时间运行的服务，很容易造成内存溢出；</strong></p>
<p><strong>2. 一旦字符串作为返回值返回，那么不可以在执行函数内部释放它，而是保存它的地址，然后由专门的函数去释放；</strong></p>
<p><strong>3. 我们只需要对 C.CString 返回的字符串进行释放，所以应该使用变量进行接收，如果一旦使用完毕就直接释放掉；</strong></p>
<p><strong>4. 因为 C  字符串是由一个指针指向，所以如果是变量之间的传递的话，那么不管有多少个变量，字符串在内存中只有一份；因此最直观的做法就是：有多少个  C.CString 就释放多少次，所以使用变量作为左值，然后只对那些出现 C.CString 的赋值语句中的左值进行 free 即可。</strong></p>
</blockquote>
<p>​        <strong>这里多提一句，关于 Go 给 Python 提供动态库，需要遵循一个原则：Go  中导出的执行函数的内部逻辑可以很复杂，但是参数和返回值一定要简单。因为这两者之间是需要通过 C 来作为媒介，参数和返回值必须能用 C  准确表达，所以建议只选择整型、浮点型、字符串这三种。</strong>    </p>
<p>​        <strong>最关键的是内存方面，对于 Go 中的数据结构我们完全不需要关心，因为 Go 的垃圾回收机制会解决它，我们只需要关注 C  中的字符串即可，而原则就是我们上面说的那样。另外在 Go 中不允许返回指针，原因我们也说过了，因为 Go 中的指针是类型安全的，只要在 Go  里面，那么 Go 的编译器便可以牢牢地把控它们。但是一旦将指针返回了，不好意思，即使你能编译成功，当 Python 调用时也会报错，会提示你  panic: runtime error: cgo result has Go pointer。所以只要返回值带有”取址符”，Python  在调用时都是不允许的，当然返回切片也是不允许的，甚至(*C.char)(unsafe.Pointer(&amp;s))也不允许，因为它也是一个指针，C 的字符串只能通过 C.CString 的方式。</strong>    </p>
<p>​        <strong>因此我们只建议返回整型、浮点型或者字符串，像数组、map 我们可以转成 json，然后再让 Python 对其进行解析即可。</strong>    </p>
<p><strong>我们举个栗子：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件名：file.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//export return_json</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">return_json</span><span class="params">()</span></span> *C.char &#123;</span><br><span class="line">    <span class="keyword">var</span> m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            <span class="comment">// 这里就不加锁了，因为多个 goroutine 不会操作同一个 key</span></span><br><span class="line">            m[fmt.Sprintf(<span class="string">&quot;satori_%d&quot;</span>, i)] = []<span class="type">int</span>&#123;i + <span class="number">100</span>, i + <span class="number">101</span>&#125;</span><br><span class="line">            time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">            wg.Done()</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">    data, _ := json.Marshal(m)</span><br><span class="line">    <span class="keyword">return</span> C.CString(<span class="type">string</span>(data))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>将 json 变成 C 字符串，然后返回，这里为了简便就不写释放逻辑了：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> pprint <span class="keyword">import</span> pprint</span><br><span class="line"><span class="keyword">import</span> orjson</span><br><span class="line"></span><br><span class="line">libgo = CDLL(<span class="string">&quot;./libgo.so&quot;</span>)</span><br><span class="line">libgo.return_json.restype = c_char_p</span><br><span class="line">start = time.perf_counter()</span><br><span class="line">res = libgo.return_json() </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;耗时：<span class="subst">&#123;time.perf_counter() - start&#125;</span>&quot;</span>)  <span class="comment"># 耗时：2.0029728785157204</span></span><br><span class="line">pprint(orjson.loads(res)) </span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&#123;&#x27;satori_0&#x27;: [100, 101],</span></span><br><span class="line"><span class="string"> &#x27;satori_1&#x27;: [101, 102],</span></span><br><span class="line"><span class="string"> &#x27;satori_2&#x27;: [102, 103],</span></span><br><span class="line"><span class="string"> &#x27;satori_3&#x27;: [103, 104],</span></span><br><span class="line"><span class="string"> &#x27;satori_4&#x27;: [104, 105]&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">pprint(orjson.loads(res)[<span class="string">&quot;satori_1&quot;</span>])  <span class="comment"># [101, 102]</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看到导出函数中可以编写更加复杂的逻辑，可以做很多的操作，但是参数和返回值一定要简单。因为内部逻辑再复杂，那也是在 Go 的内部，不需要 Python 关心。但参数和返回值就不一样了，它们是需要 Python 和 Go  同时理解的，因此我们要秉承着最保守的原则，使用那些 Python 和 Go 都能准确理解、并且不会产生歧义的数据结构。</strong></p>
<h3 id="Go-源文件编译成静态库、动态库并结合-Cython"><a href="#Go-源文件编译成静态库、动态库并结合-Cython" class="headerlink" title="Go 源文件编译成静态库、动态库并结合 Cython"></a>Go 源文件编译成静态库、动态库并结合 Cython</h3><p><strong>对于使用 ctypes 调用而言，Go  的动态库叫什么名字其实无关紧要，但是在 Linux 中静态库和动态库的命名是有规范的，我们在使用 gcc  进行链接的时候需要遵循这种规范。首先静态库以 .a 为后缀、动态库以 .so 为后缀，并且它们的名字都必须以 lib 开头。比如我们上面指定的  libgo.so，然后在链接的时候把开头的 lib 和结尾的 .so 去掉、也就是只需要指定 “go” 即可，会自动寻找 libgo.so  这个动态库，如果没有 libgo.so，那么会去寻找静态库 libgo.a。</strong></p>
<p><strong>我们还是编写 Go 源文件：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件名：go_fib.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//export go_fib</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">go_fib</span><span class="params">(n C.<span class="type">int</span>)</span></span> C.double &#123;</span><br><span class="line">    <span class="keyword">var</span> i C.<span class="type">int</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> a, b C.double = <span class="number">0.0</span>, <span class="number">1.0</span></span><br><span class="line">    <span class="keyword">for</span> ; i &lt; n; i++ &#123;</span><br><span class="line">        a, b = a + b, a</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;斐波那契计算完毕，我是 Go 语言&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>然后我们来使用 go build 根据 go 源文件生成静态库：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go build -buildmode=c-archive -o 静态库文件 [go源文件1, go源文件2, go源文件3, ...]</span><br><span class="line">[root@satori go_py]# go build -buildmode=c-archive -o libfib.a go_fib.go </span><br><span class="line">[root@satori go_py]# </span><br></pre></td></tr></table></figure>

<p><strong>然后我们还需要一个头文件，这里定义为 go_fib.h：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">go_fib</span><span class="params">(<span class="type">int</span>)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>里面只需要放入一个函数声明即可，具体实现在 libfib.a 中，然后编写 Cython 源文件：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文件名：fib.pyx</span></span><br><span class="line">cdef extern <span class="keyword">from</span> <span class="string">&quot;go_fib.h&quot;</span>:</span><br><span class="line">    double go_fib(<span class="built_in">int</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fib_with_go</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;调用 Go 编写的斐波那契数列，以静态库形式存在&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> go_fib(n)</span><br></pre></td></tr></table></figure>

<p><strong>然后我们来进行编译：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文件名：setup.py</span></span><br><span class="line"><span class="keyword">from</span> distutils.core <span class="keyword">import</span> setup, Extension</span><br><span class="line"><span class="keyword">from</span> Cython.Build <span class="keyword">import</span> cythonize</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里我们不能在 sources 里面写上 [&quot;fib.pyx&quot;, &quot;libfib.a&quot;]，这是不合法的，因为 sources 里面需要放入源文件</span></span><br><span class="line"><span class="comment"># 静态库和动态库需要通过 library_dirs 和 libraries 指定</span></span><br><span class="line">ext = Extension(name=<span class="string">&quot;wrapper_gofib&quot;</span>,</span><br><span class="line">                sources=[<span class="string">&quot;fib.pyx&quot;</span>],</span><br><span class="line">                <span class="comment"># 相当于 gcc 的 -L 参数，路径可以指定多个</span></span><br><span class="line">                library_dirs=[<span class="string">&quot;.&quot;</span>],</span><br><span class="line">                <span class="comment"># 相当于 gcc 的 -l 参数，链接的库可以指定多个</span></span><br><span class="line">                <span class="comment"># 注意：不能写 libfib.a，直接写 fib 就行，所以静态命名需要遵循规范，要以 lib 开头、.a 结尾</span></span><br><span class="line">                <span class="comment"># 动态库同理，lib 开头、.so 结尾</span></span><br><span class="line">                libraries=[<span class="string">&quot;fib&quot;</span>]</span><br><span class="line">                <span class="comment"># 如果还需要头文件的话，那么通过 include_dirs 指定</span></span><br><span class="line">                <span class="comment"># 只不过由于头文件就在当前目录中，所以我们不需要指定</span></span><br><span class="line">                )</span><br><span class="line"></span><br><span class="line">setup(ext_modules=cythonize(ext, language_level=<span class="number">3</span>))</span><br></pre></td></tr></table></figure>

<p><strong>然后我们执行 python3 setup.py build，执行成功之后，会生成一个 build 目录，我们将里面的扩展模块移动到当前目录，然后进入交互式 Python 中导入它，看看会有什么结果。</strong></p>
<p><img src="/2023/04/26/32-Python-%E5%92%8C-Go-%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/1229382-20210518173105899-2064899979.png" alt="img"></p>
<p><strong>除了静态库之外，Cython 还可以包装动态库，我们只需要生成  libfib.so 即可，其它不需要有任何改动。因为 gcc 在链接的时候，如果指定的是 fib、那么优先链接 libfib.so，当  libfib.so 不存在的时候才会去链接  libfib.a。只不过在生成扩展模块之后，对应的动态库不可以丢，它是在运行的时候被动态加载的，不仅不能丢、还要将所在路径配置到  &#x2F;etc&#x2F;ld.so.conf  中，否则找不到；而对于静态库而言，在链接的时候会把静态库的内容都包含进去，所以编译之后是可以独立于相应的静态库的。</strong></p>
<p><strong>因此这就是 Cython 的强大之处，它将 C 的性能引入了 Python 中，Cython 同时理解 C 和 Python，可以直接包装 C、C++ 源文件、静态库、动态库。关于 Cython，它是一门单独的技术，值得去学习。</strong></p>
<blockquote>
<p><strong>关于 Cython，可以看 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/traditional/tag/Cython/">https://www.cnblogs.com/traditional/tag/Cython/</a> 。</strong></p>
</blockquote>
<h4 id="由-Cython-释放内存"><a href="#由-Cython-释放内存" class="headerlink" title="由 Cython 释放内存"></a>由 Cython 释放内存</h4><p><strong>本来这一部分之前是没有的，然而在 B 站上有一个小伙伴问了我一个问题：</strong></p>
<p><img src="/2023/04/26/32-Python-%E5%92%8C-Go-%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/1229382-20211014130209405-1856212629.png" alt="img"></p>
<p><strong>这个问题很简单，我们看一下怎么做。首先编写 Go 源文件：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件名：return_string.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//export get_name</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">get_name</span><span class="params">()</span></span> *C.char &#123;</span><br><span class="line">    <span class="keyword">return</span> C.CString(<span class="string">&quot;古明地觉&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>编译成静态库：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go build -buildmode=c-archive -o libreturn_string.a return_string.go</span><br></pre></td></tr></table></figure>

<p><strong>然后编写头文件：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件名 return_string.h</span></span><br><span class="line"><span class="comment">// 对函数进行声明，函数的返回值、参数要和 Go 的导出函数保持一致</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">get_name</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p><strong>注意：Go 编译器在生成 libreturn_string.a 的同时，也会自动生成一个 libreturn_string.h，我们直接用自动生成的头文件也是可以的。</strong></p>
<p><strong>最后是 Cython 源文件：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文件名：return_string.pyx</span></span><br><span class="line">cdef extern <span class="keyword">from</span> <span class="string">&quot;return_string.h&quot;</span>:</span><br><span class="line">    <span class="comment"># 我们说对于 Cython 而言，想使用哪些函数都必须要在 cdef extern from 块里面声明好</span></span><br><span class="line">    <span class="comment"># 因此我们在得到库之后，还需要定义一个头文件</span></span><br><span class="line">    char *get_name()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_name_py</span>():</span><br><span class="line">    <span class="keyword">return</span> get_name()</span><br></pre></td></tr></table></figure>

<p><strong>以上就完事了，然后编译成 Python 扩展模块：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> distutils.core <span class="keyword">import</span> setup, Extension</span><br><span class="line"><span class="keyword">from</span> Cython.Build <span class="keyword">import</span> cythonize</span><br><span class="line"></span><br><span class="line">ext = Extension(name=<span class="string">&quot;return_string&quot;</span>,</span><br><span class="line">                sources=[<span class="string">&quot;return_string.pyx&quot;</span>],</span><br><span class="line">                library_dirs=[<span class="string">&quot;.&quot;</span>],</span><br><span class="line">                libraries=[<span class="string">&quot;return_string&quot;</span>])</span><br><span class="line"></span><br><span class="line">setup(ext_modules=cythonize(ext, language_level=<span class="number">3</span>))</span><br></pre></td></tr></table></figure>

<p><strong>然后我们来测试一下：</strong></p>
<p><img src="/2023/04/26/32-Python-%E5%92%8C-Go-%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/1229382-20211014130157463-665693272.png" alt="img"></p>
<p><strong>结果上是没有问题的，上面的小伙伴调用之后得到的整型，估计是函数声明的时候返回值类型写错了。当然我这里之所以单独拿出来说一下，并不是为了这个，而是为了引出内存释放这一话题。我们在 Go 里面返回了字符串，这个字符串是 C 在堆区创建的，Python 在调用之后，这个字符串依旧会停在堆区，不会被释放。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> return_string</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    return_string.get_name_py()</span><br></pre></td></tr></table></figure>

<p><strong>调用这个死循环，会发现内存占用瞬间飙升，原因就是每调用一次就会在堆区创建一个字符串，并且字符串还不会被回收。所以问题来了，我们要如何将 C 在堆区申请的字符串给释放掉呢？</strong></p>
<p><strong>在 Python 使用 ctypes 调用动态库的时候，我们说过，在 Go 里面需要有一个全局变量来保存字符串的指针，然后再定义一个函数，在里面调用 C.free 进行释放。但是在 Cython  中我们完全不需要这么做，因为 Cython 同时理解 C 和 Python，我们完全可以在 Cython 里面去释放这个堆区的字符串。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> libc.stdlib cimport free</span><br><span class="line"></span><br><span class="line">cdef extern <span class="keyword">from</span> <span class="string">&quot;return_string.h&quot;</span>:</span><br><span class="line">    char *get_name()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_name_py</span>():</span><br><span class="line">    <span class="comment"># 此时 s 也指向了这个堆区字符串的首元素</span></span><br><span class="line">    cdef char *s = get_name()</span><br><span class="line">    <span class="comment"># 用 Python 变量接收，此时会将堆区字符串拷贝一份得到 bytes 对象</span></span><br><span class="line">    name = s</span><br><span class="line">    <span class="comment"># 然后将堆区字符串释放掉，因为这里的 char *s 指向的字符串和 Go 里面 C.CString 申请的字符串是同一个字符串</span></span><br><span class="line">    <span class="comment"># 因此在 Go 里面调用 C.free 释放，和这里直接使用 free 释放是等价的</span></span><br><span class="line">    free(&lt;void *&gt;s)</span><br><span class="line">    <span class="keyword">return</span> name  <span class="comment"># 返回</span></span><br></pre></td></tr></table></figure>

<p><strong>此时重新编译，然后再调用的话，会发现不管调用多少次，内存占用都不会往上涨，因为堆区字符串会被回收。而之前内存占用上涨的原因是我们直接 return get_name()，那么在将堆区的字符串拷贝一份得到 bytes 对象之后就直接返回了，但堆区的字符串并没有被回收。</strong></p>
<p><strong>显然此时就方便多了，我们不需要再通过回调的方式在 Go 里面释放了，因为在 Go 里面也是要通过 C 来释放的（调用 C.free）。而我们说 Cython 同时理解 C 和 Python，所以在 Cython  里面释放完全等价。并且此时对导出函数的返回值也没有任何要求，返回数组、结构体、指针统统都是没有问题的，Cython 都是支持的。</strong></p>
<p><strong>这也算是一个比较重要的地方吧，值得说明一下。</strong></p>
<h3 id="Go-源文件直接编译成-Python-扩展模块"><a href="#Go-源文件直接编译成-Python-扩展模块" class="headerlink" title="Go 源文件直接编译成 Python 扩展模块"></a>Go 源文件直接编译成 Python 扩展模块</h3><p><strong>直接编写扩展是一件难度比较大的事情，因为这要求你严格遵循 Python&#x2F;C API，所以才有了 Cython。那么如何用 Go 来给 Python 写扩展呢，首先还是那句话，Python 和 Go 之间是通过 C  进行交互的，所以用 Go 写扩展实际上还是相当于用 C 写扩展。但其实 Go 写扩展并没有 C 写扩展方便，因为 CPython 提供的一些宏在 Go 里面没办法通过 C 这个名字空间进行引用，而且还不能调用具有可变参数的 C 函数。比如 CPython 解析函数参数时会使用一个函数：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int PyArg_ParseTuple(PyObject *args, const char *format, ...);</span><br></pre></td></tr></table></figure>

<p><strong>这个函数你在 Go 里面没法直接用，因为它包含可变参数 <code>...</code>，如果我们调用 C.PyArg_ParseTuple，Go 编译器会报错。解决办法是你要在 <code>import &quot;C&quot;</code> 上面的 C 代码中单独定义一个包装器，所以还是比较麻烦的。那么下面我们来简单实现一下 Python 的 binascii 模块里面的两个函数，看看 Go 是如何编写 Python 扩展的。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data = <span class="string">b&quot;satori&quot;</span></span><br><span class="line"><span class="built_in">print</span>(binascii.hexlify(data))  <span class="comment"># b&#x27;7361746f7269&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(binascii.unhexlify(<span class="string">b&quot;7361746f7269&quot;</span>))  <span class="comment"># satori</span></span><br></pre></td></tr></table></figure>

<p><strong>在 binascii 里面有这两个函数，我们下面就来用 Go 实现它们，先来介绍一下这两个函数吧。binascii.hexlify 是将数据用 16 进制表示，binascii.unhexlify 则是前者的逆运算。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data = <span class="string">b&quot;satori&quot;</span></span><br><span class="line"><span class="comment"># 说白了就是将每一个字节都变成 16 进制</span></span><br><span class="line"><span class="built_in">print</span>(binascii.hexlify(data))  <span class="comment"># b&#x27;7361746f7269&#x27;</span></span><br><span class="line"><span class="built_in">print</span>([<span class="built_in">hex</span>(b) <span class="keyword">for</span> b <span class="keyword">in</span> data])  <span class="comment"># [&#x27;0x73&#x27;, &#x27;0x61&#x27;, &#x27;0x74&#x27;, &#x27;0x6f&#x27;, &#x27;0x72&#x27;, &#x27;0x69&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>([<span class="built_in">hex</span>(b)[<span class="number">2</span>:] <span class="keyword">for</span> b <span class="keyword">in</span> data])  <span class="comment"># [&#x27;73&#x27;, &#x27;61&#x27;, &#x27;74&#x27;, &#x27;6f&#x27;, &#x27;72&#x27;, &#x27;69&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&quot;</span>.join([<span class="built_in">hex</span>(b)[<span class="number">2</span>:] <span class="keyword">for</span> b <span class="keyword">in</span> data]))  <span class="comment"># 7361746f7269</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># unhexlify 则是逆运算</span></span><br><span class="line">data = <span class="string">&quot;古明地觉&quot;</span>.encode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">hex_data = <span class="string">&quot;&quot;</span>.join([<span class="built_in">hex</span>(b)[<span class="number">2</span>:] <span class="keyword">for</span> b <span class="keyword">in</span> data])  <span class="comment"># 将数据手动转成 16 进制</span></span><br><span class="line"><span class="comment"># unhexlify 可以接收字节串、也可以接收字符串，但是 hexlify 只接收字节串</span></span><br><span class="line"><span class="built_in">print</span>(binascii.unhexlify(hex_data).decode(<span class="string">&quot;utf-8&quot;</span>))  <span class="comment"># 古明地觉</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当然我们仍然可以手动 unhexlify</span></span><br><span class="line">unhex_data = <span class="built_in">bytes</span>([<span class="built_in">int</span>(hex_data[i: i + <span class="number">2</span>], <span class="number">16</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(hex_data), <span class="number">2</span>)])</span><br><span class="line"><span class="built_in">print</span>(unhex_data.decode(<span class="string">&quot;utf-8&quot;</span>))  <span class="comment"># 古明地觉</span></span><br></pre></td></tr></table></figure>

<p><strong>了解完函数原理之后，我们接下来就用 Go 来写扩展实现它们。</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#cgo linux pkg-config: python3</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#include &quot;Python.h&quot;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">extern PyObject *PyInit_binascii();</span></span><br><span class="line"><span class="comment">extern PyObject *hexlify(PyObject *, PyObject *);</span></span><br><span class="line"><span class="comment">extern PyObject *unhexlify(PyObject *, PyObject *);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">static PyObject *__PyInit_binascii(void)&#123;</span></span><br><span class="line"><span class="comment">    static PyMethodDef methods[] = &#123;</span></span><br><span class="line"><span class="comment">        &#123;&quot;hexlify&quot;, (PyCFunction) hexlify, METH_O, &quot;&quot;&#125;,</span></span><br><span class="line"><span class="comment">        &#123;&quot;unhexlify&quot;, (PyCFunction) unhexlify, METH_O, &quot;&quot;&#125;,</span></span><br><span class="line"><span class="comment">        &#123;NULL, NULL, 0, NULL&#125;</span></span><br><span class="line"><span class="comment">    &#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    static PyModuleDef module = &#123;</span></span><br><span class="line"><span class="comment">        PyModuleDef_HEAD_INIT,</span></span><br><span class="line"><span class="comment">        &quot;binascii&quot;,</span></span><br><span class="line"><span class="comment">        &quot;this is a module named binascii&quot;,</span></span><br><span class="line"><span class="comment">        -1,</span></span><br><span class="line"><span class="comment">        methods,</span></span><br><span class="line"><span class="comment">        NULL, NULL, NULL, NULL</span></span><br><span class="line"><span class="comment">    &#125;;</span></span><br><span class="line"><span class="comment">    return PyModule_Create(&amp;module);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;strconv&quot;</span></span><br><span class="line">    <span class="string">&quot;strings&quot;</span></span><br><span class="line">    <span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//export hexlify</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hexlify</span><span class="params">(self, arg *C.PyObject)</span></span> *C.PyObject &#123;</span><br><span class="line">    <span class="comment">// arg 必须是一个 bytes 对象，这里我们就不做参数检测了</span></span><br><span class="line"></span><br><span class="line">    buf := strings.Builder&#123;&#125;</span><br><span class="line">    <span class="comment">// 字符串转成 C 的字符串、再转成 Go 字符串</span></span><br><span class="line">    go_string := C.GoString(C.PyBytes_AsString(arg))</span><br><span class="line">    <span class="comment">// 遍历字符串，将整型转成 16 进制</span></span><br><span class="line">    <span class="keyword">for</span> _, char := <span class="keyword">range</span> []<span class="type">byte</span>(go_string) &#123;</span><br><span class="line">        buf.WriteString(strconv.FormatInt(<span class="type">int64</span>(char), <span class="number">16</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 转成 C 字符串</span></span><br><span class="line">    c_string := C.CString(buf.String())</span><br><span class="line">    <span class="comment">// 根据 C 字符串创建 Python 的 bytes 对象</span></span><br><span class="line">    res := C.PyBytes_FromString(c_string)</span><br><span class="line">    <span class="comment">// 记得将堆区申请的 C 字符串给删除</span></span><br><span class="line">    C.free(unsafe.Pointer(c_string))</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//export unhexlify</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unhexlify</span><span class="params">(self, arg *C.PyObject)</span></span> *C.PyObject &#123;</span><br><span class="line"></span><br><span class="line">    buf := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 得到 Go bytes</span></span><br><span class="line">    go_bytes := []<span class="type">byte</span>(C.GoString(C.PyBytes_AsString(arg)))</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(go_bytes); i += <span class="number">2</span> &#123;</span><br><span class="line">        n, _ := strconv.ParseInt(<span class="type">string</span>(go_bytes[i:i+<span class="number">2</span>]), <span class="number">16</span>, <span class="number">0</span>)</span><br><span class="line">        buf = <span class="built_in">append</span>(buf, <span class="type">byte</span>(n))</span><br><span class="line">    &#125;</span><br><span class="line">    c_string := C.CString(<span class="type">string</span>(buf))</span><br><span class="line">    res := C.PyBytes_FromString(c_string)</span><br><span class="line">    C.free(unsafe.Pointer(c_string))</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//export PyInit_binascii</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PyInit_binascii</span><span class="params">()</span></span> *C.PyObject &#123;</span><br><span class="line">    <span class="keyword">return</span> C.__PyInit_binascii()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>里面涉及到的一些细节就不详细说了，使用 Go 写扩展首先需要了解如何使用 C 写扩展，而且正如之前所说，用 Go 写扩展反而会没有 C 方便。原因就是 CPython 解释器内置了大量的宏，这些宏在 Go  里面没法直接通过 C 这个名字来进行引用，还有上面说的具有可变参数的 C  函数，不能直接调用，必须定义一个包装器才可以（个人觉得这算是最大的硬伤）；以及 Python 底层的数据结构、C 的数据结构、Go  的数据结构三者要经常来回转化，还有引用计数的增加、减少，堆区上 C  字符串的释放等等，个人觉得这些东西处理起来不是一件简单的事情。个人觉得最好的做法还是前两种，如果熟悉 Cython  则更推荐第二种，至于这里的第三种：用 Go 直接给 Python 写扩展，个人不是很推荐。</strong></p>
<p><strong>而上面的代码则是简单实现了 hexlify、unhexlify 两个函数，我们来测试一下吧。</strong></p>
<p><img src="/2023/04/26/32-Python-%E5%92%8C-Go-%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/1229382-20210518173121632-1835895119.png" alt="img"></p>
<p><strong>从结果上来看是没有任何问题的，但这是参数类型传递正确的前提下。因为我们这里没有对参数进行检测，假设我们传递了一个整型过去，那么在执行 C.PyBytes_AsString 的时候很明显是会报错的。</strong></p>
<p><strong>当然这里关于扩展的更多细节，这里就不讨论了，个人觉得不管啥语言，直接写扩展都不是一件简单的事情。所以本人特别喜欢 Cython，因为它同时理解 C 和 Python，将 C 的高性能和 Python 的动态特性结合在了一起。</strong></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><strong>以上就是在 Python 中引入 Go 的几种方式，当然 Go 里面也可以引入 Python，只不过个人是以 Python 作为主语言，所以只关注前者。而 Python 引入 Go 也有三种方式：</strong></p>
<ul>
<li><code>1. Go 直接编写动态库给 Python，然后 Python 解释器通过 ctypes 调用</code></li>
<li><code>2. Go 编写静态库或者动态库，然后再由 Cython 包装成 Python 扩展，Python解释器直接 import</code></li>
<li><code>3. Go 直接为 Python 提供扩展</code></li>
</ul>
<p><strong>第三种个人不推荐，因为受到的限制太多了，可以尝试前两种。</strong></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Lin Li</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/04/26/32-Python-%E5%92%8C-Go-%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/">http://example.com/2023/04/26/32-Python-%E5%92%8C-Go-%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">LinLi's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/CPython/">CPython</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/04/26/33-%E4%B8%BA%E4%BB%80%E4%B9%88-obj-obj-%E4%B8%BA-False%E3%80%81-obj-obj-%E4%B8%BA-True/" title="33-为什么 obj == obj 为 False、[obj] == [obj] 为 True"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">33-为什么 obj == obj 为 False、[obj] == [obj] 为 True</div></div></a></div><div class="next-post pull-right"><a href="/2023/04/26/31-Python-%E5%92%8C-C-C-%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/" title="31-Python 和 C  C++ 联合编程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">31-Python 和 C  C++ 联合编程</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/03/29/01-%E7%BC%96%E8%AF%91Cpython/" title="01-编译Cpython"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">01-编译Cpython</div></div></a></div><div><a href="/2023/03/29/02-%E4%B8%80%E5%88%87%E5%AF%B9%E8%B1%A1%E7%9A%86PyObject/" title="02-一切对象皆PyObject"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">02-一切对象皆PyObject</div></div></a></div><div><a href="/2023/03/29/04-%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/" title="04-浮点数的底层实现"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">04-浮点数的底层实现</div></div></a></div><div><a href="/2023/03/29/06-Bytes%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BA%95%E5%B1%82%E6%93%8D%E4%BD%9C/" title="06-Bytes对象的底层操作"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">06-Bytes对象的底层操作</div></div></a></div><div><a href="/2023/03/29/03-Python%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E5%99%A8%E5%92%8C%E5%BA%95%E5%B1%82%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86/" title="03-Python引用计数器和底层对象管理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">03-Python引用计数器和底层对象管理</div></div></a></div><div><a href="/2023/03/29/05-Python%E6%95%B4%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/" title="05-Python整数的底层实现"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">05-Python整数的底层实现</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Lin Li</div><div class="author-info__description">今日事，今日毕</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">98</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#32-Python-%E5%92%8C-Go-%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">32-Python 和 Go 联合编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A5%94%E5%AD%90"><span class="toc-number">1.1.</span> <span class="toc-text">楔子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Go-%E6%BA%90%E6%96%87%E4%BB%B6%E7%BC%96%E8%AF%91%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93"><span class="toc-number">1.2.</span> <span class="toc-text">Go 源文件编译成动态库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Go-%E5%AF%BC%E5%87%BA%E5%87%BD%E6%95%B0%E7%BB%99-Python-%E8%B0%83%E7%94%A8"><span class="toc-number">1.3.</span> <span class="toc-text">Go 导出函数给 Python 调用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.1.</span> <span class="toc-text">数值类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.3.2.</span> <span class="toc-text">字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">1.3.3.</span> <span class="toc-text">结构体</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">返回一个结构体</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%A0%E5%85%A5%E7%BB%93%E6%9E%84%E4%BD%93%E6%8C%87%E9%92%88"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">传入结构体指针</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="toc-number">1.3.4.</span> <span class="toc-text">函数调用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Python-%E5%90%91-C-%E4%BC%A0%E9%80%92%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">Python 向 C 传递函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">1.3.5.</span> <span class="toc-text">数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.3.6.</span> <span class="toc-text">内存模型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Go-%E6%BA%90%E6%96%87%E4%BB%B6%E7%BC%96%E8%AF%91%E6%88%90%E9%9D%99%E6%80%81%E5%BA%93%E3%80%81%E5%8A%A8%E6%80%81%E5%BA%93%E5%B9%B6%E7%BB%93%E5%90%88-Cython"><span class="toc-number">1.4.</span> <span class="toc-text">Go 源文件编译成静态库、动态库并结合 Cython</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%B1-Cython-%E9%87%8A%E6%94%BE%E5%86%85%E5%AD%98"><span class="toc-number">1.4.1.</span> <span class="toc-text">由 Cython 释放内存</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Go-%E6%BA%90%E6%96%87%E4%BB%B6%E7%9B%B4%E6%8E%A5%E7%BC%96%E8%AF%91%E6%88%90-Python-%E6%89%A9%E5%B1%95%E6%A8%A1%E5%9D%97"><span class="toc-number">1.5.</span> <span class="toc-text">Go 源文件直接编译成 Python 扩展模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">1.6.</span> <span class="toc-text">小结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/03/THANOS-DBMS-Bug-Detection-via-Storage-Engine-Rotation-Based-Differential-Testing/" title="THANOS: DBMS Bug Detection via Storage Engine Rotation Based Differential Testing">THANOS: DBMS Bug Detection via Storage Engine Rotation Based Differential Testing</a><time datetime="2024-10-03T08:41:45.000Z" title="发表于 2024-10-03 16:41:45">2024-10-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/28/SQLaser-Detecting-DBMS-Logic-Bugs-with-Clause-Guided-Fuzzing/" title="SQLaser: Detecting DBMS Logic Bugs with Clause-Guided Fuzzing">SQLaser: Detecting DBMS Logic Bugs with Clause-Guided Fuzzing</a><time datetime="2024-09-28T08:37:40.000Z" title="发表于 2024-09-28 16:37:40">2024-09-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/18/MVP-Detecting-Vulnerabilities-using-Patch-Enhanced-Vulnerability-Signatures/" title="MVP: Detecting Vulnerabilities using Patch-Enhanced Vulnerability Signatures">MVP: Detecting Vulnerabilities using Patch-Enhanced Vulnerability Signatures</a><time datetime="2024-08-18T09:26:02.000Z" title="发表于 2024-08-18 17:26:02">2024-08-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/17/Movery-A-Precise-Approach-for-Modified-Vulnerable-Code-Clone-Discovery-from-Modified-Open-Source-Software-Components/" title="Movery A Precise Approach for Modified Vulnerable Code Clone Discovery from Modified Open-Source Software Components">Movery A Precise Approach for Modified Vulnerable Code Clone Discovery from Modified Open-Source Software Components</a><time datetime="2024-08-17T14:09:41.000Z" title="发表于 2024-08-17 22:09:41">2024-08-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/30/Translating-between-SQL-Dialects-for-Cloud-Migration/" title="Translating between SQL Dialects for Cloud Migration">Translating between SQL Dialects for Cloud Migration</a><time datetime="2024-07-30T07:48:40.000Z" title="发表于 2024-07-30 15:48:40">2024-07-30</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Lin Li</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>