<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>29-源码解密 map、filter、zip 底层实现，对比列表解析式 | LinLi's Blog</title><meta name="author" content="Lin Li"><meta name="copyright" content="Lin Li"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="29-源码解密 map、filter、zip 底层实现，对比列表解析式楔子Python 现在如此流行，拥有众多开源、高质量的第三方库是一个重要原因，不过 Python 的简单、灵巧、容易上手也是功不可没的，而其背后的内置函数（类）则起到了很大的作用。举个栗子： 123456789101112numbers &#x3D; [1, 2, 3, 4, 5]# 将里面每一个元素都加1print(list(map(l">
<meta property="og:type" content="article">
<meta property="og:title" content="29-源码解密 map、filter、zip 底层实现，对比列表解析式">
<meta property="og:url" content="http://example.com/2023/04/26/29-%E6%BA%90%E7%A0%81%E8%A7%A3%E5%AF%86-map%E3%80%81filter%E3%80%81zip-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%EF%BC%8C%E5%AF%B9%E6%AF%94%E5%88%97%E8%A1%A8%E8%A7%A3%E6%9E%90%E5%BC%8F/index.html">
<meta property="og:site_name" content="LinLi&#39;s Blog">
<meta property="og:description" content="29-源码解密 map、filter、zip 底层实现，对比列表解析式楔子Python 现在如此流行，拥有众多开源、高质量的第三方库是一个重要原因，不过 Python 的简单、灵巧、容易上手也是功不可没的，而其背后的内置函数（类）则起到了很大的作用。举个栗子： 123456789101112numbers &#x3D; [1, 2, 3, 4, 5]# 将里面每一个元素都加1print(list(map(l">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2023-04-26T13:23:46.000Z">
<meta property="article:modified_time" content="2023-04-26T13:24:17.731Z">
<meta property="article:author" content="Lin Li">
<meta property="article:tag" content="CPython">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/04/26/29-%E6%BA%90%E7%A0%81%E8%A7%A3%E5%AF%86-map%E3%80%81filter%E3%80%81zip-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%EF%BC%8C%E5%AF%B9%E6%AF%94%E5%88%97%E8%A1%A8%E8%A7%A3%E6%9E%90%E5%BC%8F/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '29-源码解密 map、filter、zip 底层实现，对比列表解析式',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-04-26 21:24:17'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">122</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="LinLi's Blog"><span class="site-name">LinLi's Blog</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">29-源码解密 map、filter、zip 底层实现，对比列表解析式</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-04-26T13:23:46.000Z" title="发表于 2023-04-26 21:23:46">2023-04-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-04-26T13:24:17.731Z" title="更新于 2023-04-26 21:24:17">2023-04-26</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="29-源码解密 map、filter、zip 底层实现，对比列表解析式"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="29-源码解密-map、filter、zip-底层实现，对比列表解析式"><a href="#29-源码解密-map、filter、zip-底层实现，对比列表解析式" class="headerlink" title="29-源码解密 map、filter、zip 底层实现，对比列表解析式"></a>29-源码解密 map、filter、zip 底层实现，对比列表解析式</h2><h3 id="楔子"><a href="#楔子" class="headerlink" title="楔子"></a>楔子</h3><p><strong>Python 现在如此流行，拥有众多开源、高质量的第三方库是一个重要原因，不过 Python 的简单、灵巧、容易上手也是功不可没的，而其背后的内置函数（类）则起到了很大的作用。举个栗子：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="comment"># 将里面每一个元素都加1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x + <span class="number">1</span>, numbers)))  <span class="comment"># [2, 3, 4, 5, 6]</span></span><br><span class="line"></span><br><span class="line">strings = [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;kf&quot;</span>, <span class="string">&quot;ghtc&quot;</span>]</span><br><span class="line"><span class="comment"># 筛选出长度大于等于3的</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="keyword">lambda</span> x: <span class="built_in">len</span>(x) &gt;= <span class="number">3</span>, strings)))  <span class="comment"># [&#x27;abc&#x27;, &#x27;def&#x27;, &#x27;ghtc&#x27;]</span></span><br><span class="line"></span><br><span class="line">keys = [<span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;gender&quot;</span>]</span><br><span class="line">values = [<span class="string">&quot;夏色祭&quot;</span>, <span class="number">17</span>, <span class="string">&quot;female&quot;</span>]</span><br><span class="line"><span class="comment"># 将keys 和 values 里面的元素按照顺序组成字典</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dict</span>(<span class="built_in">zip</span>(keys, values)))  <span class="comment"># &#123;&#x27;name&#x27;: &#x27;夏色祭&#x27;, &#x27;age&#x27;: 17, &#x27;gender&#x27;: &#x27;female&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看到一行代码就搞定了，那么问题来了，这些内置函数（类）在底层是怎么实现的呢？下面我们就来通过源码来分析一下，这里我们介绍 map、filter、zip。</strong></p>
<p><strong>首先这些类（map、filter、zip都是类）都位于 builtin  名字空间中，而我们之前在介绍源码的时候提到过一个文件：Python&#x2F;bltinmodule.c，我们说该文件是和内置函数（类）相关的，那么显然  map、filter、zip 也藏身于此。</strong></p>
<h3 id="map底层实现"><a href="#map底层实现" class="headerlink" title="map底层实现"></a>map底层实现</h3><p><strong>我们知道map是将一个序列中的每个元素都作用于同一个函数（当然类、方法也可以）：</strong></p>
<p><img src="/2023/04/26/29-%E6%BA%90%E7%A0%81%E8%A7%A3%E5%AF%86-map%E3%80%81filter%E3%80%81zip-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%EF%BC%8C%E5%AF%B9%E6%AF%94%E5%88%97%E8%A1%A8%E8%A7%A3%E6%9E%90%E5%BC%8F/1229382-20201125193821363-702374811.png" alt="img"></p>
<p><strong>当然，我们知道调用map的时候并没有马上执行上面的操作，而是返回一个map对象。既然是对象，那么底层必有相关的定义。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_HEAD	  </span><br><span class="line">    PyObject *iters;  </span><br><span class="line">    PyObject *func;   </span><br><span class="line">&#125; mapobject;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>PyObject_HEAD：见过很多次了，它是Python中任何对象都会有的头部信息。包含一个引用计数ob_refcnt、和一个类型对象的指针ob_type；</strong></p>
<p><strong>iters：一个指针，这里实际上是一个PyTupleObject *，以 <code>map(lambda x: x + 1, [1, 2, 3])</code> 为例，那么这里的 iters 就相当于是 <code>([1, 2, 3, 4, 5].__iter__(),)</code>。至于为什么，分析源码的时候就知道了；</strong></p>
<p><strong>func：显然就是函数指针了，PyFunctionObject *；</strong></p>
</blockquote>
<p><strong>通过底层结构体定义，我们也可以得知在调用map时并没有真正的执行；对于函数和可迭代对象，只是维护了两个指针去指向它。</strong></p>
<p><strong>而一个PyObject占用16字节，再加上两个8字节的指针总共32字节。因此在64位机器上，任何一个map对象所占大小都是32字节。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">numbers = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">100000</span>))</span><br><span class="line">strings = [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 都占32字节</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x * <span class="number">3</span>, numbers).__sizeof__())  <span class="comment"># 32</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x * <span class="number">3</span>, strings).__sizeof__())  <span class="comment"># 32</span></span><br></pre></td></tr></table></figure>

<p><strong>再来看看map的用法，Python中的 map 不仅可以作用于一个序列，还可以作用于任意多个序列。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">m1 = <span class="built_in">map</span>(<span class="keyword">lambda</span> x: x[<span class="number">0</span>] + x[<span class="number">1</span>] + x[<span class="number">2</span>], [(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>), (<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(m1))  <span class="comment"># [6, 9, 12]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># map 还可以接收任意个可迭代对象</span></span><br><span class="line">m2 = <span class="built_in">map</span>(<span class="keyword">lambda</span> x, y, z: x + y + z, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(m2))  <span class="comment"># [6, 9, 12]</span></span><br><span class="line"><span class="comment"># 所以底层结构体中的iters在这里就相当于 ([1, 2, 3].__iter__(), [2, 3, 4].__iter__(), [3, 4, 5].__iter__())</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们说map的第一个参数是一个函数, 后面可以接收任意多个可迭代对象</span></span><br><span class="line"><span class="comment"># 但是注意: 可迭代对象的数量 和 函数的参数个数 一定要匹配</span></span><br><span class="line">m3 = <span class="built_in">map</span>(<span class="keyword">lambda</span> x, y, z: <span class="built_in">str</span>(x) + y + z, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>], <span class="string">&quot;abc&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(m3))  <span class="comment"># [&#x27;1aa&#x27;, &#x27;2bb&#x27;, &#x27;3cc&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 但是可迭代对象之间的元素个数不要求相等, 会以最短的为准</span></span><br><span class="line">m4 = <span class="built_in">map</span>(<span class="keyword">lambda</span> x, y, z: x + y + z, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(m4))  <span class="comment"># [6, 9]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当然也支持更加复杂的形式</span></span><br><span class="line">m5 = <span class="built_in">map</span>(<span class="keyword">lambda</span> x, y: x[<span class="number">0</span>] + x[<span class="number">1</span>] + y, [(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">2</span>, <span class="number">3</span>)], [<span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(m5))  <span class="comment"># [6, 9]</span></span><br></pre></td></tr></table></figure>

<p><strong>所以我们看到 map 会将后面所有可迭代对象中的每一个元素按照顺序依次取出，然后传递到函数中，因此函数的参数个数 和 可迭代对象的个数 一定要相等。</strong></p>
<p><strong>那么map对象在底层是如何创建的呢？很简单，因为map是一个类，那么调用的时候一定会执行里面的 <strong>new</strong> 方法。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">map_new</span><span class="params">(PyTypeObject *type, PyObject *args, PyObject *kwds)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyObject *it, *iters, *func;</span><br><span class="line">    mapobject *lz;</span><br><span class="line">    Py_ssize_t numargs, i;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// map对象在底层对应的是 mapobject、map类本身在底层对应的则是 PyMap_Type</span></span><br><span class="line">    <span class="comment">// _PyArg_NoKeywords表示检验是否没有传递关键字参数, 如果没传递, 那么结果为真; 传递了, 结果为假;</span></span><br><span class="line">    <span class="keyword">if</span> (type == &amp;PyMap_Type &amp;&amp; !_PyArg_NoKeywords(<span class="string">&quot;map&quot;</span>, kwds))</span><br><span class="line">        <span class="comment">// 可以看到 map 不接受关键字参数</span></span><br><span class="line">        <span class="comment">// 如果传递了, 那么会报如下错误: TypeError: map() takes no keyword arguments, 可以自己尝试一下</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 位置参数都在 args 里面, 上面的 kwds 是关键字参数</span></span><br><span class="line">    <span class="comment">// 这里获取位置参数的个数, 1个函数、numargs - 1个可迭代对象, 这里的args 是一个 PyTupleObject *</span></span><br><span class="line">    numargs = PyTuple_Size(args);</span><br><span class="line">    <span class="comment">// 如果参数个数小于2</span></span><br><span class="line">    <span class="keyword">if</span> (numargs &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 抛出 TypeError, 表示 map 至少接受两个位置参数: 一个函数 和 至少一个可迭代对象</span></span><br><span class="line">        PyErr_SetString(PyExc_TypeError,</span><br><span class="line">           <span class="string">&quot;map() must have at least two arguments.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 申请一个元组, 容量为 numargs - 1, 用于存放传递的所有可迭代对象(对应的迭代器)</span></span><br><span class="line">    iters = PyTuple_New(numargs<span class="number">-1</span>);</span><br><span class="line">    <span class="comment">// 为NULL表示申请失败</span></span><br><span class="line">    <span class="keyword">if</span> (iters == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 依次循环</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span> ; i&lt;numargs ; i++) &#123;</span><br><span class="line">        <span class="comment">// PyTuple_GET_ITEM(args, i) 表示获取索引为 i 的可迭代对象</span></span><br><span class="line">        <span class="comment">// PyObject_GetIter 表示获取对应的迭代器, 相当于内置函数 iter</span></span><br><span class="line">        it = PyObject_GetIter(PyTuple_GET_ITEM(args, i));</span><br><span class="line">        <span class="comment">// 为NULL表示获取失败, 但是iters这个元组已经申请了, 所以减少其引用计数, 将其销毁</span></span><br><span class="line">        <span class="keyword">if</span> (it == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            Py_DECREF(iters);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将对应的迭代器设置在元组iters中</span></span><br><span class="line">        PyTuple_SET_ITEM(iters, i<span class="number">-1</span>, it);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 PyMap_Type 的 tp_alloc, 为其实例对象申请空间</span></span><br><span class="line">    lz = (mapobject *)type-&gt;tp_alloc(type, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 为NULL表示申请失败, 减少iters的引用计数</span></span><br><span class="line">    <span class="keyword">if</span> (lz == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Py_DECREF(iters);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 让lz的iters成员 等于 iters</span></span><br><span class="line">    lz-&gt;iters = iters;</span><br><span class="line">    <span class="comment">// 获取第一个参数, 也就是函数</span></span><br><span class="line">    func = PyTuple_GET_ITEM(args, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 增加引用计数, 因为该函数被作为参数传递给map了</span></span><br><span class="line">    Py_INCREF(func);</span><br><span class="line">    <span class="comment">// 让lz的func成员 等于 func</span></span><br><span class="line">    lz-&gt;func = func;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 转成 PyObject *泛型指针, 然后返回</span></span><br><span class="line">    <span class="keyword">return</span> (PyObject *)lz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所以我们看到map_new做的工作很简单，就是实例化一个map对象，然后对内部的成员进行赋值。我们用Python来模拟一下上述过程：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyMap</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">if</span> kwargs:</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">&quot;MyMap不接受关键字参数&quot;</span>)</span><br><span class="line">        numargs = <span class="built_in">len</span>(args)</span><br><span class="line">        <span class="keyword">if</span> numargs &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">&quot;MyMap至少接收两个参数&quot;</span>)</span><br><span class="line">        <span class="comment"># 元组内部的元素不可以改变(除非本地修改), 所以这里使用列表来模拟</span></span><br><span class="line">        iters = [<span class="literal">None</span>] * (numargs - <span class="number">1</span>)  <span class="comment"># 创建一个长度为 numargs - 1 的列表, 元素都是None, 模拟C中的NULL</span></span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; numargs:  <span class="comment"># 逐步循环</span></span><br><span class="line">            it = <span class="built_in">iter</span>(args[i])  <span class="comment"># 获取可迭代对象, 得到其迭代器</span></span><br><span class="line">            iters[i - <span class="number">1</span>] = it  <span class="comment"># 设置在 iters 中</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 为实例对象申请空间</span></span><br><span class="line">        instance = <span class="built_in">object</span>.__new__(cls)</span><br><span class="line">        <span class="comment"># 设置成员</span></span><br><span class="line">        instance.iters = iters  </span><br><span class="line">        instance.func = args[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> instance  <span class="comment"># 返回实例对象</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">m = MyMap(<span class="keyword">lambda</span> x, y: x + y, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>])</span><br><span class="line"><span class="built_in">print</span>(m)  <span class="comment"># &lt;__main__.MyMap object at 0x00000167F4552E80&gt;</span></span><br><span class="line"><span class="built_in">print</span>(m.func)  <span class="comment"># &lt;function &lt;lambda&gt; at 0x0000023ABC4C51F0&gt;</span></span><br><span class="line"><span class="built_in">print</span>(m.func(<span class="number">2</span>, <span class="number">3</span>))  <span class="comment"># 5</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(m.iters)  <span class="comment"># [&lt;list_iterator object at 0x0000025F13AF2940&gt;, &lt;list_iterator object at 0x0000025F13AF2CD0&gt;]</span></span><br><span class="line"><span class="built_in">print</span>([<span class="built_in">list</span>(it) <span class="keyword">for</span> it <span class="keyword">in</span> m.iters])  <span class="comment"># [[1, 2, 3], [11, 22, 33]]</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看到非常简单，这里我们没有设置构造函数__init__，这是因为 map 内部没有 __init__，它的成员都是在__new__里面设置的。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># map的__init__ 实际上就是 object的__init__</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">map</span>.__init__ <span class="keyword">is</span> <span class="built_in">object</span>.__init__)  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">map</span>.__init__)  <span class="comment"># &lt;slot wrapper &#x27;__init__&#x27; of &#x27;object&#x27; objects&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<p><strong>事实上，你会发现map对象非常类似迭代器，而事实上它们也正是迭代器。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Iterable, Iterator</span><br><span class="line"></span><br><span class="line">m = <span class="built_in">map</span>(<span class="built_in">str</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(m, Iterable))  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(m, Iterator))  <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<p><strong>为了能更方便地理解后续内容，这里我们来提一下Python中的迭代器，可能有人觉得Python的迭代器很神奇，但如果你看了底层实现的话，你肯定会觉得：”就这？”</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Objects/iterobject.c</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    Py_ssize_t it_index;  <span class="comment">// 每迭代一次, index自增1</span></span><br><span class="line">    PyObject *it_seq; <span class="comment">// 走到头之后, 将it_seq设置为NULL</span></span><br><span class="line">&#125; seqiterobject;</span><br></pre></td></tr></table></figure>

<p><strong>这就是Python的迭代器，非常简单，我们直接用Python来模拟一下：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyIterator</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, it_seq</span>):</span><br><span class="line">        instance = <span class="built_in">object</span>.__new__(cls)  <span class="comment"># 创建实例对象</span></span><br><span class="line">        instance.it_index = <span class="number">0</span></span><br><span class="line">        instance.it_seq = it_seq</span><br><span class="line">        <span class="keyword">return</span> instance</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 如果 self.it_seq 为None, 证明此迭代器已经迭代完毕</span></span><br><span class="line">        <span class="keyword">if</span> self.it_seq <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 逐步迭代, 说白了就是使用索引获取, 每迭代一次、索引自增1</span></span><br><span class="line">            val = self.it_seq[self.it_index]</span><br><span class="line">            self.it_index += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> val</span><br><span class="line">        <span class="keyword">except</span> IndexError:</span><br><span class="line">            <span class="comment"># 出现索引越界, 证明已经遍历完毕</span></span><br><span class="line">            <span class="comment"># 直接将 self.it_seq 设置为None即可</span></span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> MyIterator([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]):</span><br><span class="line">    <span class="built_in">print</span>(_, end=<span class="string">&quot; &quot;</span>)  <span class="comment"># 1 2 3</span></span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">my_it = MyIterator([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="comment"># 只能迭代一次</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(my_it))  <span class="comment"># [2, 3, 4]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(my_it))  <span class="comment"># []</span></span><br></pre></td></tr></table></figure>

<p><strong>Python的迭代器底层就是这么做的，可能有人觉得这不就是把  可迭代对象 和 索引 进行了一层封装嘛。每迭代一次，索引自增1，当出现索引越界时，证明迭代完了，直接将 it_seq 设置为 NULL  即可（这也侧面说明了为什么迭代器从开始到结束只能迭代一次）。</strong></p>
<p><strong>是的，迭代器就是这么简单，没有一点神秘。当然不仅是迭代器，再比如关键字 in，在C的层面其实就是一层 for 循环罢了。而迭代器除了通过 <strong>iter</strong> 实现之外，我们还可以通过  <strong>getitem__，__iter</strong> 我们下一章分析，下面看看 <strong>getitem</strong> 在源码中是如何体现的：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Objects/iterobject.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建</span></span><br><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PySeqIter_New</span><span class="params">(PyObject *seq)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">// 迭代器</span></span><br><span class="line">    seqiterobject *it;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 如果不是一个序列的话, 那么调用失败</span></span><br><span class="line">    <span class="keyword">if</span> (!PySequence_Check(seq)) &#123;</span><br><span class="line">        PyErr_BadInternalCall();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 申请空间</span></span><br><span class="line">    it = PyObject_GC_New(seqiterobject, &amp;PySeqIter_Type);</span><br><span class="line">    <span class="comment">// 为NULL表示申请失败</span></span><br><span class="line">    <span class="keyword">if</span> (it == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// it_index 初始化为0</span></span><br><span class="line">    it-&gt;it_index = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 因为seq被传递了, 所以指向的对象的引用计数要加1</span></span><br><span class="line">    Py_INCREF(seq);</span><br><span class="line">    <span class="comment">// 将成员it_seq初始化为seq</span></span><br><span class="line">    it-&gt;it_seq = seq;</span><br><span class="line">    <span class="comment">// 将该迭代器对象链接到 第0代链表 中, 并由GC负责跟踪(此处和垃圾回收机制相关, 这里不做过多介绍)</span></span><br><span class="line">    _PyObject_GC_TRACK(it);</span><br><span class="line">    <span class="comment">// 返回迭代器对象</span></span><br><span class="line">    <span class="keyword">return</span> (PyObject *)it;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代</span></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">iter_iternext</span><span class="params">(PyObject *iterator)</span></span><br><span class="line">&#123;</span><br><span class="line">    seqiterobject *it;  <span class="comment">// 迭代器对象</span></span><br><span class="line">    PyObject *seq;     <span class="comment">// 迭代器对象内部的可迭代对象</span></span><br><span class="line">    PyObject *result;  <span class="comment">// 迭代结果</span></span><br><span class="line"></span><br><span class="line">    assert(PySeqIter_Check(iterator));  <span class="comment">// 一定是迭代器</span></span><br><span class="line">    it = (seqiterobject *)iterator;  <span class="comment">// 将泛型指针PyObject * 转成 seqiterobject *</span></span><br><span class="line">    seq = it-&gt;it_seq;  <span class="comment">// 获取内部可迭代对象</span></span><br><span class="line">    <span class="comment">// 如果是NULL, 那么证明此迭代器已经迭代完毕, 直接返回NULL</span></span><br><span class="line">    <span class="keyword">if</span> (seq == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 索引达到了最大值, 因为容器内部的元素个数是有限制的; 但如果不是吃撑了写恶意代码, 这个限制几乎不可能会触发</span></span><br><span class="line">    <span class="keyword">if</span> (it-&gt;it_index == PY_SSIZE_T_MAX) &#123;</span><br><span class="line">        PyErr_SetString(PyExc_OverflowError,</span><br><span class="line">                        <span class="string">&quot;iter index too large&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 根据索引获取 seq 内部的元素</span></span><br><span class="line">    result = PySequence_GetItem(seq, it-&gt;it_index);</span><br><span class="line">    <span class="comment">// 如果不为NULL, 证明确实迭代出了元素</span></span><br><span class="line">    <span class="keyword">if</span> (result != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 索引自增1</span></span><br><span class="line">        it-&gt;it_index++;</span><br><span class="line">        <span class="comment">// 然后返回结果</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当result为NULL的时候, 证明出异常了, 也说明遍历到头了</span></span><br><span class="line">    <span class="comment">// 进行异常匹配, 如果出现的异常能匹配 IndexError 或者 StopIteration</span></span><br><span class="line">    <span class="keyword">if</span> (PyErr_ExceptionMatches(PyExc_IndexError) ||</span><br><span class="line">        PyErr_ExceptionMatches(PyExc_StopIteration))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 那么不会让异常抛出, 而是通过 PyErr_Clear() 将异常回溯栈清空</span></span><br><span class="line">        <span class="comment">// 所以使用 for i in 迭代器, 或者 list(迭代器) 等等不会报错, 原因就在于此; 尽管它们也是不断迭代, 但是在最后会捕获异常</span></span><br><span class="line">        PyErr_Clear();</span><br><span class="line">        <span class="comment">// 将it_seq设置为NULL, 表示此迭代器大限已至、油尽灯枯</span></span><br><span class="line">        it-&gt;it_seq = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">// 因为将it_seq赋值NULL, 那么原来的可迭代对象就少了一个引用, 因此要将引用计数减1</span></span><br><span class="line">        Py_DECREF(seq);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所以这就是迭代器，真的一点都不神秘。</strong></p>
<p><strong>在迭代器上面多扯皮了一会儿，但这肯定是值得的，那么回到主题。我们说调用map只是得到一个map对象，从上面的分析我们也可以得出，在整个过程并没有进行任何的计算。如果要计算的话，我们可以调用__next__、或者使用for循环等等。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">m = <span class="built_in">map</span>(<span class="keyword">lambda</span> x: x + <span class="number">1</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="built_in">print</span>([i <span class="keyword">for</span> i <span class="keyword">in</span> m])  <span class="comment"># [2, 3, 4, 5, 6]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当然我们知道 for 循环的背后本质上会调用迭代器的 __next__</span></span><br><span class="line">m = <span class="built_in">map</span>(<span class="keyword">lambda</span> x: <span class="built_in">int</span>(x) + <span class="number">1</span>, <span class="string">&quot;12345&quot;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span>(m.__next__())</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">2</span></span><br><span class="line"><span class="string">3</span></span><br><span class="line"><span class="string">4</span></span><br><span class="line"><span class="string">5</span></span><br><span class="line"><span class="string">6</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当然上面都不是最好的方式</span></span><br><span class="line"><span class="comment"># 如果只是单纯的将元素迭代出来, 而不做任何处理的话, 那么交给tuple、list、set等类型对象才是最佳的方式</span></span><br><span class="line"><span class="comment"># 像tuple(m)、list(m)、set(m)等等</span></span><br><span class="line"><span class="comment"># 所以如果你是[x for x in it]这种做法的话, 那么更建议你使用list(m), 效率会更高, 因为它用的是C中的for循环</span></span><br><span class="line"><span class="comment"># 当然不管是哪种做法, 底层都是一个不断调用__next__、逐步迭代的过程</span></span><br></pre></td></tr></table></figure>

<p><strong>所以下面我们来看看map底层是怎么做的？</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">map_next</span><span class="params">(mapobject *lz)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">// small_stack显然是一个数组, 里面存放 PyObject *, 显然它用来存放 map 中所有可迭代对象的索引为i(i=0,1,2,3...)的元素</span></span><br><span class="line">    <span class="comment">// 但这个_PY_FASTCALL_SMALL_STACK是什么呢? 我们需要详细说一下</span></span><br><span class="line">    PyObject *small_stack[_PY_FASTCALL_SMALL_STACK];</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    _PY_FASTCALL_SMALL_STACK 是一个宏, 定义在 Include/cpython/abstract.h 中, 结果就等于5</span></span><br><span class="line"><span class="comment">    small_stack这个数组会首先尝试在栈区分配，如果通过位置参数来调用一个函数的话, 可以不用申请在堆区</span></span><br><span class="line"><span class="comment">    但是数量不能过大, 官方将这个值设置成5, 如果参数个数小于等于5的话, 便可申请在栈中</span></span><br><span class="line"><span class="comment">    然后通过传递位置参数的方式对函数进行调用, 在C中调用一个 Python函数 有很多种方式；</span></span><br><span class="line"><span class="comment">    这里会通过 PyObject_Vectorcall 系列函数(矢量调用, 会更快) 来对函数进行调用, 是的，调用一个函数需要借助另一个函数</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    之所以将其设置成5, 是为了不滥用C的栈, 从而减少栈溢出的风险</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 二级指针, 指向 small_stack 数组的首元素, 所以是 PyObject **</span></span><br><span class="line">    PyObject **<span class="built_in">stack</span>;</span><br><span class="line">    <span class="comment">// 函数调用的返回值</span></span><br><span class="line">    PyObject *result = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 获取当前的线程状态对象</span></span><br><span class="line">    PyThreadState *tstate = _PyThreadState_GET();</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 获取iters内置迭代器的数量, 同时也是调用函数时的参数数量</span></span><br><span class="line">    <span class="type">const</span> Py_ssize_t niters = PyTuple_GET_SIZE(lz-&gt;iters);</span><br><span class="line">    <span class="comment">// 如果这个参数小于等于5, 那么在获取这些迭代器中的元素时, 可以直接使用在C栈中申请的数组进行存储</span></span><br><span class="line">    <span class="keyword">if</span> (niters &lt;= (Py_ssize_t)Py_ARRAY_LENGTH(small_stack)) &#123;</span><br><span class="line">        <span class="built_in">stack</span> = small_stack;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果超过了5, 那么不好意思, 只能在堆区重新申请了</span></span><br><span class="line">        <span class="built_in">stack</span> = PyMem_Malloc(niters * <span class="keyword">sizeof</span>(<span class="built_in">stack</span>[<span class="number">0</span>]));</span><br><span class="line">        <span class="comment">// 返回NULL, 表示申请失败, 说明没有内存了</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">stack</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 这里传入线程状态对象, 会在内部设置异常</span></span><br><span class="line">            _PyErr_NoMemory(tstate);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 走到这里说明一切顺利, 那么下面就开始迭代了</span></span><br><span class="line">    <span class="comment">// 如果是 map(func, [1, 2, 3], [&quot;xx&quot;, &quot;yy&quot;, &quot;zz&quot;], [2, 3, 4]), 那么第一次迭代出来的元素就是 (1, &quot;xx&quot;, 2)</span></span><br><span class="line">    Py_ssize_t nargs = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Py_ssize_t i=<span class="number">0</span>; i &lt; niters; i++) &#123;</span><br><span class="line">        <span class="comment">// 获取索引为i对应的迭代器, </span></span><br><span class="line">        PyObject *it = PyTuple_GET_ITEM(lz-&gt;iters, i);</span><br><span class="line">        <span class="comment">// Py_TYPE表示获取对象的 ob_type(类型对象), 然后调用tp_iternext成员进行迭代</span></span><br><span class="line">        <span class="comment">// 类似于 type(it).__next__(it)</span></span><br><span class="line">        PyObject *val = Py_TYPE(it)-&gt;tp_iternext(it);</span><br><span class="line">        <span class="comment">// 如果val为NULL, 直接跳转到 exit 这个label中</span></span><br><span class="line">        <span class="keyword">if</span> (val == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将 val 设置在数组索引为i的位置中, 然后进行下一轮循环, 也就是获取下一个迭代器中的元素设置在数组stack中</span></span><br><span class="line">        <span class="built_in">stack</span>[i] = val;</span><br><span class="line">        <span class="comment">// nargs++, 和参数个数、迭代器个数 保持一致</span></span><br><span class="line">        <span class="comment">// 如果可迭代对象个数是3, 那么小于5, 所以stack会申请在栈区; 但是在栈区申请的话, 长度默认为5, 因此后两个是元素是无效的</span></span><br><span class="line">        <span class="comment">// 所以在调用的时候需要指定有效的参数个数</span></span><br><span class="line">        nargs++;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 进行调用, 得到结果, 这个函数是Python3.9新增的; 如果是Python3.8的话, 调用的是_PyObject_FastCall</span></span><br><span class="line">    result = _PyObject_VectorcallTstate(tstate, lz-&gt;func, <span class="built_in">stack</span>, nargs, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>:</span><br><span class="line">    <span class="comment">// 调用完毕之后, 将stack中指针指向的对象的引用计数减1</span></span><br><span class="line">    <span class="keyword">for</span> (Py_ssize_t i=<span class="number">0</span>; i &lt; nargs; i++) &#123;</span><br><span class="line">        Py_DECREF(<span class="built_in">stack</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不相等的话, 说明该stack是在堆区申请的, 要释放</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">stack</span> != small_stack) &#123;</span><br><span class="line">        PyMem_Free(<span class="built_in">stack</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回result</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>然后突然发现map对象还有一个鲜为人知的一个方法，也是一个没有什么卵用的方法。说来惭愧，要不是看源码，我还真没注意过。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">map_reduce</span><span class="params">(mapobject *lz, PyObject *Py_UNUSED(ignored))</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">// 获取迭代器的元素个数</span></span><br><span class="line">    Py_ssize_t numargs = PyTuple_GET_SIZE(lz-&gt;iters);</span><br><span class="line">    <span class="comment">// 申请一个元素, 空间是numargs + 1 个</span></span><br><span class="line">    PyObject *args = PyTuple_New(numargs+<span class="number">1</span>);</span><br><span class="line">    Py_ssize_t i;</span><br><span class="line">    <span class="keyword">if</span> (args == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    Py_INCREF(lz-&gt;func);</span><br><span class="line">    <span class="comment">// 将函数设置为args的第一个元素</span></span><br><span class="line">    PyTuple_SET_ITEM(args, <span class="number">0</span>, lz-&gt;func);</span><br><span class="line">    <span class="comment">// 然后再将剩下的迭代器也设置在args中</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;numargs; i++)&#123;</span><br><span class="line">        PyObject *it = PyTuple_GET_ITEM(lz-&gt;iters, i);</span><br><span class="line">        Py_INCREF(it);</span><br><span class="line">        PyTuple_SET_ITEM(args, i+<span class="number">1</span>, it);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 将 Py_TYPE(lz) 和 args 打包成一个元组返回</span></span><br><span class="line">    <span class="comment">// 所以从结果上看, 返回的内容应该是: ( &lt;class &#x27;map&#x27;&gt;, (函数, 迭代器1, 迭代器2, 迭代器3, ......) )</span></span><br><span class="line">    <span class="keyword">return</span> Py_BuildValue(<span class="string">&quot;ON&quot;</span>, Py_TYPE(lz), args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyMethodDef map_methods[] = &#123;</span><br><span class="line">    <span class="comment">// 然后这个函数叫 __reduce__</span></span><br><span class="line">    &#123;<span class="string">&quot;__reduce__&quot;</span>,   (PyCFunction)map_reduce,   METH_NOARGS, reduce_doc&#125;,</span><br><span class="line">    &#123;<span class="literal">NULL</span>,           <span class="literal">NULL</span>&#125;           <span class="comment">/* sentinel */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>然后我们来演示一下：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pprint <span class="keyword">import</span> pprint</span><br><span class="line"></span><br><span class="line">m = <span class="built_in">map</span>(<span class="keyword">lambda</span> x, y, z: x + y + z, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line">pprint(m.__reduce__())</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">(&lt;class &#x27;map&#x27;&gt;,</span></span><br><span class="line"><span class="string"> (&lt;function &lt;lambda&gt; at 0x000001D2791451F0&gt;,</span></span><br><span class="line"><span class="string">  &lt;list_iterator object at 0x000001D279348640&gt;,</span></span><br><span class="line"><span class="string">  &lt;list_iterator object at 0x000001D279238700&gt;,</span></span><br><span class="line"><span class="string">  &lt;list_iterator object at 0x000001D27950AF40&gt;))</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="filter底层实现"><a href="#filter底层实现" class="headerlink" title="filter底层实现"></a>filter底层实现</h3><p><strong>然后我们filter的实现原理，看完了map之后，再看filter就简单许多了。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x % <span class="number">2</span> !=<span class="number">0</span>, lst)))  <span class="comment"># [1, 3, 5]</span></span><br></pre></td></tr></table></figure>

<p><strong>首先filter接收两个元素，第一个参数是一个函数（类、方法），第二个参数是一个可迭代对象。然后当我们迭代的时候会将可迭代对象中每一个元素都传入到函数中，如果返回的结果为真，则保留；为假，则丢弃。</strong></p>
<p><strong>但是，其实第一个参数除了是一个可调用的对象之外，它还可以是None。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lst = [<span class="string">&quot;夏色祭&quot;</span>, <span class="string">&quot;&quot;</span>, [], <span class="number">123</span>, <span class="number">0</span>, &#123;&#125;, [<span class="number">1</span>]]</span><br><span class="line"><span class="comment"># 会自动选择结果为真的元素</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="literal">None</span>, lst)))  <span class="comment"># [&#x27;夏色祭&#x27;, 123, [1]]</span></span><br></pre></td></tr></table></figure>

<p><strong>至于为什么，一会看源码filter的实现就清楚了。</strong></p>
<p><strong>下面看看底层结构：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    PyObject *func;</span><br><span class="line">    PyObject *it;</span><br><span class="line">&#125; filterobject;</span><br></pre></td></tr></table></figure>

<p><strong>我们看到和map对象是一致的，没有什么区别。因为map、filter都不会立刻调用，而是返回一个相应的对象。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">filter_new</span><span class="params">(PyTypeObject *type, PyObject *args, PyObject *kwds)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyObject *func, *seq;  <span class="comment">// 函数、可迭代对象</span></span><br><span class="line">    PyObject *it;  <span class="comment">// 可迭代对象的迭代器</span></span><br><span class="line">    filterobject *lz;  <span class="comment">// 返回值, filter对象</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">// filter也不接受关键字参数</span></span><br><span class="line">    <span class="keyword">if</span> (type == &amp;PyFilter_Type &amp;&amp; !_PyArg_NoKeywords(<span class="string">&quot;filter&quot;</span>, kwds))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 只接受两个参数</span></span><br><span class="line">    <span class="keyword">if</span> (!PyArg_UnpackTuple(args, <span class="string">&quot;filter&quot;</span>, <span class="number">2</span>, <span class="number">2</span>, &amp;func, &amp;seq))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取seq对应的迭代器</span></span><br><span class="line">    it = PyObject_GetIter(seq);</span><br><span class="line">    <span class="keyword">if</span> (it == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为filter对象申请空间</span></span><br><span class="line">    lz = (filterobject *)type-&gt;tp_alloc(type, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (lz == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Py_DECREF(it);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 增加函数的引用计数</span></span><br><span class="line">    Py_INCREF(func);</span><br><span class="line">    <span class="comment">// 初始化成员</span></span><br><span class="line">    lz-&gt;func = func;</span><br><span class="line">    lz-&gt;it = it;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 返回</span></span><br><span class="line">    <span class="keyword">return</span> (PyObject *)lz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>和map是类似的，因为本质上它们做的事情都是差不多的，下面看看迭代过程。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">filter_next</span><span class="params">(filterobject *lz)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyObject *item; <span class="comment">// 迭代器中迭代出来的每一个元素</span></span><br><span class="line">    PyObject *it = lz-&gt;it;  <span class="comment">// 迭代器</span></span><br><span class="line">    <span class="type">long</span> ok;  <span class="comment">// 是否为真, 1表示真、0表示假</span></span><br><span class="line">    PyObject *(*iternext)(PyObject *);  <span class="comment">// 函数指针, 接收一个PyObject *, 返回一个PyObject *</span></span><br><span class="line">    <span class="comment">// 如果 func == None 或者 func == bool, 那么checktrue为真; 会走单独的方法, 所以给func传递一个None是完全合法的</span></span><br><span class="line">    <span class="type">int</span> checktrue = lz-&gt;func == Py_None || lz-&gt;func == (PyObject *)&amp;PyBool_Type;</span><br><span class="line">    <span class="comment">// 迭代器的 __next__ 方法</span></span><br><span class="line">    iternext = *Py_TYPE(it)-&gt;tp_iternext;</span><br><span class="line">    <span class="comment">// 无限循环</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 迭代出迭代器的每一个元素</span></span><br><span class="line">        item = iternext(it);</span><br><span class="line">        <span class="keyword">if</span> (item == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 如果checkture, 或者说如果func == None || func == bool</span></span><br><span class="line">        <span class="keyword">if</span> (checktrue) &#123;</span><br><span class="line">            <span class="comment">// PyObject_IsTrue(item)实际上就是在判断item是否为真, 像0、长度为0的序列、False、None为假</span></span><br><span class="line">            <span class="comment">// 另外我们在if语句的时候经常会写 if item: 这种形式, 但是很少会写 if bool(item):</span></span><br><span class="line">            <span class="comment">// 因为bool(item)底层也是调用 PyObject_IsTrue</span></span><br><span class="line">            <span class="comment">// 而if item: 如果你查看它的字节码的话, 会发现有这么一条指令: POP_JUMP_IF_FALSE</span></span><br><span class="line">            <span class="comment">// 它在底层也是调用了 PyObject_IsTrue, 因此完全没有必要写成 if bool(item): 这种形式</span></span><br><span class="line">            ok = PyObject_IsTrue(item);</span><br><span class="line">            <span class="comment">// 而如果func为None或者bool的话, 那么直接走PyObject_IsTrue</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则的话, 会调用我们传递的func</span></span><br><span class="line">            <span class="comment">// 这里的 good 就是函数调用的返回值</span></span><br><span class="line">            PyObject *good;</span><br><span class="line">            <span class="comment">// 调用函数, 将返回值赋值给good</span></span><br><span class="line">            good = PyObject_CallFunctionObjArgs(lz-&gt;func, item, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="comment">// 如果 good 等于 NULL, 说明函数调用失败; 说句实话, 源码中做的很多异常捕获都是针对解释器内部的</span></span><br><span class="line">            <span class="comment">// 尤其像底层这种和NULL进行比较的, 我们在使用Python的时候, 很少会出现</span></span><br><span class="line">            <span class="keyword">if</span> (good == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                Py_DECREF(item);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断 good 是否为真</span></span><br><span class="line">            ok = PyObject_IsTrue(good);</span><br><span class="line">            Py_DECREF(good); <span class="comment">// 减少其引用计数, 因为它不被外界所使用</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果ok大于0, 说明将item传给函数调用之后返回的结果为真, 那么将item返回</span></span><br><span class="line">        <span class="keyword">if</span> (ok &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> item;</span><br><span class="line">        <span class="comment">// 同时减少其引用计数</span></span><br><span class="line">        <span class="comment">// 如果等于0, 说明为假, 那么进行下一轮循环</span></span><br><span class="line">        Py_DECREF(item);</span><br><span class="line">        <span class="comment">// 小于0的话, 表示PyObject_IsTrue调用失败了, 调用失败会返回-1</span></span><br><span class="line">        <span class="comment">// 但还是那句话, 这种情况, 在Python的使用层面上几乎不可能发生</span></span><br><span class="line">        <span class="keyword">if</span> (ok &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所以看到这里你还觉得Python神秘吗，从源代码层面我们看的非常流畅，只要你有一定的C语言基础即可。还是那句话，尽管我们不可能写一个解释器，因为背后涉及的东西太多了，但至少我们在看的过程中，很清楚底层到底在做什么。而且这背后的实现，如果让你设计一个方案的话，那么相信你也一样可以做到。</strong></p>
<p><strong>还是拿关键字 in 举例子，像<code>&quot;b&quot; in [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</code>我们知道结果为真。那如果让你设计关键字 in 的实现，你会怎么做呢？反正基本上都会想到，遍历 in 后面的可迭代对象呗，将里面的元素 依次和  in前面的元素进行比较，如果出现相等的，返回真；遍历完了也没发现相等的，那么返回假。如果你是这么想的，那么恭喜你，Python解释器内部也是这么做的，我们以列表为例：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// item in 列表: 本质上就是调用 list.__contains__(列表, item) 或者 列表.__contains__(item)</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">list_contains</span><span class="params">(PyListObject *a, PyObject *el)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyObject *item; <span class="comment">// 列表中的每一个元素</span></span><br><span class="line">    Py_ssize_t i;  <span class="comment">// 循环变量</span></span><br><span class="line">    <span class="type">int</span> cmp;  <span class="comment">// 比较的结果</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">// cmp初始为0</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, cmp = <span class="number">0</span> ; cmp == <span class="number">0</span> &amp;&amp; i &lt; Py_SIZE(a); ++i) &#123;</span><br><span class="line">        <span class="comment">// 获取PyListObject中的每一个元素</span></span><br><span class="line">        item = PyList_GET_ITEM(a, i);</span><br><span class="line">        Py_INCREF(item);</span><br><span class="line">        <span class="comment">// 调用PyObject_RichCompareBool进行比较, 大于、小于、不等于之类的都是使用这个函数, 具体是哪一种则通过第三个参数控制</span></span><br><span class="line">        <span class="comment">// 而前两个元素则是比较的对象</span></span><br><span class="line">        cmp = PyObject_RichCompareBool(el, item, Py_EQ);</span><br><span class="line">        Py_DECREF(item);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果出现相等的元素, 那么cmp为1, 因此cmp == 0 &amp;&amp; i &lt; Py_SIZE(a)会不成立, 直接结束循环</span></span><br><span class="line">    <span class="comment">// 如果没有出现相等的元素, 那么会一直遍历整个列表, 始终没有出现相等的元素, 那么cmp还是0</span></span><br><span class="line">    <span class="comment">// 为1代表真, 为0代表假</span></span><br><span class="line">    <span class="keyword">return</span> cmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>以上便是关键字  in，是不是很简单呢？所以个人推荐没事的话可以多读一读Python解释器，如果你不使用Python &#x2F; C  API进行编程的话，那么不需要你有太高的C语言水平（况且现在还有Cython）。如果你想写出高质量、并且精简利落的Python代码，那么就势必要懂得背后的实现原理。比如：我们看几道思考题，自己乱编的。</strong></p>
<p><strong>1. 为什么 方法一 要比 方法二 更高效？</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法一</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>():</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">f&quot;item: <span class="subst">&#123;item&#125;</span>&quot;</span> <span class="keyword">for</span> item <span class="keyword">in</span> lst]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法二</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f2</span>():</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> lst:</span><br><span class="line">        res.append(<span class="string">f&quot;item: <span class="subst">&#123;item&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>所以这道题考察的实际上是列表解析为什么更快？首先Python中的变量在底层本质上都是一个泛型指针PyObject *，调用res.append的时候实际上会进行一次属性查找。会调用 <code>PyObject_GetAttr(res, &quot;append&quot;)</code> ，去寻找该对象是否有 append  函数，如果有的话，那么进行获取然后调用；而列表解析，Python在编译的时候看到左右的两个中括号就知道这是一个列表解析式，所以它会立刻知道自己该干什么，会直接调用C一级函数 PyList_Append，因为Python对这些内置对象非常熟悉。所以列表解析少了一层属性查找的过程，因此它的效率会更高。</strong></p>
</blockquote>
<p><strong>2.  假设有三个变量a、b、c，三个常量 “xxx”、123、3.14，我们要判断这三个变量对应的值 和  这三个常量是否相等，该怎么做呢？注意：顺序没有要求，可以是 a &#x3D;&#x3D; “xxx”、也可以是 b  &#x3D;&#x3D; “xxx”，只要这个三个变量对应的值正好也是 “xxx”、123、3.14 就行。</strong></p>
<p><strong>显然最方便的是使用集合：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a, b, c = <span class="number">3.14</span>, <span class="string">&quot;xxx&quot;</span>, <span class="number">123</span></span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">not</span> &#123;a, b, c&#125; - &#123;<span class="string">&quot;xxx&quot;</span>, <span class="number">3.14</span>, <span class="number">123</span>&#125;)  <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<p><strong>3. 令人困惑的生成器解析式，请问下面哪段代码会报错？</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 代码一</span></span><br><span class="line">x = (<span class="string">&quot;xxx&quot;</span> <span class="keyword">for</span> _ <span class="keyword">in</span> dasdasdad)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 代码二</span></span><br><span class="line">x = (dasdasdad <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="string">&quot;xxx&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>首先生成器解析式，只有在执行的时候才会真正的产出值。但是关键字 in 后面的变量是会提前确定的，所以代码一会报错，抛出 NameError；但代码二不会，因为只有在产出值的时候才会去寻找变量 dasdasdad 指向的值。</strong></p>
<p><strong>再留个两个思考题，为什么会出现这种结果呢？</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 思考题一: </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    x = <span class="number">123</span></span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line">    lst = [x <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)]</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">123</span></span><br><span class="line"><span class="string">NameError: name &#x27;x&#x27; is not defined</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">########################################################################</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 思考题二: </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line">    a = <span class="number">123</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">eval</span>(<span class="string">&quot;a&quot;</span>))</span><br><span class="line">    <span class="built_in">print</span>([<span class="built_in">eval</span>(<span class="string">&quot;a&quot;</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)])</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">123</span></span><br><span class="line"><span class="string">NameError: name &#x27;a&#x27; is not defined</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>像这样类似的问题还有很多很多，当然最关键的还是理解底层的数据结构 以及 解释器背后的执行原理，只有这样才能写出更加高效的代码。</strong></p>
<p><strong>回到正题，filter 也有 <strong>reduce</strong> 方法，和 map 类似。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="built_in">filter</span>(<span class="literal">None</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="string">&quot;&quot;</span>, [], <span class="string">&quot;xx&quot;</span>])</span><br><span class="line"><span class="built_in">print</span>(f.__reduce__())  <span class="comment"># (&lt;class &#x27;filter&#x27;&gt;, (None, &lt;list_iterator object at 0x00000239AF2AB0D0&gt;))</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(f.__reduce__()[<span class="number">1</span>][<span class="number">1</span>]))  <span class="comment"># [1, 2, 3, 0, &#x27;&#x27;, [], &#x27;xx&#x27;]</span></span><br></pre></td></tr></table></figure>

<h3 id="zip底层实现"><a href="#zip底层实现" class="headerlink" title="zip底层实现"></a>zip底层实现</h3><p><strong>最后看看 zip，其实 zip 和 map 也是有着高度相似之处的，首先它们都可以接受任意个可迭代对象。而且 zip，我们完全可以使用 map 来进行模拟。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(</span><br><span class="line">    <span class="built_in">list</span>(<span class="built_in">zip</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>], [<span class="number">111</span>, <span class="number">222</span>, <span class="number">333</span>]))</span><br><span class="line">)  <span class="comment"># [(1, 11, 111), (2, 22, 222), (3, 33, 333)]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(</span><br><span class="line">    <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x, y, z: (x, y, z), [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>], [<span class="number">111</span>, <span class="number">222</span>, <span class="number">333</span>]))</span><br><span class="line">)  <span class="comment"># [(1, 11, 111), (2, 22, 222), (3, 33, 333)]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(</span><br><span class="line">    <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> *args: args, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>], [<span class="number">111</span>, <span class="number">222</span>, <span class="number">333</span>]))</span><br><span class="line">)  <span class="comment"># [(1, 11, 111), (2, 22, 222), (3, 33, 333)]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 所以我们看到实现zip, 完全可以使用 map, 只需要多指定一个函数即可</span></span><br></pre></td></tr></table></figure>

<p><strong>所以 zip 的底层实现同样很简单，我们来看一下：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    Py_ssize_t          tuplesize;</span><br><span class="line">    PyObject *ittuple;                  </span><br><span class="line">    PyObject *result;</span><br><span class="line">&#125; zipobject;</span><br><span class="line"><span class="comment">// 以上便是zip对象的底层定义, 这些字段的含义, 我们暂时先不讨论, 它们会体现在zip_new方法中, 我们到时候再说</span></span><br></pre></td></tr></table></figure>

<p><strong>目前我们根据结构体里面的成员，可以得到一个 zipobject 显然是占 40 字节的，16 + 8 + 8 + 8，那么结果是不是这样呢？我们来试一下就知道了。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">z1 = <span class="built_in">zip</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>])</span><br><span class="line">z2 = <span class="built_in">zip</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>])</span><br><span class="line">z3 = <span class="built_in">zip</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>], [<span class="number">111</span>, <span class="number">222</span>, <span class="number">333</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(z1.__sizeof__())  <span class="comment"># 40  </span></span><br><span class="line"><span class="built_in">print</span>(z2.__sizeof__())  <span class="comment"># 40</span></span><br><span class="line"><span class="built_in">print</span>(z3.__sizeof__())  <span class="comment"># 40</span></span><br></pre></td></tr></table></figure>

<p><strong>所以我们分析的没有错，任何一个 zip 对象所占的大小都是 40 字节。所以在计算内存大小的时候，有人会好奇这到底是怎么计算的，其实就是根据底层的结构体进行计算的。</strong></p>
<blockquote>
<p><strong>注意：如果你使用 sys.getsizeof 函数计算的话，可能会多出  16 个字节，这是因为对于可变对象，它们是会被 GC 跟踪的。在创建的时候，它们会被挂到零代链表中，所以它们额外还会有一个 前继指针 和 一个  后继指针，而 sys.getsizeof 将这两个指针的大小也算在内了。</strong></p>
</blockquote>
<p><strong>下面看看 zip 对象是如何被实例化的。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">zip_new</span><span class="params">(PyTypeObject *type, PyObject *args, PyObject *kwds)</span></span><br><span class="line">&#123;</span><br><span class="line">    zipobject *lz;  <span class="comment">// zip 对象</span></span><br><span class="line">    Py_ssize_t i;  <span class="comment">// 循环变量</span></span><br><span class="line">    PyObject *ittuple;  <span class="comment">// 所有可迭代对象的迭代器组成的元组</span></span><br><span class="line">    PyObject *result;   <span class="comment">// &quot;代码中有体现&quot;</span></span><br><span class="line">    Py_ssize_t tuplesize;  <span class="comment">// 可迭代对象的数量</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">// zip同样不需要关键字参数, 但是在3.10的时候将会提供一个关键字参数strict, 如果为True, 表示可迭代对象之间的长度必须相等, 否则报错</span></span><br><span class="line">    <span class="comment">// strict如果为False, 则和目前是等价的, 会自动以短的为准</span></span><br><span class="line">    <span class="keyword">if</span> (type == &amp;PyZip_Type &amp;&amp; !_PyArg_NoKeywords(<span class="string">&quot;zip&quot;</span>, kwds))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// args必须使用一个PyTupleObject *</span></span><br><span class="line">    assert(PyTuple_Check(args));</span><br><span class="line">    <span class="comment">// 获取可迭代对象的数量</span></span><br><span class="line">    tuplesize = PyTuple_GET_SIZE(args);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 申请一个元组, 长度为tuplesize, 用于存放可迭代对象对应的迭代器</span></span><br><span class="line">    ittuple = PyTuple_New(tuplesize);</span><br><span class="line">    <span class="keyword">if</span> (ittuple == <span class="literal">NULL</span>) <span class="comment">// 为NULL表示申请失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 然后依次遍历</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; tuplesize; ++i) &#123;</span><br><span class="line">        <span class="comment">// 获取传递的可迭代对象</span></span><br><span class="line">        PyObject *item = PyTuple_GET_ITEM(args, i);</span><br><span class="line">        <span class="comment">// 通过PyObject_GetIter获取对应的迭代器</span></span><br><span class="line">        PyObject *it = PyObject_GetIter(item);</span><br><span class="line">        <span class="keyword">if</span> (it == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 为NULL表示获取失败, 减少ittuple的引用计数, 返回NULL</span></span><br><span class="line">            Py_DECREF(ittuple);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置在ittuple中</span></span><br><span class="line">        PyTuple_SET_ITEM(ittuple, i, it);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里又申请一个元组result, 长度也为tuplesize</span></span><br><span class="line">    result = PyTuple_New(tuplesize);</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Py_DECREF(ittuple);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 然后将内部的所有元素都设置为None, Py_None就是Python中的None</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span> ; i &lt; tuplesize ; i++) &#123;</span><br><span class="line">        Py_INCREF(Py_None);</span><br><span class="line">        PyTuple_SET_ITEM(result, i, Py_None);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 申请一个zip对象</span></span><br><span class="line">    lz = (zipobject *)type-&gt;tp_alloc(type, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 申请失败减少引用计数, 返回NULL</span></span><br><span class="line">    <span class="keyword">if</span> (lz == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Py_DECREF(ittuple);</span><br><span class="line">        Py_DECREF(result);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 初始化成员</span></span><br><span class="line">    lz-&gt;ittuple = ittuple;</span><br><span class="line">    lz-&gt;tuplesize = tuplesize;</span><br><span class="line">    lz-&gt;result = result;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 转成泛型指针PyObject *之后返回</span></span><br><span class="line">    <span class="keyword">return</span> (PyObject *)lz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>再来看看，zip对象的定义：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    Py_ssize_t          tuplesize;</span><br><span class="line">    PyObject *ittuple;                  </span><br><span class="line">    PyObject *result;</span><br><span class="line">&#125; zipobject;</span><br></pre></td></tr></table></figure>

<p><strong>如果以：<code>zip([1, 2, 3], [11, 22, 33], [111, 222, 333])</code>为例的话，那么：</strong></p>
<ul>
<li><code>tuplesize: 3</code></li>
<li><code>ittuple: ([1, 2, 3].__iter__(), [11, 22, 33].__iter__(), [111, 222, 333].__iter__())</code></li>
<li><code>result: (None, None, None)</code></li>
</ul>
<p><strong>所以目前来说，其它的很好理解，唯独这个result让人有点懵，搞不懂它是干什么的。不过既然有这个成员，那就说明它肯定有用武之地，而派上用场的地方不用想，肯定是在迭代的时候使用。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">zip_next</span><span class="params">(zipobject *lz)</span></span><br><span class="line">&#123;</span><br><span class="line">    Py_ssize_t i; <span class="comment">// 循环遍变量</span></span><br><span class="line">    Py_ssize_t tuplesize = lz-&gt;tuplesize;  <span class="comment">// 可迭代对象数量</span></span><br><span class="line">    PyObject *result = lz-&gt;result;   <span class="comment">// (None, None, ....)</span></span><br><span class="line">    PyObject *it;  <span class="comment">// 每一个迭代器 </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 代码中体现</span></span><br><span class="line">    PyObject *item;</span><br><span class="line">    PyObject *olditem;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// tuplesize == 0, 直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (tuplesize == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 如果 result 的引用计数为1, 证明该元组的空间的被申请了</span></span><br><span class="line">    <span class="keyword">if</span> (Py_REFCNT(result) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 因为它要作为返回值返回, 引用计数加1</span></span><br><span class="line">        Py_INCREF(result);</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span> ; i &lt; tuplesize ; i++) &#123;</span><br><span class="line">            <span class="comment">// 依次获取每一个迭代器</span></span><br><span class="line">            it = PyTuple_GET_ITEM(lz-&gt;ittuple, i);</span><br><span class="line">            <span class="comment">// 迭代出相应的元素</span></span><br><span class="line">            item = (*Py_TYPE(it)-&gt;tp_iternext)(it);</span><br><span class="line">            <span class="comment">// 如果出现了NULL, 证明迭代结束了, 会直接停止</span></span><br><span class="line">            <span class="comment">// 所以会以元素最少的可迭代对象(迭代器)为准</span></span><br><span class="line">            <span class="keyword">if</span> (item == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                Py_DECREF(result);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 设置在 result 中, 但是要先获取result中原来的元素, 并将其引用计数减1, 因为元组不再持有对它的引用</span></span><br><span class="line">            olditem = PyTuple_GET_ITEM(result, i);</span><br><span class="line">            PyTuple_SET_ITEM(result, i, item);</span><br><span class="line">            Py_DECREF(olditem);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则的话同样的逻辑, 只不过需要自己重新手动申请一个tuple</span></span><br><span class="line">        result = PyTuple_New(tuplesize);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">// 然后下面的逻辑是类似的</span></span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span> ; i &lt; tuplesize ; i++) &#123;</span><br><span class="line">            it = PyTuple_GET_ITEM(lz-&gt;ittuple, i);</span><br><span class="line">            item = (*Py_TYPE(it)-&gt;tp_iternext)(it);</span><br><span class="line">            <span class="keyword">if</span> (item == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                Py_DECREF(result);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            PyTuple_SET_ITEM(result, i, item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回元组 result</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所以当我们进行迭代的时候，迭代出来的是一个元组。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">z = <span class="built_in">zip</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>])</span><br><span class="line"><span class="built_in">print</span>(z.__next__())  <span class="comment"># (1, 11)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 即使只有一个可迭代对象, 依旧是一个元组, 因为底层返回的result就是一个元组</span></span><br><span class="line">z = <span class="built_in">zip</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(z.__next__())  <span class="comment"># (1,)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可迭代对象的嵌套也是一样的规律, 直接把里面的列表看成一个标量即可</span></span><br><span class="line">z = <span class="built_in">zip</span>([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>]])</span><br><span class="line"><span class="built_in">print</span>(z.__next__())  <span class="comment"># ([1, 2, 3],)</span></span><br></pre></td></tr></table></figure>

<p><strong>最后，zip 也有一个__reduce__ 方法：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">z = <span class="built_in">zip</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>])</span><br><span class="line"><span class="built_in">print</span>(z.__reduce__())</span><br><span class="line"><span class="comment"># (&lt;class &#x27;zip&#x27;&gt;, (&lt;list_iterator object at 0x0000018D1723B0D0&gt;, &lt;list_iterator object at 0x0000018D1723B040&gt;))</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>([<span class="built_in">tuple</span>(_) <span class="keyword">for</span> _ <span class="keyword">in</span> z.__reduce__()[<span class="number">1</span>]])  <span class="comment"># [(1, 2, 3), (11, 22, 33)]</span></span><br></pre></td></tr></table></figure>

<h3 id="map、filter-和-列表解析之间的区别"><a href="#map、filter-和-列表解析之间的区别" class="headerlink" title="map、filter 和 列表解析之间的区别"></a>map、filter 和 列表解析之间的区别</h3><p><strong>其实在使用 map、filter 的时候，我们完全可以使用列表解析来实现。比如：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>([<span class="built_in">str</span>(_) <span class="keyword">for</span> _ <span class="keyword">in</span> lst])  <span class="comment"># [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">str</span>, lst)))  <span class="comment"># [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;]</span></span><br></pre></td></tr></table></figure>

<p><strong>这两者之间实际上是没有什么太大区别的，都是将 lst  中的元素一个一个迭代出来、然后调用 str 、返回结果。如果非要找出区别话，就是列表解析使用的是 Python  的for循环，而调用list的时候使用的是C中的for循环。从这个角度来说，使用 map 的效率会更高一些。</strong></p>
<p><img src="/2023/04/26/29-%E6%BA%90%E7%A0%81%E8%A7%A3%E5%AF%86-map%E3%80%81filter%E3%80%81zip-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%EF%BC%8C%E5%AF%B9%E6%AF%94%E5%88%97%E8%A1%A8%E8%A7%A3%E6%9E%90%E5%BC%8F/1229382-20201125193830267-1530099100.png" alt="img"></p>
<p><strong>所以后者的效率稍微更高一些，因为列表解析用的是 Python 的for循环，<code>list(map(func, iter))</code> 用的是C的for循环。但是注意：如果是下面这种做法的话，会得到相反的结果。</strong></p>
<p><img src="/2023/04/26/29-%E6%BA%90%E7%A0%81%E8%A7%A3%E5%AF%86-map%E3%80%81filter%E3%80%81zip-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%EF%BC%8C%E5%AF%B9%E6%AF%94%E5%88%97%E8%A1%A8%E8%A7%A3%E6%9E%90%E5%BC%8F/1229382-20201125193834669-1119332528.png" alt="img"></p>
<p><strong>我们看到 map 貌似变慢了，其实原因很简单，后者多了一层匿名函数的调用，所以速度变慢了。</strong></p>
<p><strong>如果列表解析也是函数调用的话：</strong></p>
<p><img src="/2023/04/26/29-%E6%BA%90%E7%A0%81%E8%A7%A3%E5%AF%86-map%E3%80%81filter%E3%80%81zip-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%EF%BC%8C%E5%AF%B9%E6%AF%94%E5%88%97%E8%A1%A8%E8%A7%A3%E6%9E%90%E5%BC%8F/1229382-20201125193841219-1119337106.png" alt="img"></p>
<p><strong>会发现速度更慢了，当然这种做法完全是吃饱了撑的。之所以说这些，是想说明在同等条件下，list(map)  这种形式是要比列表解析快的。当然在工作中，这两者都是可以使用的，这点效率上的差别其实不用太在意，如果真的到了需要在乎这点差别的时候，那么你应该考虑的是换一门更有效率的静态语言。</strong></p>
<p><strong>filter 和 列表解析之间的差别，也是如此。</strong></p>
<p><img src="/2023/04/26/29-%E6%BA%90%E7%A0%81%E8%A7%A3%E5%AF%86-map%E3%80%81filter%E3%80%81zip-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%EF%BC%8C%E5%AF%B9%E6%AF%94%E5%88%97%E8%A1%A8%E8%A7%A3%E6%9E%90%E5%BC%8F/1229382-20201125193847064-600779731.png" alt="img"></p>
<p><strong>对于过滤含有 1000个 False 和 1个True  的元组，它们的结果都是一样的，但是谁的效率更高呢？首先第一种方式 肯定比  第二种方式快，因为第二种方式涉及到函数的调用；但是第三种方式，我们知道它在底层会走单独的分支，所以再加上之前的结论，我们认为第三种方式是最快的。</strong></p>
<p><img src="/2023/04/26/29-%E6%BA%90%E7%A0%81%E8%A7%A3%E5%AF%86-map%E3%80%81filter%E3%80%81zip-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%EF%BC%8C%E5%AF%B9%E6%AF%94%E5%88%97%E8%A1%A8%E8%A7%A3%E6%9E%90%E5%BC%8F/1229382-20201125193853552-1339478062.png" alt="img"></p>
<p><strong>结果也确实是我们分析的这样，当然我们说在底层 None 和 bool  都会走相同的分支，所以这里将 None 换成 bool 也是可以的。虽然 bool 是一个类，但是通过 filter_new  函数我们知道，底层不会进行调用，也是直接使用 PyObject_IsTrue，可以将 None 换成 bool 看看结果如何，应该是差不多的。</strong></p>
<p><img src="/2023/04/26/29-%E6%BA%90%E7%A0%81%E8%A7%A3%E5%AF%86-map%E3%80%81filter%E3%80%81zip-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%EF%BC%8C%E5%AF%B9%E6%AF%94%E5%88%97%E8%A1%A8%E8%A7%A3%E6%9E%90%E5%BC%8F/1229382-20201125193858542-1189251065.png" alt="img"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>所以 map、filter 完全可以使用列表解析替代，如果执行的逻辑比较复杂的话，那么对于 map、filter 而言就要写匿名函数了。但逻辑简单的话，比如：获取为真的元素，完全可以通过<code>list(filter(None, lst))</code>实现，效率更高，因为它走的是相当于是C的循环；但如果获取大于3的元素，那么就需要使用<code>list(filter(lambda x: x &gt; 3, lst))</code>这种形式了，而我们说它的效率是不如列表解析<code>[x for x in lst if x &gt; 3]</code>的，因为前者多了一层函数调用。</strong></p>
<p><strong>但是在工作中，这两种方式都是可以的，使用哪一种就看个人喜好。到此我们发现，如果排除那一点点效率上的差异，那么确实有列表解析式就完全足够了，因为列表解析式可以同时实现 map、filter 的功能，而且表达上也更加地直观。只不过是 map、filter 先出现，然后才有的列表解析式，但是前者依旧被保留了下来。</strong></p>
<blockquote>
<p><strong>当然 map、filter 返回的是一个可迭代对象，它不会立即计算，可以节省资源；当然这个功能，我们也可以通过生成器表达式来实现。</strong></p>
</blockquote>
<p><strong>map、filter、zip 的底层实现我们就看完了，是不是很简单呢？</strong></p>
<blockquote>
<p><strong>另外，如果你得到的结论和我这里的不一致，那么不妨把可迭代对象的元素个数设置的稍微大一些，最终结论和我这里一定是一样的。</strong></p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Lin Li</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/04/26/29-%E6%BA%90%E7%A0%81%E8%A7%A3%E5%AF%86-map%E3%80%81filter%E3%80%81zip-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%EF%BC%8C%E5%AF%B9%E6%AF%94%E5%88%97%E8%A1%A8%E8%A7%A3%E6%9E%90%E5%BC%8F/">http://example.com/2023/04/26/29-%E6%BA%90%E7%A0%81%E8%A7%A3%E5%AF%86-map%E3%80%81filter%E3%80%81zip-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%EF%BC%8C%E5%AF%B9%E6%AF%94%E5%88%97%E8%A1%A8%E8%A7%A3%E6%9E%90%E5%BC%8F/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">LinLi's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/CPython/">CPython</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/04/26/30-%E6%BA%90%E7%A0%81%E8%A7%A3%E5%AF%86%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0-iter%E3%80%81next/" title="30-源码解密内置函数 iter、next"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">30-源码解密内置函数 iter、next</div></div></a></div><div class="next-post pull-right"><a href="/2023/04/25/28-Python%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%EF%BC%9A%E6%BA%90%E7%A0%81%E8%A7%A3%E5%AF%86Python%E4%B8%AD%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/" title="28-Python内存管理与垃圾回收(第二部分)：源码解密Python中的垃圾回收机制"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">28-Python内存管理与垃圾回收(第二部分)：源码解密Python中的垃圾回收机制</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/03/29/01-%E7%BC%96%E8%AF%91Cpython/" title="01-编译Cpython"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">01-编译Cpython</div></div></a></div><div><a href="/2023/03/29/02-%E4%B8%80%E5%88%87%E5%AF%B9%E8%B1%A1%E7%9A%86PyObject/" title="02-一切对象皆PyObject"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">02-一切对象皆PyObject</div></div></a></div><div><a href="/2023/03/29/04-%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/" title="04-浮点数的底层实现"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">04-浮点数的底层实现</div></div></a></div><div><a href="/2023/03/29/06-Bytes%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BA%95%E5%B1%82%E6%93%8D%E4%BD%9C/" title="06-Bytes对象的底层操作"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">06-Bytes对象的底层操作</div></div></a></div><div><a href="/2023/03/29/03-Python%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E5%99%A8%E5%92%8C%E5%BA%95%E5%B1%82%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86/" title="03-Python引用计数器和底层对象管理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">03-Python引用计数器和底层对象管理</div></div></a></div><div><a href="/2023/03/29/05-Python%E6%95%B4%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/" title="05-Python整数的底层实现"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">05-Python整数的底层实现</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Lin Li</div><div class="author-info__description">今日事，今日毕</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">122</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#29-%E6%BA%90%E7%A0%81%E8%A7%A3%E5%AF%86-map%E3%80%81filter%E3%80%81zip-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%EF%BC%8C%E5%AF%B9%E6%AF%94%E5%88%97%E8%A1%A8%E8%A7%A3%E6%9E%90%E5%BC%8F"><span class="toc-number">1.</span> <span class="toc-text">29-源码解密 map、filter、zip 底层实现，对比列表解析式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A5%94%E5%AD%90"><span class="toc-number">1.1.</span> <span class="toc-text">楔子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.2.</span> <span class="toc-text">map底层实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#filter%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.3.</span> <span class="toc-text">filter底层实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#zip%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.4.</span> <span class="toc-text">zip底层实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map%E3%80%81filter-%E5%92%8C-%E5%88%97%E8%A1%A8%E8%A7%A3%E6%9E%90%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.5.</span> <span class="toc-text">map、filter 和 列表解析之间的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.6.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/08/%E8%A7%A3%E5%86%B3Camera-ready-%E2%9C%98-Problem-Not-all-fonts-are-embedded-%E9%97%AE%E9%A2%98/" title="解决Camera ready ✘ Problem: Not all fonts are embedded. 问题">解决Camera ready ✘ Problem: Not all fonts are embedded. 问题</a><time datetime="2025-04-08T14:19:21.000Z" title="发表于 2025-04-08 22:19:21">2025-04-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/21/Sequence-Oriented-DBMS-Fuzzing/" title="Sequence-Oriented DBMS Fuzzing">Sequence-Oriented DBMS Fuzzing</a><time datetime="2025-02-21T09:35:08.000Z" title="发表于 2025-02-21 17:35:08">2025-02-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/18/AGENTLESS-Demystifying-LLM-based-Software-Engineering-Agents/" title="AGENTLESS: Demystifying LLM-based Software Engineering Agents">AGENTLESS: Demystifying LLM-based Software Engineering Agents</a><time datetime="2025-02-18T12:16:29.000Z" title="发表于 2025-02-18 20:16:29">2025-02-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/01/DeepSeek-R1-Incentivizing-Reasoning-Capability-in-LLMs-via-Reinforcement-Learning/" title="DeepSeek-R1: Incentivizing Reasoning Capability in LLMs via Reinforcement Learning">DeepSeek-R1: Incentivizing Reasoning Capability in LLMs via Reinforcement Learning</a><time datetime="2025-02-01T11:11:48.000Z" title="发表于 2025-02-01 19:11:48">2025-02-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/01/DeepSeek-Coder-When-the-Large-Language-Model-Meets-Programming-The-Rise-of-Code-Intelligence/" title="DeepSeek-Coder: When the Large Language Model Meets Programming - The Rise of Code Intelligence">DeepSeek-Coder: When the Large Language Model Meets Programming - The Rise of Code Intelligence</a><time datetime="2025-02-01T02:43:19.000Z" title="发表于 2025-02-01 10:43:19">2025-02-01</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Lin Li</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>