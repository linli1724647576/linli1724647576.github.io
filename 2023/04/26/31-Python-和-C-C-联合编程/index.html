<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>31-Python 和 C  C++ 联合编程 | LinLi's Blog</title><meta name="author" content="Lin Li"><meta name="copyright" content="Lin Li"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="31-Python 和 C &#x2F; C++ 联合编程楔子Python 和 C &#x2F; C++ 混合编程已经屡见不鲜了，那为什么要将这两种语言结合起来呢？或者说，这两种语言混合起来能给为我们带来什么好处呢？首先，Python 和 C &#x2F; C++ 联合，无非两种情况。  1. C &#x2F; C++ 为主导的项目中引入 Python; 2. Python 为主导的项目中引入 C &#x2F; C+">
<meta property="og:type" content="article">
<meta property="og:title" content="31-Python 和 C  C++ 联合编程">
<meta property="og:url" content="http://example.com/2023/04/26/31-Python-%E5%92%8C-C-C-%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="LinLi&#39;s Blog">
<meta property="og:description" content="31-Python 和 C &#x2F; C++ 联合编程楔子Python 和 C &#x2F; C++ 混合编程已经屡见不鲜了，那为什么要将这两种语言结合起来呢？或者说，这两种语言混合起来能给为我们带来什么好处呢？首先，Python 和 C &#x2F; C++ 联合，无非两种情况。  1. C &#x2F; C++ 为主导的项目中引入 Python; 2. Python 为主导的项目中引入 C &#x2F; C+">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2023-04-26T13:25:12.000Z">
<meta property="article:modified_time" content="2023-04-26T13:25:38.027Z">
<meta property="article:author" content="Lin Li">
<meta property="article:tag" content="CPython">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/04/26/31-Python-%E5%92%8C-C-C-%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '31-Python 和 C  C++ 联合编程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-04-26 21:25:38'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">95</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="LinLi's Blog"><span class="site-name">LinLi's Blog</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">31-Python 和 C  C++ 联合编程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-04-26T13:25:12.000Z" title="发表于 2023-04-26 21:25:12">2023-04-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-04-26T13:25:38.027Z" title="更新于 2023-04-26 21:25:38">2023-04-26</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="31-Python 和 C  C++ 联合编程"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="31-Python-和-C-x2F-C-联合编程"><a href="#31-Python-和-C-x2F-C-联合编程" class="headerlink" title="31-Python 和 C &#x2F; C++ 联合编程"></a>31-Python 和 C &#x2F; C++ 联合编程</h1><h2 id="楔子"><a href="#楔子" class="headerlink" title="楔子"></a>楔子</h2><p><strong>Python 和 C &#x2F; C++ 混合编程已经屡见不鲜了，那为什么要将这两种语言结合起来呢？或者说，这两种语言混合起来能给为我们带来什么好处呢？首先，Python 和 C &#x2F; C++ 联合，无非两种情况。</strong></p>
<ul>
<li><code>1. C / C++ 为主导的项目中引入 Python;</code></li>
<li><code>2. Python 为主导的项目中引入 C / C++;</code></li>
</ul>
<p><strong>首先是第一种情况，因为 C &#x2F; C++  是编译型语言，而它们的编译调试的成本是很大的。如果用 C &#x2F; C++  开发一个大型项目的话，比如游戏引擎，这个时候代码的修改、调试是无可避免的。而对于编译型语言来说，你对代码做任何一点改动都需要重新编译，而这个耗时是比较长的，所以这样算下来成本会非常高。这个时候一个比较不错的做法是，将那些跟性能无关的内容开放给脚本，可以是 Lua 脚本、也可以是 Python 脚本，而脚本语言不需要编译，我们可以随时修改，这样可以减少编译调试的成本。还有就是引入了 Python  脚本之后，我们可以把 C &#x2F; C++ 做的更加模块化，由 Python 将 C &#x2F; C++ 各个部分联合起来，这样可以降低 C &#x2F; C++  代码的耦合度，从而加强可重用性。</strong></p>
<p><strong>然后是第二种情况，Python 项目中引入 C &#x2F; C++。我们知道  Python 的效率不是很高，如果你希望 Python 能够具有更高的性能，那么可以把一些和性能相关的逻辑使用 C &#x2F; C++  进行重写。此外，Python 有大量的第三方库，特别是诸如 Numpy、Pandas、Scipy 等等和科学计算密切相关的库，底层都是基于 C &#x2F; C++ 的。再比如机器学习，底层核心算法都是基于 C &#x2F; C++ 编写的，然后在业务层暴露给 Python  去调用，因此对于一些需要高性能的领域，Python 是必须要引入 C &#x2F; C++ 的。此外 Python 还有一个最让人诟病的问题，就是由于  GIL 的限制导致 Python 无法有效利用多核，而引入 C &#x2F; C++ 可以绕过 GIL 的限制。</strong></p>
<blockquote>
<p><strong>此外有一个项目叫做 Cython，从名字你就能看出来这是将 Python 和 C &#x2F; C++ 结合在了一起，之所以把它们结合在一起，很明显，因为这两者不是对立的，而是互补的。Python  是高阶语言、动态、易于学习，并且灵活。但是这些优秀的特性是需要付出代价的，因为 Python  的动态性、以及它是解释型语言，导致其运行效率比静态编译型语言慢了好几个数量级。而 C &#x2F; C++  是非常古老的静态编译型语言，并且至今也被广泛使用。从时间来算的话，其编译器已有将近半个世纪的历史，在性能上做了足够的优化。而 Cython  的出现，就是为了让你编写的代码具有 C &#x2F; C++ 的高效率的同时，还能有 Python 的开发速度。</strong></p>
</blockquote>
<p><strong>而笔者本人是主 Python  的，所以我们只会介绍第二种，也就是 Python 项目中引入 C &#x2F; C++。而在 Python 中引入 C &#x2F;  C++，也涉及两种情况。第一种是，Python 通过 ctypes 模块直接调用 C &#x2F; C++ 编写好的动态链接库，此时不会涉及任何的  Python &#x2F; C API，只是单纯的通过 ctypes 模块将 Python 中的数据转成 C  中的数据传递给函数进行调用，调用完之后再将返回值转成 Python 中的数据。因此这种方式它和 Python 底层提供的 Python &#x2F; C  API 无关，和 Python  的版本也无关，因此会很方便。但很明显这种方式是有局限性的，至于局限性在哪儿，我们后面慢慢聊，因此还有一种选择是通过 C &#x2F; C++ 为  Python 编写扩展模块的方式，来在 Python 中引入 C &#x2F; C++，比如 OpenCV。</strong></p>
<p><strong>无论是 ctypes 调用动态链接库，还是 C &#x2F; C++ 为 Python 编写扩展模块，我们都会介绍。</strong></p>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p><strong>首先是 Python 的安装，估计这应该不用我说了，我这里使用的 Python 版本是 3.8.7。</strong></p>
<p><strong>然后重点是 C &#x2F; C++ 编译器的安装，我这里使用的是 64 位的 Windows 10 操作系统，所以我们需要手动安装相应的编译环境。可以下载一个 gcc，然后配置到环境变量中，就可以使用了。</strong></p>
<p><strong>或者安装 Visual Studio，我的 Visual Studio 版本是 2017，在命令行中可以通过 cl 命令进行编译。</strong></p>
<p><img src="/2023/04/26/31-Python-%E5%92%8C-C-C-%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/1229382-20210212015141779-226451671.png" alt="img"></p>
<p><strong>当然这两种命令的使用方式都是类似的，或者你也可以使用 Linux，比如  CentOS，基本上自带 gcc。当然 Linux 的话，环境什么的比较简单，这里就不再废话了。重点是如果你是在 Windows 上使用  Visual Studio 的话，在命令行中输入命令 cl，很可能会提示你命令找不到；再或者编译的时候，会提示你 fatal error  不包括路径集等等。出现以上问题的话，说明你的环境变量没有配置正确，下面来说一下环境变量的配置。再次强调，我操作系统是 64 位 Windows  10，Visual Studio 版本是  2017，相信大部分人应该我是一样的，如果完全一样的话，那么路径啥的应该也是一致的，当然最好还是检查一下。</strong></p>
<p><strong>首先在 path 中添加如下几个路径：</strong></p>
<ul>
<li><code>C:\Program Files (x86)\Microsoft Visual Studio\2017\Community\VC\Tools\MSVC\14.16.27023\bin\Hostx64\x64</code></li>
<li><code>C:\Program Files (x86)\Windows Kits\10\bin\10.0.17763.0\x64</code></li>
<li><code>C:\Program Files (x86)\Microsoft Visual Studio\2017\Community\Common7\IDE</code></li>
</ul>
<p><img src="/2023/04/26/31-Python-%E5%92%8C-C-C-%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/1229382-20210212015149372-462263121.png" alt="img"></p>
<p><strong>然后，新建一个环境变量。</strong></p>
<p><img src="/2023/04/26/31-Python-%E5%92%8C-C-C-%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/1229382-20210212015154132-1559314596.png" alt="img"></p>
<p><strong>变量名为 LIB，变量值为以下路径，由于是写在一行，所以路径之间需要使用分号进行隔开。</strong></p>
<ul>
<li><code>C:\Program Files (x86)\Windows Kits\10\Lib\10.0.17763.0\um\x64</code></li>
<li><code>C:\Program Files (x86)\Windows Kits\10\Lib\10.0.17763.0\ucrt\x64</code></li>
<li><code>C:\Program Files (x86)\Microsoft Visual Studio\2017\Community\VC\Tools\MSVC\14.16.27023\lib\x64</code></li>
</ul>
<p><strong>最后，还是新建一个环境变量，变量名为 INCLUDE，变量值为以下路径：</strong></p>
<ul>
<li><code>C:\Program Files (x86)\Windows Kits\10\Include\10.0.17763.0\ucrt</code></li>
<li><code>C:\Program Files (x86)\Windows Kits\10\Lib\10.0.17763.0\um</code></li>
<li><code>C:\Program Files (x86)\Microsoft Visual Studio\2017\Community\VC\Tools\MSVC\14.16.27023\include</code></li>
</ul>
<p><strong>以上就是 Windows 系统中配置 Visual Studio 2017 环境变量的整个过程，配置完毕之后重启命令行之后就可以使用了。注意：以上是我当前机器的路径，如果你的配置和我不一样，记得仔细检查。</strong></p>
<blockquote>
<p><strong>不过个人更习惯使用 gcc，因此后面我们会使用 gcc 进行编译。</strong></p>
</blockquote>
<h2 id="Python-ctypes-模块调用-C-x2F-C-动态链接库"><a href="#Python-ctypes-模块调用-C-x2F-C-动态链接库" class="headerlink" title="Python ctypes 模块调用 C &#x2F; C++ 动态链接库"></a>Python ctypes 模块调用 C &#x2F; C++ 动态链接库</h2><p><strong>通过 ctypes 模块（Python 自带的）调用 C &#x2F; C++  动态库，也算是 Python 和 C &#x2F; C++ 联合编程的一种方案，而且是最简单的一种方案。因为它只对你的操作系统有要求，比如 Windows 上编译的动态库是 .dll 文件，Linux 上编译的动态库是 .so 文件，只要操作系统一致，那么任何提供了 ctypes 模块的  Python 解释器都可以调用。这种方式的使用场景是 Python 和 C &#x2F; C++  不需要做太多的交互，比如嵌入式设备，可能只是简单调用底层驱动提供的某个接口而已。</strong></p>
<p><strong>再比如我们使用 C &#x2F; C++ 写了一个高性能的算法，然后通过  Python 的 ctypes 模块进行调用也是可以的，但我们之前说使用 ctypes 具有相应的局限性，这个局限性就是 C &#x2F; C++  提供的接口不能太复杂。因为 ctypes  提供的交互能力还是比较有限的，最明显的问题就是不同语言数据类型不同，一些复杂的交互方式还是比较难做到的，还有多线程的控制问题等等。</strong></p>
<h3 id="举个小栗子"><a href="#举个小栗子" class="headerlink" title="举个小栗子"></a>举个小栗子</h3><p><strong>首先我们来举个栗子，演示一下。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这是个简单到不能再简单的 C 函数，然后我们来编译成动态库。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">编译方式: gcc -o .dll文件或者.so文件 -shared c或者c++源文件</span><br></pre></td></tr></table></figure>

<p><strong>如果你用的是 Visual Studio，那么把 gcc 换成 cl 即可。我当前的源文件叫做 main.c，我们编译成 main.dll，那么命令就需要这么写：gcc -o main.dll -shared main.c。</strong></p>
<p><strong>编译成功之后，我们通过 ctypes 来进行调用。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 ctypes 很简单，直接import进来，然后使用 ctypes.CDLL 这个类来加载动态链接库</span></span><br><span class="line"><span class="comment"># 或者是用 ctypes.cdll.LoadLibrary(&quot;./main.dll&quot;)</span></span><br><span class="line">lib = ctypes.CDLL(<span class="string">r&quot;./main.dll&quot;</span>)  <span class="comment"># 加载之后就得到了动态链接库对象</span></span><br><span class="line"><span class="comment"># 我们可以直接通过 . 的方式去调用里面的函数了，会发现成功打印</span></span><br><span class="line"><span class="built_in">print</span>(lib.f())  <span class="comment"># 123</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 但是为了确定是否存在这个函数，我们一般会使用反射去获取</span></span><br><span class="line"><span class="comment"># 因为如果函数不存在通过 . 的方式调用会抛异常的</span></span><br><span class="line">func = <span class="built_in">getattr</span>(lib, <span class="string">&quot;f&quot;</span>, <span class="literal">None</span>)</span><br><span class="line"><span class="keyword">if</span> func:</span><br><span class="line">    <span class="built_in">print</span>(func)  <span class="comment"># &lt;_FuncPtr object at 0x0000029F75F315F0&gt;</span></span><br><span class="line">    func()  <span class="comment"># hello world</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不存在 f2 这个函数，所以得到的结果为 None</span></span><br><span class="line">func1 = <span class="built_in">getattr</span>(lib, <span class="string">&quot;f2&quot;</span>, <span class="literal">None</span>)</span><br><span class="line"><span class="built_in">print</span>(func1)  <span class="comment"># None</span></span><br></pre></td></tr></table></figure>

<p><strong>所以使用ctypes去调用动态链接库非常方便，过程很简单：</strong></p>
<ul>
<li><code>1. 通过 ctypes.CDLL 去加载动态库，另外注意的是：dll 或者 so  文件的路径最好是绝对路径，即便不是也要表明层级。比如我们这里的 py 文件和 dll 文件是在同一个目录下，但是我们加载的时候不可以写  main.dll，这样会报错找不到，我们需要写成 ./main.dll</code></li>
<li><code>2. 加载动态链接库之后会返回一个对象，我们上面起名为 lib，这个 lib 就是得到的动态链接库了</code></li>
<li><code>3. 然后可以直接通过 lib 调用里面的函数，但是一般我们会使用反射的方式来获取，因为不知道函数到底存不存在，如果不存在直接调用会抛出异常，如果存在这个函数我们才会调用。</code></li>
</ul>
<blockquote>
<p><strong>Linux 和 Mac 也是一样的，这里不演示了，只不过编译之后的名字不一样。Linux 系统是 .so，Mac 系统是 .dylib。</strong></p>
</blockquote>
<p><strong>此外我们也可以在 C 中进行打印，举个栗子：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>然后编译，进行调用。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"></span><br><span class="line">lib = ctypes.CDLL(<span class="string">r&quot;./main.dll&quot;</span>)  <span class="comment"># 加载之后就得到了动态链接库对象</span></span><br><span class="line">lib.f()  <span class="comment"># hello world</span></span><br></pre></td></tr></table></figure>

<p><strong>另外，Python 的 ctypes 调用的都是 C  语言函数，如果你用的 C++ 编译器，那么会编译成 C++ 中的函数。我们知道 C 语言的函数不支持重载，说白了就是不可以定义两个同名的函数，而 C++ 的函数是支持重载的，只要参数类型不一致即可，然后调用的时候会根据传递的参数调用对应的函数。所以当我们使用 C++  编译器的时候，需要通过 extern “C” 将函数包起来，这样 C++ 编译器在编译的时候会将其编译成 C 的函数。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意: 我们不能直接通过 extern &quot;C&quot; &#123;&#125; 将函数包起来, 因为这不符合 C 的语法, extern 在 C 中是用来声明一个外部变量的</span></span><br><span class="line"><span class="comment">// 所以我们应该使用宏替换的方式, 如果是 C++ 编译器的话, 那么编译的时候 #ifdef __cplusplus 是会通过的, 因为 __cplusplus 是一个预定义的宏</span></span><br><span class="line"><span class="comment">// 如果是 C 编译器, 那么 #ifdef __cplusplus 不会通过</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><strong>当然我们在介绍 ctypes 使用的 gcc 都是 C 编译器，会编译成 C 的函数，所以后面 extern “C” 的逻辑就不加了。</strong></p>
<p><strong>我们以上就演示了，如何通过 Python 的 ctypes 模块来调用 C &#x2F; C++ 动态库，但显然目前还是远远不够的。比如说：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3.14</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>然后我们调用的时候，会得到什么结果呢？来试一下：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"></span><br><span class="line">lib = ctypes.CDLL(<span class="string">r&quot;./main.dll&quot;</span>)  <span class="comment"># 加载之后就得到了动态链接库对象</span></span><br><span class="line"><span class="built_in">print</span>(lib.f())  <span class="comment"># 1374389535</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看到得到一个不符合预期的结果，我们暂且不纠结它是怎么来的，现在的问题是它返回的为什么不是 3.14 呢？原因是 ctypes 在解析的时候默认是按照整型来解析的，但很明显我们 C 函数返回是浮点型，因此我们在调用之前需要显式的指定其返回值。</strong></p>
<p><strong>不过在这之前，我们需要先来看看 Python 类型和 C 类型之间的转换关系。</strong></p>
<h3 id="Python-类型与-C-语言类型之间的转换"><a href="#Python-类型与-C-语言类型之间的转换" class="headerlink" title="Python 类型与 C 语言类型之间的转换"></a>Python 类型与 C 语言类型之间的转换</h3><p><strong>我们说可以使用 ctypes  调用动态链接库，主要是调用动态链接库中使用C编写好的函数，但这些函数肯定都是需要参数的，还有返回值，不然编写动态链接库有啥用呢。那么问题来了，不同的语言变量类型不同，所以 Python 能够直接往 C 编写的函数中传参吗？显然不行，因此 ctypes 提供了大量的类，帮我们将 Python 中的类型转成 C  语言中的类型。</strong></p>
<p><strong>我们说了，Python 中类型不能直接往 C 语言的函数中传递（整型是个例外），而 ctypes 可以帮助我们将 Python 的类型转成 C 类型。而常见的类型分为以下几种：数值、字符、指针。</strong></p>
<h4 id="数值类型转换"><a href="#数值类型转换" class="headerlink" title="数值类型转换"></a>数值类型转换</h4><p><strong>C 语言的数值类型分为如下：</strong></p>
<ul>
<li><code>int：整型</code></li>
<li><code>unsigned int：无符号整型</code></li>
<li><code>short：短整型</code></li>
<li><code>unsigned short：无符号短整型</code></li>
<li><code>long：长整形</code></li>
<li><code>unsigned long：无符号长整形</code></li>
<li><code>long long：64位机器上等同于 long</code></li>
<li><code>unsigned long long：等同于 unsigned long</code></li>
<li><code>float：单精度浮点型</code></li>
<li><code>double：双精度浮点型</code></li>
<li><code>long double：看成是 double 即可</code></li>
<li><code>_Bool：布尔类型</code></li>
<li><code>ssize_t：等同于 long 或者 long long</code></li>
<li><code>size_t：等同于 unsigned long 或者 unsigned long long</code></li>
</ul>
<p><img src="/2023/04/26/31-Python-%E5%92%8C-C-C-%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/1229382-20210212015202708-1325772424.png" alt="img"></p>
<p><strong>下面来演示一下：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面都是 ctypes 中提供的类，将 Python 中的对象传进去，就可以转换为 C 语言能够识别的类型</span></span><br><span class="line"><span class="built_in">print</span>(ctypes.c_int(<span class="number">1</span>))  <span class="comment"># c_long(1)</span></span><br><span class="line"><span class="built_in">print</span>(ctypes.c_uint(<span class="number">1</span>))  <span class="comment"># c_ulong(1)</span></span><br><span class="line"><span class="built_in">print</span>(ctypes.c_short(<span class="number">1</span>))  <span class="comment"># c_short(1)</span></span><br><span class="line"><span class="built_in">print</span>(ctypes.c_ushort(<span class="number">1</span>))  <span class="comment"># c_ushort(1)</span></span><br><span class="line"><span class="built_in">print</span>(ctypes.c_long(<span class="number">1</span>))  <span class="comment"># c_long(1)</span></span><br><span class="line"><span class="built_in">print</span>(ctypes.c_ulong(<span class="number">1</span>))  <span class="comment"># c_ulong(1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># c_longlong 等价于 c_long，c_ulonglong 等价于c_ulong</span></span><br><span class="line"><span class="built_in">print</span>(ctypes.c_longlong(<span class="number">1</span>))  <span class="comment"># c_longlong(1)</span></span><br><span class="line"><span class="built_in">print</span>(ctypes.c_ulonglong(<span class="number">1</span>))  <span class="comment"># c_ulonglong(1)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(ctypes.c_float(<span class="number">1.1</span>))  <span class="comment"># c_float(1.100000023841858)</span></span><br><span class="line"><span class="built_in">print</span>(ctypes.c_double(<span class="number">1.1</span>))  <span class="comment"># c_double(1.1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在64位机器上，c_longdouble等于c_double</span></span><br><span class="line"><span class="built_in">print</span>(ctypes.c_longdouble(<span class="number">1.1</span>))  <span class="comment"># c_double(1.1)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(ctypes.c_bool(<span class="literal">True</span>))  <span class="comment"># c_bool(True)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 相当于c_longlong和c_ulonglong</span></span><br><span class="line"><span class="built_in">print</span>(ctypes.c_ssize_t(<span class="number">10</span>))  <span class="comment"># c_longlong(10)</span></span><br><span class="line"><span class="built_in">print</span>(ctypes.c_size_t(<span class="number">10</span>))  <span class="comment"># c_ulonglong(10)</span></span><br></pre></td></tr></table></figure>

<h4 id="字符类型转换、指针类型转换"><a href="#字符类型转换、指针类型转换" class="headerlink" title="字符类型转换、指针类型转换"></a>字符类型转换、指针类型转换</h4><p><strong>C 语言的字符类型分为如下：</strong></p>
<ul>
<li><code>char：一个 ascii 字符或者 -128~127 的整型</code></li>
<li><code>wchar：一个 unicode 字符</code></li>
<li><code>unsigned char：一个 ascii 字符或者 0~255 的一个整型</code></li>
</ul>
<p><strong>C 语言的指针类型分为如下：</strong></p>
<ul>
<li><code>char *：字符指针</code></li>
<li><code>wchar_t *：字符指针</code></li>
<li><code>void *：空指针</code></li>
</ul>
<p><img src="/2023/04/26/31-Python-%E5%92%8C-C-C-%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/1229382-20210212015210704-1251164677.png" alt="img"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 必须传递一个字节(里面是 ascii 字符)，或者一个 int，来代表 C 里面的字符</span></span><br><span class="line"><span class="built_in">print</span>(ctypes.c_char(<span class="string">b&quot;a&quot;</span>))  <span class="comment"># c_char(b&#x27;a&#x27;)</span></span><br><span class="line"><span class="built_in">print</span>(ctypes.c_char(<span class="number">97</span>))  <span class="comment"># c_char(b&#x27;a&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 传递一个 unicode 字符，当然 ascii 字符也是可以的，并且不是字节形式</span></span><br><span class="line"><span class="built_in">print</span>(ctypes.c_wchar(<span class="string">&quot;憨&quot;</span>))  <span class="comment"># c_wchar(&#x27;憨&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 和 c_char 类似，但是 c_char 既可以传入单个字节、也可以传整型，而这里的 c_byte 则要求必须传递整型。</span></span><br><span class="line"><span class="built_in">print</span>(ctypes.c_byte(<span class="number">97</span>))  <span class="comment"># c_byte(97)</span></span><br><span class="line"><span class="built_in">print</span>(ctypes.c_ubyte(<span class="number">97</span>))  <span class="comment"># c_ubyte(97)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># c_char_p 就是 c 里面字符数组了，其实我们可以把它看成是 Python 中的 bytes 对象</span></span><br><span class="line"><span class="comment"># char *s = &quot;hello world&quot;;</span></span><br><span class="line"><span class="comment"># 那么这里面也要传递一个 bytes 类型的字符串，返回一个地址</span></span><br><span class="line"><span class="built_in">print</span>(ctypes.c_char_p(<span class="string">b&quot;hello world&quot;</span>))  <span class="comment"># c_char_p(2082736374464)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接传递一个字符串，同样返回一个地址</span></span><br><span class="line"><span class="built_in">print</span>(ctypes.c_wchar_p(<span class="string">&quot;憨八嘎~&quot;</span>))  <span class="comment"># c_wchar_p(2884583039392)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ctypes.c_void_p后面演示</span></span><br></pre></td></tr></table></figure>

<p><strong>常见的类型就是上面这些，至于其他的类型，比如整型指针、数组、结构体、回调函数等等，ctypes 也是支持的，我们后面会介绍。</strong></p>
<h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p><strong>下面我们来看看如何传递参数。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a, <span class="type">float</span> f, <span class="type">char</span> *s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d, b = %.2f, s = %s\n&quot;</span>, a, f, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这是一个很简单的 C 文件，然后编译成 dll 之后，让 Python 去调用，这里我们编译之后的文件名叫做还叫做 main.dll。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">lib = CDLL(<span class="string">r&quot;./main.dll&quot;</span>)  <span class="comment"># 加载之后就得到了动态链接库对象</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    lib.test(<span class="number">1</span>, <span class="number">1.2</span>, <span class="string">b&quot;hello world&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># argument 2: &lt;class &#x27;TypeError&#x27;&gt;: Don&#x27;t know how to convert parameter 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们看到一个问题，那就是报错了，告诉我们不知道如何转化第二个参数</span></span><br><span class="line"><span class="comment"># 正如我们之前说的，整型是会自动转化的，但是浮点型是不会自动转化的</span></span><br><span class="line"><span class="comment"># 因此我们需要使用 ctypes 来包装一下，当然还有整型，即便整型会自动转，我们还是建议手动转化一下</span></span><br><span class="line"><span class="comment"># 这里传入 c_int(1) 和 1 都是一样的，但是建议传入 c_int(1)</span></span><br><span class="line">lib.test(c_int(<span class="number">1</span>), c_float(<span class="number">1.2</span>), c_char_p(<span class="string">b&quot;hello world&quot;</span>))  <span class="comment"># a = 1, b = 1.20, s = hello world</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看到完美的打印出来了，我们再来试试布尔类型。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">_Bool</span> flag)</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="comment">//布尔类型本质上是一个int</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>, flag);</span><br><span class="line">&#125;</span><br><span class="line">import ctypes</span><br><span class="line">from ctypes import *</span><br><span class="line"></span><br><span class="line">lib = ctypes.CDLL(<span class="string">&quot;./main.dll&quot;</span>)</span><br><span class="line"></span><br><span class="line">lib.test(c_bool(True))  <span class="meta"># a = 1</span></span><br><span class="line">lib.test(c_bool(False))  <span class="meta"># a = 0</span></span><br><span class="line"># 可以看到 True 被解释成了 <span class="number">1</span>，False 被解释成了 <span class="number">0</span></span><br><span class="line"></span><br><span class="line"># 我们说整型会自动转化，而布尔类型继承自整型所以布尔类型也可以直接传递</span><br><span class="line">lib.test(True)  <span class="meta"># a = 1</span></span><br><span class="line">lib.test(False)  <span class="meta"># a = 0</span></span><br></pre></td></tr></table></figure>

<p><strong>然后再来看看字符和字符数组的传递：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> age, <span class="type">char</span> *gender)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (age &gt;= <span class="number">18</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(gender, <span class="string">&quot;female&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;age &gt;= 18, gender is female\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;age &gt;= 18, gender is male\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(gender, <span class="string">&quot;female&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;age &lt; 18, gender is female\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;age &lt; 18, gender is main\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">from ctypes import *</span><br><span class="line"></span><br><span class="line">lib = CDLL(<span class="string">&quot;./main.dll&quot;</span>)</span><br><span class="line">lib.test(c_int(<span class="number">20</span>), c_char_p(b<span class="string">&quot;female&quot;</span>))  <span class="meta"># age &gt;= 18, gender is female</span></span><br><span class="line">lib.test(c_int(<span class="number">20</span>), c_char_p(b<span class="string">&quot;male&quot;</span>))  <span class="meta"># age &gt;= 18, gender is male</span></span><br><span class="line">lib.test(c_int(<span class="number">14</span>), c_char_p(b<span class="string">&quot;female&quot;</span>))  <span class="meta"># age &lt; 18, gender is female</span></span><br><span class="line">lib.test(c_int(<span class="number">14</span>), c_char_p(b<span class="string">&quot;male&quot;</span>))  <span class="meta"># age &lt; 18, gender is main</span></span><br><span class="line"></span><br><span class="line"># 我们看到 C 中的字符数组，我们直接通过 c_char_p 来传递即可</span><br><span class="line"># 至于单个字符，使用 c_char 即可</span><br></pre></td></tr></table></figure>

<p><strong>同理我们也可以打印宽字符，逻辑是类似的。</strong></p>
<h3 id="传递可变的字符串"><a href="#传递可变的字符串" class="headerlink" title="传递可变的字符串"></a>传递可变的字符串</h3><p><strong>我们知道 C 中不存在字符串这个概念，Python 中的字符串在 C 中也是通过字符数组来实现的，我们通过 ctypes 像 C 函数传递一个字符串的时候，在 C 中是可以被修改的。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">char</span> *s)</span></span><br><span class="line">&#123;</span><br><span class="line">    s[<span class="number">0</span>] = <span class="string">&#x27;S&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">&#125;</span><br><span class="line">from ctypes import *</span><br><span class="line"></span><br><span class="line">lib = CDLL(<span class="string">&quot;./main.dll&quot;</span>)</span><br><span class="line">lib.test(c_char_p(b<span class="string">&quot;satori&quot;</span>))  # Satori</span><br></pre></td></tr></table></figure>

<p><strong>我们看到小写的字符串，第一个字符变成了大写，但即便能修改我们也不建议这么做，因为 bytes 对象在 Python 中是不能更改的，所以在 C  中也不应该更改。当然不是说不让修改，而是应该换一种方式。如果是需要修改的话，那么不要使用 c_char_p 的方式来传递，而是建议通过  create_string_buffer 来给 C 语言传递可以修改字符的空间。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 传入一个 int，表示创建一个具有固定大小的字符缓存，这里是 10 个</span></span><br><span class="line">s = create_string_buffer(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 直接打印就是一个对象</span></span><br><span class="line"><span class="built_in">print</span>(s)  <span class="comment"># &lt;ctypes.c_char_Array_10 object at 0x000001E2E07667C0&gt;</span></span><br><span class="line"><span class="comment"># 也可以调用 value 方法打印它的值，可以看到什么都没有</span></span><br><span class="line"><span class="built_in">print</span>(s.value)  <span class="comment"># b&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 并且它还有一个 raw 方法，表示 C 语言中的字符数组，由于长度为 10，并且没有内容，所以全部是 \x00，就是C语言中的 \0</span></span><br><span class="line"><span class="built_in">print</span>(s.raw)  <span class="comment"># b&#x27;\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00&#x27;</span></span><br><span class="line"><span class="comment"># 还可以查看长度</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(s))  <span class="comment"># 10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 其它类型也是一样的</span></span><br><span class="line">v = c_int(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 我们看到 c_int(1) 它的类型就是 ctypes.c_long</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(v))  <span class="comment"># &lt;class &#x27;ctypes.c_long&#x27;&gt;</span></span><br><span class="line"><span class="comment"># 当然你把 c_int，c_long，c_longlong 这些花里胡哨的都当成是整型就完事了</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 此外我们还能够拿到它的值，调用 value 方法</span></span><br><span class="line"><span class="built_in">print</span>(v.value, <span class="built_in">type</span>(v.value))  <span class="comment"># 1 &lt;class &#x27;int&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line">v = c_char(<span class="string">b&quot;a&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(v))  <span class="comment"># &lt;class &#x27;ctypes.c_char&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(v.value, <span class="built_in">type</span>(v.value))  <span class="comment"># b&#x27;a&#x27; &lt;class &#x27;bytes&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line">v = c_char_p(<span class="string">b&quot;hello world&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(v))  <span class="comment"># &lt;class &#x27;ctypes.c_char_p&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(v.value, <span class="built_in">type</span>(v.value))  <span class="comment"># b&#x27;hello world&#x27; &lt;class &#x27;bytes&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line">v = c_wchar_p(<span class="string">&quot;夏色祭&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(v))  <span class="comment"># &lt;class &#x27;ctypes.c_wchar_p&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(v.value, <span class="built_in">type</span>(v.value))  <span class="comment"># 夏色祭 &lt;class &#x27;str&#x27;&gt;</span></span><br><span class="line"><span class="comment"># 因此 ctypes 中的对象调用 value 即可得到 Python 中的对象</span></span><br></pre></td></tr></table></figure>

<p><strong>当然 create_string_buffer 如果只传一个 int，那么表示创建对应长度的字符缓存。除此之外，还可以指定字节串，此时的字符缓存大小和指定的字节串大小是一致的：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时我们直接创建了一个字符缓存</span></span><br><span class="line">s = create_string_buffer(<span class="string">b&quot;hello&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(s)  <span class="comment"># &lt;ctypes.c_char_Array_6 object at 0x0000021944E467C0&gt;</span></span><br><span class="line"><span class="built_in">print</span>(s.value)  <span class="comment"># b&#x27;hello&#x27;</span></span><br><span class="line"><span class="comment"># 我们知道在 C 中，字符数组是以 \0 作为结束标记的，所以结尾会有一个 \0，因为 raw 表示 C 中原始的字符数组</span></span><br><span class="line"><span class="built_in">print</span>(s.raw)  <span class="comment"># b&#x27;hello\x00&#x27;</span></span><br><span class="line"><span class="comment"># 长度为 6，b&quot;hello&quot; 五个字符再加上 \0 一共 6 个</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(s))</span><br></pre></td></tr></table></figure>

<p><strong>当然 create_string_buffer 还可以在指定字节串的同时，指定空间大小。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时我们直接创建了一个字符缓存，如果不指定容量，那么默认和对应的字符数组大小一致</span></span><br><span class="line"><span class="comment"># 但是我们还可以同时指定容量，记得容量要比前面的字节串的长度要大。</span></span><br><span class="line">s = create_string_buffer(<span class="string">b&quot;hello&quot;</span>, <span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(s)  <span class="comment"># &lt;ctypes.c_char_Array_10 object at 0x0000019361C067C0&gt;</span></span><br><span class="line"><span class="built_in">print</span>(s.value)  <span class="comment"># b&#x27;hello&#x27;</span></span><br><span class="line"><span class="comment"># 长度为 10，剩余的 5 个显然是 \0</span></span><br><span class="line"><span class="built_in">print</span>(s.raw)  <span class="comment"># b&#x27;hello\x00\x00\x00\x00\x00&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(s))  <span class="comment"># 10</span></span><br></pre></td></tr></table></figure>

<p><strong>下面我们来看看如何使用 create_string_buffer 来传递：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">test</span><span class="params">(<span class="type">char</span> *s)</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="comment">//变量的形式依旧是char *s</span></span><br><span class="line">    <span class="comment">//下面的操作就是相当于把字符数组的索引为5到11的部分换成&quot; satori&quot;</span></span><br><span class="line">    s[<span class="number">5</span>] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    s[<span class="number">6</span>] = <span class="string">&#x27;s&#x27;</span>;</span><br><span class="line">    s[<span class="number">7</span>] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    s[<span class="number">8</span>] = <span class="string">&#x27;t&#x27;</span>;</span><br><span class="line">    s[<span class="number">9</span>] = <span class="string">&#x27;o&#x27;</span>;</span><br><span class="line">    s[<span class="number">10</span>] = <span class="string">&#x27;r&#x27;</span>;</span><br><span class="line">    s[<span class="number">11</span>] = <span class="string">&#x27;i&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s = %s\n&quot;</span>, s);</span><br><span class="line">&#125;</span><br><span class="line">from ctypes import *</span><br><span class="line"></span><br><span class="line">lib = CDLL(<span class="string">&quot;./main.dll&quot;</span>)</span><br><span class="line">s = create_string_buffer(b<span class="string">&quot;hello&quot;</span>, <span class="number">20</span>)</span><br><span class="line">lib.test(s)  <span class="meta"># s = hello satori</span></span><br></pre></td></tr></table></figure>

<p><strong>此时就成功地修改了，我们这里的 b”hello” 占五个字节，下一个正好是索引为 5 的地方，然后把索引为 5 到 11 的部分换成对应的字符。但是需要注意的是，一定要小心 <code>\0</code>，我们知道 C 语言中一旦遇到了 <code>\0</code> 就表示这个字符数组结束了。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">lib = CDLL(<span class="string">&quot;./main.dll&quot;</span>)</span><br><span class="line"><span class="comment"># 这里把&quot;hello&quot;换成&quot;hell&quot;，看看会发生什么</span></span><br><span class="line">s = create_string_buffer(<span class="string">b&quot;hell&quot;</span>, <span class="number">20</span>)</span><br><span class="line">lib.test(s)  <span class="comment"># s = hell</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们看到这里只打印了&quot;hell&quot;，这是为什么？</span></span><br><span class="line"><span class="comment"># 我们看一下这个s</span></span><br><span class="line"><span class="built_in">print</span>(s.raw)  <span class="comment"># b&#x27;hell\x00 satori\x00\x00\x00\x00\x00\x00\x00\x00&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们看到这个 create_string_buffer 返回的对象是可变的，在将 s 传进去之后被修改了</span></span><br><span class="line"><span class="comment"># 如果没有传递的话，我们知道它是长这样的。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">b&#x27;hell\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00&#x27;</span></span><br><span class="line"><span class="string">hell的后面全部是C语言中的 \0</span></span><br><span class="line"><span class="string">修改之后变成了这样</span></span><br><span class="line"><span class="string">b&#x27;hell\x00 satori\x00\x00\x00\x00\x00\x00\x00\x00&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">我们看到确实是把索引为5到11(包含11)的部分变成了&quot; satori&quot;</span></span><br><span class="line"><span class="string">但是我们知道 C 语言中扫描字符数组的时候一旦遇到了 \0，就表示结束了，而hell后面就是 \0,</span></span><br><span class="line"><span class="string">因为即便后面还有内容也不会输出了，所以直接就只打印了 hell</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>另外除了 create_string_buffer 之外，还有一个 create_unicode_buffer，针对于 wchar_t *，用法和 create_string_buffer 类似。</strong></p>
<h3 id="调用操作系统的库函数"><a href="#调用操作系统的库函数" class="headerlink" title="调用操作系统的库函数"></a>调用操作系统的库函数</h3><p><strong>我们知道 Python 解释器本质上就是使用 C 语言写出来的一个软件，那么操作系统呢？操作系统本质上它也是一个软件，不管是 Windows、Linux 还是 MacOS 都自带了大量的共享库，那么我们就可以使用 Python 去调用。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> platform</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断当前的操作系统平台。</span></span><br><span class="line"><span class="comment"># Windows 平台返回 &quot;Windows&quot;，Linux 平台返回 &quot;Linux&quot;，MacOS 平台返回 &quot;Darwin&quot;</span></span><br><span class="line">system = platform.system()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不同的平台共享库不同</span></span><br><span class="line"><span class="keyword">if</span> system == <span class="string">&quot;Windows&quot;</span>:</span><br><span class="line">    lib = cdll.msvcrt</span><br><span class="line"><span class="keyword">elif</span> system == <span class="string">&quot;Linux&quot;</span>:</span><br><span class="line">    lib = CDLL(<span class="string">&quot;libc.so.6&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> system == <span class="string">&quot;Darwin&quot;</span>:</span><br><span class="line">    lib = CDLL(<span class="string">&quot;libc.dylib&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;不支持的平台，程序结束&quot;</span>)</span><br><span class="line">    sys.exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用对应的函数，比如 printf，注意里面需要传入字节</span></span><br><span class="line">lib.printf(<span class="string">b&quot;my name is %s, age is %d\n&quot;</span>, <span class="string">b&quot;van&quot;</span>, <span class="number">37</span>)  <span class="comment"># my name is van, age is 37</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果包含汉字就不能使用 b&quot;&quot; 这种形式了，因为这种形式只适用于 ascii 字符，我们需要手动 encode 成 utf-8</span></span><br><span class="line">lib.printf(<span class="string">&quot;姓名: %s, 年龄: %d\n&quot;</span>.encode(<span class="string">&quot;utf-8&quot;</span>), <span class="string">&quot;古明地觉&quot;</span>.encode(<span class="string">&quot;utf-8&quot;</span>), <span class="number">17</span>)  <span class="comment"># 姓名: 古明地觉, 年龄: 17</span></span><br></pre></td></tr></table></figure>

<p><strong>我们上面是在 Windows 上调用的，这段代码即便拿到 Linux 和 MacOS 上也可以正常执行。</strong></p>
<p><strong>当然这里面还支持其他的函数，我们这里以 Windows 为例：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">libc = cdll.msvcrt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个大小为 10 的buffer</span></span><br><span class="line">s = create_string_buffer(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># strcpy 表示将字符串进行拷贝</span></span><br><span class="line">libc.strcpy(s, c_char_p(<span class="string">b&quot;hello satori&quot;</span>))</span><br><span class="line"><span class="comment"># 由于 buffer 只有10个字节大小，所以无法完全拷贝</span></span><br><span class="line"><span class="built_in">print</span>(s.value)  <span class="comment"># b&#x27;hello sato&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 unicode buffer</span></span><br><span class="line">s = create_unicode_buffer(<span class="number">10</span>)</span><br><span class="line">libc.strcpy(s, c_wchar_p(<span class="string">&quot;我也觉得很变态啊&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(s.value)  <span class="comment"># 我也觉得很变态啊</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 比如 puts 函数</span></span><br><span class="line">libc.puts(<span class="string">b&quot;hello world&quot;</span>)  <span class="comment"># hello world</span></span><br></pre></td></tr></table></figure>

<p><strong>对于 Windows 来说，我们还可以调用一些其它的函数，但是不再是通过 cdll.msvcrt 这种方式了。在 Windows 上面有一个 user32 这么个东西，我们来看一下：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们通过 cdll.user32 本质上还是加载了 Windows 上的一个共享库</span></span><br><span class="line"><span class="comment"># 这个库给我们提供了很多方便的功能</span></span><br><span class="line">win = cdll.user32</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比如查看屏幕的分辨率</span></span><br><span class="line"><span class="built_in">print</span>(win.GetSystemMetrics(<span class="number">0</span>))  <span class="comment"># 1920</span></span><br><span class="line"><span class="built_in">print</span>(win.GetSystemMetrics(<span class="number">1</span>))  <span class="comment"># 1080</span></span><br></pre></td></tr></table></figure>

<p><strong>我们还可以用它来打开 MessageBoxA：</strong></p>
<p><img src="/2023/04/26/31-Python-%E5%92%8C-C-C-%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/1229382-20210212015220536-1208285821.png" alt="img"></p>
<p><strong>可以看到我们通过 cdll.user32 就可以很轻松地调用 Windows 的 api，具体有哪些 api 可以去网上查找，搜索 win32 api 即可。</strong></p>
<p><strong>除了 ctypes，还有几个专门用来操作 win32  服务的模块，win32gui、win32con、win32api、win32com、win32process。直接 pip install  pywin32 即可，或者 pip install pypiwin32。</strong></p>
<h4 id="显示窗体和隐藏窗体"><a href="#显示窗体和隐藏窗体" class="headerlink" title="显示窗体和隐藏窗体"></a>显示窗体和隐藏窗体</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> win32gui</span><br><span class="line"><span class="keyword">import</span> win32con</span><br><span class="line"></span><br><span class="line"><span class="comment"># 首先查找窗体，这里查找 qq。需要传入 窗口类名 窗口标题名，至于这个怎么获取可以使用 spy 工具查看</span></span><br><span class="line">qq = win32gui.FindWindow(<span class="string">&quot;TXGuifoundation&quot;</span>, <span class="string">&quot;QQ&quot;</span>)</span><br><span class="line"><span class="comment"># 然后让窗体显示出来</span></span><br><span class="line">win32gui.ShowWindow(qq, win32con.SW_SHOW)</span><br><span class="line"><span class="comment"># 还可以隐藏</span></span><br><span class="line">win32gui.ShowWindow(qq, win32con.SW_HIDE)</span><br></pre></td></tr></table></figure>

<h4 id="控制窗体的位置和大小"><a href="#控制窗体的位置和大小" class="headerlink" title="控制窗体的位置和大小"></a>控制窗体的位置和大小</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> win32gui</span><br><span class="line"><span class="keyword">import</span> win32con</span><br><span class="line"></span><br><span class="line">qq = win32gui.FindWindow(<span class="string">&quot;TXGuiFoundation&quot;</span>, <span class="string">&quot;QQ&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主要要接收如下参数</span></span><br><span class="line"><span class="comment"># 参数一：控制的窗体</span></span><br><span class="line"><span class="comment"># 参数二：大致方位：HWND_TOPMOST，位于上方</span></span><br><span class="line"><span class="comment"># 参数三：位置x</span></span><br><span class="line"><span class="comment"># 参数四：位置y</span></span><br><span class="line"><span class="comment"># 参数五：长度</span></span><br><span class="line"><span class="comment"># 参数六：宽度</span></span><br><span class="line"><span class="comment"># 参数七：比较固定，就是让窗体一直显示</span></span><br><span class="line">win32gui.SetWindowPos(qq, win32con.HWND_TOPMOST, <span class="number">100</span>, <span class="number">100</span>, <span class="number">300</span>, <span class="number">300</span>, win32con.SWP_SHOWWINDOW)</span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/26/31-Python-%E5%92%8C-C-C-%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/1229382-20210212015229559-1641962774.png" alt="img"></p>
<p><strong>那么我们还可以让窗体满屏幕乱跑：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> win32gui</span><br><span class="line"><span class="keyword">import</span> win32con</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">qqWin = win32gui.FindWindow(<span class="string">&quot;TXGuiFoundation&quot;</span>, <span class="string">&quot;QQ&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将位置变成随机数</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    x = random.randint(<span class="number">1</span>, <span class="number">1920</span>)</span><br><span class="line">    y = random.randint(<span class="number">1</span>, <span class="number">1080</span>)</span><br><span class="line">    win32gui.SetWindowPos(qqWin, win32con.HWND_TOPMOST, x, y, <span class="number">300</span>, <span class="number">300</span>, win32con.SWP_SHOWWINDOW)</span><br></pre></td></tr></table></figure>

<h4 id="语音播放"><a href="#语音播放" class="headerlink" title="语音播放"></a>语音播放</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> win32com.client</span><br><span class="line"><span class="comment"># 直接调用操作系统的语音接口</span></span><br><span class="line">speaker = win32com.client.Dispatch(<span class="string">&quot;SAPI.SpVoice&quot;</span>)</span><br><span class="line"><span class="comment"># 输入你想要说的话，前提是操作系统语音助手要认识。一般中文和英文是没有问题的</span></span><br><span class="line">speaker.Speak(<span class="string">&quot;他能秒我，他能秒杀我？他要是能把我秒了，我当场······&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>Python 中 win32 模块的 api 非常多，几乎可以操作整个 Windows 提供的服务，win32 模块就是相当于把 Windows 服务封装成了一个一个的接口。不过这些服务、或者调用这些服务具体都能干些什么，可以自己去研究，这里就到此为止了。</strong></p>
<h3 id="ctypes-获取返回值"><a href="#ctypes-获取返回值" class="headerlink" title="ctypes 获取返回值"></a>ctypes 获取返回值</h3><p><strong>我们前面已经看到了，通过 ctypes  向动态链接库中的函数传参时是没有问题的，但是我们如何拿到返回值呢？我们之前都是使用 printf  直接打印的，但是这样显然不行，我们肯定是要拿到返回值去做一些别的事情的。那么我们在 C 函数中直接 return  不就可以啦，还记得之前演示的返回浮点型的例子吗？我们明明返回了 3.14，但得到的确是一大长串整数，所以我们需要在调用函数之前告诉 ctypes 返回值的类型。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">test1</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    c = a + b;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test2</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">from ctypes import *</span><br><span class="line"></span><br><span class="line">lib = CDLL(<span class="string">&quot;./main.dll&quot;</span>)</span><br><span class="line">print(lib.test1(<span class="number">25</span>, <span class="number">33</span>))  # <span class="number">58</span></span><br><span class="line">print(lib.test2())  # <span class="number">-883932787</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看到对于 test1 的结果是正常的，但是对于 test2 来说即便返回的是 void，在 Python 中依旧会得到一个整型，因为默认都会按照整型进行解析，但这个结果肯定是不正确的。不过对于整型来说，是完全没有问题的。</strong></p>
<p><strong>正如我们传递参数一样，需要使用 ctypes 转化一下，那么在获取返回值的时候，也需要提前使用 ctypes 指定一下返回值到底是什么类型，只有这样才能拿到动态链接库中函数的正确的返回值。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wchar.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> * <span class="title function_">test1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *s = <span class="string">&quot;hello satori&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">wchar_t</span> * <span class="title function_">test2</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 遇到 wchar_t 的时候，一定要导入 wchar.h 头文件</span></span><br><span class="line">    <span class="type">wchar_t</span> *s = <span class="string">L&quot;憨八嘎&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line">from ctypes import *</span><br><span class="line"></span><br><span class="line">lib = CDLL(<span class="string">&quot;./main.dll&quot;</span>)</span><br><span class="line"># 不出所料，我们在动态链接库中返回的是一个字符数组的首地址，我们希望拿到指向的字符串</span><br><span class="line"># 然而 Python 拿到的仍是一个整型，而且一看感觉这像是一个地址。如果是地址的话那么从理论上讲是对的，返回地址、获取地址</span><br><span class="line">print(lib.test1())  # <span class="number">1788100608</span></span><br><span class="line"># 但我们希望的是获取地址指向的字符数组，所以我们需要指定一下返回的类型</span><br><span class="line"># 指定为 c_char_p，告诉 ctypes 你在解析的时候将 test1 的返回值按照 c_char_p 进行解析</span><br><span class="line">lib.test1.restype = c_char_p</span><br><span class="line"># 此时就没有问题了</span><br><span class="line">print(lib.test1())  <span class="meta"># b<span class="string">&#x27;hello satori&#x27;</span></span></span><br><span class="line"></span><br><span class="line"># 同理对于 unicode 也是一样的，如果不指定类型，得到的依旧是一个整型</span><br><span class="line">lib.test2.restype = c_wchar_p</span><br><span class="line">print(lib.test2())  # 憨八嘎</span><br></pre></td></tr></table></figure>

<p><strong>因此我们就将 Python 中的类型和 C 语言中的类型通过 ctypes 关联起来了，我们传参的时候需要转化，同理获取返回值的时候也要使用 ctypes 来声明一下类型。因为默认 Python  调用动态链接库的函数返回的都是整型，至于返回的整型的值到底是什么？从哪里来的？我们不需要关心，你可以理解为地址、或者某块内存的脏数据，但是不管怎么样，结果肯定是不正确的（如果函数返回的就是整形除外）。因此我们需要提前声明一下返回值的类型。声明方式：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lib.CFunction.restype = ctypes类型</span><br></pre></td></tr></table></figure>

<p><strong>我们说 lib 就是 ctypes 调用 dll 或者 so  得到的动态链接库，而里面的函数就相当于是一个个的 CFunction，然后设置内部的  restype（返回值类型），就可以得到正确的返回值了。另外即便返回值设置的不对，比如：test1 返回一个 char *，但是我们将类型设置为 c_float，调用的时候也不会报错而且得到的也是一个 float，但是这个结果肯定是不对的。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">lib = CDLL(<span class="string">&quot;./main.dll&quot;</span>)</span><br><span class="line">lib.test1.restype = c_char_p</span><br><span class="line"><span class="built_in">print</span>(lib.test1())  <span class="comment"># b&#x27;hello satori&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置为 c_float</span></span><br><span class="line">lib.test1.restype = c_float</span><br><span class="line"><span class="comment"># 获取了不知道从哪里来的脏数据</span></span><br><span class="line"><span class="built_in">print</span>(lib.test1())  <span class="comment"># 2.5420596244190436e+20</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 另外 ctypes 调用还有一个特点</span></span><br><span class="line">lib.test2.restype = c_wchar_p</span><br><span class="line"><span class="built_in">print</span>(lib.test2(<span class="number">123</span>, c_float(<span class="number">1.35</span>), c_wchar_p(<span class="string">&quot;呼呼呼&quot;</span>)))  <span class="comment"># 憨八嘎</span></span><br><span class="line"><span class="comment"># 我们看到 test2 是不需要参数的，如果我们传了那么就会忽略掉，依旧能得到正常的返回值</span></span><br><span class="line"><span class="comment"># 但是不要这么做，因为没准就出问题了，所以还是该传几个参数就传几个参数</span></span><br></pre></td></tr></table></figure>

<p><strong>下面我们来看看浮点类型的返回值怎么获取，当然方法和上面是一样的。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> <span class="title function_">test1</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> c;</span><br><span class="line">    c = <span class="built_in">sqrt</span>(a * a + b * b);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line">from ctypes import *</span><br><span class="line"></span><br><span class="line">lib = CDLL(<span class="string">&quot;./main.dll&quot;</span>)</span><br><span class="line"></span><br><span class="line"># 得到的结果是一个整型，默认都是整型。</span><br><span class="line"># 我们不知道这个整型是从哪里来的，就把它理解为地址吧，但是不管咋样，结果肯定是不对的</span><br><span class="line">print(lib.test1(<span class="number">3</span>, <span class="number">4</span>))  # <span class="number">1084227584</span></span><br><span class="line"></span><br><span class="line"># 我们需要指定返回值的类型，告诉 ctypes 返回的是一个 <span class="type">float</span></span><br><span class="line">lib.test1.restype = c_float</span><br><span class="line"># 此时结果就是对的</span><br><span class="line">print(lib.test1(<span class="number">3</span>, <span class="number">4</span>))  # <span class="number">5.0</span></span><br><span class="line"></span><br><span class="line"># 如果指定为 <span class="type">double</span> 呢？</span><br><span class="line">lib.test1.restype = c_double</span><br><span class="line"># 得到的结果也有问题，总之类型一定要匹配</span><br><span class="line">print(lib.test1(<span class="number">3</span>, <span class="number">4</span>))  # <span class="number">5.356796015e-315</span></span><br><span class="line"></span><br><span class="line"># 至于 <span class="type">int</span> 就不用说了，因为默认就是 <span class="type">int</span>。所以和第一个结果是一样的</span><br><span class="line">lib.test1.restype = c_int</span><br><span class="line">print(lib.test1(<span class="number">3</span>, <span class="number">4</span>))  # <span class="number">1084227584</span></span><br></pre></td></tr></table></figure>

<p><strong>所以类型一定要匹配，该是什么类型就是什么类型。即便动态链接库中返回的是  float，我们在 Python 中通过 ctypes 也要指定为 float，而不是指定为 double，尽管都是浮点数并且 double  的精度还更高，但是结果依旧不是正确的。至于整型就不需要关心了，但即便如此，int、long 也建议不要混用，而且传参的时候最好也进行转化。</strong></p>
<p><img src="/2023/04/26/31-Python-%E5%92%8C-C-C-%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/1229382-20200129145849006-1139771193.jpg" alt="img"></p>
<h3 id="ctypes-给动态链接库中的函数传递指针"><a href="#ctypes-给动态链接库中的函数传递指针" class="headerlink" title="ctypes 给动态链接库中的函数传递指针"></a>ctypes 给动态链接库中的函数传递指针</h3><p><strong>我们使用 ctypes  可以创建一个字符数组并且拿到首地址，但是对于整型、浮点型我们怎么创建指针呢？下面就来揭晓。另外，一旦涉及到指针操作的时候就要小心了，因为这往往是比较危险的，所以 Python 把指针给隐藏掉了，当然不是说没有指针，肯定是有指针的。只不过操作指针的权限没有暴露给程序员，能够操作指针的只有对应的解释器。</strong></p>
<h4 id="ctypes-byref-和-ctypes-pointer-创建指针"><a href="#ctypes-byref-和-ctypes-pointer-创建指针" class="headerlink" title="ctypes.byref 和 ctypes.pointer 创建指针"></a>ctypes.byref 和 ctypes.pointer 创建指针</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">v = c_int(<span class="number">123</span>)</span><br><span class="line"><span class="comment"># 我们知道可以通过 value 属性获取相应的值</span></span><br><span class="line"><span class="built_in">print</span>(v.value)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 但是我们还可以修改</span></span><br><span class="line">v.value = <span class="number">456</span></span><br><span class="line"><span class="built_in">print</span>(v)  <span class="comment"># c_long(456)</span></span><br><span class="line"></span><br><span class="line">s = create_string_buffer(<span class="string">b&quot;hello&quot;</span>)</span><br><span class="line">s[<span class="number">3</span>] = <span class="string">b&#x27;&gt;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(s.value)  <span class="comment"># b&#x27;hel&gt;o&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如何创建指针呢？通过 byref 和 pointer</span></span><br><span class="line">v2 = c_int(<span class="number">123</span>)</span><br><span class="line"><span class="built_in">print</span>(byref(v2))  <span class="comment"># &lt;cparam &#x27;P&#x27; (000001D9DCF86888)&gt;</span></span><br><span class="line"><span class="built_in">print</span>(pointer(v2))  <span class="comment"># &lt;__main__.LP_c_long object at 0x000001D9DCF868C0&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看到 byref 和 pointer 都可以创建指针，那么这两者有什么区别呢？byref 返回的指针相当于右值，而 pointer 返回的指针相当于左值。举个栗子：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以整型的指针为例：</span></span><br><span class="line"><span class="type">int</span> num = <span class="number">123</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;num </span><br></pre></td></tr></table></figure>

<p><strong>对于上面的例子，如果是 byref，那么结果相当于 &amp;num，拿到的就是一个具体的值。如果是 pointer，那么结果相当于 p。这两者在传递的时候是没有区别的，只是对于 pointer 来说，它返回的是一个左值，我们是可以继续拿来做文章的。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">n = c_int(<span class="number">123</span>)</span><br><span class="line"><span class="comment"># 拿到变量 n 的指针</span></span><br><span class="line">p1 = byref(n)</span><br><span class="line">p2 = pointer(n)</span><br><span class="line"><span class="comment"># pointer 返回的是左值，我们可以继续做文章，比如继续获取指针，此时获取的就是 p2 的指针</span></span><br><span class="line"><span class="built_in">print</span>(byref(p2))  <span class="comment"># &lt;cparam &#x27;P&#x27; (0000023953796888)&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 但是 p1 不行，因为 byref 返回的是一个右值</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(byref(p1))</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># byref() argument must be a ctypes instance, not &#x27;CArgObject&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>因此两者的区别就在这里，但是还是那句话，我们在传递的时候是无所谓的，传递哪一个都可以。</strong></p>
<h4 id="传递指针"><a href="#传递指针" class="headerlink" title="传递指针"></a>传递指针</h4><p><strong>我们知道了可以通过 ctypes.byref、ctypes.pointer 的方式传递指针，但是如果函数返回的也是指针呢？我们知道除了返回 int 之外，都要指定返回值类型，那么指针如何指定呢？答案是通过 ctypes.POINTER。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接收两个 float *，返回一个 float *</span></span><br><span class="line"><span class="type">float</span> *<span class="title function_">test1</span><span class="params">(<span class="type">float</span> *a, <span class="type">float</span> *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 因为返回指针，所以为了避免被销毁，我们使用 static 静态声明</span></span><br><span class="line">    <span class="type">static</span> <span class="type">float</span> c;</span><br><span class="line">    c = *a + *b;</span><br><span class="line">    <span class="keyword">return</span> &amp;c;</span><br><span class="line">&#125;</span><br><span class="line">from ctypes import *</span><br><span class="line"></span><br><span class="line">lib = CDLL(<span class="string">&quot;./main.dll&quot;</span>)</span><br><span class="line"></span><br><span class="line"># 声明一下，返回的类型是一个 POINTER(c_float)，也就是 <span class="type">float</span> 的指针类型</span><br><span class="line">lib.test1.restype = POINTER(c_float)</span><br><span class="line"># 别忘了传递指针，因为函数接收的是指针，两种传递方式都可以</span><br><span class="line">res = lib.test1(byref(c_float(<span class="number">3.14</span>)), pointer(c_float(<span class="number">5.21</span>)))</span><br><span class="line">print(res)  # &lt;__main__.LP_c_float object at <span class="number">0x000001FFF1F468C0</span>&gt;</span><br><span class="line">print(type(res))  # &lt;class <span class="string">&#x27;__main__.LP_c_float&#x27;</span>&gt;</span><br><span class="line"># 这个 res 是 ctypes 类型，和 pointer(c_float(<span class="number">5.21</span>)) 的类型是一样的，都是 &lt;class <span class="string">&#x27;__main__.LP_c_float&#x27;</span>&gt;</span><br><span class="line"># 我们调用 contents 即可拿到 ctypes 中的值，那么显然在此基础上再调用 value 就能拿到 Python 中的值</span><br><span class="line">print(res.contents)  # c_float(<span class="number">8.350000381469727</span>)</span><br><span class="line">print(res.contents.value)  # <span class="number">8.350000381469727</span></span><br></pre></td></tr></table></figure>

<p><strong>因此我们看到了如果返回的是指针类型可以使用 POINTER(类型) 来声明，也就是说 POINTER 是用来声明指针类型的，而 byref、pointer 则是用来获取指针的。</strong></p>
<h3 id="声明类型"><a href="#声明类型" class="headerlink" title="声明类型"></a>声明类型</h3><p><strong>我们知道可以事先声明返回值的类型，这样才能拿到正确的返回值。而我们传递的时候，直接传递正确的类型即可，但是其实也是可以事先声明的。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">lib = CDLL(<span class="string">&quot;./main.dll&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过 argtypes，我们可以事先指定需要传入两个 float 的指针类型，注意：要指定为一个元组，即便是一个参数也要是元组</span></span><br><span class="line">lib.test1.argtypes = (POINTER(c_float), POINTER(c_float))</span><br><span class="line">lib.test1.restype = POINTER(c_float)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 但是和 restype 不同，argtypes 实际上是可以不要的</span></span><br><span class="line"><span class="comment"># 因为返回的默认是一个整型，我们才需要通过 restype 事先声明返回值的类型，这是有必要的</span></span><br><span class="line"><span class="comment"># 但是对于 argtypes 来说，我们传参的时候已经直接指定类型了，所以 argtypes 即便没有也是可以的</span></span><br><span class="line"><span class="comment"># 所以 argtypes 的作用就类似于其他静态语言中的类型声明，先把类型定好，如果你传的类型不对，直接给你报错</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 这里第二个参数传c_int</span></span><br><span class="line">    res = lib.test1(byref(c_float(<span class="number">3.21</span>)), c_int(<span class="number">123</span>))</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="comment"># 所以直接就给你报错了</span></span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># argument 2: &lt;class &#x27;TypeError&#x27;&gt;: expected LP_c_float instance instead of c_long</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时正确执行</span></span><br><span class="line">res1 = lib.test1(byref(c_float(<span class="number">3.21</span>)), byref(c_float(<span class="number">666</span>)))</span><br><span class="line"><span class="built_in">print</span>(res1.contents.value)  <span class="comment"># 669.2100219726562</span></span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/26/31-Python-%E5%92%8C-C-C-%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/1229382-20200129161338513-2047487237.jpg" alt="img"></p>
<h3 id="传递数组"><a href="#传递数组" class="headerlink" title="传递数组"></a>传递数组</h3><p><strong>下面我们来看看如何使用 ctypes  传递数组，这里我们只讲传递，不讲返回。因为 C 语言返回数组给 Python  实际上会存在很多问题，比如：返回的数组的内存由谁来管理，不用了之后空间由谁来释放，事实上 ctypes  内部对于返回数组支持的也不是很好。因此我们一般不会向 Python 返回一个 C 语言中的数组，因为 C 语言中的数组传递给 Python  涉及到效率的问题，Python 中的列表传递直接传递一个引用即可，但是 C 语言中的数组过来肯定是要拷贝一份的，所以这里我们只讲 Python  如何通过 ctypes 给动态链接库传递数组，不再介绍动态链接库如何返回数组给 Python。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个数组，假设叫 [1, 2, 3, 4, 5]</span></span><br><span class="line">a5 = (c_int * <span class="number">5</span>)(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(a5)  <span class="comment"># &lt;__main__.c_long_Array_5 object at 0x00000162428968C0&gt;</span></span><br><span class="line"><span class="comment"># 上面这种方式就得到了一个数组</span></span><br><span class="line"><span class="comment"># 当然下面的方式也是可以的</span></span><br><span class="line">a5 = (c_int * <span class="number">5</span>)(*<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">6</span>))</span><br><span class="line"><span class="built_in">print</span>(a5)  <span class="comment"># &lt;__main__.c_long_Array_5 object at 0x0000016242896940&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>下面演示一下：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符数组默认是以 \0 作为结束的，我们可以通过 strlen 来计算长度。</span></span><br><span class="line"><span class="comment">// 但是对于整型的数组来说我们不知道有多长</span></span><br><span class="line"><span class="comment">// 因此有两种声明参数的方式，一种是 int a[n]，指定数组的长度</span></span><br><span class="line"><span class="comment">// 另一种是通过指定 int *a 的同时，再指定一个参数 int size，调用函数的时候告诉函数这个数组有多长</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">test1</span><span class="params">(<span class="type">int</span> a[<span class="number">5</span>])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 可能有人会问了，难道不能通过 sizeof 计算吗？答案是不能，无论是 int *a 还是 int a[n]</span></span><br><span class="line">    <span class="comment">// 数组作为函数的参数时会退化为指针，我们调用的时候，传递的都是指针，指针在 64 位机器上默认占 8 个字节。</span></span><br><span class="line">    <span class="comment">// 所以int a[] = &#123;...&#125;这种形式，如果直接在当前函数中计算的话，那么 sizeof(a) 就是数组里面所有元素的总大小，因为a是一个数组名</span></span><br><span class="line">    <span class="comment">// 但是当把 a 传递给一个函数的时候，那么等价于将 a 的首地址拷贝一份传过去，此时在新的函数中再计算 sizeof(a) 的时候就是一个指针的大小</span></span><br><span class="line">    <span class="comment">//至于 int *a 这种声明方式，不管在什么地方，sizeof(a) 都是一个指针的大小</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    a[<span class="number">3</span>] = <span class="number">10</span>;</span><br><span class="line">    a[<span class="number">4</span>] = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>;i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">        sum += a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line">from ctypes import *</span><br><span class="line"></span><br><span class="line">lib = CDLL(<span class="string">&quot;./main.dll&quot;</span>)</span><br><span class="line"></span><br><span class="line"># 创建 <span class="number">5</span> 个元素的数组，但是只给<span class="number">3</span>个元素</span><br><span class="line">arr = (c_int * <span class="number">5</span>)(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"># 在动态链接库中，设置剩余两个元素</span><br><span class="line"># 所以如果没问题的话，结果应该是 <span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span> + <span class="number">10</span> + <span class="number">20</span></span><br><span class="line">print(lib.test1(arr))  # <span class="number">36</span></span><br></pre></td></tr></table></figure>

<h3 id="传递结构体"><a href="#传递结构体" class="headerlink" title="传递结构体"></a>传递结构体</h3><p><strong>有了前面的数据结构还不够，我们还要看看结构体是如何传递的，有了结构体的传递，我们就能发挥更强大的功能。那么我们来看看如何使用 ctypes 定义一个结构体：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于这样一个结构体应该如何定义呢？</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">struct Girl &#123;</span></span><br><span class="line"><span class="string">  char *name;     // 姓名</span></span><br><span class="line"><span class="string">  int age;        // 年龄</span></span><br><span class="line"><span class="string">  char *gender;   //性别</span></span><br><span class="line"><span class="string">  int class;      //班级</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个类，必须继承自 ctypes.Structure</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span>(<span class="title class_ inherited__">Structure</span>):</span><br><span class="line">    <span class="comment"># 创建一个 _fields_ 变量，必须是这个名字，注意开始和结尾都只有一个下划线</span></span><br><span class="line">    <span class="comment"># 然后就可以写结构体的字段了，具体怎么写估计一看就清晰了</span></span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">&quot;name&quot;</span>, c_char_p),</span><br><span class="line">        (<span class="string">&quot;age&quot;</span>, c_int),</span><br><span class="line">        (<span class="string">&quot;gender&quot;</span>, c_char_p),</span><br><span class="line">        (<span class="string">&quot;class&quot;</span>, c_int)</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure>

<p><strong>我们向 C 中传递一个结构体，然后再返回：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Girl</span> &#123;</span></span><br><span class="line">  <span class="type">char</span> *name;</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">  <span class="type">char</span> *gender;</span><br><span class="line">  <span class="type">int</span> <span class="class"><span class="keyword">class</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收一个结构体，返回一个结构体</span></span><br><span class="line"><span class="keyword">struct</span> Girl <span class="title function_">test1</span><span class="params">(<span class="keyword">struct</span> Girl g)</span>&#123;</span><br><span class="line">  g.name = <span class="string">&quot;古明地觉&quot;</span>;</span><br><span class="line">  g.age = <span class="number">17</span>;</span><br><span class="line">  g.gender = <span class="string">&quot;female&quot;</span>;</span><br><span class="line">  g.class = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br><span class="line">from ctypes import *</span><br><span class="line"></span><br><span class="line">lib = CDLL(<span class="string">&quot;./main.dll&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Girl(Structure):</span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">&quot;name&quot;</span>, c_char_p),</span><br><span class="line">        (<span class="string">&quot;age&quot;</span>, c_int),</span><br><span class="line">        (<span class="string">&quot;gender&quot;</span>, c_char_p),</span><br><span class="line">        (<span class="string">&quot;class&quot;</span>, c_int)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 此时返回值类型就是一个 Girl 类型，另外我们这里的类型和 C 中结构体的名字不一样也是可以的</span><br><span class="line">lib.test1.restype = Girl</span><br><span class="line"># 传入一个实例，拿到返回值</span><br><span class="line">g = Girl()</span><br><span class="line">res = lib.test1(g)</span><br><span class="line">print(res, type(res))  # &lt;__main__.Girl object at <span class="number">0x0000015423A06840</span>&gt; &lt;class <span class="string">&#x27;__main__.Girl&#x27;</span>&gt;</span><br><span class="line">print(res.name, str(res.name, encoding=<span class="string">&quot;utf-8&quot;</span>))  <span class="meta"># b<span class="string">&#x27;\xe5\x8f\xa4\xe6\x98\x8e\xe5\x9c\xb0\xe8\xa7\x89&#x27;</span> 古明地觉</span></span><br><span class="line">print(res.age)  # <span class="number">17</span></span><br><span class="line">print(res.gender)  <span class="meta"># b<span class="string">&#x27;female&#x27;</span></span></span><br><span class="line">print(getattr(res, <span class="string">&quot;class&quot;</span>))  # <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><strong>如果是结构体指针呢？</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Girl</span> &#123;</span></span><br><span class="line">  <span class="type">char</span> *name;</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">  <span class="type">char</span> *gender;</span><br><span class="line">  <span class="type">int</span> <span class="class"><span class="keyword">class</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收一个指针，返回一个指针</span></span><br><span class="line"><span class="keyword">struct</span> Girl *<span class="title function_">test1</span><span class="params">(<span class="keyword">struct</span> Girl *g)</span>&#123;</span><br><span class="line">  g -&gt; name = <span class="string">&quot;mashiro&quot;</span>;</span><br><span class="line">  g -&gt; age = <span class="number">17</span>;</span><br><span class="line">  g -&gt; gender = <span class="string">&quot;female&quot;</span>;</span><br><span class="line">  g -&gt; <span class="class"><span class="keyword">class</span> =</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br><span class="line">from ctypes import *</span><br><span class="line"></span><br><span class="line">lib = CDLL(<span class="string">&quot;./main.dll&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Girl(Structure):</span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">&quot;name&quot;</span>, c_char_p),</span><br><span class="line">        (<span class="string">&quot;age&quot;</span>, c_int),</span><br><span class="line">        (<span class="string">&quot;gender&quot;</span>, c_char_p),</span><br><span class="line">        (<span class="string">&quot;class&quot;</span>, c_int)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 此时指定为 Girl 类型的指针</span><br><span class="line">lib.test1.restype = POINTER(Girl)</span><br><span class="line"># 传入一个实例，拿到返回值</span><br><span class="line"># 但返回的是指针，我们还需要手动调用一个 contents 才可以拿到对应的值。</span><br><span class="line">g = Girl()</span><br><span class="line">res = lib.test1(byref(g))</span><br><span class="line">print(str(res.contents.name, encoding=<span class="string">&quot;utf-8&quot;</span>))  <span class="meta"># mashiro</span></span><br><span class="line">print(res.contents.age)  # <span class="number">16</span></span><br><span class="line">print(res.contents.gender)  <span class="meta"># b<span class="string">&#x27;female&#x27;</span></span></span><br><span class="line">print(getattr(res.contents, <span class="string">&quot;class&quot;</span>))  # <span class="number">3</span></span><br><span class="line"></span><br><span class="line"># 另外我们不仅可以通过返回的 res 去调用，还可以通过 g 来调用，因为我们传递的是 g 的指针</span><br><span class="line"># 修改指针指向的内存就相当于修改g，所以我们通过g来调用也是可以的</span><br><span class="line">print(str(g.name, encoding=<span class="string">&quot;utf-8&quot;</span>))  <span class="meta"># mashiro</span></span><br></pre></td></tr></table></figure>

<p><strong>因此对于结构体来说，我们先创建一个结构体（Girl）实例  g，如果动态链接库的函数中接收的是结构体，那么直接把 g 传进去等价于将 g 拷贝了一份，此时函数中进行任何修改都不会影响原来的  g。但如果函数中接收的是结构体指针，我们传入 byref(g) 相当于把 g 的指针拷贝了一份，在函数中修改是会影响 g 的。而返回的 res  也是一个指针，所以我们除了通过 res.contents 来获取结构体中的值之外，还可以通过 g 来获取。再举个栗子对比一下：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">struct Num &#123;</span><br><span class="line">  <span class="built_in">int</span> x;</span><br><span class="line">  <span class="built_in">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct Num test1(struct Num n)&#123;</span><br><span class="line">  n.x += <span class="number">1</span>;</span><br><span class="line">  n.y += <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Num *test2(struct Num *n)&#123;</span><br><span class="line">  n-&gt;x += <span class="number">1</span>;</span><br><span class="line">  n-&gt;y += <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">lib = CDLL(<span class="string">&quot;./main.dll&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Num</span>(<span class="title class_ inherited__">Structure</span>):</span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">&quot;x&quot;</span>, c_int),</span><br><span class="line">        (<span class="string">&quot;y&quot;</span>, c_int),</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们在创建的时候是可以传递参数的</span></span><br><span class="line">num = Num(x=<span class="number">1</span>, y=<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(num.x, num.y)  <span class="comment"># 1 2</span></span><br><span class="line"></span><br><span class="line">lib.test1.restype = Num</span><br><span class="line">res = lib.test1(num)</span><br><span class="line"><span class="comment"># 我们看到通过 res 得到的结果是修改之后的值</span></span><br><span class="line"><span class="comment"># 但是对于 num 来说没有变</span></span><br><span class="line"><span class="built_in">print</span>(res.x, res.y)  <span class="comment"># 2 3</span></span><br><span class="line"><span class="built_in">print</span>(num.x, num.y)  <span class="comment"># 1 2</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">因为我们将 num 传进去之后，相当于将 num 拷贝了一份。</span></span><br><span class="line"><span class="string">函数里面的结构体和这里的 num 尽管长得一样，但是没有任何关系</span></span><br><span class="line"><span class="string">所以 res 获取的结果是自增之后的结果，但是 num 还是之前的 num</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们来试试传递指针，将 byref(num) 再传进去</span></span><br><span class="line">lib.test2.restype = POINTER(Num)</span><br><span class="line">res = lib.test2(byref(num))</span><br><span class="line"><span class="built_in">print</span>(num.x, num.y)  <span class="comment"># 2 3</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">我们看到将指针传进去之后，相当于把 num 的指针拷贝了一份。</span></span><br><span class="line"><span class="string">然后在函数中修改，相当于修改指针指向的内存，所以是会影响外面的 num 的</span></span><br><span class="line"><span class="string">而动态链接库的函数中返回的是参数中的结构体指针，而我们传递的 byref(num) 也是这里的num的指针</span></span><br><span class="line"><span class="string">尽管传递指针的时候也是拷贝了一份，两个指针本身来说虽然也没有任何联系，但是它们存储的地址是一样的</span></span><br><span class="line"><span class="string">那么通过 res.contents 获取到的内容就相当于是这里的 num</span></span><br><span class="line"><span class="string">因此此时我们通过 res.contents 获取和通过 num 来获取都是一样的。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(res.contents.x, res.contents.y)  <span class="comment"># 2 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 另外还需要注意的一点就是：如果传递的是指针，一定要先创建一个变量</span></span><br><span class="line"><span class="comment"># 比如这里，一定是：先要 num = Num()，然后再 byref(num)，不可以直接就 byref(Num())</span></span><br><span class="line"><span class="comment"># 原因很简单，因为 Num() 这种形式在创建完 Num 实例之后就销毁了，因为没有变量保存它，那么此时再修改指针指向的内存就会有问题，因为内存的值已经被回收了</span></span><br><span class="line"><span class="comment"># 如果不是指针，那么可以直接传递 Num()，因为拷贝了一份</span></span><br></pre></td></tr></table></figure>

<p><strong>所以在这里，C 中返回一个指针是没有问题的，因为它指向的对象是我们在 Python 中创建的，Python 会管理它。</strong></p>
<p><img src="/2023/04/26/31-Python-%E5%92%8C-C-C-%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/1229382-20200130022408720-967585017.jpg" alt="img"></p>
<h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p><strong>在看回调函数之前，我们先看看如何把一个函数赋值给一个变量。准确的说，是让一个指针指向一个函数，这个指针叫做函数指针。通常我们说的指针变量是指向一个整型、字符型或数组等等，而函数指针是指向函数。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">  <span class="type">int</span> c;</span><br><span class="line">  c = a + b;</span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// 创建一个指针变量 p，让 add 等于 p</span></span><br><span class="line">  <span class="comment">// 我们看到就类似声明函数一样，指定返回值类型和变量类型即可</span></span><br><span class="line">  <span class="comment">// 但是注意的是，中间一定是 *p，不是 p，因为这是一个函数指针，所以要有 *</span></span><br><span class="line">  <span class="type">int</span> (*p)(<span class="type">int</span>, <span class="type">int</span>) = add;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;1 + 3 = %d\n&quot;</span>, p(<span class="number">1</span>, <span class="number">3</span>)); <span class="comment">//1 + 3 = 4</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>除此之外我们还以使用 typedef。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">  <span class="type">int</span> c;</span><br><span class="line">  c = a + b;</span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于创建了一个类型，名字叫做 func，这个 func 表示的是一个函数指针类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*func)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// 声明一个 func 类型的函数指针 p，等于 add</span></span><br><span class="line">  func p = add;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;2 + 3 = %d\n&quot;</span>, p(<span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// 2 + 3 = 5</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>下面来看看如何使用回调函数，说白了就是把一个函数指针作为函数的参数。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">evaluate</span><span class="params">(<span class="type">int</span> score)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (score &lt; <span class="number">60</span> &amp;&amp; score &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;bad&quot;</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span> (score &lt; <span class="number">80</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;not bad&quot;</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span> (score &lt; <span class="number">90</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;good&quot;</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span> (score &lt;=<span class="number">100</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;excellent&quot;</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;无效的成绩&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收一个整型和一个函数指针，指针指向的函数接收一个整型返回一个 char *</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">execute1</span><span class="params">(<span class="type">int</span> score, <span class="type">char</span> *(*f)(<span class="type">int</span>))</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> f(score);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//除了上面那种方式，我们还可以跟之前一样通过 typedef</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> *(*func)(<span class="type">int</span>);</span><br><span class="line"><span class="comment">// 这样声明也是可以的。</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">execute2</span><span class="params">(<span class="type">int</span> score, func f)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> f(score);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, execute1(<span class="number">88</span>, evaluate)); <span class="comment">// good</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, execute2(<span class="number">70</span>, evaluate)); <span class="comment">// not bad</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们知道了在 C 中传入一个函数，那么在 Python 中如何定义一个 C 语言可以识别的函数呢？毫无疑问，类似于结构体，我们肯定是要先定义一个 Python 的函数，然后再把 Python 的函数转化成 C 语言可以识别的函数。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> (*f)(<span class="type">int</span> *, <span class="type">int</span> *))</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> f(&amp;a, &amp;b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们就以这个函数为例，add 函数返回一个 int，接收两个 int，和一个函数指针，那么我们如何在 Python 中定义这样的函数并传递呢？</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">lib = CDLL(<span class="string">&quot;./main.dll&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 动态链接库中的函数接收的函数的参数是两个 int *，所以我们这里的 a 和 b 也是一个 pointer</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a.contents.value + b.contents.value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时我们把 C 中的函数用 Python 表达了，但是这样肯定是不可能直接传递的，能传就见鬼了</span></span><br><span class="line"><span class="comment"># 那我们要如何转化呢？</span></span><br><span class="line"><span class="comment"># 可以通过 ctypes 里面的函数 CFUNCTYPE 转化一下，这个函数接收任意个参数</span></span><br><span class="line"><span class="comment"># 但是第一个参数是函数的返回值类型，然后函数的参数写在后面，有多少写多少。</span></span><br><span class="line"><span class="comment"># 比如这里的函数返回一个 int，接收两个 int *，所以就是</span></span><br><span class="line">t = CFUNCTYPE(c_int, POINTER(c_int), POINTER(c_int))</span><br><span class="line"><span class="comment"># 如果函数不需要返回值，那么写一个 None 即可</span></span><br><span class="line"><span class="comment"># 然后得到一个类型 t，此时的类型 t 就等同于 C 中的 typedef int (*t)(int*, int*);</span></span><br><span class="line"><span class="comment"># 将我们的函数传进去，就得到了 C 语言可以识别的函数 func</span></span><br><span class="line">func = t(add)</span><br><span class="line"><span class="comment"># 然后调用，别忘了定义返回值类型，当然这里是 int 就无所谓了</span></span><br><span class="line">lib.add.restype = c_int</span><br><span class="line"><span class="built_in">print</span>(lib.add(<span class="number">88</span>, <span class="number">96</span>, func))</span><br><span class="line"><span class="built_in">print</span>(lib.add(<span class="number">59</span>, <span class="number">55</span>, func))</span><br><span class="line"><span class="built_in">print</span>(lib.add(<span class="number">94</span>, <span class="number">105</span>, func))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">184</span></span><br><span class="line"><span class="string">114</span></span><br><span class="line"><span class="string">199</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/26/31-Python-%E5%92%8C-C-C-%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/1229382-20200130160241362-1029015726.jpg" alt="img"></p>
<p><strong>以上便是 ctypes 的基本用法，但其实我们可以通过 ctypes  玩出更高级的花样，甚至可以串改内部的解释器。ctypes 内部提供了一个属性叫 pythonapi，它实际上就是加载了 Python  安装目录里面的 python38.dll。有兴趣可以自己去了解一下，需要你了解底层的 Python &#x2F; C API，当然我们也很少这么做。对于  ctypes 调用 C 库而言，我们目前算是介绍完了。</strong></p>
<h2 id="使用-C-x2F-C-为-Python-开发扩展模块"><a href="#使用-C-x2F-C-为-Python-开发扩展模块" class="headerlink" title="使用 C &#x2F; C++ 为 Python 开发扩展模块"></a>使用 C &#x2F; C++ 为 Python 开发扩展模块</h2><p><strong>我们上面介绍 ctypes，我们说这种方式它不涉及任何的 Python &#x2F; C API，但是它只能做一些简单的交互。而如果是编写扩展模块的话，那么它是可以被 Python 解释器识别的，也就是说我们可以通过 import 的方式进行导入。</strong></p>
<blockquote>
<p><strong>关于扩展模块，这里不得不再提一下 Cython，使用 Python &#x2F; C API 编写扩展不是一件轻松的事情，其实还是 C 语言本身比较底层吧。而 Cython 则是帮我们解决了这一点，Cython 代码和  Python 高度相似，而 cython 编译器会自动帮助我们将 Cython 代码翻译成C代码，所以Cython本质上也是使用了 Python &#x2F; C API。只不过它让我们不需要直接面对C，只要我们编写 Cython 代码即可，会自动帮我们转成 C 的代码。</strong></p>
<p><strong>所以随着 Cython 的出现，现在使用 Python &#x2F; C API 编写扩展算是越来越少了，不过话虽如此，使用 Python &#x2F; C API 编写可以极大的帮助我们熟悉 Python 的底层。</strong></p>
</blockquote>
<p><strong>那么废话不多说，直接开始吧。</strong></p>
<h3 id="编写扩展模块的基本骨架"><a href="#编写扩展模块的基本骨架" class="headerlink" title="编写扩展模块的基本骨架"></a>编写扩展模块的基本骨架</h3><p><strong>首先使用 C &#x2F; C++ 为 Python 编写扩展的话，是需要遵循一定套路的，而这个套路很固定。那么下面就来介绍一下整个流程：</strong></p>
<p><strong>Python 的扩展模块是需要被 import 进来的，那么它必然要有一个入口。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个 xxx 非常重要，这个是你最终生成的扩展模块的名字，前面的 PyInit 是写死的</span></span><br><span class="line">PyInit_xxx(<span class="type">void</span>)  <span class="comment">// 模块初始化入口</span></span><br></pre></td></tr></table></figure>

<p><strong>有了入口之后，我们还需要创建模块，创建模块使用下面这个函数。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PyModule_Create  <span class="comment">// 创建模块</span></span><br></pre></td></tr></table></figure>

<p><strong>创建模块，那么总要有模块信息吧。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PyModuleDef  <span class="comment">// 模块信息</span></span><br></pre></td></tr></table></figure>

<p><strong>那么模块信息里面都可以包含哪些信息呢？模块名算吧，模块里面有哪些函数算吧。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PyMethodDef  <span class="comment">// 模块函数信息, 一个数组, 因为一个模块可以包含多个函数</span></span><br></pre></td></tr></table></figure>

<p><strong>而一个 Python 中的函数底层会对应一个结构体，这个结构体里面保存了 Python 函数的元信息，并且还保存了一个指向 C 函数的指针，这是显然的。</strong></p>
<p><strong>我们通过一个例子来说明以下吧，这样会更好理解一些，具体细节在编写代码的时候再补充。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f2</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="keyword">return</span> a + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>以上是非常简单的一个模块，里面只有两个简单的函数，但是我们知道当被导入时它就是一个 PyModuleObject 对象。里面除了我们定义的两个函数之外还有其它的属性，显然这是 Python  解释器在背后帮助我们完成的，具体流程也是我们上面说的那几步（省略了亿点点细节）。</strong></p>
<p><strong>那么我们如何使用 C 来进行编写呢？下面来操作一下。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">编写 Python 扩展模块，需要引入 Python.h 这个头文件</span></span><br><span class="line"><span class="comment">该头文件在 Python 安装目录的 include 目录下，我们必须要导入它</span></span><br><span class="line"><span class="comment">当然这个头文件里面还导入了很多其它的头文件，我们也可以直接拿来用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Python.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">编写我们之前的两个函数 f1 和 f2，必须返回 PyObject *</span></span><br><span class="line"><span class="comment">函数里面至少要接收一个 PyObject *self，而这个参数我们是不需要管的，当然不叫 self 也是可以的</span></span><br><span class="line"><span class="comment">显然跟方法里面的 self 是一个道理，所以对于 Python 调用者而言，f1 是一个不需要接收参数的函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">f1</span><span class="params">(PyObject *self)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> PyLong_FromLong(<span class="number">123</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">f2</span><span class="params">(PyObject *self, PyObject *a)</span> &#123;</span><br><span class="line">    <span class="type">long</span> x;</span><br><span class="line">    <span class="comment">// 转成 C 中的 long，进行相加，然后再转成 Python 的 int; 或者调用 PyNumber_Add() 也可以</span></span><br><span class="line">    x = PyLong_AsLong(a);</span><br><span class="line">    PyObject *result = PyLong_FromLong(x + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 但是注意：虽然我们定义了 f1 和 f2，但是它们是 C 中的函数，不是 Python 的</span></span><br><span class="line"><span class="comment">// Python 中的函数在 C 中对应的是一个结构体，里面会有函数指针，指向这里的 f1 和 f2</span></span><br><span class="line"><span class="comment">// 但除了函数指针，还有其它的信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">定义一个结构体数组，结构体类型为 PyMethodDef，显然这个 PyMethodDef 就是 Python 中的函数</span></span><br><span class="line"><span class="comment">PyMethodDef 里面有四个成员，分别是：函数名、函数指针(需要转成PyCFunction)、函数参数标识、函数的doc</span></span><br><span class="line"><span class="comment">关于 PyMethodDef 我们后面会单独说</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> PyMethodDef methods[] = &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;f1&quot;</span>,</span><br><span class="line">        (PyCFunction) f1,</span><br><span class="line">        METH_NOARGS, <span class="comment">// 后面单独说</span></span><br><span class="line">        <span class="string">&quot;this is a function named f1&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;<span class="string">&quot;f2&quot;</span>, (PyCFunction) f2, METH_O, <span class="string">&quot;this is a function named f2&quot;</span>&#125;,</span><br><span class="line">    <span class="comment">// 结尾要有一个 &#123;NULL, NULL, 0, NULL&#125; 充当哨兵</span></span><br><span class="line">    &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">我们编写的 py 文件，解释器会自动把它变成一个模块，但是这里我们需要手动定义</span></span><br><span class="line"><span class="comment">下面定义一个 PyModuleDef 类型的结构体，它就是我们的模块信息</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> PyModuleDef module = &#123;</span><br><span class="line">    <span class="comment">// 头部信息，PyModuleDef_Base m_base，正如所有对象都有 PyObject 这个结构体一样</span></span><br><span class="line">    <span class="comment">// 而 Python.h 中提供了一个宏，#define PyModuleDef_HEAD_INIT PyModuleDef_Base m_base; 我们可以使用 PyModuleDef_HEAD_INIT 来代替</span></span><br><span class="line">    PyModuleDef_HEAD_INIT,</span><br><span class="line">    <span class="string">&quot;kagura_nana&quot;</span>, <span class="comment">// 模块的名字</span></span><br><span class="line">    <span class="string">&quot;this is a module named kagura_nana&quot;</span>, <span class="comment">// 模块的doc，没有的话直接写成NULL即可</span></span><br><span class="line">    <span class="number">-1</span>, <span class="comment">// 模块的独立空间，这个不需要关心，直接写成 -1 即可</span></span><br><span class="line">    methods, <span class="comment">// 上面的 PyMethodDef 结构数组，必须写在这里，不然我们没法使用定义的函数</span></span><br><span class="line">    <span class="comment">// 下面直接写4个NULL即可</span></span><br><span class="line">    <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上便是 PyModuleDef 结构体实例的创建过程，至于里面的一些细节我们后面说</span></span><br><span class="line"><span class="comment">// 到目前为止，前置工作就做完了，下面还差两步</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">扩展库入口函数，这是一个宏，Python 的源代码我们知道是使用 C 来编写的</span></span><br><span class="line"><span class="comment">但是编译的时候为了支持 C++ 的编译器也能编译，于是需要通过 extern &quot;C&quot; 定义函数</span></span><br><span class="line"><span class="comment">然后这样 C++ 编译器在编译的的时候就会按照 C 的标准来编译函数，这个宏就是干这件事情的，主要和 Python 中的函数保持一致</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">PyMODINIT_FUNC</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">模块初始化入口，注意：模块名叫 kagura_nana，那么下面就必须要写成 PyInit_kagura_nana</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">PyInit_kagura_nana(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 将 PyModuleDef 结构体实例的指针传递进去，然后返回得到 Python 中的模块</span></span><br><span class="line">    <span class="keyword">return</span> PyModule_Create(&amp;module);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>整体逻辑还是非常简单的，过程如下：</strong></p>
<ul>
<li><code>include &quot;Python.h&quot;，这个是必须的</code></li>
<li><code>定义我们函数，具体定义什么函数、里面写什么代码完全取决于你的业务</code></li>
<li><code>定义一个PyMethodDef结构体数组</code></li>
<li><code>定义一个PyModuleDef结构体</code></li>
<li><code>定义模块初始化入口，然后返回模块对象</code></li>
</ul>
<p><strong>那么如何将这个 C 文件变成扩展模块呢？显然要经过编译，而 Python 提供了 distutils 标准库，可以非常轻松地帮我们把 C 文件编译成扩展模块。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> distutils.core <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">setup(</span><br><span class="line">    <span class="comment"># 打包之后会有一个 egg_info，表示该模块的元信息信息，name 就表示打包之后的 egg 文件名</span></span><br><span class="line">    <span class="comment"># 显然和模块名是一致的</span></span><br><span class="line">    name=<span class="string">&quot;kagura_nana&quot;</span>,</span><br><span class="line">    version=<span class="string">&quot;1.11&quot;</span>, <span class="comment"># 版本号</span></span><br><span class="line">    author=<span class="string">&quot;古明地盆&quot;</span>,</span><br><span class="line">    author_email=<span class="string">&quot;66666@东方地灵殿.com&quot;</span>,</span><br><span class="line">    <span class="comment"># 关键来了，这里面接收一个类 Extension，类里面传入两个参数</span></span><br><span class="line">    <span class="comment"># 第一个参数是我们的模块名，必须和 PyInit_xxx 中的 xxx 保持一致，否则报错</span></span><br><span class="line">    <span class="comment"># 第二个参数是一个列表，表示用到了哪些 C 文件，因为扩展模块对应的 C 文件不一定只有一个，我们这里的 C 文件还叫 main.c</span></span><br><span class="line">    ext_modules=[Extension(<span class="string">&quot;kagura_nana&quot;</span>, [<span class="string">&quot;main.c&quot;</span>])]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><strong>当前的 py 文件名叫做 1.py，我们在控制台中直接输入 python 1.py install 即可。注意：在介绍 ctypes 我用的是 gcc，但这里默认是使用 Visual Studio 2017 进行编译的。</strong></p>
<p><img src="/2023/04/26/31-Python-%E5%92%8C-C-C-%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/1229382-20210212015255393-47729497.png" alt="img"></p>
<p><strong>我们看到对应的 pyd 已经生成了，在你当前目录会有一个 build目录，然后 build 目录中 lib 开头的目录里面便存放了编译好的 pyd文件，并且还自动帮我们拷贝到了 site-packages 目录中。</strong></p>
<p><img src="/2023/04/26/31-Python-%E5%92%8C-C-C-%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/1229382-20210212015302384-381878609.png" alt="img"></p>
<p><strong>我们看到了 kagura_nana.cp38-win_amd64.pyd  文件，中间的部分表示解释器的版本，所以编写扩展模块的方式虽然可定制性更高，但它除了操作系统之外，还需要特定的解释器版本。因为中间是  cp38，所以只能 Python3.8 版本的解释器才可以导入它。然后还有一个 egg-info，它是我们编写的模块的元信息，我们打开看看。</strong></p>
<p><img src="/2023/04/26/31-Python-%E5%92%8C-C-C-%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/1229382-20210212015308135-1505296629.png" alt="img"></p>
<p><strong>有几个我们没有写，所以是 UNKNOW，当然这都不重要，重要的是我们能不能调用，试一试吧。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kagura_nana</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(kagura_nana)  <span class="comment"># &lt;module &#x27;kagura_nana&#x27; from &#x27;C:\\python38\\lib\\site-packages\\kagura_nana.cp38-win_amd64.pyd&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(kagura_nana.f1())  <span class="comment"># 123</span></span><br><span class="line"><span class="built_in">print</span>(kagura_nana.f2(<span class="number">123</span>))  <span class="comment"># 124</span></span><br></pre></td></tr></table></figure>

<p><strong>可以看到调用是没有任何问题的，最后再看一个神奇的东西，我们知道在 pycharm 这样的智能编辑器中，通过 Ctrl 加左键可以调到指定模块的指定位置。</strong></p>
<p><img src="/2023/04/26/31-Python-%E5%92%8C-C-C-%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/1229382-20210212015314973-369259813.png" alt="img"></p>
<p><strong>神奇的一幕出现了，我们点击进去居然还能跳转，其实我们在编译成扩展模块移动到 <code>site-packages</code> 之后，pycharm 会进行检测、然后将其抽象成一个普通的 py 文件，方便你查看。我们看到模块注释、函数的注释跟我们在 C  文件中指定的一样。但是注意：该文件只是 pycharm 方便你查看函数注释等信息而专门做的一个抽象，事实上你把这个文件删掉也是没有关系的。</strong></p>
<p><strong>因此我们可以再总结一下整体流程：</strong></p>
<p><strong>第一步：include “Python.h”，必须要引入这个头文件，这个头文件中还引入了 C 中的一些头文件，具体都引入了哪些库我们可以查阅。当然如果不确定但又懒得看，我们还可以手动再引入一次，反正 include 同一个头文件只会引入一次。</strong></p>
<p><strong>第二步：理论上这不是第二步，但是按照编写代码顺序我们就认为它是第二步吧，对，就是按照我们上面写的代码从上往下撸。这一步你需要编写函数，这个函数就是 C 语言中定义的函数，这个函数返回一个 PyObject * ，至少要接收一个PyObject *，我们一般叫它  self，这第一个参数你可以看成是必须的，无论我们传不传其他参数，这个参数是必需要有的。所以如果只有这一个参数，那么我们就认为这个函数不接收参数，因为我们在调用的时候没有传递。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">f1</span><span class="params">(PyObject *self)</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">f2</span><span class="params">(PyObject *self)</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">f3</span><span class="params">(PyObject *self)</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 假设我们定义了这三个函数吧，三个函数都不接受参数</span></span><br></pre></td></tr></table></figure>

<p><strong>第三步：定义一个 PyMethodDef  类型的数组，这个数组也是我们后面的 PyModuleDef 对象中的一个参数，这个数组名字叫什么就无所谓了。至于  PyMethodDef，我们可以单独使用 PyMethodDef  创建实例，然后将变量写到数组中，也可以直接在数组中创建。如果是直接在数组中创建的话，那么就不需要再使用 PyMethodDef 定义了，直接在  {} 里面写成员信息即可。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> PyMethodDef module_functions[] = &#123;</span><br><span class="line">    &#123;	</span><br><span class="line">        <span class="comment">// 暴露给 Python 的函数名</span></span><br><span class="line">        <span class="string">&quot;f1&quot;</span>,</span><br><span class="line">        <span class="comment">// 函数指针，最好使用 PyCFunction 转一下，可以确保不出问题。</span></span><br><span class="line">        <span class="comment">// 如果不转，我自己测试没有问题，但是编译时候会给警告，最好还是按照标准，把指针的类型转换一下</span></span><br><span class="line">        <span class="comment">// 转换成 Python 底层识别的 PyCFunction</span></span><br><span class="line">        (PyCFunction) f1, </span><br><span class="line">        METH_NOARGS, <span class="comment">// 参数类型，至于怎么接收 *args 和 **kwargs 的参数，后面说</span></span><br><span class="line">        <span class="string">&quot;函数f1的注释&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;<span class="string">&quot;f2&quot;</span>, (PyCFunction)f2, METH_NOARGS, <span class="string">&quot;函数f2的注释&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;f3&quot;</span>, (PyCFunction)f3, METH_NOARGS, <span class="string">&quot;函数f3的注释&quot;</span>&#125;,</span><br><span class="line">    <span class="comment">//别忘记，下面的 &#123;NULL, NULL, 0, NULL&#125;，充当哨兵</span></span><br><span class="line">    &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第四步：定义 PyModuleDef 对象，这个变量的名字叫什么也没有要求。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> PyModuleDef m = &#123;</span><br><span class="line">    PyModuleDef_HEAD_INIT, <span class="comment">// 头部信息</span></span><br><span class="line">    <span class="comment">// 模块名，这个是有讲究的，你要编译的扩展模块叫啥，这里就写啥</span></span><br><span class="line">    <span class="string">&quot;kagura_nana&quot;</span>, </span><br><span class="line">    <span class="string">&quot;模块的注释&quot;</span>,</span><br><span class="line">    <span class="number">-1</span>, <span class="comment">// 模块的空间，这个是给子解释器调用的，我们不需要关心，直接写 -1 即可，表示不使用</span></span><br><span class="line">    module_functions, <span class="comment">// 然后是我们上面定义的数组名，里面放了一大堆的 PyMethodDef 结构体实例</span></span><br><span class="line">    <span class="comment">// 然后是四个 NULL，因为该结构还有其它成员，但我们不需要使用，所以指定 NULL 即可。当然有的编译器比较智能，你若不指定自动为 NULL</span></span><br><span class="line">    <span class="comment">// 但为了规范，我们还是手动写上，因为规范的做法就是给每个成员都赋上值</span></span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第五步：写上一个宏，其实把它单独拆分出来，有点小题大做了。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PyMODINIT_FUNC</span><br><span class="line"><span class="comment">// 一个宏，主要是保证函数按照 C 的标准，不用在意，写上就行</span></span><br></pre></td></tr></table></figure>

<p><strong>第六步：创建一个模块的入口函数，我们说编译的扩展模块叫 kagura_nana，那么这个函数名就要这么写。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PyInit_kagura_nana(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 会根据上面定义的 PyModuleDef 实例，得到 Python 中的模块</span></span><br><span class="line">    <span class="comment">// PyModule_Create 就是用来创建 Python 中的模块的，直接将 PyModuleDef 定义的对象的指针扔进去</span></span><br><span class="line">    <span class="comment">// 便可得到 Python 中的模块，然后直接返回即可。</span></span><br><span class="line">    <span class="keyword">return</span> PyModule_Create(&amp;m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第七步：定义一个py文件，假设叫 xx.py，那么在里面写上如下内容，然后 python xx.py install 即可。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> distutils.core <span class="keyword">import</span>  *</span><br><span class="line"></span><br><span class="line">setup(</span><br><span class="line">    <span class="comment"># 这是生成的 egg 文件名，也是里面的元信息中的 Name</span></span><br><span class="line">    name=<span class="string">&quot;kagura_nana&quot;</span>,</span><br><span class="line">    <span class="comment"># 版本号</span></span><br><span class="line">    version=<span class="string">&quot;10.22&quot;</span>,  </span><br><span class="line">    <span class="comment"># 作者</span></span><br><span class="line">    author=<span class="string">&quot;古明地觉&quot;</span>,  </span><br><span class="line">    <span class="comment"># 作者邮箱</span></span><br><span class="line">    author_email=<span class="string">&quot;东方地灵殿&quot;</span>,</span><br><span class="line">    <span class="comment"># 当然还有其它参数，作为元信息来描述模块，比如 description：模块介绍。</span></span><br><span class="line">    <span class="comment"># 有兴趣的话可以看函数的注释，或者根据已有的 egg 文件自己查看</span></span><br><span class="line">    <span class="comment"># 下面是扩展模块，Extension(&quot;yousa&quot;, [&quot;C源文件&quot;])</span></span><br><span class="line">    <span class="comment"># 我们说 Extension 里面的第一个参数也必须是你的扩展模块的名字，并且必须要和 PyInit_xxx 以及 PyModuleDef 中的第一个成员保持一致</span></span><br><span class="line">    <span class="comment"># 至于第二个参数就是一个列表，你需要用到哪些 C 源文件。</span></span><br><span class="line">    <span class="comment"># 而且我们看到这个 Extension 也在一个列表里面，因为我们也可以传入多个 Extension 同时生成多个扩展模块。</span></span><br><span class="line">    <span class="comment"># 我们可以写好一个生成一个，你也可以一次性写多个，然后只编译一次。</span></span><br><span class="line">    ext_modules=[Extension(<span class="string">&quot;hanser&quot;</span>, [<span class="string">&quot;a.c&quot;</span>])]</span><br></pre></td></tr></table></figure>

<p><strong>以上便是编写扩展模块的基本流程，但是里面还有很多细节没有说。</strong></p>
<h4 id="PyMethodDef"><a href="#PyMethodDef" class="headerlink" title="PyMethodDef"></a>PyMethodDef</h4><p><strong>首先是 PyMethodDef，我们说它对应的是 Python 中的函数，那么我们肯定要来看看它的定义，藏身于 *Include&#x2F;methodobject.h* 中。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PyMethodDef</span> &#123;</span></span><br><span class="line">    <span class="comment">/* 函数名 */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>  *ml_name;   </span><br><span class="line">    <span class="comment">/* 实现对应逻辑的 C 函数，但是需要转成 PyCFunction 类型，主要是为了更好的处理关键字参数 */</span></span><br><span class="line">    PyCFunction ml_meth;    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 参数类型 </span></span><br><span class="line"><span class="comment">    #define METH_VARARGS  0x0001  扩展位置参数，*args</span></span><br><span class="line"><span class="comment">    #define METH_KEYWORDS 0x0002  扩展关键字参数，**kwargs</span></span><br><span class="line"><span class="comment">    #define METH_NOARGS   0x0004  不需要参数</span></span><br><span class="line"><span class="comment">    #define METH_O        0x0008  需要一个参数</span></span><br><span class="line"><span class="comment">    #define METH_CLASS    0x0010  被 classmethod 装饰</span></span><br><span class="line"><span class="comment">    #define METH_STATIC   0x0020  被 staticmethod 装饰   </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">int</span>         ml_flags;   </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//函数的 __doc__，没有的话传递 NULL</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>  *ml_doc; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PyMethodDef</span> <span class="title">PyMethodDef</span>;</span></span><br></pre></td></tr></table></figure>

<p><strong>如果不需要参数，那么 ml_flags 传入一个 METH_NOARGS；接收一个参数传入 METH_O；所以我们上面的 f1 对应的 ml_flags 是 METHOD_NOARGS，f2 对应的 ml_flags 是 METH_O。</strong></p>
<p><strong>如果是多个参数，那么直接写成 METH_VARAGRS 即可，也就是通过扩展位置参数的方式，但是这要如何解析呢？比如：有一个函数f3接收3个参数，这在C中要如何实现呢？别急我们后面会说。</strong></p>
<h3 id="引用计数和内存管理"><a href="#引用计数和内存管理" class="headerlink" title="引用计数和内存管理"></a>引用计数和内存管理</h3><p><strong>我们在最开始的时候就说过，PyObject  贯穿了我们的始终。我们说这里面存放了引用计数和类型指针，并且 Python 中所有对象底层对应的结构体都嵌套了 PyObject，因此  Python 中的所有对象都有引用计数和类型。并且 Python 的对象在底层，都可以看成是 PyObject 的一个扩展，因此参数、返回值都是 PyObject *，至于具体类型则是通过里面的 ob_type 动态判断。比如：之前使用的 PyLong_FromLong。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyLong_FromLong</span><span class="params">(<span class="type">long</span> ival)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyLongObject *v;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> (PyObject *)v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>此外 Python 还专门定义了几个宏，来看一下：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Py_REFCNT(ob)           (((PyObject*)(ob))-&gt;ob_refcnt)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Py_TYPE(ob)             (((PyObject*)(ob))-&gt;ob_type)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Py_SIZE(ob)             (((PyVarObject*)(ob))-&gt;ob_size)</span></span><br></pre></td></tr></table></figure>

<p><strong>Py_REFCNT：拿到对象的引用计数；Py_TYPE：拿到对象的类型；Py_SIZE：拿到对象的ob_size，也就是变长对象里面的元素个数。除此之外，Python 还提供了两个宏：Py_INCREF 和 Py_DECREF 来用于引用计数的增加和减少。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引用计数增加很简单，就是找到 ob_refcnt，然后 ++</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Py_INCREF(op) (                         \</span></span><br><span class="line"><span class="meta">    _Py_INC_REFTOTAL  _Py_REF_DEBUG_COMMA       \</span></span><br><span class="line"><span class="meta">    ((PyObject *)(op))-&gt;ob_refcnt++)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是减少的话，做的事情稍微多一些</span></span><br><span class="line"><span class="comment">// 其实主要就是判断引用计数是否为 0，如果为 0 直接调用 _Py_Dealloc 将对象销毁</span></span><br><span class="line"><span class="comment">// _Py_Dealloc 也是一个宏，会调用对应类型对象的 tp_dealloc，也就是析构方法</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Py_DECREF(op)                                   \</span></span><br><span class="line"><span class="meta">    do &#123;                                                \</span></span><br><span class="line"><span class="meta">        PyObject *_py_decref_tmp = (PyObject *)(op);    \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (_Py_DEC_REFTOTAL  _Py_REF_DEBUG_COMMA       \</span></span><br><span class="line"><span class="meta">        --(_py_decref_tmp)-&gt;ob_refcnt != 0)             \</span></span><br><span class="line"><span class="meta">            _Py_CHECK_REFCNT(_py_decref_tmp)            \</span></span><br><span class="line"><span class="meta">        <span class="keyword">else</span>                                            \</span></span><br><span class="line"><span class="meta">            _Py_Dealloc(_py_decref_tmp);                \</span></span><br><span class="line"><span class="meta">    &#125; while (0)</span></span><br></pre></td></tr></table></figure>

<p><strong>当然这些东西我们在系列的最开始的时候就已经说过了，但是接下来我们要引出一个非常关键的地方，就是内存管理。到目前为止我们没有涉及到内存管理的操作，但我们知道 Python 中的对象都是申请在堆区的，这个是不会自动释放的。举个栗子：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">f</span><span class="params">(PyObject *self)</span></span><br><span class="line">&#123;	</span><br><span class="line">    PyObject *s = PyUnicode_FromString(<span class="string">&quot;你好呀~~~&quot;</span>);</span><br><span class="line">    <span class="comment">// Py_None 就是 Python 中的 None, 同理还有 Py_True、Py_False，我们后面会继续提</span></span><br><span class="line">    <span class="comment">// 这里增加引用计数，至于为什么要增加，我们后面说</span></span><br><span class="line">    Py_INCREF(Py_None);</span><br><span class="line">    <span class="keyword">return</span> Py_None;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这个函数不需要参数，如果我们写一个死循环不停的调用这个函数，你会发现内存的占用蹭蹭的往上涨。就是因为这个 PyUnicodeObject 是申请在堆区的，此时内部的引用计数为 1。函数执行完毕变量 s 被销毁了，但是 s  是一个指针，这个指针被销毁了是不假，但是它指向的内存并没有被销毁。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">f</span><span class="params">(PyObject *self, PyObject *args, PyObject *kw)</span></span><br><span class="line">&#123;	</span><br><span class="line">    PyObject *s = PyUnicode_FromString(<span class="string">&quot;hello~~~&quot;</span>);</span><br><span class="line">    Py_DECREF(s);</span><br><span class="line">    Py_INCREF(Py_None);</span><br><span class="line">    <span class="keyword">return</span> Py_None;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>因此我们需要手动调用 Py_DECREF 这个宏，来将 s 指向的 PyUnicodeObject 的引用计数减 1，这样引用计数就为 0 了。不过有一个特例，那就是当这个指针作为返回值的时候，我们不需要手动减去引用计数，因为会自动减。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">f</span><span class="params">(PyObject *self)</span></span><br><span class="line">&#123;	</span><br><span class="line">    PyObject *s = PyUnicode_FromString(<span class="string">&quot;hello~~~&quot;</span>);</span><br><span class="line">    <span class="comment">// 如果我们把 s 给返回了，那么我们就不需要调用 Py_DECREF 了</span></span><br><span class="line">    <span class="comment">// 因为一旦作为返回值，那么会自动减去 1</span></span><br><span class="line">    <span class="comment">// 所以此时 C 中的对象是由 Python 来管理的，准确的说应该是作为返回值的指针指向的对象是由 Python 来管理的</span></span><br><span class="line">    <span class="keyword">return</span> s;	</span><br><span class="line">    <span class="comment">// 所以在返回 Py_None 的时候，我们需要手动将引用计数加 1，因为它作为了返回值。</span></span><br><span class="line">    <span class="comment">// 如果你不加 1，那么当你无限调用的时候，总会有那么一刻，Py_None 会被销毁，因为它的引用计数在不断减少</span></span><br><span class="line">    <span class="comment">// 但当销毁 Py_None 的时候，会出现 Fatal Python error: deallocating None，解释器异常退出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>不过这里还存在一个问题，那就是我们在 C 中返回的是 Python 传过来的。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">f</span><span class="params">(PyObject *self, PyObject *val)</span></span><br><span class="line">&#123;	</span><br><span class="line">	<span class="comment">//传递过来一个 PyObject *，然后原封不动的返回</span></span><br><span class="line">	<span class="keyword">return</span> val;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>显然上面 val 指向的内存不是在 C 中调用 api 创建的，而是  Python 创建然后传递过来的，也就是说这个 val 已经指向了一块合法的内存（和增加 Py_None  引用计数类似）。但是内存中的对象的引用计数是没有变化的，虽说有新的变量（这里的 val）指向它了，但是这个 val 是 C 中的变量不是  Python 中的变量，因此它的引用计数是没有变化的。然后作为返回值返回之后，指向对象的引用计数减一。所以你会发现在 Python  中，创建一个变量，然后传递到 f 中，执行完之后再进行打印就会发生段错误，因为对应的内存已经被回收了。如果能正常打印，说明在 Python  中这个变量的引用计数不为  1，也可能是小整数对象池、或者有多个变量引用，那么就创建一个大整数或者其他的对象多调用几次，因为作为返回值，每次调用引用计数都会减1。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">f</span><span class="params">(PyObject *self)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">// 假设创建一个 PyListObject</span></span><br><span class="line">    PyObject *l1 = PyList_New(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 将 l1 赋值给 l2，但是不好意思，这两位老铁指向的 PyListObject 的引用计数还是 1</span></span><br><span class="line">    PyObject *l2 = l1;</span><br><span class="line">    Py_INCREF(Py_None);</span><br><span class="line">    <span class="keyword">return</span> Py_None;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>因此我们说，如果在 C 中创建一个 PyObject  的话，那么它的引用计数会是 1，因为对象被初始化了，引用计数默认是 1。至于传递，无论你在 C 中将创建 PyObject *  赋值给了多少个变量，它们指向的 PyObject 的引用计数都会是 1。因为这些变量是 C 中的变量，不是 Python 中的。</strong></p>
<p><strong>因此我们的问题就很好解释了，我们说当一个 PyObject *  作为返回值的时候，它指向的对象的引用计数会减去 1，那么当 Python 传递过来一个 PyObject *  指针的时候，由于它作为了返回值，因此调用之后会发现引用计数会减少了。因此当你在 Python  中调用扩展函数结束之后，这个变量指向的内存可能就被销毁了。如果你在 Python  传递过来的指针没有作为返回值，那么引用计数是不会发生变化的，但是一旦作为了返回值，引用计数会自动减 1，因此我们需要手动的加 1。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">f</span><span class="params">(PyObject *self, PyObject *val)</span></span><br><span class="line">&#123;	</span><br><span class="line">    Py_INCREF(val);</span><br><span class="line">    <span class="keyword">return</span> val;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>因此我们可以得出如下结论：</strong></p>
<blockquote>
<p><strong>如果在 C 中，创建一个 PyObject *var，并且 var  已经指向了合法的内存，比如调用 PyList_New、PyDict_New 等等 api 返回的 PyObject *，总之就是已经存在了  PyObject。那么如果 var 没有作为返回值，我们必须手动地将 var 指向的对象的引用计数减  1，否则这个对象就会在堆区一直待着不会被回收。可能有人问，如果 PyObject *var2 &#x3D; var，我将 var  再赋值给一个变量呢？那么只需要对一个变量进行 Py_DECREF 即可，当然对哪个变量都是一样的，因为在 C  中变量的传递不会导致引用计数的增加。</strong></p>
<p><strong>如果 C 中创建的 PyObject * 作为返回值了，那么会自动将指向的对象的引用计数减 1，因此此时该指针指向的内存就由 Python 来管理了，就相当于在 Python 中创建了一个对象，我们不需要关心。</strong></p>
<p><strong>最后关键的一点，如果 C 中返回的指针指向的内存是 Python  中创建好的，假设我们在 Python 中创建了一个对象，然后把指针传递过来了，但是我们说这不会导致引用计数的增加，因为赋值的变量是 C  中的变量。如果 C  中用来接收参数的指针没有作为返回值，那么引用计数在扩展函数调用之前是多少、调用之后还是多少。然而一旦作为了返回值，我们说引用计数会自动减  1，因此假设你在调用扩展函数之前引用计数是  3，那么调用之后你会发现引用计数变成了2。为了防止段错误，一旦作为返回值，我们需要在返回之前手动地将引用计数加1。</strong></p>
</blockquote>
<p><strong>C中创建的：不作为返回值，引用计数手动减 1、作为返回值，不处理；Python 中创建传递过来的，不作为返回值，不处理、作为返回值，引用计数手动加 1。</strong></p>
<p><strong>而实现引用计数增加和减少所使用的宏就是 Py_INCREF  和 Py_DECREF，但它们要求传递的 PyObject * 不可以为 NULL。如果可能为 NULL 的话，那么建议使用 Py_XINCREF 和 Py_XDECREF。</strong></p>
<h3 id="参数的解析"><a href="#参数的解析" class="headerlink" title="参数的解析"></a>参数的解析</h3><p><strong>我们说，PyMethodDef 内部有一个 ml_flags 属性，表示此函数的参数类型，我们说有如下几种：</strong></p>
<p><strong>1. 不接受参数，METH_NOARGS，对应函数格式如下：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">f</span><span class="params">(PyObject *self)</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. 接受一个参数，METH_O，对应函数格式如下：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static PyObject *</span><br><span class="line">f(PyObject *self, PyObject *val)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. 接受任意个位置参数，METH_VARARGS，对应函数格式如下：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">f</span><span class="params">(PyObject *self, PyObject *args)</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4. 接受任意个位置参数和关键字参数，METH_VARARGS | METH_KEYWORDS，对应函数格式如下：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static PyObject *</span><br><span class="line">f(PyObject *self, PyObject *args, PyObject *kwargs)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第一种和第二种显然都很简单，关键是第三种和第四种要怎么做呢？我们先来看看第三种，解析多个位置参数可以使用一个函数：PyArg_ParseTuple。</strong></p>
<h4 id="解析多个位置参数"><a href="#解析多个位置参数" class="headerlink" title="解析多个位置参数"></a>解析多个位置参数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">函数原型：int PyArg_ParseTuple(PyObject *args, const char *format, ...); 位于 Python/getargs.c 中</span><br></pre></td></tr></table></figure>

<p><strong>所以重点就在 PyArg_ParseTuple 上面，我们注意到里面有一个 format，显然类似于 printf，里面肯定是一些占位符，那么都支持哪些占位符呢？常用的如下：</strong></p>
<ul>
<li><code>i：接收一个 Python 中的 int，然后解析成 C 的 int</code></li>
<li><code>l：接收一个 Python 中的 int，然后将传来的值解析成 C 的 long</code></li>
<li><code>f：接收一个 Python 中的 float，然后将传来的值解析成 C 的 float</code></li>
<li><code>d：接收一个 Python 中的 float，然后将传来的值解析成 C 的 double</code></li>
<li><code>s：接收一个 Python 中的 str，然后将传来的值解析成 C 的 char *</code></li>
<li><code>u：接收一个 Python 中的 str，然后将传来的值解析成 C 的 wchar_t *</code></li>
<li><code>O：接收一个 Python 中的 object，然后将传来的值解析成 C 的 PyObject *</code></li>
</ul>
<p><strong>我们举个栗子：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">f</span><span class="params">(PyObject *self, PyObject *args)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 目前我们定义了一个 PyObject *args，如果是 METH_O，那么这个 args 就是对应的一个参数</span></span><br><span class="line">    <span class="comment">// 如果 METH_VARAGRS，还是只需要定义一个 *args 即可，只不过此时的 *args 是一个 PyTupleObject，我们需要将多个参数解析出来</span></span><br><span class="line">    <span class="comment">//假设此时我们这个函数是接收 3 个 int，然后相加    </span></span><br><span class="line">    <span class="type">int</span> a, b, c;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    下面我们需要使用 PyArg_ParseTuple 进行解析，因为我们接收三个参数</span></span><br><span class="line"><span class="comment">    这个函数返回一个整型，如果失败会返回 0，成功返回非 0</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (!PyArg_ParseTuple(args, <span class="string">&quot;iii&quot;</span>, &amp;a, &amp;b, &amp;c))&#123;</span><br><span class="line">        <span class="comment">// 失败我们需要返回 NULL</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> PyLong_FromLong(a + b + c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们还是编译一下，当然编译的过程我们就不显示了，跟之前是一样的。并且为了方便，我们的模块名就不改了，但是编译之后的 pyd 文件内容已经变了。不过需要注意的是，我们说编译之后会有一个 build 目录，然后会自动把里面的 pyd 文件拷贝到  site-packages  中，如果你修改了代码，但是模块名没有变的话，那么编译之后的文件名还和原来一样。如果一样的话，那么由于已经存在相同文件了，可能就不会再拷贝了。因此两种做法：要么你把模块名给改了，这样编译会生成新的模块。要么编译之前记得把上一次编译生成的 build 目录先删掉，我们推荐第二种做法，不然 site-packages 目录下会出现一大堆我们自己定义的模块。</strong></p>
<p><strong>然后我们将 ml_flags 改成 METH_VARARGS，来测试一下。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Python.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">f</span><span class="params">(PyObject *self, PyObject *args)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, c;</span><br><span class="line">    <span class="keyword">if</span> (!PyArg_ParseTuple(args, <span class="string">&quot;iii&quot;</span>, &amp;a, &amp;b, &amp;c))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> PyLong_FromLong(a + b + c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyMethodDef methods[] = &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;f&quot;</span>,</span><br><span class="line">        (PyCFunction) f,</span><br><span class="line">        <span class="comment">// 这里需要改成 METH_VARAGRS，这个地方很重要，因为它表示了函数的参数类型。如果这个地方不修改的话，Python 在调用函数时会发生段错误</span></span><br><span class="line">        METH_VARARGS, </span><br><span class="line">        <span class="string">&quot;this is a function named f&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyModuleDef module = &#123;</span><br><span class="line">    PyModuleDef_HEAD_INIT,</span><br><span class="line">    <span class="string">&quot;kagura_nana&quot;</span>, </span><br><span class="line">    <span class="string">&quot;this is a module named kagura_nana&quot;</span>, </span><br><span class="line">    <span class="number">-1</span>, </span><br><span class="line">    methods,</span><br><span class="line">    <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PyMODINIT_FUNC</span><br><span class="line"></span><br><span class="line"><span class="title function_">PyInit_kagura_nana</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> PyModule_Create(&amp;module);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们编译成扩展模块之后，来测试一下，但是注意，你在调用的时候 pycharm 可能会感到别扭。</strong></p>
<p><img src="/2023/04/26/31-Python-%E5%92%8C-C-C-%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/1229382-20210212015328074-1712286863.png" alt="img"></p>
<p><strong>因为在调用函数 f 的是给你飘黄了，原因就是我们上一次在生成 pyd  的时候，里面的函数是 f1 和 f2，并没有 f。而我们 pycharm 会将 pyd 抽象成一个普通的 py 文件让你查看，但同时它也是  pycharm 自动提示的依据。因为上一次 pycharm 已经抽象出来了这个文件，而里面没有 f  这个函数，所以这里会飘黄。但是不用管，因为我们调用的是生成的 pyd 文件，跟 pycharm 抽象出来的 py 文件无关。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kagura_nana</span><br><span class="line"></span><br><span class="line"><span class="comment"># 传参不符合，自动给你报错</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(kagura_nana.f())</span><br><span class="line"><span class="keyword">except</span> TypeError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># function takes exactly 3 arguments (0 given)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(kagura_nana.f(<span class="number">123</span>))</span><br><span class="line"><span class="keyword">except</span> TypeError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># function takes exactly 3 arguments (1 given)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(kagura_nana.f(<span class="number">123</span>, <span class="string">&quot;xxx&quot;</span>, <span class="number">123</span>, <span class="number">123</span>))</span><br><span class="line"><span class="keyword">except</span> TypeError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># function takes exactly 3 arguments (4 given)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    kagura_nana.f(<span class="number">123</span>, <span class="number">123.0</span>, <span class="number">123</span>)  <span class="comment"># int: 123, long: 123, float: 123.000000, double: 123.000000</span></span><br><span class="line"><span class="keyword">except</span> TypeError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># integer argument expected, got float</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(kagura_nana.f(<span class="number">123</span>, <span class="number">123</span>, <span class="number">123</span>))  <span class="comment"># 369</span></span><br></pre></td></tr></table></figure>

<p><strong>怎么样，是不是很简单呢？当然 PyArg_ParseTuple 解析失败，Python 底层自动帮你报错了，告诉你缺了几个参数，或者哪个参数的类型错了。</strong></p>
<p><strong>我们这里是以 i 进行演示的，至于其它的几个占位符也是类似的。当然 O  比较特殊，因为它是转成 PyObject *，所以此时我们是可以传递元组、列表、字典等任意高阶对象的。而我们之前的 ctypes  则是不支持的，还是那句话，因为它没有涉及任何 Python &#x2F; C API 的调用，显然数据的表达能力有限。</strong></p>
<h4 id="解析成-PyObject"><a href="#解析成-PyObject" class="headerlink" title="解析成 PyObject *"></a>解析成 PyObject *</h4><p><strong>我们说 PyArg_ParseTuple 中的 i 代表 int、l 代表 long、f 代表 float、d 代表 double、s 代表 char*、u代表 wchar_t *，这些都比较简单。我们重点是 O，其实 O 也不难，无非就是后续的一些 Python &#x2F; C API 调用罢了。</strong></p>
<p><strong>我们还是以普通的 py 文件为例：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">lst: <span class="built_in">list</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    假设我们传递一个列表, 然后返回一个元组, 并且将里面的元素都设置成元素的类型</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">tuple</span>([<span class="built_in">type</span>(item) <span class="keyword">for</span> item <span class="keyword">in</span> lst])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(foo([<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;3&quot;</span>, &#123;&#125;]))  <span class="comment"># (&lt;class &#x27;int&#x27;&gt;, &lt;class &#x27;int&#x27;&gt;, &lt;class &#x27;str&#x27;&gt;, &lt;class &#x27;dict&#x27;&gt;)</span></span><br></pre></td></tr></table></figure>

<p><strong>如果使用 C 来编写扩展的话，要怎么做呢？</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Python.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">foo</span><span class="params">(PyObject *self, PyObject *args)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyObject *lst;  <span class="comment">// 首先我们这里要接收一个 PyObject *</span></span><br><span class="line">    <span class="comment">// 我们要修改 lst，让它指向我们传递的列表, 因此要传递一个二级指针进行修改</span></span><br><span class="line">    <span class="keyword">if</span> (!PyArg_ParseTuple(args, <span class="string">&quot;O&quot;</span>, &amp;lst))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算列表中的元素个数，申请同样大小的元组。</span></span><br><span class="line">    <span class="comment">// 其实还可以使用 PyList_Size，底层也是调用了 Py_SIZE，只是 PyList_Size 会进行类型检测，同理还有 PyTuple_Size 等等</span></span><br><span class="line">    Py_ssize_t arg_count = Py_SIZE(lst);</span><br><span class="line">    <span class="comment">// 申请完毕之后，里面的元素全部是 NULL，然后我们来进行设置</span></span><br><span class="line">    <span class="comment">// 但是这里我们故意多申请一个，我们看看 NULL 在 Python 中的表现是什么</span></span><br><span class="line">    PyObject *tpl = PyTuple_New(arg_count + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 申明类型对象、以及元素</span></span><br><span class="line">    PyObject *type, *val;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arg_count; i++) &#123;</span><br><span class="line">        val = PyList_GetItem(lst, i);  <span class="comment">// 获取对应元素，赋值给 val</span></span><br><span class="line">        <span class="comment">// 获取对应的类型对象，但得到的是 PyTypeObject *，所以需要转成 PyObject *</span></span><br><span class="line">        <span class="comment">// 或者你使用 Py_TYPE 这个宏也可以，内部自动帮你转了</span></span><br><span class="line">        type = (PyObject *)val -&gt; ob_type;</span><br><span class="line">        <span class="comment">//设置到元组中</span></span><br><span class="line">        PyTuple_SetItem(tpl, i, type);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tpl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyMethodDef methods[] = &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;foo&quot;</span>,</span><br><span class="line">        (PyCFunction) foo,</span><br><span class="line">        <span class="comment">// 记得这里写上 METH_VARARGS, 假设我们写的是 METH_NOARGS, 那么即便我们上面定义了参数也是没有意义的</span></span><br><span class="line">        <span class="comment">// 调用的时候 Python 会提示你: TypeError: foo() takes no arguments</span></span><br><span class="line">        METH_VARARGS,</span><br><span class="line">        <span class="literal">NULL</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyModuleDef module = &#123;</span><br><span class="line">    PyModuleDef_HEAD_INIT,</span><br><span class="line">    <span class="string">&quot;kagura_nana&quot;</span>,</span><br><span class="line">    <span class="string">&quot;this is a module named kagura_nana&quot;</span>,</span><br><span class="line">    <span class="number">-1</span>,</span><br><span class="line">    methods,</span><br><span class="line">    <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PyMODINIT_FUNC</span><br><span class="line"></span><br><span class="line"><span class="title function_">PyInit_kagura_nana</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> PyModule_Create(&amp;module);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>然后使用 Python 测试一下：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kagura_nana</span><br><span class="line"><span class="built_in">print</span>(</span><br><span class="line">    kagura_nana.foo([<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;3&quot;</span>, &#123;&#125;])</span><br><span class="line">)  <span class="comment"># (&lt;class &#x27;int&#x27;&gt;, &lt;class &#x27;int&#x27;&gt;, &lt;class &#x27;str&#x27;&gt;, &lt;class &#x27;dict&#x27;&gt;, &lt;NULL&gt;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们看到得到结果是一致的，并且我们多申请了一个空间，但是没有设置，所以结尾多了一个 &lt;NULL&gt;</span></span><br><span class="line"><span class="comment"># 但是注意：不要试图通过 kagura_nana.foo([1, 2, &quot;3&quot;, &#123;&#125;])[-1] 的方式来获取这个 NULL，会造成段错误</span></span><br><span class="line"><span class="comment"># 因为 Python 操作指针会自动操作指针指向的内存，而 NULL 是一个空指针，指向的内存是非法的</span></span><br><span class="line"><span class="comment"># 另外段错误是一种非常可怕的错误，它造成的结果就是解释器直接就异常退出了。</span></span><br><span class="line"><span class="comment"># 并且这不是异常捕获能解决的问题，异常捕获也是解释器正常运行的前提下。因此申请容器的时候，要保证元数个数相匹配</span></span><br></pre></td></tr></table></figure>

<p><strong>从这里我们也能看出使用 C 来为 Python 写扩展是一件多么麻烦的事情，因此 Cython 的出现是一个福音。当然我们上面的代码只是演示，没有太大意义，完全可以用 Python 实现。</strong></p>
<h4 id="传递字符串"><a href="#传递字符串" class="headerlink" title="传递字符串"></a>传递字符串</h4><p><strong>然后我们再来看看字符串的传递，比较简单，说白了这些都是 Python &#x2F; C API 的调用。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Python.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">f1</span><span class="params">(PyObject *self, PyObject *args)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 这里我们接受任意个字符串，然后将它们拼接在一起，最后放在列表中返回。</span></span><br><span class="line">   <span class="comment">// 由于是任意个，所以无法使用 PyArg_ParseTuple 了</span></span><br><span class="line">   <span class="comment">// 因为我们不知道占位符要写几个 O，但我们说 args 是一个元组，那么我们可以按照元组的方式进行解析</span></span><br><span class="line">   Py_ssize_t arg_count = Py_SIZE(args);  <span class="comment">// 计算元组的长度</span></span><br><span class="line">   PyObject *res = PyUnicode_FromWideChar(<span class="string">L&quot;&quot;</span>, <span class="number">0</span>);  <span class="comment">// 返回值，因为包含中文，所以是宽字符</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i &lt; arg_count; i++)&#123;</span><br><span class="line">       <span class="comment">// 将 res 和 里面的字符串依次拼接，等价于字符串的加法</span></span><br><span class="line">       res = PyUnicode_Concat(res, PyTuple_GetItem(args, i));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 我们上面这种做法比较笨，直接通过 PyUnicode_Join 直接拼接不香吗？我们目前先这么做，join 的话在下面的 f2 函数中</span></span><br><span class="line">   <span class="comment">// 然后创建一个列表，将结果放进去。我们申请列表，容量只需要为 1 即可</span></span><br><span class="line">   PyObject *lst = PyList_New(<span class="number">1</span>);</span><br><span class="line">   PyList_SetItem(lst, <span class="number">0</span>, res);</span><br><span class="line">   <span class="comment">// 我们说 lst 是在 C 中创建的, 但是它作为了返回值, 所以我们不需要关心它的引用计数, 因为会自动减一</span></span><br><span class="line">   <span class="comment">// 那 res 怎么办？它要不要减少引用计数，答案是不需要、也不能，因为它作为了容器的一个元素(这里面有很多细节，我们暂且不表，在后面介绍 PyDictObject 的时候再说)</span></span><br><span class="line">   <span class="keyword">return</span> lst;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">f2</span><span class="params">(PyObject *self, PyObject *args)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 这里还可以指定连接的字符，这里就直接返回吧</span></span><br><span class="line">    PyObject *res = PyUnicode_Join(PyUnicode_FromWideChar(<span class="string">L&quot;||&quot;</span>, <span class="number">2</span>), args);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyMethodDef methods[] = &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;f1&quot;</span>,</span><br><span class="line">        (PyCFunction) f1,</span><br><span class="line">        METH_VARARGS,</span><br><span class="line">        <span class="literal">NULL</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;f2&quot;</span>,</span><br><span class="line">        (PyCFunction) f2,</span><br><span class="line">        METH_VARARGS,</span><br><span class="line">        <span class="literal">NULL</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyModuleDef module = &#123;</span><br><span class="line">    PyModuleDef_HEAD_INIT,</span><br><span class="line">    <span class="string">&quot;kagura_nana&quot;</span>,</span><br><span class="line">    <span class="string">&quot;this is a module named kagura_nana&quot;</span>,</span><br><span class="line">    <span class="number">-1</span>,</span><br><span class="line">    methods,</span><br><span class="line">    <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PyMODINIT_FUNC</span><br><span class="line"></span><br><span class="line"><span class="title function_">PyInit_kagura_nana</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> PyModule_Create(&amp;module);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Python 进行调用，看看结果。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kagura_nana</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(kagura_nana.f1(<span class="string">&quot;哼哼&quot;</span>, <span class="string">&quot;嘿嘿&quot;</span>, <span class="string">&quot;哈哈&quot;</span>))  <span class="comment"># [&#x27;哼哼嘿嘿哈哈&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(kagura_nana.f2(<span class="string">&quot;哼哼&quot;</span>, <span class="string">&quot;嘿嘿&quot;</span>, <span class="string">&quot;哈哈&quot;</span>))  <span class="comment"># 哼哼||嘿嘿||哈哈</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看到结果是没有问题的，还是蛮有趣的。</strong></p>
<h3 id="类型检查和返回异常"><a href="#类型检查和返回异常" class="headerlink" title="类型检查和返回异常"></a>类型检查和返回异常</h3><p><strong>在 Python 中，当我们传递的类型不对时会报错。那么在底层我如何才能检测传递过来的参数是不是想要的类型呢？首先我们想到的是通过 ob_type，假设我们要求 val 是一个 int，那么：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Python.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">f1</span><span class="params">(PyObject *self, PyObject *val)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">// 获取类型名称， 如果是字符串，那么 tp_name 就是 &quot;str&quot;，字典是 &quot;dict&quot;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *tp_name = val -&gt; ob_type -&gt; tp_name;</span><br><span class="line">    <span class="type">char</span> *res;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(tp_name, <span class="string">&quot;int&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        res = <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res = <span class="string">&quot;failure&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> PyUnicode_FromString(res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyMethodDef methods[] = &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;f1&quot;</span>,</span><br><span class="line">        (PyCFunction) f1,</span><br><span class="line">        METH_O,</span><br><span class="line">        <span class="literal">NULL</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyModuleDef module = &#123;</span><br><span class="line">    PyModuleDef_HEAD_INIT,</span><br><span class="line">    <span class="string">&quot;kagura_nana&quot;</span>,</span><br><span class="line">    <span class="string">&quot;this is a module named kagura_nana&quot;</span>,</span><br><span class="line">    <span class="number">-1</span>,</span><br><span class="line">    methods,</span><br><span class="line">    <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PyMODINIT_FUNC</span><br><span class="line"></span><br><span class="line"><span class="title function_">PyInit_kagura_nana</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> PyModule_Create(&amp;module);</span><br><span class="line">&#125;</span><br><span class="line">import kagura_nana</span><br><span class="line"><span class="title function_">print</span><span class="params">(kagura_nana.f1(<span class="number">123</span>))</span>  <span class="meta"># success</span></span><br><span class="line"><span class="title function_">print</span><span class="params">(kagura_nana.f1(<span class="string">&quot;123&quot;</span>))</span>  <span class="meta"># failure</span></span><br></pre></td></tr></table></figure>

<p><strong>以上是一种判断方式，但是 Python 底层给我们提供了其它的 API 来进行判断。比如：</strong></p>
<ul>
<li><code>判断是否为整型: PyLong_Check</code></li>
<li><code>判断是否为字符串: PyUnicode_Check</code></li>
<li><code>判断是否为浮点型: PyFloat_Check</code></li>
<li><code>判断是否为复数: PyComplex_Check</code></li>
<li><code>判断是否为元组: PyTuple_Check</code></li>
<li><code>判断是否为列表: PyList_Check</code></li>
<li><code>判断是否为字典: PyDict_Check</code></li>
<li><code>判断是否为集合: PySet_Check</code></li>
<li><code>判断是否为字节串: PyBytes_Check</code></li>
<li><code>判断是否为函数: PyFunction_Check</code></li>
<li><code>判断是否为方法: PyMethod_Check</code></li>
<li><code>判断是否为实例对象: PyInstance_Check</code></li>
<li><code>判断是否为类(type的实例对象): PyType_Check</code></li>
<li><code>判断是否为可迭代对象: PyIter_Check</code></li>
<li><code>判断是否为数值: PyNumber_Check</code></li>
<li><code>判断是否为序列(实现 __getitem__ 和 __len__): PySequence_Check</code></li>
<li><code>判断是否为映射(必须实现 __getitem__、__len__ 和 __iter__): PyMapping_Check</code></li>
<li><code>判断是否为模块: PyModule_Check</code></li>
</ul>
<p><strong>写法非常固定，因此我们上面的判断逻辑就可以进行如下修改：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">f1</span><span class="params">(PyObject *self, PyObject *val)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *res;</span><br><span class="line">    <span class="keyword">if</span> (PyLong_Check(val)) &#123;</span><br><span class="line">        res = <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res = <span class="string">&quot;failure&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> PyUnicode_FromString(res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这种写法是不是就简单多了呢？其它部分不需要动，然后你可以自己重新编译、并测试一下，看看结果是不是一样的。</strong></p>
<p><strong>然后问题来了，如果用户传递的参数个数不对，或者类型不对，那么我们应该返回一个 TypeError，或者说返回一个异常。那么在 C 中，要如何设置异常呢？其实设置异常，说白了就是把输出信息打印到 stderr 中，然后直接返回 NULL 即可。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Python.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">f1</span><span class="params">(PyObject *self, PyObject *args)</span></span><br><span class="line">&#123;</span><br><span class="line">    Py_ssize_t arg_count = Py_SIZE(args);</span><br><span class="line">    <span class="keyword">if</span> (arg_count != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="comment">// 这里是我们设置的异常, 其实参数个数不对的话, 我们可以借助于 PyArg_ParseTuple 来帮助我们</span></span><br><span class="line">        <span class="comment">// 因为指定的占位符已经表明了参数的个数</span></span><br><span class="line">        PyErr_Format(PyExc_TypeError, <span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt; f1() takes 3 positional arguments but %d were given&quot;</span>, arg_count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 然后我们要求第一个参数是整型, 第二个参数是字符串, 第三个参数是列表</span></span><br><span class="line">    PyObject *a, *b, *c;</span><br><span class="line">    <span class="comment">// 因为参数一定是三个, 否则逻辑不会执行到这里, 因此我们不需要判断了</span></span><br><span class="line">    PyArg_ParseTuple(args, <span class="string">&quot;OOO&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">    <span class="comment">// 检测</span></span><br><span class="line">    <span class="keyword">if</span> (!PyLong_Check(a)) &#123;</span><br><span class="line">        PyErr_Format(PyExc_ValueError, <span class="string">&quot;The 1th argument requires a int, but got %s&quot;</span>, Py_TYPE(a) -&gt; tp_name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!PyUnicode_Check(b)) &#123;</span><br><span class="line">        PyErr_Format(PyExc_ValueError, <span class="string">&quot;The 2th argument requires a str, but got %s&quot;</span>, Py_TYPE(b) -&gt; tp_name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!PyList_Check(c)) &#123;</span><br><span class="line">        PyErr_Format(PyExc_ValueError, <span class="string">&quot;The 3th argument requires a list, but got %s&quot;</span>, Py_TYPE(c) -&gt; tp_name);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检测成功之后, 我们将整数和字符串添加到列表中</span></span><br><span class="line">    PyList_Append(c, a);</span><br><span class="line">    PyList_Append(c, b);</span><br><span class="line">    <span class="comment">// 这里我们将列表给返回, 而它是 Python 传递过来的, 所以一旦返回、引用计数会减一, 因此我们需要手动加一</span></span><br><span class="line">    Py_INCREF(c);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyMethodDef methods[] = &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;f1&quot;</span>,</span><br><span class="line">        (PyCFunction) f1,</span><br><span class="line">        METH_VARARGS,</span><br><span class="line">        <span class="literal">NULL</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyModuleDef module = &#123;</span><br><span class="line">    PyModuleDef_HEAD_INIT,</span><br><span class="line">    <span class="string">&quot;kagura_nana&quot;</span>,</span><br><span class="line">    <span class="string">&quot;this is a module named kagura_nana&quot;</span>,</span><br><span class="line">    <span class="number">-1</span>,</span><br><span class="line">    methods,</span><br><span class="line">    <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PyMODINIT_FUNC</span><br><span class="line"></span><br><span class="line"><span class="title function_">PyInit_kagura_nana</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> PyModule_Create(&amp;module);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所以逻辑就是像上面那样，通过 PyErr_Format  来设置异常，这个会被 Python 端接收到，但是异常一旦设置，就必须要返回 NULL，否则会出现段错误。但反过来吗，返回 NULL  的话则不一定要设置异常，但如果你不设置，那么 Python 底层会默认帮你设置一个 SystemError，并且异常的 value  信息为：<built-in function f1> returned NULL without setting an  error，提示你返回了 NULL 但没有设置 error。因为返回 NULL 表示程序需要终止了，那么就应该把为什么需要终止的理由告诉使用者。</built-in></strong></p>
<p><strong>然后我们来测试一下：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kagura_nana</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    kagura_nana.f1()</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># &gt;&gt;&gt;&gt;&gt;&gt; f1() takes 3 positional arguments but 0 were given</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    kagura_nana.f1(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># &gt;&gt;&gt;&gt;&gt;&gt; f1() takes 3 positional arguments but 4 were given</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    kagura_nana.f1(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># The 2th argument requires a str, but got int</span></span><br><span class="line"></span><br><span class="line">lst = [<span class="string">&quot;xx&quot;</span>, <span class="string">&quot;yy&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(kagura_nana.f1(<span class="number">123</span>, <span class="string">&quot;123&quot;</span>, lst))  <span class="comment"># [&#x27;xx&#x27;, &#x27;yy&#x27;, 123, &#x27;123&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># [&#x27;xx&#x27;, &#x27;yy&#x27;, 123, &#x27;123&#x27;]</span></span><br></pre></td></tr></table></figure>

<p><strong>所表现的一切，都和我们在底层设置的一样。另外我们再来看看这个函数的身份是什么：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kagura_nana</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(): <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(kagura_nana.f1)  <span class="comment"># &lt;built-in function f1&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>)  <span class="comment"># &lt;built-in function sum&gt;</span></span><br><span class="line"><span class="built_in">print</span>(foo)  <span class="comment"># &lt;function foo at 0x000001F1BAAF61F0&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>我们居然实现了一个内置函数，怎么样是不是很神奇呢？因为扩展模块里面的函数和解释器内置的函数本质上都是一样的，所以它们都是 built-in。</strong></p>
<h3 id="返回布尔类型和-None"><a href="#返回布尔类型和-None" class="headerlink" title="返回布尔类型和 None"></a>返回布尔类型和 None</h3><p><strong>我们说函数都必须返回一个 PyObject  *，如果这个函数没有返回值，那么在 Python 中实际上返回的是一个 None，但是我们不能返回 NULL，None 和 NULL  是两码事。在扩展函数中，如果返回 NULL 就表示这个函数执行的时候，不符合某个逻辑，我们需要终止掉，不能再执行下去了。这是在底层，但是在  Python 的层面，你需要告诉使用者为什么不能执行了，或者说底层的哪一行代码不满足条件，因此这个时候我们会在 return NULL  之前需要手动设置一个异常，这样在 Python 代码中才知道为什么底层函数退出了。当然有时候会自动帮我们设置，比如们说的  PyArg_ParseTuple。</strong></p>
<p><strong>那么在底层如何返回一个 None 呢？既然要返回我们就需要知道它的结构是什么。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先在 Python 中，None 也是有类型的</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="literal">None</span>))  <span class="comment"># &lt;class &#x27;NoneType&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>这个 NoneType 在底层对应的是 _PyNone_Type，至于 None 在底层对应的结构体是 _Py_NoneStruct，所以我们返回的时候应该返回这个结构体的指针。不过官方不推荐直接使用，而是给我们定义了一个宏，<code>#define Py_None (&amp;_Py_NoneStruct)</code>，我们直接返回 Py_None 即可。</strong></p>
<p><strong>不光是 None，我们说还有 True 和 False，True 和 False 对应的结构体是：_Py_FalseStruct，_Py_TrueStruct，它们本质上是 PyLongObject，Python 也不推荐直接返回，也是定义了两个宏。</strong></p>
<ul>
<li><code>#define Py_False ((PyObject *) &amp;_Py_FalseStruct)</code></li>
<li><code>#define Py_True ((PyObject *) &amp;_Py_TrueStruct)</code></li>
</ul>
<p><strong>推荐我们使用 Py_False 和 Py_True。</strong></p>
<p><strong>另外：</strong></p>
<ul>
<li><code>return Py_None; 等价于 Py_RETURN_NONE;</code></li>
<li><code>return Py_True; 等价于 Py_RETURN_TRUE;</code></li>
<li><code>return Py_False; 等价于 Py_RETURN_FALSE;</code></li>
</ul>
<p><strong>可以自己测试一下，比如条件满足返回 Py_True，不满足返回 Py_False 等等。</strong></p>
<h3 id="传递关键字参数"><a href="#传递关键字参数" class="headerlink" title="传递关键字参数"></a>传递关键字参数</h3><p><strong>我们上面的例子都是通过位置参数实现的，如果我们通过关键字参数传递呢？很明显是会报错的，因为我们参数名叫什么都不知道，所以上面的例子都不支持关键字参数。那么下面我们就来看看关键字参数要如何实现。</strong></p>
<p><strong>传递关键字参数的话，我们是通过 key&#x3D;value 的方式来实现，那么在 C 中我们如何解析呢？既然支持关键字的方式，那么是不是也可以实现默认参数呢？答案是肯定的，我们知道解析位置参数是通过  PyArg_ParseTuple，而解析关键字参数是通过 PyArg_ParseTupleAndKeywords。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">函数原型: int PyArg_ParseTupleAndKeywords(PyObject *args, PyObject *kw, const char *format, char *keywords[], ...) </span><br></pre></td></tr></table></figure>

<p><strong>我们看到相比原来的 PyArg_ParseTuple，多了一个 kw 和一个 char * 类型的数组，具体怎么用我们在编写代码的时候说。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Python.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">f1</span><span class="params">(PyObject *self, PyObject *args, PyObject *kwargs)</span>  </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 我们说函数既可以通过位置参数、还可以通过关键字参数传递，那么函数的参数类型就要变成 METH_VARARGS | METH_KEYWORDS</span></span><br><span class="line">    <span class="comment">// 参数 args 就是 PyTupleObject 对象, kwargs 就是 PyDictObject 对象</span></span><br><span class="line">    <span class="comment">// 假设我们定义了三个参数，name、age、place，这三个参数可以通过位置参数传递、也可以通过关键字参数传递</span></span><br><span class="line">    <span class="type">wchar_t</span> *name;</span><br><span class="line">    <span class="type">int</span> age = <span class="number">17</span>;</span><br><span class="line">    <span class="type">wchar_t</span> *gender = <span class="string">L&quot;FEMALE&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 告诉 Python 解释器参数的名字，注意：里面字符串的顺序就是函数定义的参数顺序</span></span><br><span class="line">    <span class="comment">// 这里的字符串就是函数的参数名，上面的是变量名。其实变量名字叫什么无所谓，只是为了一致我们会起相同的名字</span></span><br><span class="line">    <span class="type">char</span> *keys[] = &#123;<span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;gender&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="comment">// 注意结尾要有一个 NULL，否则会报出段错误。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析参数，我们看到 format 中本来应该是 uiu 的，但是中间出现了一个 |</span></span><br><span class="line">    <span class="comment">// 这就表示 | 后面的参数是可以不填的，如果不填会使用我们上面给出的默认值</span></span><br><span class="line">    <span class="comment">// 因此这里 name 就是必填的，因为它在 | 的前面，而 age 和 gender 可以不填，如果不填就用我们上面给出的默认值</span></span><br><span class="line">    <span class="keyword">if</span> (!PyArg_ParseTupleAndKeywords(args, kwargs, <span class="string">&quot;u|iu&quot;</span>, keys, &amp;name, &amp;age, &amp;gender))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;  <span class="comment">// keys 就是函数的所以参数的名字，然后后面把指针传进去，注意顺序要和参数顺序保持一致</span></span><br><span class="line">    <span class="type">wchar_t</span> res[<span class="number">100</span>];</span><br><span class="line">    swprintf(res, <span class="number">100</span>, <span class="string">L&quot;name: %s, age: %d, gender: %s&quot;</span>, name, age, gender);</span><br><span class="line">    <span class="keyword">return</span> PyUnicode_FromWideChar(res, wcslen(res));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyMethodDef methods[] = &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;f1&quot;</span>,</span><br><span class="line">        (PyCFunction) f1,</span><br><span class="line">        METH_VARARGS | METH_KEYWORDS,  <span class="comment">// 注意这里, 因为支持位置参数和关键字参数, 所以是 METH_VARARGS | METH_KEYWORDS</span></span><br><span class="line">        <span class="literal">NULL</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyModuleDef module = &#123;</span><br><span class="line">    PyModuleDef_HEAD_INIT,</span><br><span class="line">    <span class="string">&quot;kagura_nana&quot;</span>,</span><br><span class="line">    <span class="string">&quot;this is a module named kagura_nana&quot;</span>,</span><br><span class="line">    <span class="number">-1</span>,</span><br><span class="line">    methods,</span><br><span class="line">    <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PyMODINIT_FUNC</span><br><span class="line"></span><br><span class="line"><span class="title function_">PyInit_kagura_nana</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> PyModule_Create(&amp;module);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>用 Python 来测试一下。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kagura_nana</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(kagura_nana.f1())</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># function missing required argument &#x27;name&#x27; (pos 1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(kagura_nana.f1(<span class="number">123</span>))</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># argument 1 must be str, not int</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(kagura_nana.f1(<span class="string">&quot;古明地觉&quot;</span>))  <span class="comment"># name: 古明地觉, age: 17, gender: FEMALE</span></span><br><span class="line"><span class="built_in">print</span>(kagura_nana.f1(<span class="string">&quot;古明地恋&quot;</span>, <span class="number">16</span>))  <span class="comment"># name: 古明地恋, age: 16, gender: FEMALE</span></span><br><span class="line"><span class="built_in">print</span>(kagura_nana.f1(<span class="string">&quot;古明地恋&quot;</span>, <span class="number">16</span>, <span class="string">&quot;女&quot;</span>))  <span class="comment"># name: 古明地恋, age: 16, gender: 女</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看到一切都符合我们的预期，而且 PyArg_ParseTuple，和  PyArg_ParseTupleAndKeywords  可以自动帮我们检测参数是否合法，不合法抛出合理的异常。当然你也可以检测参数的个数，或者将参数一个一个获取、用 PyXxx_Check  系列检测函数进行判断，看看是否符合预期，当然这么做就比较麻烦了。</strong></p>
<p><strong>PyArg_ParseTuple 和 PyArg_ParseTupleAndKeywords 里面的占位符还可以接收一些特殊的符号，我们举个栗子。为了更好的说明，我们统一以 PyArg_ParseTupleAndKeywords 为例。</strong></p>
<h4 id="占位符"><a href="#占位符" class="headerlink" title="占位符 :"></a>占位符 :</h4><p><strong>下面的是之前写的 C 代码，我们不做任何改动，来测试一下当参数传递错误时的报错信息。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Python.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">f1</span><span class="params">(PyObject *self, PyObject *args, PyObject *kwargs)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">wchar_t</span> *name;</span><br><span class="line">    <span class="type">int</span> age = <span class="number">17</span>;</span><br><span class="line">    <span class="type">wchar_t</span> *gender = <span class="string">L&quot;FEMALE&quot;</span>;</span><br><span class="line">    <span class="type">char</span> *keys[] = &#123;<span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;gender&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (!PyArg_ParseTupleAndKeywords(args, kwargs, <span class="string">&quot;u|iu&quot;</span>, keys, &amp;name, &amp;age, &amp;gender))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">wchar_t</span> res[<span class="number">100</span>];</span><br><span class="line">    swprintf(res, <span class="number">100</span>, <span class="string">L&quot;name: %s, age: %d, gender: %s&quot;</span>, name, age, gender);</span><br><span class="line">    <span class="keyword">return</span> PyUnicode_FromWideChar(res,wcslen(res));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyMethodDef methods[] = &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;f1&quot;</span>,</span><br><span class="line">        (PyCFunction) f1,</span><br><span class="line">        METH_VARARGS | METH_KEYWORDS,</span><br><span class="line">        <span class="literal">NULL</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyModuleDef module = &#123;</span><br><span class="line">    PyModuleDef_HEAD_INIT,</span><br><span class="line">    <span class="string">&quot;kagura_nana&quot;</span>,</span><br><span class="line">    <span class="string">&quot;this is a module named kagura_nana&quot;</span>,</span><br><span class="line">    <span class="number">-1</span>,</span><br><span class="line">    methods,</span><br><span class="line">    <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PyMODINIT_FUNC</span><br><span class="line"></span><br><span class="line"><span class="title function_">PyInit_kagura_nana</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> PyModule_Create(&amp;module);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们用 Python 来测试一下，注意观察报错信息。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kagura_nana</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(kagura_nana.f1())</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># function missing required argument &#x27;name&#x27; (pos 1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(kagura_nana.f1(<span class="string">&quot;古明地觉&quot;</span>, xxx=<span class="number">123</span>))</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># &#x27;xxx&#x27; is an invalid keyword argument for this function</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(kagura_nana.f1(<span class="string">&quot;古明地觉&quot;</span>, name=<span class="number">123</span>))</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># argument for function given by name (&#x27;name&#x27;) and position (1)</span></span><br></pre></td></tr></table></figure>

<p><strong>报错信息似乎没有什么特别的，但是注意了，我们来做一下改动。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!PyArg_ParseTupleAndKeywords(args, kwargs, <span class="string">&quot;u|iu:abcdefg&quot;</span>, keys, &amp;name, &amp;age, &amp;gender))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>其它地方都不变，我们只在 format 字符串的结尾加上了一个 <code>:abcdefg</code>，然后编译再来测试一下。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kagura_nana</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(kagura_nana.f1())</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># abcdefg() missing required argument &#x27;name&#x27; (pos 1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(kagura_nana.f1(<span class="string">&quot;古明地觉&quot;</span>, xxx=<span class="number">123</span>))</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># &#x27;xxx&#x27; is an invalid keyword argument for abcdefg()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(kagura_nana.f1(<span class="string">&quot;古明地觉&quot;</span>, name=<span class="number">123</span>))</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># argument for abcdefg() given by name (&#x27;name&#x27;) and position (1)</span></span><br></pre></td></tr></table></figure>

<p><strong>你看到了什么？没错，默认的报错信息使用的是 function，但我们通过在占位符中指定 <code>:xxx</code> ，可以将 function 变成我们指定的内容 xxx，一般和函数名保持一致。另外需要注意的是，<code>:xxx</code> 要出现在占位符的结尾，并且只能出现一次。如果这样的话会变成什么样子呢？</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PyArg_ParseTupleAndKeywords(args, kwargs, &quot;u:aaa|iu:abcdefg&quot;, keys, &amp;name, &amp;age, &amp;gender)</span><br></pre></td></tr></table></figure>

<p><strong>显然这变成了只接受一个参数，然后我们将参数不对时、返回报错信息中的 function 换成了 <code>aaa|iu:abcdefg</code>。并且你在传递参数的时候还会报出如下错误：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SystemError: More keyword list entries (3) than format specifiers (1)</span><br></pre></td></tr></table></figure>

<p><strong>因为占位符中相当于只有一个 u，也就是接收一个参数，但是我们后面跟了 &amp;name、&amp;age、&amp;gender。关键字 entry 是 3，占位符是 1，两者不匹配。因此 <code>:xxx</code> 一定要出现在最后面，并且只能出现一次。</strong></p>
<p><strong>另外，即使函数不接收参数我们也是可以这么做的，比如：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Python.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">f1</span><span class="params">(PyObject *self, PyObject *args, PyObject *kwargs)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *keys[] = &#123;<span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="comment">// 不接收参数</span></span><br><span class="line">    <span class="keyword">if</span> (!PyArg_ParseTupleAndKeywords(args, kwargs, <span class="string">&quot;&quot;</span>, keys))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Py_INCREF(Py_None);</span><br><span class="line">    <span class="keyword">return</span> Py_None;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyMethodDef methods[] = &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;f1&quot;</span>,</span><br><span class="line">        (PyCFunction) f1,</span><br><span class="line">        METH_VARARGS | METH_KEYWORDS,</span><br><span class="line">        <span class="literal">NULL</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyModuleDef module = &#123;</span><br><span class="line">    PyModuleDef_HEAD_INIT,</span><br><span class="line">    <span class="string">&quot;kagura_nana&quot;</span>,</span><br><span class="line">    <span class="string">&quot;this is a module named kagura_nana&quot;</span>,</span><br><span class="line">    <span class="number">-1</span>,</span><br><span class="line">    methods,</span><br><span class="line">    <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PyMODINIT_FUNC</span><br><span class="line"></span><br><span class="line"><span class="title function_">PyInit_kagura_nana</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> PyModule_Create(&amp;module);</span><br><span class="line">&#125;</span><br><span class="line">import kagura_nana</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    print(kagura_nana.f1(<span class="string">&quot;xxx&quot;</span>))</span><br><span class="line">except Exception as e:</span><br><span class="line">    print(e)  <span class="meta"># function takes at most 0 arguments (1 given)</span></span><br></pre></td></tr></table></figure>

<p><strong>然后我们加上 <code>:xxx</code>。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">f1</span><span class="params">(PyObject *self, PyObject *args, PyObject *kwargs)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *keys[] = &#123;<span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="comment">// 这里还可以使用数字</span></span><br><span class="line">    <span class="keyword">if</span> (!PyArg_ParseTupleAndKeywords(args, kwargs, <span class="string">&quot;:123&quot;</span>, keys))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Py_INCREF(Py_None);</span><br><span class="line">    <span class="keyword">return</span> Py_None;</span><br><span class="line">&#125;</span><br><span class="line">import kagura_nana</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    print(kagura_nana.f1(<span class="string">&quot;xxx&quot;</span>))</span><br><span class="line">except Exception as e:</span><br><span class="line">    print(e)  # <span class="number">123</span>() takes at most <span class="number">0</span> arguments (<span class="number">1</span> given)</span><br></pre></td></tr></table></figure>

<p><strong>我们看到返回信息也被我们修改了，以上就是 <code>:xxx</code> 的作用。所以目前我们看到了两个特殊符号，一个是 <code>|</code> 用来实现默认参数，一个是这里的 <code>:</code> 用来自定义报错信息中的函数名。</strong></p>
<h4 id="占位符-1"><a href="#占位符-1" class="headerlink" title="占位符 !"></a>占位符 !</h4><p><strong>我们说占位符 O 表示接收一个 Python 中的对象，但这个对象显然是没有限制的，可以是列表、可以是字典等等。我们之前是通过 Check 的方式进行检测，但是 Python 底层为我们提供更简便的做法，先来看一个常规的例子：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">f1</span><span class="params">(PyObject *self, PyObject *args, PyObject *kwargs)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *keys[] = &#123;<span class="string">&quot;val1&quot;</span>, <span class="string">&quot;val2&quot;</span>, <span class="string">&quot;val3&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    PyObject *val1;</span><br><span class="line">    PyObject *val2;    </span><br><span class="line">    PyObject *val3;        </span><br><span class="line">    <span class="keyword">if</span> (!PyArg_ParseTupleAndKeywords(args, kwargs, <span class="string">&quot;OOO&quot;</span>, keys, &amp;val1, &amp;val2, &amp;val3))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Py_INCREF(Py_None);</span><br><span class="line">    <span class="keyword">return</span> Py_None;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这个例子很简单，就是接收三个 PyObject *，但如果我希望第一个参数的类型是浮点型，第三个参数的类型是字典，这个时候该怎么做呢？此时 ! 就派上用场了。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">f1</span><span class="params">(PyObject *self, PyObject *args, PyObject *kwargs)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *keys[] = &#123;<span class="string">&quot;val1&quot;</span>, <span class="string">&quot;val2&quot;</span>, <span class="string">&quot;val3&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    PyObject *val1;</span><br><span class="line">    PyObject *val2;</span><br><span class="line">    PyObject *val3;</span><br><span class="line">    <span class="comment">// 我们希望限制第一个参数和第三个参数的类型, 那么在它们的后面加上 ! 即可</span></span><br><span class="line">    <span class="comment">// 但是注意: 一旦加上了 !, 那么 O! 就要对应两个位置(分别是类型和变量, 当然都是指针)</span></span><br><span class="line">    <span class="comment">// 我们说, 第一个参数是浮点型, 那么第一个 O! 对应 &amp;PyFloat_Type, &amp;val1</span></span><br><span class="line">    <span class="comment">// 第二个参数没有限制, 那么就是 &amp;val2</span></span><br><span class="line">    <span class="comment">// 第三个参数是字典, 那么最后一个 O! 对应 &amp;PyDict_Type, &amp;val3</span></span><br><span class="line">    <span class="keyword">if</span> (!PyArg_ParseTupleAndKeywords(args, kwargs, <span class="string">&quot;O!OO!:my_func&quot;</span>, keys, </span><br><span class="line">                                     &amp;PyFloat_Type, &amp;val1, &amp;val2, &amp;PyDict_Type, &amp;val3))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Py_INCREF(Py_None);</span><br><span class="line">    <span class="keyword">return</span> Py_None;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>然后其它地方不变，我们来编译测试一下。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kagura_nana</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(kagura_nana.f1(<span class="number">123</span>, <span class="number">123</span>, <span class="string">&quot;xx&quot;</span>))</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># my_func() argument 1 must be float, not int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(kagura_nana.f1(<span class="number">123.0</span>, <span class="number">11</span>, <span class="string">&quot;xx&quot;</span>))</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># my_func() argument 3 must be dict, not str</span></span><br></pre></td></tr></table></figure>

<p><strong>这个功能就很方便了，可以让我们更加轻松地限制参数类型。但如果你用过 Cython 的话，你会发现我这里所说的方便实在是不敢恭维。如果你要写扩展，那么我强烈推荐 Cython，而且用 Cython 可以轻松的连接 C &#x2F; C++。</strong></p>
<blockquote>
<p><strong>注意：! 只能跟在 O 的后面。</strong></p>
</blockquote>
<h4 id="占位符-amp"><a href="#占位符-amp" class="headerlink" title="占位符 &amp;"></a>占位符 &amp;</h4><p><strong>&amp; 的话，对于我们编写扩展而言用的不是很多，首先 &amp; 和  上面说的 ! 用法类似，并且都只能跟在 O 的后面。O! 的话，我们说会对应一个类型指针和一个 PyObject  *（参数就会传递给它），会判断传递的参数的类型是否和指定的类型一致。但 O&amp;  的话，则是对应一个函数（convert）和一个任意类型的指针（address），会执行 <code>convert(object, address)</code>，这个 object 就是我们传递过来的参数。我们举个栗子：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">convert</span><span class="params">(PyObject *object, <span class="type">long</span> *any)</span>&#123;</span><br><span class="line">    <span class="comment">// 将 object 转成 long, 赋值给 *any</span></span><br><span class="line">    *any = PyLong_AsLong(object);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">f1</span><span class="params">(PyObject *self, PyObject *args, PyObject *kwargs)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *keys[] = &#123;<span class="string">&quot;val1&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="type">long</span> any = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 我们传递一个 Python 中的整数(假设为 PyObject *val1), 那么这里就会执行 convert(val1, &amp;any) </span></span><br><span class="line">    <span class="keyword">if</span> (!PyArg_ParseTupleAndKeywords(args, kwargs, <span class="string">&quot;O&amp;&quot;</span>, keys,</span><br><span class="line">                                     convert, &amp;any))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行完毕之后, any 就会被改变, 为了方便我们就直接打印一下吧, 顺便加一个 1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;any = %ld\n&quot;</span>, any + <span class="number">1</span>);</span><br><span class="line">    Py_INCREF(Py_None);</span><br><span class="line">    <span class="keyword">return</span> Py_None;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们来测试一下：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(kagura_nana.f1(<span class="number">123</span>))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">any = 124</span></span><br><span class="line"><span class="string">None</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>效果大概就是这样，个人觉得对于我们编写扩展而言用处不是很大，了解一下即可。</strong></p>
<h4 id="占位符-2"><a href="#占位符-2" class="headerlink" title="占位符 ;"></a>占位符 ;</h4><p><strong>占位符 <code>;</code> 和 <code>:</code> 比较类似，但 <code>;</code> 更加粗暴。至于怎么个粗暴法，看个栗子就一目了然了。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">f1</span><span class="params">(PyObject *self, PyObject *args, PyObject *kwargs)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *keys[] = &#123;<span class="string">&quot;val1&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    PyObject *val1;</span><br><span class="line">    <span class="keyword">if</span> (!PyArg_ParseTupleAndKeywords(args, kwargs, <span class="string">&quot;O!;my name is van, i am a artist, a performance artist&quot;</span>, keys,</span><br><span class="line">                                    &amp;PyFloat_Type, &amp;val1))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Py_INCREF(Py_None);</span><br><span class="line">    <span class="keyword">return</span> Py_None;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>然后我们来调用试试，看看会有什么结果：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kagura_nana</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(kagura_nana.f1())</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># function missing required argument &#x27;val1&#x27; (pos 1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(kagura_nana.f1(<span class="number">123</span>, <span class="number">123</span>))</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># function takes at most 1 argument (2 given)</span></span><br></pre></td></tr></table></figure>

<p><strong>目前来看的话，似乎一切正常，但是往下看：</strong></p>
<p><img src="/2023/04/26/31-Python-%E5%92%8C-C-C-%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/1229382-20210212015337660-882885515.png" alt="img"></p>
<p><strong>此时把整个报错信息都给修改了，因此这个符号也不是很常用。</strong></p>
<blockquote>
<p><strong>注意：<code>;</code> 同样需要放到结尾，并且和 <code>:</code> 相互排斥，两者不可同时出现。</strong></p>
</blockquote>
<h4 id="占位符-3"><a href="#占位符-3" class="headerlink" title="占位符 $"></a>占位符 $</h4><p><strong>老规矩，还是先来看一个常规的例子。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">f1</span><span class="params">(PyObject *self, PyObject *args, PyObject *kwargs)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *keys[] = &#123;<span class="string">&quot;val1&quot;</span>, <span class="string">&quot;val2&quot;</span>, <span class="string">&quot;val3&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    PyObject *val1;</span><br><span class="line">    PyObject *val2;</span><br><span class="line">    PyObject *val3;</span><br><span class="line">    <span class="keyword">if</span> (!PyArg_ParseTupleAndKeywords(args, kwargs, <span class="string">&quot;OOO&quot;</span>, keys,</span><br><span class="line">                                    &amp;val1, &amp;val2, &amp;val3))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Py_INCREF(Py_None);</span><br><span class="line">    <span class="keyword">return</span> Py_None;</span><br><span class="line">&#125;</span><br><span class="line">import kagura_nana</span><br><span class="line"></span><br><span class="line"><span class="title function_">print</span><span class="params">(kagura_nana.f1(<span class="number">123</span>, <span class="number">123</span>, <span class="number">123</span>))</span></span><br><span class="line"><span class="title function_">print</span><span class="params">(kagura_nana.f1(<span class="number">123</span>, val2=<span class="number">123</span>, val3=<span class="number">123</span>))</span></span><br><span class="line"><span class="title function_">print</span><span class="params">(kagura_nana.f1(<span class="number">123</span>, <span class="number">123</span>, val3=<span class="number">123</span>))</span></span><br><span class="line"><span class="title function_">print</span><span class="params">(kagura_nana.f1(val1=<span class="number">123</span>, val2=<span class="number">123</span>, val3=<span class="number">123</span>))</span></span><br></pre></td></tr></table></figure>

<p><strong>以上都是没有问题的，可以通过位置参数传递、也可以通过关键字参数传递，只要位置参数在关键字参数之前即可。但如果我们希望某个参数只能通过关键字的方式传递呢？</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">f1</span><span class="params">(PyObject *self, PyObject *args, PyObject *kwargs)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *keys[] = &#123;<span class="string">&quot;val1&quot;</span>, <span class="string">&quot;val2&quot;</span>, <span class="string">&quot;val3&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    PyObject *val1;</span><br><span class="line">    PyObject *val2;</span><br><span class="line">    PyObject *val3;</span><br><span class="line">    <span class="comment">// 指定一个 $, 那么 $ 后面只能通过关键字参数的方式传递</span></span><br><span class="line">    <span class="keyword">if</span> (!PyArg_ParseTupleAndKeywords(args, kwargs, <span class="string">&quot;OO$O&quot;</span>, keys,</span><br><span class="line">                                    &amp;val1, &amp;val2, &amp;val3))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Py_INCREF(Py_None);</span><br><span class="line">    <span class="keyword">return</span> Py_None;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>重新编译然后测试：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kagura_nana</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(kagura_nana.f1(<span class="number">123</span>, val2=<span class="number">123</span>, val3=<span class="number">123</span>))</span><br><span class="line"><span class="built_in">print</span>(kagura_nana.f1(<span class="number">123</span>, <span class="number">123</span>, val3=<span class="number">123</span>))</span><br><span class="line"><span class="built_in">print</span>(kagura_nana.f1(val1=<span class="number">123</span>, val2=<span class="number">123</span>, val3=<span class="number">123</span>))</span><br><span class="line"><span class="comment"># 以上仍然是正常的, 都会打印 None</span></span><br><span class="line"><span class="comment"># 但是下面不行了, 因为 val3 必须通过关键字参数的方式传递</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    kagura_nana.f1(<span class="number">123</span>, <span class="number">123</span>, <span class="number">123</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># function takes exactly 2 positional arguments (3 given)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 其实这就等价于如下:</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>(<span class="params">val1, val2, *, val3</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<p><strong>不过有一点需要注意，目前来说，如果 <code>|</code> 和 <code>$</code> 同时出现的话，那么 <code>|</code> 必须要在 <code>$</code> 的前面。所以如果既有仅限关键字参数、又有可选参数，那么仅限关键字参数必须同时也是可选参数，所以 <code>|</code> 要在 <code>$</code> 的前面。如果我们把 <code>|</code> 写在了 <code>$</code> 的后面，那么执行会抛异常。</strong></p>
<p><img src="/2023/04/26/31-Python-%E5%92%8C-C-C-%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/1229382-20210212015345658-963304683.png" alt="img"></p>
<p><strong>并且，即便仅限关键字参数和默认参数相同，那也应该这么写 <code>OO|$O</code>，而不能这么写 <code>OO$|O</code>。</strong></p>
<h4 id="占位符-4"><a href="#占位符-4" class="headerlink" title="占位符"></a>占位符</h4><p><strong>这个 # 不可以跟在 O 后面，它是跟在 s 或者 u 后面，用来限制长度，有兴趣自己去了解一下。</strong></p>
<h3 id="Py-BuildValue"><a href="#Py-BuildValue" class="headerlink" title="Py_BuildValue"></a>Py_BuildValue</h3><p><strong>下面介绍一个非常方便的函数 Py_BuildValue，专门用来对数据进行打包的，返回一个 PyObject *，同样是通过占位符的方式。</strong></p>
<p><strong>Py_BuildValue 的占位符和 PyArg_ParseTuple  里面的占位符是一致的，只不过功能相反。比如：i，PyArg_ParseTuple 是将 Python 中的 int 转成 C 中的 int，而  Py_BuildValue 是将 C 中的 int 打包成 Python 中的 int。所以它们的占位符一致，功能正好相反，并且我们在介绍  PyArg_ParseTuple 的时候只介绍一部分占位符，其实支持的占位符不止我们上面说的那些，下面就来罗列一下。</strong></p>
<blockquote>
<p><strong>再重复一次，PyArg_ParseTuple 和 Py_BuildValue 的占位符是一致的，但是功能相反。</strong></p>
</blockquote>
<p><img src="/2023/04/26/31-Python-%E5%92%8C-C-C-%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/1229382-20210212015355373-976625594.png" alt="img"></p>
<p><strong>我们只接用官方的栗子，因为官方给的栗子非常直观。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Py_BuildValue(<span class="string">&quot;&quot;</span>)                       		            None</span><br><span class="line"><span class="title function_">Py_BuildValue</span><span class="params">(<span class="string">&quot;i&quot;</span>, <span class="number">123</span>)</span>                                     123</span><br><span class="line"><span class="title function_">Py_BuildValue</span><span class="params">(<span class="string">&quot;iii&quot;</span>, <span class="number">123</span>, <span class="number">456</span>, <span class="number">789</span>)</span>                         <span class="params">(<span class="number">123</span>, <span class="number">456</span>, <span class="number">789</span>)</span></span><br><span class="line"><span class="title function_">Py_BuildValue</span><span class="params">(<span class="string">&quot;s&quot;</span>, <span class="string">&quot;hello&quot;</span>)</span>                                 &#x27;hello&#x27;</span><br><span class="line"><span class="title function_">Py_BuildValue</span><span class="params">(<span class="string">&quot;y&quot;</span>, <span class="string">&quot;hello&quot;</span>)</span>                                 b&#x27;hello&#x27;</span><br><span class="line"><span class="title function_">Py_BuildValue</span><span class="params">(<span class="string">&quot;ss&quot;</span>, <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>)</span>                       <span class="params">(<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;world&#x27;</span>)</span></span><br><span class="line"><span class="title function_">Py_BuildValue</span><span class="params">(<span class="string">&quot;s#&quot;</span>, <span class="string">&quot;hello&quot;</span>, <span class="number">4</span>)</span>                             &#x27;hell&#x27;</span><br><span class="line"><span class="title function_">Py_BuildValue</span><span class="params">(<span class="string">&quot;y#&quot;</span>, <span class="string">&quot;hello&quot;</span>, <span class="number">4</span>)</span>                             b&#x27;hell&#x27;</span><br><span class="line"><span class="title function_">Py_BuildValue</span><span class="params">(<span class="string">&quot;()&quot;</span>)</span>                                         <span class="params">()</span></span><br><span class="line"><span class="title function_">Py_BuildValue</span><span class="params">(<span class="string">&quot;(i)&quot;</span>, <span class="number">123</span>)</span>                                   <span class="params">(<span class="number">123</span>,)</span></span><br><span class="line"><span class="title function_">Py_BuildValue</span><span class="params">(<span class="string">&quot;(ii)&quot;</span>, <span class="number">123</span>, <span class="number">456</span>)</span>                             <span class="params">(<span class="number">123</span>, <span class="number">456</span>)</span></span><br><span class="line"><span class="title function_">Py_BuildValue</span><span class="params">(<span class="string">&quot;(i,i)&quot;</span>, <span class="number">123</span>, <span class="number">456</span>)</span>                            <span class="params">(<span class="number">123</span>, <span class="number">456</span>)</span></span><br><span class="line"><span class="title function_">Py_BuildValue</span><span class="params">(<span class="string">&quot;[i,i]&quot;</span>, <span class="number">123</span>, <span class="number">456</span>)</span>                            [123, 456]</span><br><span class="line"><span class="title function_">Py_BuildValue</span><span class="params">(<span class="string">&quot;&#123;s:i,s:i&#125;&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="number">123</span>, <span class="string">&quot;def&quot;</span>, <span class="number">456</span>)</span>          &#123;<span class="string">&#x27;abc&#x27;</span>: <span class="number">123</span>, <span class="string">&#x27;def&#x27;</span>: <span class="number">456</span>&#125;</span><br><span class="line">Py_BuildValue(<span class="string">&quot;((ii)(ii)) (ii)&quot;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)          (((<span class="number">1</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">4</span>)), (<span class="number">5</span>, <span class="number">6</span>))</span><br></pre></td></tr></table></figure>

<p><strong>如果是多个符号，自动会变成一个元组。我们来测试一下：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Python.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">f1</span><span class="params">(PyObject *self, PyObject *args, PyObject *kwargs)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyObject *lst = PyList_New(<span class="number">5</span>);</span><br><span class="line">    PyList_SetItem(lst, <span class="number">0</span>,</span><br><span class="line">                   Py_BuildValue(<span class="string">&quot;i&quot;</span>, <span class="number">123</span>));</span><br><span class="line">    PyList_SetItem(lst, <span class="number">1</span>,</span><br><span class="line">                   Py_BuildValue(<span class="string">&quot;is&quot;</span>, <span class="number">123</span>, <span class="string">&quot;hello matsuri&quot;</span>));</span><br><span class="line"></span><br><span class="line">    PyList_SetItem(lst, <span class="number">2</span>,</span><br><span class="line">                   Py_BuildValue(<span class="string">&quot;[i, i]&quot;</span>, <span class="number">123</span>, <span class="number">321</span>));</span><br><span class="line"></span><br><span class="line">    PyList_SetItem(lst, <span class="number">3</span>,</span><br><span class="line">                   Py_BuildValue(<span class="string">&quot;(s)s&quot;</span>, <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;matsuri&quot;</span>));</span><br><span class="line"></span><br><span class="line">    PyList_SetItem(lst, <span class="number">4</span>,</span><br><span class="line">                   Py_BuildValue(<span class="string">&quot;&#123;s: s&#125;&quot;</span>, <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;matsuri&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> lst;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyMethodDef methods[] = &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;f1&quot;</span>,</span><br><span class="line">        (PyCFunction) f1,</span><br><span class="line">        METH_VARARGS | METH_KEYWORDS,  </span><br><span class="line">        <span class="literal">NULL</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyModuleDef module = &#123;</span><br><span class="line">    PyModuleDef_HEAD_INIT,</span><br><span class="line">    <span class="string">&quot;kagura_nana&quot;</span>,</span><br><span class="line">    <span class="string">&quot;this is a module named kagura_nana&quot;</span>,</span><br><span class="line">    <span class="number">-1</span>,</span><br><span class="line">    methods,</span><br><span class="line">    <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PyMODINIT_FUNC</span><br><span class="line"></span><br><span class="line"><span class="title function_">PyInit_kagura_nana</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> PyModule_Create(&amp;module);</span><br><span class="line">&#125;</span><br><span class="line">from pprint import pprint</span><br><span class="line">import kagura_nana</span><br><span class="line"><span class="title function_">pprint</span><span class="params">(kagura_nana.f1())</span></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">[123,</span><br><span class="line"> <span class="params">(<span class="number">123</span>, <span class="string">&#x27;hello matsuri&#x27;</span>)</span>,</span><br><span class="line"> [123, 321],</span><br><span class="line"> <span class="params">((<span class="string">&#x27;hello&#x27;</span>,), <span class="string">&#x27;matsuri&#x27;</span>)</span>,</span><br><span class="line"> &#123;<span class="string">&#x27;hello&#x27;</span>: <span class="string">&#x27;matsuri&#x27;</span>&#125;]</span><br><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看到结果是符合我们的预期的，另外除了 Py_BuildValue 之外，还有一个 PyTuple_Pack，这两者是类似的，只不过后者只接收 PyObject *，举个栗子就很清晰了：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Py_BuildValue(&quot;OO&quot;, a, b) 等价于 PyTuple_Pack(2, a, b)</span><br></pre></td></tr></table></figure>

<p><strong>这个是固定打包成元组，而且第一个参数是个数，不是 format，因此它不支持通过占位符来指定元素类型，而是只接收 PyObject *。</strong></p>
<h3 id="操作-PyDictObject"><a href="#操作-PyDictObject" class="headerlink" title="操作 PyDictObject"></a>操作 PyDictObject</h3><p><strong>Python  中的字典在底层要如何读取、如何设置，这个我们必须要好好地说一说。像整型、浮点型、字符串、元组、列表、集合，它们都比较简单，我们就不详细说了。比如列表：Python 中插入元素是调用 insert，那么底层则是 PyList_Insert；追加元素是 append，那么底层则是  PyList_Append；设置元素是 __setitem__，那么底层则是 PyList_SetItem；同理获取元素是  PyList_GetItem，写法非常具有规范性。所以如果不知道某个 API 的话，可以去查看解释的源码，比如你想查看元组，那么就去  Include&#x2F;tupleobject.h 中查看：</strong></p>
<p><img src="/2023/04/26/31-Python-%E5%92%8C-C-C-%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/1229382-20210212015455511-312227169.png" alt="img"></p>
<p><strong>像这些凡是以 PyAPI 开头的都是可以直接用的，PyAPI_DATA  表示数据，PyAPI_FUNC 表示函数，至于它们的含义是什么，我们可以通过文档查看。在 Python 的安装目录的 Doc  目录下就有，点击通过关键字进行检索即可。当然基本数据类型的一些方法，相信通过函数名即可判断，比如：PyTuple_GetItem，很明显就是通过索引获取元素的。还是那句话，Python 解释器的整个工程，在命名方面都非常有规律。</strong></p>
<p><strong>所以我们的重点是字典的使用，因为字典比较特殊，它里面的键值对的形式，而列表、元组等容器里面的元素是单一独立的。</strong></p>
<h4 id="PyDictObject-的读取"><a href="#PyDictObject-的读取" class="headerlink" title="PyDictObject 的读取"></a>PyDictObject 的读取</h4><p><strong>先来介绍内部关于读取的一些 API：</strong></p>
<ul>
<li><code>PyDict_Contains(dic, key)：判断字典中是否具有某个 key</code></li>
<li><code>PyDict_GetItem(dic, key)：获取字典中某个 key 对应的 value</code></li>
<li><code>PyDict_GetItemString(dic, key)：和 PyDict_GetItem 作用相同，但这里的 key 是一个 char *</code></li>
<li><code>PyDict_Keys(dic)：获取所有的 key</code></li>
<li><code>PyDict_Values(dic)：获取所有的 value</code></li>
<li><code>PyDict_Items(dic)：获取所有的 key-value</code></li>
</ul>
<p><strong>下面我们来操作一波：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Python.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">f1</span><span class="params">(PyObject *self, PyObject *args, PyObject *kwargs)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyObject *dic;</span><br><span class="line">    <span class="type">char</span> *keys[] = &#123;<span class="string">&quot;dic&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (!PyArg_ParseTupleAndKeywords(args, kwargs, <span class="string">&quot;O!&quot;</span>, keys, &amp;PyDict_Type, &amp;dic))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    PyObject *res;  <span class="comment">// 返回值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 检查是否包含 &quot;name&quot; 这个 key</span></span><br><span class="line">    PyObject *name = PyUnicode_FromString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!PyDict_Contains(dic, name))&#123;</span><br><span class="line">        res = PyUnicode_FromString(<span class="string">&quot;key `name` does not exists&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res = PyDict_GetItem(dic, name);</span><br><span class="line">        <span class="comment">// 注意：这一步很关键，因为我们下面返回了 res，而这个 res 是从 Python 传递过来的字典中获取的</span></span><br><span class="line">        <span class="comment">// 因此它的引用计数不会加 1，只是指向了某个已存在的空间，因此返回之前我们需要将引用计数加 1</span></span><br><span class="line">        <span class="comment">// 至于 if 里面的 res，因为它是在 C 中创建了新的空间，所以不需要关心</span></span><br><span class="line">        Py_INCREF(res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此时我们能直接返回 res 吗? 很明显是不能的，因为我们上面还创建了一个 Python 的字符串 name</span></span><br><span class="line">    <span class="comment">// 这是在 C 中创建的，并且也没作为返回值，那么我们就必须要手动将其引用计数减 1</span></span><br><span class="line">    <span class="comment">// 因此这种时候更推荐使用 PyDict_GetItemString，它接收一个 C 字符串，函数结束时自动释放</span></span><br><span class="line">    <span class="comment">// 但是很明显这个函数局限性比较大</span></span><br><span class="line">    Py_DECREF(name);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyMethodDef methods[] = &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;f1&quot;</span>,</span><br><span class="line">        (PyCFunction) f1,</span><br><span class="line">        METH_VARARGS | METH_KEYWORDS,  </span><br><span class="line">        <span class="literal">NULL</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyModuleDef module = &#123;</span><br><span class="line">    PyModuleDef_HEAD_INIT,</span><br><span class="line">    <span class="string">&quot;kagura_nana&quot;</span>,</span><br><span class="line">    <span class="string">&quot;this is a module named kagura_nana&quot;</span>,</span><br><span class="line">    <span class="number">-1</span>,</span><br><span class="line">    methods,</span><br><span class="line">    <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PyMODINIT_FUNC</span><br><span class="line"></span><br><span class="line"><span class="title function_">PyInit_kagura_nana</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> PyModule_Create(&amp;module);</span><br><span class="line">&#125;</span><br><span class="line">import kagura_nana</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    print(kagura_nana.f1(<span class="string">&quot;&quot;</span>))</span><br><span class="line">except Exception as e:</span><br><span class="line">    print(e)  <span class="meta"># argument 1 must be dict, not str</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(kagura_nana.f1(&#123;&#125;))  <span class="meta"># key `name` does not exists</span></span><br><span class="line">print(kagura_nana.f1(&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;古明地觉&quot;</span>&#125;))  # 古明地觉</span><br></pre></td></tr></table></figure>

<h4 id="PyDictObject-的遍历"><a href="#PyDictObject-的遍历" class="headerlink" title="PyDictObject 的遍历"></a>PyDictObject 的遍历</h4><p><strong>首先我们说可以通过 PyDict_Keys、PyDict_Values、PyDict_Items 来进行遍历，下面演示一下。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">f1</span><span class="params">(PyObject *self, PyObject *args, PyObject *kwargs)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyObject *dic;</span><br><span class="line">    <span class="type">char</span> *keys[] = &#123;<span class="string">&quot;dic&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (!PyArg_ParseTupleAndKeywords(args, kwargs, <span class="string">&quot;O!&quot;</span>, keys, &amp;PyDict_Type, &amp;dic))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    PyObject *res = PyList_New(<span class="number">3</span>);  <span class="comment">// 返回值</span></span><br><span class="line">    PyList_SetItem(res, <span class="number">0</span>, PyDict_Keys(dic));</span><br><span class="line">    PyList_SetItem(res, <span class="number">1</span>, PyDict_Values(dic));</span><br><span class="line">    PyList_SetItem(res, <span class="number">2</span>, PyDict_Items(dic));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">import kagura_nana</span><br><span class="line"></span><br><span class="line"><span class="title function_">print</span><span class="params">(kagura_nana.f1(&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;satori&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">17</span>&#125;))</span></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">[[&#x27;name&#x27;, &#x27;age&#x27;], </span><br><span class="line"> [&#x27;satori&#x27;, 17], </span><br><span class="line"> [<span class="params">(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;satori&#x27;</span>)</span>, <span class="params">(<span class="string">&#x27;age&#x27;</span>, <span class="number">17</span>)</span>]]</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<p><strong>而且我们看到 PyDict_Keys  等函数返回的是列表，这说明创建了一个新的空间，引用计数为 1。但我们没有调用  Py_DECREF，这是因为我们将其放在了一个新的列表中，如果作为某个容器的元素，那么引用计数也应该要增加。但对于  PyListObject、PyTupleObject 而言，通过 PyList_SetItem、PyTuple_SetItem  是不会增加指向对象的引用计数的，所以结果正好抵消，我们不需要对引用计数做任何处理。</strong></p>
<blockquote>
<p><strong>但如果我们是通过 PyList_Append 进行追加、或者  PyList_Insert 进行插入的话，那么是会增加引用计数的，这样引用计数就增加了 2，因此我们还需要减去  1。所以这一点比较烦人，因为你光知道何时增加引用计数、何时减少引用计数还是不够的，你还要看某一个操作到底有没有增加、或者减少。就拿我们这里设置元素为例，本来作为容器内的一个元素，理论上是要增加引用计数的，但是结果却没有增加。而添加和插入元素，也是作为容器的一个元素，但是这两个操作却增加了。所以还是推荐 Cython，再度安利一波，写扩展用 Cython 真的非常香。</strong></p>
</blockquote>
<p><strong>这里我们将元素都获取出来了，至于遍历也很简单，这里不测试了。</strong></p>
<h4 id="PyDictObject-的设置和删除"><a href="#PyDictObject-的设置和删除" class="headerlink" title="PyDictObject 的设置和删除"></a>PyDictObject 的设置和删除</h4><ul>
<li><code>PyDict_SetItem(dic, key, value)：设置元素</code></li>
<li><code>PyDict_DelItem(dic, key, value)：删除元素</code></li>
<li><code>PyDict_Clear(dic)：清空字典</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">f1</span><span class="params">(PyObject *self, PyObject *args, PyObject *kwargs)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyObject *dic;</span><br><span class="line">    <span class="type">char</span> *keys[] = &#123;<span class="string">&quot;dic&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (!PyArg_ParseTupleAndKeywords(args, kwargs, <span class="string">&quot;O!&quot;</span>, keys, &amp;PyDict_Type, &amp;dic))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置一个 &quot;name&quot;: &quot;satori&quot;</span></span><br><span class="line">    PyObject *key = PyUnicode_FromString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    PyObject *value = PyUnicode_FromString(<span class="string">&quot;satori&quot;</span>);</span><br><span class="line">    PyDict_SetItem(dic, key, value);</span><br><span class="line">    <span class="comment">// 因为 key 和 value 是 C 中创建的，首先引用计数为 1</span></span><br><span class="line">    <span class="comment">// 然后它们又放到了字典里，对于字典而言，设置元素是会增加引用计数的，所以这里引用计数变成了 2</span></span><br><span class="line">    <span class="comment">// 因此我们需要手动将它们的引用计数减去 1，否则这个键值对永远不会被回收。</span></span><br><span class="line">    <span class="comment">// 所以最让人烦的就是这个引用计数，非常的讨厌，因为你不知道它到底有没有增加</span></span><br><span class="line">    Py_XDECREF(key);</span><br><span class="line">    Py_XDECREF(value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果有 &quot;age&quot; 这个 key 就将其删掉</span></span><br><span class="line">    key = PyUnicode_FromString(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (PyDict_Contains(dic, key)) &#123;</span><br><span class="line">        PyDict_DelItem(dic, key);</span><br><span class="line">    &#125;</span><br><span class="line">    Py_XDECREF(key); <span class="comment">// 同样减少引用计数</span></span><br><span class="line">    Py_INCREF(Py_None);</span><br><span class="line">    <span class="keyword">return</span> Py_None;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试一下：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kagura_nana</span><br><span class="line"></span><br><span class="line">dic = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;mashiro&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">17</span>&#125;</span><br><span class="line">kagura_nana.f1(dic)</span><br><span class="line"><span class="built_in">print</span>(dic)  <span class="comment"># &#123;&#x27;name&#x27;: &#x27;satori&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>当然还有很多其它 API，可以查看源代码（Include&#x2F;dictobject.h）自己测试一下。</strong></p>
<h2 id="编写扩展类"><a href="#编写扩展类" class="headerlink" title="编写扩展类"></a>编写扩展类</h2><p><strong>我们之前在 C 中编写的都是函数，但光有函数显然是不够的，我们需要实现类。而在 C 中实现的类被称为扩展类，它和 Python 内置的类（int、dict、str等等）是等价的，都属于静态类，直接指向了 C 一级的数据结构。</strong></p>
<p><strong>下面来看看在 C 中如何实现扩展类，首先我们来实现一个最基本的扩展类，也就是只包含一些最关键的部分。然后再添加类参数、方法，以及继承等等。</strong></p>
<p><strong>当然最重要的一点，我们还要解决类的循环引用、以及自定义垃圾回收。像列表、元组、字典等容器，它们也都会发生循环引用。</strong></p>
<blockquote>
<p><strong>前面有一点我们没有提，当一个容器（比如列表）引用计数减一的时候，里面的元素（指向的对象）的引用计数是不会发生改变的。只有当一个容器的引用计数为 0 被销毁的时候，在销毁之前会先将内部元素的引用计数都减 1，然后再销毁这个容器。</strong></p>
</blockquote>
<p><strong>而循环引用是引用计数机制所面临的最大的痛点，所以 Python 中的 gc 就是来干这个事情的，通过分代技术根据对象的生命周期划分为三个链表，然后通过三色标记模型来找出那些具有循环引用的对象，改变它们的引用计数。所以在 Python 中一个对象是否要被回收，最终还是取决于它的引用计数是否为 0。如果是 Python  代码的话，我们在实现类的时候，解释器会自动帮我们处理这一点，但我们是做类扩展，因此这些东西就必须由我们来考虑了。</strong></p>
<h3 id="编写扩展类前奏曲"><a href="#编写扩展类前奏曲" class="headerlink" title="编写扩展类前奏曲"></a>编写扩展类前奏曲</h3><p><strong>我们之前编写了扩展函数，我们说首先要创建一个模块，这里也是一样的，因为类也要在模块里面。编写函数是有套路的，编写类也是一样，我们还是先看看大致的流程，具体细节会在慢慢补充。</strong></p>
<p><strong>首先我们需要了解以下内容：</strong></p>
<ul>
<li><code>1. 一个类要有类名、构造函数、析构函数</code></li>
<li><code>2. 所有的类在底层都是一个 PyTypeObject 实例，而且类也是一个对象</code></li>
<li><code>3. PyType_Ready 对类进行初始化，主要是进行属性字典的设置</code></li>
<li><code>4. PyModule_AddObject，将扩展类添加到模块中</code></li>
</ul>
<p><strong>那么一个类在底层都有哪些属性呢？很明显，我们说所有的类都是一个 PyTypeObject 实例，那么我们就把这个结构体拷贝出来看一下就知道了。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面我们来介绍一下内部成员都代表什么含义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> &#123;</span></span><br><span class="line">    <span class="comment">// 头部信息，PyVarObject ob_base; 里面包含了引用计数、类型、ob_size</span></span><br><span class="line">    <span class="comment">// 而创建这个结构体实例的话，Python 提供了一个宏，PyVarObject_HEAD_INIT(type, size)</span></span><br><span class="line">    <span class="comment">// 传入类型和大小可以直接创建，至于引用计数则默认为 1</span></span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    <span class="comment">// 创建之后的类名</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *tp_name; <span class="comment">/* For printing, in format &quot;&lt;module&gt;.&lt;name&gt;&quot; */</span></span><br><span class="line">    <span class="comment">// 大小，用于申请空间的，注意了，这里是两个成员</span></span><br><span class="line">    Py_ssize_t tp_basicsize, tp_itemsize; <span class="comment">/* For allocation */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Methods to implement standard operations */</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 析构方法__del__，当删除实例对象时会调用这个操作</span></span><br><span class="line">    <span class="comment">// typedef void (*destructor)(PyObject *); 函数接收一个PyObject *，没有返回值</span></span><br><span class="line">    destructor tp_dealloc;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印其实例对象是调用的函数</span></span><br><span class="line">    <span class="comment">// typedef int (*printfunc)(PyObject *, FILE *, int); 函数接收一个PyObject *、FILE * 和 int</span></span><br><span class="line">    printfunc tp_print;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取属性，内部的 __getattr__ 方法</span></span><br><span class="line">    <span class="comment">// typedef PyObject *(*getattrfunc)(PyObject *, char *);</span></span><br><span class="line">    getattrfunc tp_getattr;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置属性,内部的 __setattr__ 方法</span></span><br><span class="line">    <span class="comment">// typedef int (*setattrfunc)(PyObject *, char *, PyObject *);</span></span><br><span class="line">    setattrfunc tp_setattr;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在 Python3.5之后才产生的，这个不需要关注。</span></span><br><span class="line">    <span class="comment">// 并且在其它类的注释中，这个写的都是tp_reserved</span></span><br><span class="line">    PyAsyncMethods *tp_as_async; <span class="comment">/* formerly known as tp_compare (Python 2)</span></span><br><span class="line"><span class="comment">                                    or tp_reserved (Python 3) */</span></span><br><span class="line">    <span class="comment">// 内部的 __repr__方法</span></span><br><span class="line">    <span class="comment">// typedef PyObject *(*reprfunc)(PyObject *);</span></span><br><span class="line">    reprfunc tp_repr;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 一个对象作为数值所有拥有的方法</span></span><br><span class="line">    PyNumberMethods *tp_as_number;</span><br><span class="line">    <span class="comment">// 一个对象作为序列所有拥有的方法</span></span><br><span class="line">    PySequenceMethods *tp_as_sequence;</span><br><span class="line">    <span class="comment">// 一个对象作为映射所有拥有的方法</span></span><br><span class="line">    PyMappingMethods *tp_as_mapping;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* More standard operations (here for binary compatibility) */</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">//内部的 __hash__ 方法</span></span><br><span class="line">    <span class="comment">// typedef Py_hash_t (*hashfunc)(PyObject *);</span></span><br><span class="line">    hashfunc tp_hash;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 内部的 __call__ 方法</span></span><br><span class="line">    <span class="comment">// typedef PyObject * (*ternaryfunc)(PyObject *, PyObject *, PyObject *);</span></span><br><span class="line">    ternaryfunc tp_call;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 内部的 __repr__ 方法</span></span><br><span class="line">    <span class="comment">// typedef PyObject *(*reprfunc)(PyObject *);</span></span><br><span class="line">    reprfunc tp_str;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取属性</span></span><br><span class="line">    <span class="comment">// typedef PyObject *(*getattrofunc)(PyObject *, PyObject *);</span></span><br><span class="line">    getattrofunc tp_getattro;</span><br><span class="line">    <span class="comment">// 设置属性</span></span><br><span class="line">    <span class="comment">// typedef int (*setattrofunc)(PyObject *, PyObject *, PyObject *);</span></span><br><span class="line">    setattrofunc tp_setattro;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//作为缓存，不需要关心</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">    typedef struct &#123;</span></span><br><span class="line"><span class="comment">    	 getbufferproc bf_getbuffer;</span></span><br><span class="line"><span class="comment">     	releasebufferproc bf_releasebuffer;</span></span><br><span class="line"><span class="comment">	&#125; PyBufferProcs;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    PyBufferProcs *tp_as_buffer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个类的特点，比如：</span></span><br><span class="line">    <span class="comment">// Py_TPFLAGS_HEAPTYPE: 是否在堆区申请空间</span></span><br><span class="line">    <span class="comment">// Py_TPFLAGS_BASETYPE: 是否允许这个类被其它类继承</span></span><br><span class="line">    <span class="comment">// Py_TPFLAGS_IS_ABSTRACT: 是否为抽象类</span></span><br><span class="line">    <span class="comment">// Py_TPFLAGS_HAVE_GC: 是否被垃圾回收跟踪</span></span><br><span class="line">    <span class="comment">// 这里面有很多，具体可以去 object.h 中查看</span></span><br><span class="line">    <span class="comment">// 一般我们设置成 Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC 即可</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> tp_flags;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 这个类的注释</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *tp_doc; <span class="comment">/* Documentation string */</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">//用于检测是否出现循环引用，和下面的tp_clear是一组</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    class A:</span></span><br><span class="line"><span class="comment">    	pass</span></span><br><span class="line"><span class="comment">    a = A()</span></span><br><span class="line"><span class="comment">    a.attr = a</span></span><br><span class="line"><span class="comment">    此时就会出现循环引用</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// typedef int (*traverseproc)(PyObject *, visitproc, void *);</span></span><br><span class="line">    traverseproc tp_traverse;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除对包含对象的引用</span></span><br><span class="line">    inquiry tp_clear;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 富比较</span></span><br><span class="line">    <span class="comment">// typedef PyObject *(*richcmpfunc) (PyObject *, PyObject *, int);</span></span><br><span class="line">    richcmpfunc tp_richcompare;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 弱引用，不需要关心</span></span><br><span class="line">    Py_ssize_t tp_weaklistoffset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// __iter__方法</span></span><br><span class="line">    <span class="comment">// typedef PyObject *(*getiterfunc) (PyObject *);</span></span><br><span class="line">    getiterfunc tp_iter;</span><br><span class="line">    <span class="comment">// __next__方法</span></span><br><span class="line">    <span class="comment">// typedef PyObject *(*iternextfunc) (PyObject *);</span></span><br><span class="line">    iternextfunc tp_iternext;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Attribute descriptor and subclassing stuff */</span></span><br><span class="line">    <span class="comment">// 内部的方法，这个 PyMethodDef 不陌生了吧</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PyMethodDef</span> *<span class="title">tp_methods</span>;</span></span><br><span class="line">    <span class="comment">// 内部的成员</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PyMemberDef</span> *<span class="title">tp_members</span>;</span></span><br><span class="line">    <span class="comment">// 一个结构体，包含了 name、get、set、doc、closure</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PyGetSetDef</span> *<span class="title">tp_getset</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 继承的基类</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">tp_base</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 内部的属性字典</span></span><br><span class="line">    PyObject *tp_dict;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 描述符，__get__ 方法</span></span><br><span class="line">    <span class="comment">// typedef PyObject *(*descrgetfunc) (PyObject *, PyObject *, PyObject *);</span></span><br><span class="line">    descrgetfunc tp_descr_get;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 描述符，__set__ 方法</span></span><br><span class="line">    <span class="comment">// typedef int (*descrsetfunc) (PyObject *, PyObject *, PyObject *);</span></span><br><span class="line">    descrsetfunc tp_descr_set;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 生成的实例对象是否有属性字典</span></span><br><span class="line">    <span class="comment">// 我们上一个例子中的实例对象显然是没有属性字典的，因为我们当时没有设置这个成员</span></span><br><span class="line">    Py_ssize_t tp_dictoffset;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化函数</span></span><br><span class="line">    <span class="comment">// typedef int (*initproc)(PyObject *, PyObject *, PyObject *);</span></span><br><span class="line">    initproc tp_init;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 为实例对象分配空间的函数</span></span><br><span class="line">    <span class="comment">// typedef PyObject *(*allocfunc)(struct _typeobject *, Py_ssize_t);</span></span><br><span class="line">    allocfunc tp_alloc;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// __new__ 方法</span></span><br><span class="line">    <span class="comment">// typedef PyObject *(*newfunc)(struct _typeobject *, PyObject *, PyObject *);</span></span><br><span class="line">    newfunc tp_new;</span><br><span class="line">    <span class="comment">// 我们一般设置到 tp_new 即可，剩下的就不需要管了</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放一个实例对象</span></span><br><span class="line">    <span class="comment">// typedef void (*freefunc)(void *); 一般会在析构函数中调用</span></span><br><span class="line">    freefunc tp_free; <span class="comment">/* Low-level free-memory routine */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// typedef int (*inquiry)(PyObject *); 是否被 gc 跟踪</span></span><br><span class="line">    inquiry tp_is_gc; <span class="comment">/* For PyObject_IS_GC */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 继承哪些类，这里可以指定继承多个类</span></span><br><span class="line">    <span class="comment">// 这个还是有必要的，因此这个可以单独设置</span></span><br><span class="line">    PyObject *tp_bases;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//下面的就不需要关心了</span></span><br><span class="line">    PyObject *tp_mro; <span class="comment">/* method resolution order */</span></span><br><span class="line">    PyObject *tp_cache;</span><br><span class="line">    PyObject *tp_subclasses;</span><br><span class="line">    PyObject *tp_weaklist;</span><br><span class="line">    destructor tp_del;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> tp_version_tag;</span><br><span class="line">    destructor tp_finalize;</span><br><span class="line">&#125; PyTypeObject;</span><br></pre></td></tr></table></figure>

<p><strong>这里面我们看到有很多成员，如果有些成员我们不需要的话，那么就设置为 0  即可。不过即便设置为 0，但是有些成员我们在调用 PyType_Ready 初始化的时候，也会设置进去。比如  tp_dict，这个我们创建类的时候没有设置，但是这个类是有属性字典的，因为在 PyType_Ready 中设置了；但有的不会，比如  tp_dictoffset，这个我们没有设置，那么类在 PyType_Ready  中也不会设置，因此这个类的实例对象，就真的没有属性字典了。再比如 tp_free，我们也没有设置，但是是可以调用的，原因你懂的。</strong></p>
<p><strong>虽然里面的成员非常多，但是我们在实现的时候不一定每一个成员都要设置。如果只需要指定某几个成员的话，那么我们可以先创建一个 PyTypeObject 实例，然后针对指定的属性进行设置即可。</strong></p>
<p><strong>下面我们来编写一个简单的扩展类，具体细节在代码中体现。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Python.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这一步是直接定义一个类，它就是我们在 Python 中使用的类，这里采用 C++，因此我们编译时的文件要从 main.c 改成 main.cpp</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    PyObject_HEAD  <span class="comment">// 公共的头部信息</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">或者你直接使用结构体的方式也是可以的，这样源文件还叫 main.c 不需要修改</span></span><br><span class="line"><span class="comment">typedef struct &#123;</span></span><br><span class="line"><span class="comment">    PyObject_HEAD  // 头部信息</span></span><br><span class="line"><span class="comment">&#125; MyClass;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里我们实现 Python 中的 __new__ 方法，这个 __new__ 方法接收哪些参数来着</span></span><br><span class="line"><span class="comment">// 一个类本身，以及 __init__ 中的参数，我们一般会这样写 def __new__(cls, *args, **kwargs):</span></span><br><span class="line"><span class="comment">// 所以这里的第一个参数就不再是 PyObject *了，而是 PyTypeObject *</span></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">MyClass_new</span><span class="params">(PyTypeObject *cls, PyObject *args, PyObject *kw)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 我们说 Python 中的 __new__ 方法默认都干了哪些事来着</span></span><br><span class="line">    <span class="comment">// 为创建的实例对象开辟一份空间，然后会将这份空间的指针返回回去交给 self</span></span><br><span class="line">    <span class="comment">// 当然交给 __init__ 的还有其它参数，这些参数是 __init__ 需要使用的，__new__ 方法不需要关心</span></span><br><span class="line">    <span class="comment">// 但是毕竟要先经过 __new__ 方法，所以 __new__ 方法中要有参数位能够接收</span></span><br><span class="line">    <span class="comment">// 最终 __new__ 会将自身返回的 self 连同其它参数组合起来一块交给 __init__</span></span><br><span class="line">    <span class="comment">// 所以 __init__ 中 self 我们不需要关心，我们只需要传递 self 后面的参数即可，因为在 __new__ 会自动传递self</span></span><br><span class="line">    <span class="comment">// 另外多提一嘴：我们使用实例对象调用方法的时候，会自动传递 self，你有没有想过它为什么会自动传递呢？</span></span><br><span class="line">    <span class="comment">// 其实这个在底层是使用了描述符，至于底层是怎么实现的，我们在之前已经说过了</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所以我们这里要为 self 分配一个空间，self 也是一个指针，但是它已经有了明确的类型，所以我们需要转化一下</span></span><br><span class="line">    <span class="comment">// 当然这里不叫 self 也是可以的，只是我们按照官方的约定，不会引起歧义</span></span><br><span class="line">    <span class="comment">// 分配空间是通过调用 PyTypeObject 的 tp_alloc 方法，传入一个 PyTypeObject *，以及大小，这里是固定的所以是 0</span></span><br><span class="line">    MyClass *self = (MyClass *)cls -&gt; tp_alloc(cls, <span class="number">0</span>);  <span class="comment">// 此时就由 Python 管理了</span></span><br><span class="line">    <span class="comment">// 记得返回 self，转成 PyObject *，当然我们这里是 __new__ 方法的默认实现，你也可以做一些其它的事情来控制一下类的实例化行为</span></span><br><span class="line">    <span class="keyword">return</span> (PyObject *)self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数接收三个 PyObject *, 但它返回的是一个 int, 0 表示成功、-1 表示失败</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">MyClass_init</span><span class="params">(PyObject *self, PyObject *args, PyObject *kw)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 假设这个构造函数接收三个参数：name，age，gender</span></span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">char</span> *gender;</span><br><span class="line">    <span class="type">char</span> *keys[] = &#123;<span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;gender&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (!PyArg_ParseTupleAndKeywords(args, kw, <span class="string">&quot;sis&quot;</span>, keys, &amp;name, &amp;age, &amp;gender))&#123;</span><br><span class="line">        <span class="comment">// 这里失败了不能返回 NULL，而是返回 -1，__init__ 比较特殊</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//至于如何设置到 self 当中，我们后面演示，这里先打印一下</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;name = %s, age = %d, gender = %s\n&quot;</span>, name, age, gender);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们说结果为 0 返回成功，结果为 -1 返回失败，所以走到这里的话应该返回 0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数, 返回值是 void，关于这些函数的参数和返回值的定义可以查看上面介绍的 PyTypeObject 结构体</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">MyClass_del</span><span class="params">(PyObject *self)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 打印一句话吧</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;call __del__\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 拿到类型，调用 tp_free 释放，这个是释放实例对象所占空间的。所以 tp_alloc 是申请、tp_dealloc 是释放</span></span><br><span class="line">    Py_TYPE(self) -&gt; tp_free(self);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyModuleDef module = &#123;</span><br><span class="line">    PyModuleDef_HEAD_INIT, <span class="comment">// 头部信息</span></span><br><span class="line">    <span class="string">&quot;kagura_nana&quot;</span>,  <span class="comment">// 模块名</span></span><br><span class="line">    <span class="string">&quot;this is a module named hanser&quot;</span>, <span class="comment">// 模块注释</span></span><br><span class="line">    <span class="number">-1</span>,  <span class="comment">// 模块空间</span></span><br><span class="line">    <span class="number">0</span>,  <span class="comment">// 这里是 PyMethodDef 数组，但是我们这里没有 PyMethodDef，所以就是 0，也就是我们这里面没有定义函数</span></span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PyMODINIT_FUNC</span><br><span class="line"><span class="title function_">PyInit_kagura_nana</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建类的这些过程，我们也可以单独写，我们这里第一次演示就直接写在模块初始化函数里面了</span></span><br><span class="line">    <span class="comment">// 实例化一个 PyTypeObject，但是这里面的属性非常多，我们通过直接赋值的方式需要写一大堆，所以先定义，然后设置指定的属性</span></span><br><span class="line">    <span class="type">static</span> PyTypeObject cls;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们知道 PyTypeObject 结构体的第一个参数就是 PyVarObject ob_base;</span></span><br><span class="line">    <span class="comment">// 需要引用计数(初始为1)、类型 &amp;PyType_Type、ob_size(不可变，写上0即可)</span></span><br><span class="line">    PyVarObject ob_base = &#123;<span class="number">1</span>, &amp;PyType_Type, <span class="number">0</span>&#125;;</span><br><span class="line">    cls.ob_base = ob_base;  <span class="comment">// 类的公共头部</span></span><br><span class="line">    <span class="comment">// 这里是类名，但是这个 MyClass 是 Python 中打印的时候显示的名字，或者说调用 __name__ 显示的名字</span></span><br><span class="line">    <span class="comment">// 假设我们上面的是 MyClass1，那么在 Python 中你就需要使用 MyClass1 来实例化</span></span><br><span class="line">    <span class="comment">// 但是使用 type 查看的时候显示的 MyClass，因为类名叫 MyClass，但是很明显这两者应该是一致的</span></span><br><span class="line">    cls.tp_name = <span class="string">&quot;MyClass&quot;</span>;</span><br><span class="line">    cls.tp_basicsize = <span class="keyword">sizeof</span>(MyClass);  <span class="comment">// 类的空间大小</span></span><br><span class="line">    cls.tp_itemsize = <span class="number">0</span>; <span class="comment">// 设置为 0</span></span><br><span class="line">    <span class="comment">// 设置类的 __new__ 方法、__init__ 方法、__del__ 方法</span></span><br><span class="line">    cls.tp_new = MyClass_new;</span><br><span class="line">    cls.tp_init = MyClass_init;</span><br><span class="line">    cls.tp_dealloc = MyClass_del;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化类，调用 PyType_Ready,而且 Python 内部的类在创建完成之后也会调用这个方法进行初始化，它会对创建类进行一些属性的设置</span></span><br><span class="line">    <span class="comment">// 记得传入指针进去</span></span><br><span class="line">    <span class="keyword">if</span> (PyType_Ready(&amp;cls) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 如果结果小于0，说明设置失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个是我们自己创建的类，所以需要手动增加引用计数</span></span><br><span class="line">    Py_XINCREF(&amp;cls);</span><br><span class="line">    <span class="comment">// 加入到模块中，这个不需要在创建 PyModuleDef 的时候指定，而是可以单独添加</span></span><br><span class="line">    <span class="comment">// 我们需要先把模块创建出来，然后通过 PyModule_AddObject 将类添加进去</span></span><br><span class="line">    PyObject *m = PyModule_Create(&amp;module);</span><br><span class="line">    <span class="comment">// 传入 创建的模块的指针 m、类名(这个类名要和我们上面设置的 tp_name 保持一致)、以及由 PyTypeObject * 转化得到的 PyObject *</span></span><br><span class="line">    <span class="comment">// 另外多提一嘴，这里的 m、和 cls 以及上面 module 都只是 C 中的变量，具体的模块名和类名是 kagura_nana 和 MyClass</span></span><br><span class="line">    PyModule_AddObject(m, <span class="string">&quot;MyClass&quot;</span>, (PyObject *)&amp;cls);</span><br><span class="line">    <span class="keyword">return</span> m; <span class="comment">// 将模块对象返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>然后是用于编译的 py 文件：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> distutils.core <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">setup(</span><br><span class="line">    name=<span class="string">&quot;kagura_nana&quot;</span>,</span><br><span class="line">    version=<span class="string">&quot;1.11&quot;</span>,</span><br><span class="line">    author=<span class="string">&quot;古明地盆&quot;</span>,</span><br><span class="line">    author_email=<span class="string">&quot;66666@东方地灵殿.com&quot;</span>,</span><br><span class="line">    <span class="comment"># 这里改成 main.cpp</span></span><br><span class="line">    ext_modules=[Extension(<span class="string">&quot;kagura_nana&quot;</span>, [<span class="string">&quot;main.cpp&quot;</span>])],</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意：之前使用的都是自己住的地方的台式机，里面装了相应的环境，因为机器性能比较好。但是春节本人回家了，现在使用的是自己的笔记本，而笔记本里面没有装 Visual Studio 等环境，因此接下来环境会选择我阿里云上的 CentOS。</strong></p>
</blockquote>
<p><strong>编译的方式跟之前一样，只不过需要先执行一下 <code>yum install gcc-c++</code>，否则编译时会抛出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc: error trying to exec &#x27;cc1plus&#x27;: execvp: No such file or directory</span><br></pre></td></tr></table></figure>

<p><strong>如果你已经装了，那么是没有问题的，但也建议执行确认一下。下面操作一波：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> kagura_nana</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>kagura_nana</span><br><span class="line">&lt;module <span class="string">&#x27;kagura_nana&#x27;</span> <span class="keyword">from</span> <span class="string">&#x27;/usr/local/lib64/python3.6/site-packages/kagura_nana.cpython-36m-x86_64-linux-gnu.so&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="comment"># 然后实例化一个类</span></span><br><span class="line"><span class="meta">... </span>    <span class="comment"># 我们说这个类的构造函数中接收三个参数，我们先不传递，看看会有什么表现</span></span><br><span class="line"><span class="meta">... </span>    self = kagura_nana.MyClass()</span><br><span class="line"><span class="meta">... </span><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(e)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">call __del__</span><br><span class="line">Required argument <span class="string">&#x27;name&#x27;</span> (pos <span class="number">1</span>) <span class="keyword">not</span> found</span><br></pre></td></tr></table></figure>

<p><strong>尽管实例化失败，但是这个对象在 <strong>new</strong> 方法中被创建了，所以依旧会调用 __del__。然后我们传递参数，但是我们在构造函数中只是打印，并没有设置到 self 中。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>self = kagura_nana.MyClass(<span class="string">&quot;mashiro&quot;</span>, <span class="number">16</span>, <span class="string">&quot;female&quot;</span>)</span><br><span class="line">name = mashiro, age = <span class="number">16</span>, gender = female</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>self.name</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AttributeError: <span class="string">&#x27;MyClass&#x27;</span> <span class="built_in">object</span> has no attribute <span class="string">&#x27;name&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看到调用失败了，因为我们没有设置到 self 中，然后再看看析构函数。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> self</span><br><span class="line">call __del__</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br></pre></td></tr></table></figure>

<p><strong>成功调用，然后里面的 printf 也成功执行。</strong></p>
<h3 id="给实例对象添加属性"><a href="#给实例对象添加属性" class="headerlink" title="给实例对象添加属性"></a>给实例对象添加属性</h3><p><strong>整体流程我们大致了解了，下面看看如何给实例对象添加属性。我们说 PyTypeObject 里面有一个 tp_members 属性，很明显它就是用来指定实例对象的属性的。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Python.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;structmember.h&quot;</span>  <span class="comment">// 添加成员需要导入这个头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    <span class="comment">// 添加成员，这里面的参数要和 __init__ 中的参数保持一致，你可以把 name、age、gender 看成是要通过 self. 的方式来设置的属性</span></span><br><span class="line">    <span class="comment">// 假设这里面没有 gender,那么即使 Python 中传了 gender 这个参数、并且解析出来了</span></span><br><span class="line">    <span class="comment">// 但是你仍然没办法设置，所以实例化的对象依旧无法访问</span></span><br><span class="line">    PyObject *name;</span><br><span class="line">    PyObject *age;</span><br><span class="line">    PyObject *gender;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// 你仍然可以使用结构体的方式定义</span></span><br><span class="line"><span class="comment">typedef struct&#123;</span></span><br><span class="line"><span class="comment">	PyObject_HEAD</span></span><br><span class="line"><span class="comment">	PyObject *name;</span></span><br><span class="line"><span class="comment">	PyObject *age;</span></span><br><span class="line"><span class="comment">	PyObject *gender;</span></span><br><span class="line"><span class="comment">&#125;MyClass;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">MyClass_new</span><span class="params">(PyTypeObject *cls, PyObject *args, PyObject *kw)</span></span><br><span class="line">&#123;</span><br><span class="line">    MyClass *self = (MyClass *)cls -&gt; tp_alloc(cls, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> (PyObject *)self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">MyClass_init</span><span class="params">(PyObject *self, PyObject *args, PyObject *kw)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 这里不使用 C 的类型了，使用 PyObject *，参数和原来一样</span></span><br><span class="line">    PyObject *name;</span><br><span class="line">    PyObject *age = <span class="literal">NULL</span>;</span><br><span class="line">    PyObject *gender = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 注意：上面申明的三个 PyObject * 变量叫什么名字其实是没有所谓的，重点是 MyClass 和 下面 keys</span></span><br><span class="line">    <span class="comment">// keys 里面的字符串就是 __init__ 中的参数名，MyClass 中的变量则是实例对象的属性名</span></span><br><span class="line">    <span class="comment">// 假设把 MyClass 这个类中的 name 改成 NAME，那么最终的形式就等价于 self.NAME = name</span></span><br><span class="line">    <span class="type">char</span> *keys[] = &#123;<span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;gender&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (!PyArg_ParseTupleAndKeywords(args, kw, <span class="string">&quot;O!|O!O!&quot;</span>, keys, &amp;PyUnicode_Type, &amp;name,</span><br><span class="line">                                     &amp;PyLong_Type, &amp;age, &amp;PyUnicode_Type, &amp;gender))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注意: 有一个很关键的点，在 __init__ 函数调用结束之后，name、age、gender 的引用计数会减一</span></span><br><span class="line">    <span class="comment">// 而它们又是从 Python 传递过来的，所以为了保证不出现悬空指针，我们必须要将引用计数手动加 1</span></span><br><span class="line">    Py_XINCREF(name);</span><br><span class="line">    <span class="comment">// 而 age 和 gender 是可以不传的，我们需要给一个默认值。</span></span><br><span class="line">    <span class="comment">// 当传递了 age，那么增加引用计数；没有传递 age，我们自己创建一个，由于是创建，引用计数初始为 1，所以此时就无需增加了。gender 也是同理</span></span><br><span class="line">    <span class="keyword">if</span> (age) Py_XINCREF(age); <span class="keyword">else</span> age = PyLong_FromLong(<span class="number">17</span>);</span><br><span class="line">    <span class="keyword">if</span> (gender) Py_XINCREF(gender); <span class="keyword">else</span> gender = PyUnicode_FromWideChar(<span class="string">L&quot;萌妹子&quot;</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="comment">// 这里就是设置 __init__ 属性的，将解析出来的参数设置到 __init__ 中</span></span><br><span class="line">    <span class="comment">// 注意 PyObject * 要转成 MyClass *，并且考虑优先级，我们需要使用括号括起来</span></span><br><span class="line">    ((MyClass *)self) -&gt; name = name;</span><br><span class="line">    ((MyClass *)self) -&gt; age = age;</span><br><span class="line">    ((MyClass *)self) -&gt; gender = gender;</span><br><span class="line">    <span class="comment">// 此时我们的构造函数就设置完成了</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">MyClass_del</span><span class="params">(PyObject *self)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 同样的问题，当对象在销毁的时候，实例对象的成员的引用计数是不是也要减去 1 呢</span></span><br><span class="line">    Py_XDECREF(((MyClass *)self) -&gt; name);</span><br><span class="line">    Py_XDECREF(((MyClass *)self) -&gt; age);</span><br><span class="line">    Py_XDECREF(((MyClass *)self) -&gt; gender);</span><br><span class="line">    Py_TYPE(self) -&gt; tp_free(self);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyModuleDef module = &#123;</span><br><span class="line">    PyModuleDef_HEAD_INIT,</span><br><span class="line">    <span class="string">&quot;kagura_nana&quot;</span>,</span><br><span class="line">    <span class="string">&quot;this is a module named hanser&quot;</span>,</span><br><span class="line">    <span class="number">-1</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PyMODINIT_FUNC</span><br><span class="line"><span class="title function_">PyInit_kagura_nana</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">static</span> PyTypeObject cls;</span><br><span class="line"></span><br><span class="line">    PyVarObject ob_base = &#123;<span class="number">1</span>, &amp;PyType_Type, <span class="number">0</span>&#125;;</span><br><span class="line">    cls.ob_base = ob_base;</span><br><span class="line">    cls.tp_name = <span class="string">&quot;MyClass&quot;</span>;</span><br><span class="line">    cls.tp_basicsize = <span class="keyword">sizeof</span>(MyClass);</span><br><span class="line">    cls.tp_itemsize = <span class="number">0</span>;</span><br><span class="line">    cls.tp_new = MyClass_new;</span><br><span class="line">    cls.tp_init = MyClass_init;</span><br><span class="line">    cls.tp_dealloc = MyClass_del;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加成员，这是一个 PyMemberDef 类型的数组，然后显然要把数组名放到类的 tp_members 中</span></span><br><span class="line">    <span class="comment">// PyNumberDef 结构体有以下成员：name type offset flags doc</span></span><br><span class="line">    <span class="type">static</span> PyMemberDef members[] = &#123;</span><br><span class="line">        <span class="comment">//这些成员具体值是什么？我们需要在 MyClass_init 中设置</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;name&quot;</span>, <span class="comment">// 成员名</span></span><br><span class="line">            T_OBJECT_EX, <span class="comment">// 类型，关于类型我们一会儿介绍</span></span><br><span class="line">            <span class="comment">// 接收结构体对象和一个成员</span></span><br><span class="line">            <span class="comment">// 获取对应值的偏移地址，由于 Python 中的类是动态变化的，所以 C 只能通过偏移的地址来找到对应的成员，offsetof 是一个宏</span></span><br><span class="line">            <span class="comment">// 而这里面的 name 就是我们定义的 MyClass 里面的 name，所以如果 MyClass 里面不设置，那么这里会报错</span></span><br><span class="line">            offsetof(MyClass, name),</span><br><span class="line">            <span class="number">0</span>, <span class="comment">// 变量的读取类型，设置为 0 表示可读写，设置为 1 表示只读</span></span><br><span class="line">            <span class="string">&quot;this is a name&quot;</span> <span class="comment">//成员说明</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 这里将 age 设置为只读</span></span><br><span class="line">        &#123;<span class="string">&quot;age&quot;</span>, T_OBJECT_EX, offsetof(MyClass, age), <span class="number">1</span>, <span class="string">&quot;this is a age&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;gender&quot;</span>, T_OBJECT_EX, offsetof(MyClass, gender), <span class="number">0</span>, <span class="string">&quot;this is a gender&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="literal">NULL</span>&#125;  <span class="comment">// 结尾有一个&#123;NULL&#125;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 设置成员，这一步很关键，否则之前的相当于白做</span></span><br><span class="line">    cls.tp_members = members;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PyType_Ready(&amp;cls) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Py_XINCREF(&amp;cls);</span><br><span class="line">    PyObject *m = PyModule_Create(&amp;module);</span><br><span class="line">    PyModule_AddObject(m, <span class="string">&quot;MyClass&quot;</span>, (PyObject *)&amp;cls);</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们来测试一下：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> kagura_nana</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>self = kagura_nana.MyClass(<span class="string">&quot;古明地觉&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>self.name, self.age, self.gender</span><br><span class="line">(<span class="string">&#x27;古明地觉&#x27;</span>, <span class="number">17</span>, <span class="string">&#x27;萌妹子&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>self = kagura_nana.MyClass(<span class="string">&quot;古明地恋&quot;</span>, <span class="number">16</span>, <span class="string">&quot;美少女&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>self.name, self.age, self.gender</span><br><span class="line">(<span class="string">&#x27;古明地恋&#x27;</span>, <span class="number">16</span>, <span class="string">&#x27;美少女&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>self.name, self.gender = <span class="string">&quot;koishi&quot;</span>, <span class="string">&quot;びしょうじょ&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>self.name, self.age, self.gender</span><br><span class="line">(<span class="string">&#x27;koishi&#x27;</span>, <span class="number">16</span>, <span class="string">&#x27;びしょうじょ&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 我们看到一些都没有问题，但接下来重点来了</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>self.age = <span class="number">16</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AttributeError: readonly attribute</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br></pre></td></tr></table></figure>

<p><strong>一切正常，并且我们看到 age 是只读的，因为我们在 PyMemberDef 中将其设置为只读，我们来看一下这个结构体。该结构体的定义藏身于 *Include&#x2F;structmember.h* 中。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PyMemberDef</span> &#123;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;   <span class="comment">// 实例属性的名字, 比如我们上面的 name、age、gender</span></span><br><span class="line">    <span class="type">int</span> type;		   <span class="comment">// 实例属性的类型, 这一点很关键, 支持的类型我们一会说</span></span><br><span class="line">    Py_ssize_t offset;  <span class="comment">// 实例属性的偏移量，通过 offsetof(TYPE, MEMBER) 这个宏来获取</span></span><br><span class="line">    <span class="type">int</span> flags;		   <span class="comment">// 设置为 0 表示可读可写, 设置为 1 表示只读</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *doc;    <span class="comment">// 属性说明</span></span><br><span class="line">&#125; PyMemberDef;</span><br></pre></td></tr></table></figure>

<p><strong>然后我们重点看一下里面的 type 成员，它表示属性的类型，支持如下选项：</strong></p>
<ul>
<li><code>#define T_SHORT     0</code></li>
<li><code>#define T_INT       1</code></li>
<li><code>#define T_LONG      2</code></li>
<li><code>#define T_FLOAT     3</code></li>
<li><code>#define T_DOUBLE    4</code></li>
<li><code>#define T_STRING    5</code></li>
<li><code>#define T_OBJECT    6</code></li>
<li><code>#define T_CHAR      7</code></li>
<li><code>#define T_BYTE      8 </code></li>
<li><code>#define T_UBYTE     9</code></li>
<li><code>#define T_USHORT    10</code></li>
<li><code>#define T_UINT      11</code></li>
<li><code>#define T_ULONG     12</code></li>
<li><code>#define T_STRING_INPLACE    13</code></li>
<li><code>#define T_BOOL      14</code></li>
<li><code>#define T_OBJECT_EX 16</code></li>
<li><code>#define T_LONGLONG      17</code></li>
<li><code>#define T_ULONGLONG     18</code></li>
<li><code>#define T_PYSSIZET      19  </code></li>
<li><code>#define T_NONE          20  </code></li>
</ul>
<p><strong>我们的类（MyClass）中的成员应该是 PyObject  *，但是用来接收参数的变量可以不是，只不过在设置实例属性的时候需要再转成 PyObject *，如果接收的就是 PyObject  *，那么就不需要再转了。而上面这些描述的就是参数的类型，所以我们一般用 T_OBJECT_EX 即可，但是还有一个  T_OBJECT，这两者的区别是前者如果接收的是 NULL（没有接收到值），那么会引发一个 AttributeError。</strong></p>
<blockquote>
<p><strong>到目前为止，我们应该感受到使用 C&#x2F;C++ 来写扩展是一件多么痛苦的事情，特别是引用计数，一搞不好就出现内存泄漏或者悬空指针。因此，关键来了，再次安利一波 Cython。</strong></p>
</blockquote>
<p><strong>除了 <strong>init__、__new__、__del</strong> 之外，你还可以添加其它的方法，比如 tp_call、tp_getset 等等。</strong></p>
<h3 id="给类添加成员"><a href="#给类添加成员" class="headerlink" title="给类添加成员"></a>给类添加成员</h3><p><strong>一个类里面可以定义很多的函数，那么这在 C 中是如何实现的呢？很简单，和模块中定义函数是一致的。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Python.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;structmember.h&quot;</span>  <span class="comment">// 添加成员需要导入这个头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">        public:</span><br><span class="line">        PyObject_HEAD</span><br><span class="line">        <span class="comment">// 添加成员，这里面的参数要和 __init__ 中的参数保持一致，你可以把 name、age、gender 看成是要通过 self. 的方式来设置的属性</span></span><br><span class="line">        <span class="comment">// 假设这里面没有 gender,那么即使 Python 中传了 gender 这个参数、并且解析出来了</span></span><br><span class="line">        <span class="comment">// 但是你仍然没办法设置，所以实例化的对象依旧无法访问</span></span><br><span class="line">        PyObject *name;</span><br><span class="line">        PyObject *age;</span><br><span class="line">        PyObject *gender;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">MyClass_new</span><span class="params">(PyTypeObject *cls, PyObject *args, PyObject *kw)</span></span><br><span class="line">&#123;</span><br><span class="line">    MyClass *self = (MyClass *)cls -&gt; tp_alloc(cls, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> (PyObject *)self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">MyClass_init</span><span class="params">(PyObject *self, PyObject *args, PyObject *kw)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyObject *name;</span><br><span class="line">    PyObject *age = <span class="literal">NULL</span>;</span><br><span class="line">    PyObject *gender = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">char</span> *keys[] = &#123;<span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;gender&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (!PyArg_ParseTupleAndKeywords(args, kw, <span class="string">&quot;O!|O!O!&quot;</span>, keys, &amp;PyUnicode_Type, &amp;name,</span><br><span class="line">                                     &amp;PyLong_Type, &amp;age, &amp;PyUnicode_Type, &amp;gender))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Py_XINCREF(name);</span><br><span class="line">    <span class="keyword">if</span> (age) Py_XINCREF(age); <span class="keyword">else</span> age = PyLong_FromLong(<span class="number">17</span>);</span><br><span class="line">    <span class="keyword">if</span> (gender) Py_XINCREF(gender); <span class="keyword">else</span> gender = PyUnicode_FromWideChar(<span class="string">L&quot;萌妹子&quot;</span>, <span class="number">3</span>);</span><br><span class="line">    ((MyClass *)self) -&gt; name = name;</span><br><span class="line">    ((MyClass *)self) -&gt; age = age;</span><br><span class="line">    ((MyClass *)self) -&gt; gender = gender;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">MyClass_del</span><span class="params">(PyObject *self)</span></span><br><span class="line">&#123;</span><br><span class="line">    Py_XDECREF(((MyClass *)self) -&gt; name);</span><br><span class="line">    Py_XDECREF(((MyClass *)self) -&gt; age);</span><br><span class="line">    Py_XDECREF(((MyClass *)self) -&gt; gender);</span><br><span class="line">    Py_TYPE(self) -&gt; tp_free(self);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面来给类添加成员函数啦，添加方法跟之前的创建函数是一样的</span></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">age_incr_1</span><span class="params">(PyObject *self, PyObject *args, PyObject *kw)</span></span><br><span class="line">&#123;</span><br><span class="line">    ((MyClass *)self) -&gt; age = PyNumber_Add(((MyClass *)self) -&gt; age, PyLong_FromLong(<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> Py_None;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构建 PyMethodDef[], 方法和之前创建函数是一样的，但是这是类的方法，记得添加到类的 tp_methods 成员中</span></span><br><span class="line"><span class="type">static</span> PyMethodDef MyClass_methods[] = &#123;</span><br><span class="line">        &#123;<span class="string">&quot;age_incr_1&quot;</span>, (PyCFunction)age_incr_1, METH_VARARGS | METH_KEYWORDS, <span class="string">&quot;method age_incr_1&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyModuleDef module = &#123;</span><br><span class="line">        PyModuleDef_HEAD_INIT,</span><br><span class="line">        <span class="string">&quot;kagura_nana&quot;</span>,</span><br><span class="line">        <span class="string">&quot;this is a module named hanser&quot;</span>,</span><br><span class="line">        <span class="number">-1</span>,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PyMODINIT_FUNC</span><br><span class="line"><span class="title function_">PyInit_kagura_nana</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">static</span> PyTypeObject cls;</span><br><span class="line"></span><br><span class="line">    PyVarObject ob_base = &#123;<span class="number">1</span>, &amp;PyType_Type, <span class="number">0</span>&#125;;</span><br><span class="line">    cls.ob_base = ob_base;</span><br><span class="line">    cls.tp_name = <span class="string">&quot;MyClass&quot;</span>;</span><br><span class="line">    cls.tp_basicsize = <span class="keyword">sizeof</span>(MyClass);</span><br><span class="line">    cls.tp_itemsize = <span class="number">0</span>;</span><br><span class="line">    cls.tp_new = MyClass_new;</span><br><span class="line">    cls.tp_init = MyClass_init;</span><br><span class="line">    cls.tp_dealloc = MyClass_del;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> PyMemberDef members[] = &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;name&quot;</span>,</span><br><span class="line">            T_OBJECT_EX,</span><br><span class="line">            offsetof(MyClass, name),</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            <span class="string">&quot;this is a name&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;<span class="string">&quot;age&quot;</span>, T_OBJECT_EX, offsetof(MyClass, age), <span class="number">0</span>, <span class="string">&quot;this is a age&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;gender&quot;</span>, T_OBJECT_EX, offsetof(MyClass, gender), <span class="number">0</span>, <span class="string">&quot;this is a gender&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="literal">NULL</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    cls.tp_members = members;</span><br><span class="line">    <span class="comment">// 设置方法</span></span><br><span class="line">    cls.tp_methods = MyClass_methods;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PyType_Ready(&amp;cls) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Py_XINCREF(&amp;cls);</span><br><span class="line">    PyObject *m = PyModule_Create(&amp;module);</span><br><span class="line">    PyModule_AddObject(m, <span class="string">&quot;MyClass&quot;</span>, (PyObject *)&amp;cls);</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们看到几乎没有任何区别，那么下面就来测试一下：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> kagura_nana</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>self = kagura_nana.MyClass(<span class="string">&quot;古明地恋&quot;</span>, <span class="number">16</span>, <span class="string">&quot;美少女&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>self.age_incr_1()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>self.age</span><br><span class="line"><span class="number">17</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br></pre></td></tr></table></figure>

<h3 id="循环引用造成的内存泄漏"><a href="#循环引用造成的内存泄漏" class="headerlink" title="循环引用造成的内存泄漏"></a>循环引用造成的内存泄漏</h3><p><strong>我们说 Python 的引用计数有一个重大缺陷，那就是它无法解决循环引用。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    my = MyClass(<span class="string">&quot;古明地觉&quot;</span>)</span><br><span class="line">    my.name = my</span><br></pre></td></tr></table></figure>

<p><strong>如果你执行上面这段代码的话，那么你会发现内存不断飙升，很明显我们上面在 C 中定义的类是没有考虑循环引用的，因为它没有被 GC 跟踪。</strong></p>
<p><img src="/2023/04/26/31-Python-%E5%92%8C-C-C-%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/1229382-20210212015512909-1991186827.png" alt="img"></p>
<p><strong>我们看到由于内存使用量不断增加，最后被操作系统强制 kill  掉了，主要就在于我们没有解决循环引用，导致实例对象不断被创建、但却没有被回收（引用计数最大的缺陷）。如果想要解决循环引用的话，那么就需要  Python 中的 GC 出马，而使用 GC 的前提是这个类的实例对象要被 GC 跟踪，因此我们还需要指定  tp_flags。除此之外，我们还要指定 tp_traverse（判断内部成员是否被循环引用）和  tp_clear（清理）两个函数，至于具体细节编写代码时有所体现。最后我们上面的那个类也是不允许被继承的，如果想被继承，同样需要指定  tp_flags。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> kagura_nana</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">A</span>(kagura_nana.MyClass):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="built_in">type</span> <span class="string">&#x27;MyClass&#x27;</span> <span class="keyword">is</span> <span class="keyword">not</span> an acceptable base <span class="built_in">type</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>我们看到 MyClass 不是一个可以被继承的类，那么下面我们来进行修改。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Python.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;structmember.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">        public:</span><br><span class="line">        PyObject_HEAD</span><br><span class="line">        PyObject *name;</span><br><span class="line">        PyObject *age;</span><br><span class="line">        PyObject *gender;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">MyClass_new</span><span class="params">(PyTypeObject *cls, PyObject *args, PyObject *kw)</span></span><br><span class="line">&#123;</span><br><span class="line">    MyClass *self = (MyClass *)cls -&gt; tp_alloc(cls, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> (PyObject *)self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">MyClass_init</span><span class="params">(PyObject *self, PyObject *args, PyObject *kw)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyObject *name;</span><br><span class="line">    PyObject *age = <span class="literal">NULL</span>;</span><br><span class="line">    PyObject *gender = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">char</span> *keys[] = &#123;<span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;gender&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (!PyArg_ParseTupleAndKeywords(args, kw, <span class="string">&quot;O!|O!O!&quot;</span>, keys, &amp;PyUnicode_Type, &amp;name,</span><br><span class="line">                                     &amp;PyLong_Type, &amp;age, &amp;PyUnicode_Type, &amp;gender))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Py_XINCREF(name);</span><br><span class="line">    <span class="keyword">if</span> (age) Py_XINCREF(age); <span class="keyword">else</span> age = PyLong_FromLong(<span class="number">17</span>);</span><br><span class="line">    <span class="keyword">if</span> (gender) Py_XINCREF(gender); <span class="keyword">else</span> gender = PyUnicode_FromWideChar(<span class="string">L&quot;萌妹子&quot;</span>, <span class="number">3</span>);</span><br><span class="line">    ((MyClass *)self) -&gt; name = name;</span><br><span class="line">    ((MyClass *)self) -&gt; age = age;</span><br><span class="line">    ((MyClass *)self) -&gt; gender = gender;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">age_incr_1</span><span class="params">(PyObject *self, PyObject *args, PyObject *kw)</span></span><br><span class="line">&#123;</span><br><span class="line">    ((MyClass *)self) -&gt; age = PyNumber_Add(((MyClass *)self) -&gt; age, PyLong_FromLong(<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> Py_None;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> PyMethodDef MyClass_methods[] = &#123;</span><br><span class="line">        &#123;<span class="string">&quot;age_incr_1&quot;</span>, (PyCFunction)age_incr_1, METH_VARARGS | METH_KEYWORDS, <span class="string">&quot;method age_incr_1&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否被循环引用，参数和返回的值的定义还是参考源码，这里面的参数名要固定</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">MyClass_traverse</span><span class="params">(MyClass *self, visitproc visit, <span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="comment">// 底层帮你提供了一个宏</span></span><br><span class="line">    Py_VISIT(self -&gt; name);</span><br><span class="line">    Py_VISIT(self -&gt; age);</span><br><span class="line">    Py_VISIT(self -&gt; gender);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 清理</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">MyClass_clear</span><span class="params">(MyClass *self)</span>&#123;</span><br><span class="line">    Py_CLEAR(self -&gt; name);</span><br><span class="line">    Py_CLEAR(self -&gt; age);</span><br><span class="line">    Py_CLEAR(self -&gt; gender);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">MyClass_del</span><span class="params">(PyObject *self)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 我们在 MyClass_clear 中使用了 Py_CLEAR，那么这里减少引用计数的逻辑就不需要了，直接调用 MyClass_clear 即可</span></span><br><span class="line">    MyClass_clear((MyClass *) self);</span><br><span class="line">    <span class="comment">// 我们说 Python 会跟踪创建的对象，如果被回收了，那么应该从链表中移除</span></span><br><span class="line">    PyObject_GC_UnTrack(self);</span><br><span class="line">    Py_TYPE(self) -&gt; tp_free(self);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyModuleDef module = &#123;</span><br><span class="line">        PyModuleDef_HEAD_INIT,</span><br><span class="line">        <span class="string">&quot;kagura_nana&quot;</span>,</span><br><span class="line">        <span class="string">&quot;this is a module named hanser&quot;</span>,</span><br><span class="line">        <span class="number">-1</span>,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PyMODINIT_FUNC</span><br><span class="line"><span class="title function_">PyInit_kagura_nana</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">static</span> PyTypeObject cls;</span><br><span class="line"></span><br><span class="line">    PyVarObject ob_base = &#123;<span class="number">1</span>, &amp;PyType_Type, <span class="number">0</span>&#125;;</span><br><span class="line">    cls.ob_base = ob_base;</span><br><span class="line">    cls.tp_name = <span class="string">&quot;MyClass&quot;</span>;</span><br><span class="line">    cls.tp_basicsize = <span class="keyword">sizeof</span>(MyClass);</span><br><span class="line">    cls.tp_itemsize = <span class="number">0</span>;</span><br><span class="line">    cls.tp_new = MyClass_new;</span><br><span class="line">    cls.tp_init = MyClass_init;</span><br><span class="line">    cls.tp_dealloc = MyClass_del;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> PyMemberDef members[] = &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;name&quot;</span>,</span><br><span class="line">            T_OBJECT_EX,</span><br><span class="line">            offsetof(MyClass, name),</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            <span class="string">&quot;this is a name&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;<span class="string">&quot;age&quot;</span>, T_OBJECT_EX, offsetof(MyClass, age), <span class="number">0</span>, <span class="string">&quot;this is a age&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;gender&quot;</span>, T_OBJECT_EX, offsetof(MyClass, gender), <span class="number">0</span>, <span class="string">&quot;this is a gender&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="literal">NULL</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    cls.tp_members = members;</span><br><span class="line">    cls.tp_methods = MyClass_methods;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解决循环引用造成的内存泄漏，通过 Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC 开启垃圾回收，同时允许该类被继承</span></span><br><span class="line">    cls.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC;</span><br><span class="line">    <span class="comment">// 设置 tp_traverse 和 tp_clear</span></span><br><span class="line">    cls.tp_traverse = (traverseproc) MyClass_traverse;</span><br><span class="line">    cls.tp_clear = (inquiry) MyClass_clear;</span><br><span class="line">    <span class="comment">// 如果想指定继承的类的话，那么通过 tp_bases 指定即可，这里不再说了</span></span><br><span class="line">    <span class="keyword">if</span> (PyType_Ready(&amp;cls) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Py_XINCREF(&amp;cls);</span><br><span class="line">    PyObject *m = PyModule_Create(&amp;module);</span><br><span class="line">    PyModule_AddObject(m, <span class="string">&quot;MyClass&quot;</span>, (PyObject *)&amp;cls);</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>下面我们来继续测试一下，看看有没有问题：</strong></p>
<p><img src="/2023/04/26/31-Python-%E5%92%8C-C-C-%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/1229382-20210212015521571-1265763120.png" alt="img"></p>
<p><strong>可以看到，此时类可以被继承了，并且也没有出现循环引用导致的内存泄漏。</strong></p>
<p>​        <strong>真的想说，用 C  写扩展实在是太不容易了，很明显这还只是非常简单的，因为目前这个类基本没啥方法。如果加上描述符、自定义迭代器，或者我们再多写几个方法。方法之间互相调用，导入模块（目前还没有说）等等，绝对是让人头皮发麻的事情，所以写扩展我一般只用 Cython。</strong>    </p>
<h2 id="全局解释器锁"><a href="#全局解释器锁" class="headerlink" title="全局解释器锁"></a>全局解释器锁</h2><p><strong>我们使用 C &#x2F; C++ 写扩展除了增加效率之外，最大的特点就是能够释放掉 GIL，关于 GIL 也是一个老生常谈的问题。我在前面系列已经说过，这里不再赘述了。</strong></p>
<p><strong>那么问题来了，在 C 中如何获取 GIL 呢？</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先 Python 中的线程是对 C 线程的一个封装，同时还会对应一个 PyThreadState(线程状态) 对象，用来对线程状态进行描述</span></span><br><span class="line"><span class="comment">// 而如果要使用 Python / C API 的话，那么就不能是 C 中的线程，而是 Python 中的线程</span></span><br><span class="line">Py_GILState_STATE gstate;</span><br><span class="line"><span class="comment">// 所以 Python 为了简便而提供了一个函数 PyGILState_Ensure，在 C 中创建了一个线程，那么调用这个函数后，C 线程就会被封装成 Python 中的线程</span></span><br><span class="line"><span class="comment">// 不然的话，我们要写好多代码。这一步会对 Python 中线程进行初始化创建一个 PyThreadState 对象，同时获取 GIL</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">gstate = PyGILState_Ensure(); </span><br><span class="line"><span class="comment">// 做一些其它操作，注意：一旦使用 Python / C API，那么必须要获取到 GIL</span></span><br><span class="line">call_some_function();</span><br><span class="line"><span class="comment">// 释放掉 GIL</span></span><br><span class="line">PyGILState_Release(gstate);</span><br></pre></td></tr></table></figure>

<p><strong>一旦在 C 中获取到 GIL，那么 Python  的其它线程都必须处于等待状态，并且当调用扩展模块中的函数时，解释器是没有权利迫使当前线程释放 GIL 的，因为调用的是 C 的代码，Python 解释器能控制的只有 Python 的字节码这一层。所以在一些操作执行结束后，必须要主动释放 GIL，否则 Python  的其它线程永远不会得到被调度的机会。</strong></p>
<p><strong>但有时我们做的是一些纯 C &#x2F; C++ 操作，不需要和 Python  进行交互，这个时候希望告诉 Python 解释器，其它的线程该执行执行，不用等我，这个时候怎么做呢？首先Python  底层给我们提供了两个宏：Py_BEGIN_ALLOW_THREADS 和 Py_END_ALLOW_THREADS。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将当前线程状态给保存下来，然后其它线程就可以继续执行了，从名字上也能看出，开始允许多个线程并行执行</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Py_BEGIN_ALLOW_THREADS &#123; \</span></span><br><span class="line"><span class="meta">                        PyThreadState *_save; \</span></span><br><span class="line"><span class="meta">                        _save = PyEval_SaveThread();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 恢复线程状态，回到解释器的 GIL 调用中</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Py_END_ALLOW_THREADS    PyEval_RestoreThread(_save); \</span></span><br><span class="line"><span class="meta">                 &#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>从宏定义中我们可以看出，这两个宏是需要成对出现的，当然你也可以使用更细的 API 自己控制。总之：当释放 GIL 的时候，一定不要和 Python 进行交互，或者说不能有任何 Python &#x2F; C API 的调用。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Python.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子线程调用的函数, 要求接受一个 void *、返回一个 void*</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">test</span><span class="params">(<span class="type">void</span> *lst)</span> &#123;</span><br><span class="line">    <span class="comment">// 对于扩展而言，我们是通过 Python 调用里面的函数，所以调用它的是 Python 中的线程</span></span><br><span class="line">    <span class="comment">// 但这是我们使用 pthread 创建的子线程进行调用，不是 Python 中的，因此它不能和 Python 有任何的交互</span></span><br><span class="line">    <span class="comment">// 而我们是需要和 Python 交互的，这里面的参数 lst 就是由 PyObject * 转化得到的，因此我们需要封装成 Python 中的线程</span></span><br><span class="line">    PyGILState_STATE gstate;</span><br><span class="line">    gstate = PyGILState_Ensure();</span><br><span class="line">    <span class="comment">// 这里面和 Python 进行交互</span></span><br><span class="line">    PyObject *lst1 = (PyObject *) lst;</span><br><span class="line">    <span class="comment">// 我们往里面添加设置几个元素</span></span><br><span class="line">    PyObject *item = PyLong_FromLong(<span class="number">123</span>);</span><br><span class="line">    PyList_Append(lst1, item);</span><br><span class="line">    <span class="comment">// 注意：以上引用计数变成了 2，我们需要再减去 1</span></span><br><span class="line">    Py_XDECREF(item);</span><br><span class="line">    item = PyUnicode_FromString(<span class="string">&quot;hello matsuri&quot;</span>);</span><br><span class="line">    PyList_Append(lst1, item);</span><br><span class="line">    Py_XDECREF(item);</span><br><span class="line">    <span class="comment">// 假设我们以上 Python 的逻辑就调用完了，那么我们是不是要将 GIL 给释放掉呢？否则其它线程永远没有机会得到调度</span></span><br><span class="line">    <span class="comment">// 干脆我们就不释放了，看看效果吧</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyObject* <span class="title function_">test_gil</span><span class="params">(PyObject *self, PyObject *args)</span>&#123;</span><br><span class="line">    <span class="comment">// 假设我们接受一个 list</span></span><br><span class="line">    PyObject *lst = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (!PyArg_ParseTuple(args, <span class="string">&quot;O!&quot;</span>, &amp;PyList_Type, &amp;lst))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程 id</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="comment">// 创建一个线程</span></span><br><span class="line">    <span class="type">int</span> res = pthread_create(&amp;tid, <span class="literal">NULL</span>, test, (<span class="type">void</span> *)lst);</span><br><span class="line">    <span class="keyword">if</span> (res != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_create error: error_code = %d\n&quot;</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Py_None;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyMethodDef methods[] = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;test_gil&quot;</span>, (PyCFunction) test_gil, METH_VARARGS, <span class="string">&quot;this is a function named test_gil&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyModuleDef module = &#123;</span><br><span class="line">    PyModuleDef_HEAD_INIT,</span><br><span class="line">    <span class="string">&quot;kagura_nana&quot;</span>,</span><br><span class="line">    <span class="string">&quot;this is a module named hanser&quot;</span>,</span><br><span class="line">    <span class="number">-1</span>,</span><br><span class="line">    methods,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PyMODINIT_FUNC</span><br><span class="line"><span class="title function_">PyInit_kagura_nana</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    PyObject *m = PyModule_Create(&amp;module);</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们来测试一下：</strong></p>
<p><img src="/2023/04/26/31-Python-%E5%92%8C-C-C-%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/1229382-20210212015529203-1935981105.png" alt="img"></p>
<p><strong>我们看了程序就无法执行了，因为 Python 只能利用单核，我们在 C  中开启了子线程，然后创建对应的 Python 线程。此时就有两个 Python 线程，只不过一个是主线程，另一个是在 C  中创建的子线程，然后这个子线程通过 Python &#x2F; C API 获取了  GIL，但是用完了不释放，这就导致了主线程永远得不到机会执行。当然也无法接收 Ctrl + C 命令，因此我们需要新启一个终端 kill 掉它。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Python.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">test</span><span class="params">(<span class="type">void</span> *lst)</span> &#123;</span><br><span class="line">    PyGILState_STATE gstate;</span><br><span class="line">    gstate = PyGILState_Ensure();</span><br><span class="line">    PyObject *lst1 = (PyObject *) lst;</span><br><span class="line">    PyObject *item = PyLong_FromLong(<span class="number">123</span>);</span><br><span class="line">    PyList_Append(lst1, item);</span><br><span class="line">    Py_XDECREF(item);</span><br><span class="line">    item = PyUnicode_FromString(<span class="string">&quot;hello matsuri&quot;</span>);</span><br><span class="line">    PyList_Append(lst1, item);</span><br><span class="line">    Py_XDECREF(item);</span><br><span class="line">    <span class="comment">// 这里将 GIL 释放掉</span></span><br><span class="line">    PyGILState_Release(gstate);</span><br><span class="line">    <span class="comment">// 然后下面就不可以再有任何 Python / C API 的出现了</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyObject* <span class="title function_">test_gil</span><span class="params">(PyObject *self, PyObject *args)</span>&#123;</span><br><span class="line">    PyObject *lst = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (!PyArg_ParseTuple(args, <span class="string">&quot;O!&quot;</span>, &amp;PyList_Type, &amp;lst))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="type">int</span> res = pthread_create(&amp;tid, <span class="literal">NULL</span>, test, (<span class="type">void</span> *)lst);</span><br><span class="line">    <span class="keyword">if</span> (res != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_create error: error_code = %d\n&quot;</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Py_None;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyMethodDef methods[] = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;test_gil&quot;</span>, (PyCFunction) test_gil, METH_VARARGS, <span class="string">&quot;this is a function named test_gil&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyModuleDef module = &#123;</span><br><span class="line">    PyModuleDef_HEAD_INIT,</span><br><span class="line">    <span class="string">&quot;kagura_nana&quot;</span>,</span><br><span class="line">    <span class="string">&quot;this is a module named hanser&quot;</span>,</span><br><span class="line">    <span class="number">-1</span>,</span><br><span class="line">    methods,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PyMODINIT_FUNC</span><br><span class="line"><span class="title function_">PyInit_kagura_nana</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    PyObject *m = PyModule_Create(&amp;module);</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>然后我们再来测试一下：</strong></p>
<p><img src="/2023/04/26/31-Python-%E5%92%8C-C-C-%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/1229382-20210212015537923-320854250.png" alt="img"></p>
<p><strong>我们看到此时就没有任何问题了，当 C 中的线程将 GIL  给释放掉之后，此时它和 Python 线程就没有关系了，它就是 C 的线程。那么下面可以写纯 C &#x2F; C++  代码，此时可以实现并行执行。但是能不用多线程就不用多线程，因为多线程出现 bug 之后难以调试。</strong></p>
<p><strong>另外我们目前是在 C 中创建的 Python 线程，但是很明显这需要你对 C 的多线程理解有一定要求。那么我也可以不在 C 中创建，而是在 Python 中创建子线程去调用。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Python.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyObject* <span class="title function_">test_gil</span><span class="params">(PyObject *self, PyObject *args)</span>&#123;</span><br><span class="line">    PyObject *lst = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (!PyArg_ParseTuple(args, <span class="string">&quot;O!&quot;</span>, &amp;PyList_Type, &amp;lst))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此时该函数要被 Python 的子线程进行调用，但是很明显默认还是受到 GIL 的限制的</span></span><br><span class="line">    Py_BEGIN_ALLOW_THREADS  <span class="comment">// 释放掉 GIL，此时调用该函数的 Python 线程将不再受到解释器的制约，从而实现并行执行</span></span><br><span class="line">    <span class="comment">// 但是很明显，这里面不可以有任何的 Python / C API 调用</span></span><br><span class="line">    <span class="type">long</span> a;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) a ++;  <span class="comment">// 不停的对 a 进行自增，显然程序会一直卡在这里</span></span><br><span class="line">    Py_END_ALLOW_THREADS  <span class="comment">// 获取 GIL，此时会回到解释器的线程调度中</span></span><br><span class="line">    <span class="comment">// 下面就可以包含 Python 逻辑了，如果再遇到纯 C / C++ 逻辑，那么就再通过这两个宏继续实现并行</span></span><br><span class="line">    <span class="comment">// 当然为了演示，我们上面是个死循环</span></span><br><span class="line">    <span class="keyword">return</span> Py_None;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyMethodDef methods[] = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;test_gil&quot;</span>, (PyCFunction) test_gil, METH_VARARGS, <span class="string">&quot;this is a function named test_gil&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyModuleDef module = &#123;</span><br><span class="line">    PyModuleDef_HEAD_INIT,</span><br><span class="line">    <span class="string">&quot;kagura_nana&quot;</span>,</span><br><span class="line">    <span class="string">&quot;this is a module named hanser&quot;</span>,</span><br><span class="line">    <span class="number">-1</span>,</span><br><span class="line">    methods,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PyMODINIT_FUNC</span><br><span class="line"><span class="title function_">PyInit_kagura_nana</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    PyObject *m = PyModule_Create(&amp;module);</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>然后我们在 Python 中创建子线程去调用：</strong></p>
<p><img src="/2023/04/26/31-Python-%E5%92%8C-C-C-%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/1229382-20210212015548684-835884103.png" alt="img"></p>
<p><strong>我们开启了一个子线程，去调用扩展模块中的函数，然后主线程也写了一个死循环。下面看一下 CPU 的使用率：</strong></p>
<p><img src="/2023/04/26/31-Python-%E5%92%8C-C-C-%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/1229382-20210212015553378-2039892645.png" alt="img"></p>
<p><strong>我们看到成功利用了多核，此时我们就通过编写扩展的方式来绕过了解释器中 GIL 的限制。</strong></p>
<p><strong>所以对于一些 C &#x2F; C++ 逻辑，它们不需要和 Python  进行所谓的交互，那么我们就可以把 GIL 释放掉。因为 GIL 本来就是为了保护 Python 中的对象的，为了内存管理，CPython  的开发人员为了直接在解释器上面加上了一把超级大锁，但是当我们不需要和 Python 对象进行交互的时候，就可以把 GIL 给释放掉。</strong></p>
<blockquote>
<p><strong>GIL 是字节码级别互斥锁，当线程执行字节码的时候，如果自身已经获取到  GIL ，那么会判断是否有释放的 GIL 的请求（gil_drop_request）：有则释放、将 CPU  使用权交给其它线程，没有则直接执行字节码；如果自身没有获取到 GIL，那么会先判断 GIL  是否被别的线程获取，若被别的线程获取就一直申请、没有则拿到 GIL 执行字节码。</strong></p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>这一次我们聊了聊 Python 和 C&#x2F;C++ 联合编程，我们可以在  Python 中引入 C&#x2F;C++，也可以在 C&#x2F;C++ 中引入 Python，甚至还可以定制 Python 解释器。只不过笔者是主 Python 的，因此在 C&#x2F;C++ 中引入 Python 就不说了。</strong></p>
<p><strong>Python 引入 C&#x2F;C++ 主要是通过编写扩展的方式，这真的是一件痛苦的事情，需要你对 Python &#x2F; C API 有很深的了解，最后仍然安利一波 Cython。</strong></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Lin Li</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/04/26/31-Python-%E5%92%8C-C-C-%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/">http://example.com/2023/04/26/31-Python-%E5%92%8C-C-C-%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">LinLi's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/CPython/">CPython</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/04/26/32-Python-%E5%92%8C-Go-%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B/" title="32-Python 和 Go 联合编程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">32-Python 和 Go 联合编程</div></div></a></div><div class="next-post pull-right"><a href="/2023/04/26/30-%E6%BA%90%E7%A0%81%E8%A7%A3%E5%AF%86%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0-iter%E3%80%81next/" title="30-源码解密内置函数 iter、next"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">30-源码解密内置函数 iter、next</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/03/29/01-%E7%BC%96%E8%AF%91Cpython/" title="01-编译Cpython"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">01-编译Cpython</div></div></a></div><div><a href="/2023/03/29/02-%E4%B8%80%E5%88%87%E5%AF%B9%E8%B1%A1%E7%9A%86PyObject/" title="02-一切对象皆PyObject"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">02-一切对象皆PyObject</div></div></a></div><div><a href="/2023/03/29/04-%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/" title="04-浮点数的底层实现"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">04-浮点数的底层实现</div></div></a></div><div><a href="/2023/03/29/06-Bytes%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BA%95%E5%B1%82%E6%93%8D%E4%BD%9C/" title="06-Bytes对象的底层操作"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">06-Bytes对象的底层操作</div></div></a></div><div><a href="/2023/03/29/03-Python%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E5%99%A8%E5%92%8C%E5%BA%95%E5%B1%82%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86/" title="03-Python引用计数器和底层对象管理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">03-Python引用计数器和底层对象管理</div></div></a></div><div><a href="/2023/03/29/05-Python%E6%95%B4%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/" title="05-Python整数的底层实现"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">05-Python整数的底层实现</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Lin Li</div><div class="author-info__description">今日事，今日毕</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">95</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#31-Python-%E5%92%8C-C-x2F-C-%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">31-Python 和 C &#x2F; C++ 联合编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A5%94%E5%AD%90"><span class="toc-number">1.1.</span> <span class="toc-text">楔子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87"><span class="toc-number">1.2.</span> <span class="toc-text">环境准备</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Python-ctypes-%E6%A8%A1%E5%9D%97%E8%B0%83%E7%94%A8-C-x2F-C-%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93"><span class="toc-number">1.3.</span> <span class="toc-text">Python ctypes 模块调用 C &#x2F; C++ 动态链接库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BE%E4%B8%AA%E5%B0%8F%E6%A0%97%E5%AD%90"><span class="toc-number">1.3.1.</span> <span class="toc-text">举个小栗子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Python-%E7%B1%BB%E5%9E%8B%E4%B8%8E-C-%E8%AF%AD%E8%A8%80%E7%B1%BB%E5%9E%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.3.2.</span> <span class="toc-text">Python 类型与 C 语言类型之间的转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">数值类型转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E3%80%81%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">字符类型转换、指针类型转换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="toc-number">1.3.3.</span> <span class="toc-text">参数传递</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E9%80%92%E5%8F%AF%E5%8F%98%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.3.4.</span> <span class="toc-text">传递可变的字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BA%93%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.5.</span> <span class="toc-text">调用操作系统的库函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E7%AA%97%E4%BD%93%E5%92%8C%E9%9A%90%E8%97%8F%E7%AA%97%E4%BD%93"><span class="toc-number">1.3.5.1.</span> <span class="toc-text">显示窗体和隐藏窗体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E7%AA%97%E4%BD%93%E7%9A%84%E4%BD%8D%E7%BD%AE%E5%92%8C%E5%A4%A7%E5%B0%8F"><span class="toc-number">1.3.5.2.</span> <span class="toc-text">控制窗体的位置和大小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E9%9F%B3%E6%92%AD%E6%94%BE"><span class="toc-number">1.3.5.3.</span> <span class="toc-text">语音播放</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ctypes-%E8%8E%B7%E5%8F%96%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">1.3.6.</span> <span class="toc-text">ctypes 获取返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ctypes-%E7%BB%99%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E4%BC%A0%E9%80%92%E6%8C%87%E9%92%88"><span class="toc-number">1.3.7.</span> <span class="toc-text">ctypes 给动态链接库中的函数传递指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ctypes-byref-%E5%92%8C-ctypes-pointer-%E5%88%9B%E5%BB%BA%E6%8C%87%E9%92%88"><span class="toc-number">1.3.7.1.</span> <span class="toc-text">ctypes.byref 和 ctypes.pointer 创建指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E9%80%92%E6%8C%87%E9%92%88"><span class="toc-number">1.3.7.2.</span> <span class="toc-text">传递指针</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.8.</span> <span class="toc-text">声明类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E9%80%92%E6%95%B0%E7%BB%84"><span class="toc-number">1.3.9.</span> <span class="toc-text">传递数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E9%80%92%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">1.3.10.</span> <span class="toc-text">传递结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.11.</span> <span class="toc-text">回调函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-C-x2F-C-%E4%B8%BA-Python-%E5%BC%80%E5%8F%91%E6%89%A9%E5%B1%95%E6%A8%A1%E5%9D%97"><span class="toc-number">1.4.</span> <span class="toc-text">使用 C &#x2F; C++ 为 Python 开发扩展模块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E5%86%99%E6%89%A9%E5%B1%95%E6%A8%A1%E5%9D%97%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%AA%A8%E6%9E%B6"><span class="toc-number">1.4.1.</span> <span class="toc-text">编写扩展模块的基本骨架</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#PyMethodDef"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">PyMethodDef</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E5%92%8C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">1.4.2.</span> <span class="toc-text">引用计数和内存管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E7%9A%84%E8%A7%A3%E6%9E%90"><span class="toc-number">1.4.3.</span> <span class="toc-text">参数的解析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90%E5%A4%9A%E4%B8%AA%E4%BD%8D%E7%BD%AE%E5%8F%82%E6%95%B0"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">解析多个位置参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90%E6%88%90-PyObject"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">解析成 PyObject *</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E9%80%92%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.4.3.3.</span> <span class="toc-text">传递字符串</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5%E5%92%8C%E8%BF%94%E5%9B%9E%E5%BC%82%E5%B8%B8"><span class="toc-number">1.4.4.</span> <span class="toc-text">类型检查和返回异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B%E5%92%8C-None"><span class="toc-number">1.4.5.</span> <span class="toc-text">返回布尔类型和 None</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E9%80%92%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%82%E6%95%B0"><span class="toc-number">1.4.6.</span> <span class="toc-text">传递关键字参数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%A0%E4%BD%8D%E7%AC%A6"><span class="toc-number">1.4.6.1.</span> <span class="toc-text">占位符 :</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%A0%E4%BD%8D%E7%AC%A6-1"><span class="toc-number">1.4.6.2.</span> <span class="toc-text">占位符 !</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%A0%E4%BD%8D%E7%AC%A6-amp"><span class="toc-number">1.4.6.3.</span> <span class="toc-text">占位符 &amp;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%A0%E4%BD%8D%E7%AC%A6-2"><span class="toc-number">1.4.6.4.</span> <span class="toc-text">占位符 ;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%A0%E4%BD%8D%E7%AC%A6-3"><span class="toc-number">1.4.6.5.</span> <span class="toc-text">占位符 $</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%A0%E4%BD%8D%E7%AC%A6-4"><span class="toc-number">1.4.6.6.</span> <span class="toc-text">占位符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Py-BuildValue"><span class="toc-number">1.4.7.</span> <span class="toc-text">Py_BuildValue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C-PyDictObject"><span class="toc-number">1.4.8.</span> <span class="toc-text">操作 PyDictObject</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#PyDictObject-%E7%9A%84%E8%AF%BB%E5%8F%96"><span class="toc-number">1.4.8.1.</span> <span class="toc-text">PyDictObject 的读取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PyDictObject-%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">1.4.8.2.</span> <span class="toc-text">PyDictObject 的遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PyDictObject-%E7%9A%84%E8%AE%BE%E7%BD%AE%E5%92%8C%E5%88%A0%E9%99%A4"><span class="toc-number">1.4.8.3.</span> <span class="toc-text">PyDictObject 的设置和删除</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E5%86%99%E6%89%A9%E5%B1%95%E7%B1%BB"><span class="toc-number">1.5.</span> <span class="toc-text">编写扩展类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E5%86%99%E6%89%A9%E5%B1%95%E7%B1%BB%E5%89%8D%E5%A5%8F%E6%9B%B2"><span class="toc-number">1.5.1.</span> <span class="toc-text">编写扩展类前奏曲</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%99%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7"><span class="toc-number">1.5.2.</span> <span class="toc-text">给实例对象添加属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%99%E7%B1%BB%E6%B7%BB%E5%8A%A0%E6%88%90%E5%91%98"><span class="toc-number">1.5.3.</span> <span class="toc-text">给类添加成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E9%80%A0%E6%88%90%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-number">1.5.4.</span> <span class="toc-text">循环引用造成的内存泄漏</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E8%A7%A3%E9%87%8A%E5%99%A8%E9%94%81"><span class="toc-number">1.6.</span> <span class="toc-text">全局解释器锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.7.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/17/Movery-A-Precise-Approach-for-Modified-Vulnerable-Code-Clone-Discovery-from-Modified-Open-Source-Software-Components/" title="Movery A Precise Approach for Modified Vulnerable Code Clone Discovery from Modified Open-Source Software Components">Movery A Precise Approach for Modified Vulnerable Code Clone Discovery from Modified Open-Source Software Components</a><time datetime="2024-08-17T14:09:41.000Z" title="发表于 2024-08-17 22:09:41">2024-08-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/30/Translating-between-SQL-Dialects-for-Cloud-Migration/" title="Translating between SQL Dialects for Cloud Migration">Translating between SQL Dialects for Cloud Migration</a><time datetime="2024-07-30T07:48:40.000Z" title="发表于 2024-07-30 15:48:40">2024-07-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/30/Mallet-SQL-Dialect-Translation-with-LLM-Rule-Generation/" title="Mallet: SQL Dialect Translation with LLM Rule Generation">Mallet: SQL Dialect Translation with LLM Rule Generation</a><time datetime="2024-07-30T07:47:16.000Z" title="发表于 2024-07-30 15:47:16">2024-07-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/11/Keep-It-Simple-Testing-Databases-via-Differential-Query-Plans/" title="Keep It Simple: Testing Databases via Differential Query Plans">Keep It Simple: Testing Databases via Differential Query Plans</a><time datetime="2024-07-11T03:23:01.000Z" title="发表于 2024-07-11 11:23:01">2024-07-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/08/WINGFUZZ-Implementing-Continuous-Fuzzing-for-DBMSs/" title="WINGFUZZ: Implementing Continuous Fuzzing for DBMSs">WINGFUZZ: Implementing Continuous Fuzzing for DBMSs</a><time datetime="2024-07-08T05:48:21.000Z" title="发表于 2024-07-08 13:48:21">2024-07-08</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Lin Li</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>