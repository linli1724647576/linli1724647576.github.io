<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>13-剖析Python的流程控制语句 | LinLi's Blog</title><meta name="author" content="Lin Li"><meta name="copyright" content="Lin Li"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="13-剖析Python的流程控制语句（if、for、while），以及异常捕获机制楔子在上一章中，我们介绍了Python虚拟机中常见的字节码指令。但我们的流程都是从上往下顺序执行的，在执行的过程中没有任何变化，但是显然这是不够的，因为怎么能没有流程控制呢。下面我们来看看Python所提供的流程控制手段，其中也包括异常检测机制。 Python虚拟机中的if控制流if字节码if语句算是最简单也是最常用">
<meta property="og:type" content="article">
<meta property="og:title" content="13-剖析Python的流程控制语句">
<meta property="og:url" content="http://example.com/2023/04/02/13-%E5%89%96%E6%9E%90Python%E7%9A%84%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/index.html">
<meta property="og:site_name" content="LinLi&#39;s Blog">
<meta property="og:description" content="13-剖析Python的流程控制语句（if、for、while），以及异常捕获机制楔子在上一章中，我们介绍了Python虚拟机中常见的字节码指令。但我们的流程都是从上往下顺序执行的，在执行的过程中没有任何变化，但是显然这是不够的，因为怎么能没有流程控制呢。下面我们来看看Python所提供的流程控制手段，其中也包括异常检测机制。 Python虚拟机中的if控制流if字节码if语句算是最简单也是最常用">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2023-04-02T08:17:05.000Z">
<meta property="article:modified_time" content="2023-04-12T02:38:22.369Z">
<meta property="article:author" content="Lin Li">
<meta property="article:tag" content="CPython">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/04/02/13-%E5%89%96%E6%9E%90Python%E7%9A%84%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '13-剖析Python的流程控制语句',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-04-12 10:38:22'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">63</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="LinLi's Blog"><span class="site-name">LinLi's Blog</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">13-剖析Python的流程控制语句</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-04-02T08:17:05.000Z" title="发表于 2023-04-02 16:17:05">2023-04-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-04-12T02:38:22.369Z" title="更新于 2023-04-12 10:38:22">2023-04-12</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="13-剖析Python的流程控制语句"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="13-剖析Python的流程控制语句（if、for、while），以及异常捕获机制"><a href="#13-剖析Python的流程控制语句（if、for、while），以及异常捕获机制" class="headerlink" title="13-剖析Python的流程控制语句（if、for、while），以及异常捕获机制"></a>13-剖析Python的流程控制语句（if、for、while），以及异常捕获机制</h2><h3 id="楔子"><a href="#楔子" class="headerlink" title="楔子"></a>楔子</h3><p><strong>在上一章中，我们介绍了Python虚拟机中常见的字节码指令。但我们的流程都是从上往下顺序执行的，在执行的过程中没有任何变化，但是显然这是不够的，因为怎么能没有流程控制呢。下面我们来看看Python所提供的流程控制手段，其中也包括异常检测机制。</strong></p>
<h3 id="Python虚拟机中的if控制流"><a href="#Python虚拟机中的if控制流" class="headerlink" title="Python虚拟机中的if控制流"></a>Python虚拟机中的if控制流</h3><h4 id="if字节码"><a href="#if字节码" class="headerlink" title="if字节码"></a>if字节码</h4><p><strong>if语句算是最简单也是最常用的控制流语句，那么它的字节码是怎么样的呢？当然我们这里的if语句指的是if、elif、elif…、else整体，里面的if、某个elif或者else叫做该if语句的分支。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">gender = &quot;男&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">if gender == &quot;男&quot;:</span></span><br><span class="line"><span class="string">    print(&quot;nice muscle&quot;)</span></span><br><span class="line"><span class="string">elif gender == &quot;女&quot;:</span></span><br><span class="line"><span class="string">    print(&quot;白い肌&quot;)</span></span><br><span class="line"><span class="string">else:</span></span><br><span class="line"><span class="string">    print(&quot;秀吉&quot;)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">import</span> dis</span><br><span class="line">    dis.dis(<span class="built_in">compile</span>(s, <span class="string">&quot;man&quot;</span>, <span class="string">&quot;exec&quot;</span>))</span><br></pre></td></tr></table></figure>

<p><strong>反编译得到的字节码指令比较多，我们来慢慢分析。</strong></p>
<blockquote>
<p><strong>注意：到了现在，相信对字节码指令都已经熟悉了，因此之前说过的指令我们就不详细展开说了，只会简单提一下。</strong></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>           <span class="number">0</span> LOAD_CONST               <span class="number">0</span> (<span class="string">&#x27;男&#x27;</span>) <span class="comment">//加载字符串常量</span></span><br><span class="line">            <span class="number">2</span> STORE_NAME               <span class="number">0</span> (gender)<span class="comment">//建立符号和对象的映射关系</span></span><br><span class="line"></span><br><span class="line"><span class="number">4</span>           <span class="number">4</span> LOAD_NAME                <span class="number">0</span> (gender)<span class="comment">//加载变量gender</span></span><br><span class="line">            <span class="number">6</span> LOAD_CONST               <span class="number">0</span> (<span class="string">&#x27;男&#x27;</span>)<span class="comment">//加载字符串常量</span></span><br><span class="line">            <span class="number">8</span> COMPARE_OP               <span class="number">2</span> (==)<span class="comment">//将gender和&quot;男&quot;进行==操作</span></span><br><span class="line">           <span class="number">10</span> POP_JUMP_IF_FALSE       <span class="number">22</span><span class="comment">//这里的22表示如果为False, 就跳转到字节码偏移量、或者字节码的索引为22的地方</span></span><br><span class="line">    					  <span class="comment">//显然是下面的22 LOAD_NAME 0 (gender), 即：该if下面的elif</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span>          <span class="number">12</span> LOAD_NAME                <span class="number">1</span> (print) <span class="comment">//如果gender == &quot;男&quot;成立, 那么不会跳转, 直接往下执行, 加载符号print</span></span><br><span class="line">           <span class="number">14</span> LOAD_CONST               <span class="number">1</span> (<span class="string">&#x27;nice muscle&#x27;</span>)<span class="comment">//加载字符串常量</span></span><br><span class="line">           <span class="number">16</span> CALL_FUNCTION            <span class="number">1</span><span class="comment">//函数调用</span></span><br><span class="line">           <span class="number">18</span> POP_TOP	<span class="comment">//将函数返回值从栈顶弹出去</span></span><br><span class="line">           <span class="number">20</span> JUMP_FORWARD            <span class="number">26</span> (to <span class="number">48</span>)<span class="comment">//if语句只会执行一个分支, 一旦执行了某个分支, 整个if语句就结束了</span></span><br><span class="line">    					          <span class="comment">//所以跳转到字节码偏移量为48的位置, 这里的22就表示相对于当前位置向前跳转了多少</span></span><br><span class="line"></span><br><span class="line"><span class="number">6</span>     &gt;&gt;   <span class="number">22</span> LOAD_NAME                <span class="number">0</span> (gender) <span class="comment">//显然这是elif的分支, 加载变量gender</span></span><br><span class="line">           <span class="number">24</span> LOAD_CONST               <span class="number">2</span> (<span class="string">&#x27;女&#x27;</span>)<span class="comment">//加载字符串常量&quot;女&quot;</span></span><br><span class="line">           <span class="number">26</span> COMPARE_OP               <span class="number">2</span> (==)<span class="comment">//将gender和&quot;女&quot;进行==判断</span></span><br><span class="line">           <span class="number">28</span> POP_JUMP_IF_FALSE       <span class="number">40</span><span class="comment">//如果不成立就跳转到字节码偏移量为40的地方, 显然是elif下面的else</span></span><br><span class="line">    					  <span class="comment">//如果elif下面还有elif, 那么就跳转到下一个elif, 总之就是一个分支一个分支的往下跳转</span></span><br><span class="line"></span><br><span class="line"><span class="number">7</span>          <span class="number">30</span> LOAD_NAME                <span class="number">1</span> (print)<span class="comment">//走到这里说明gender == &quot;女&quot;成立, 加载变量print</span></span><br><span class="line">           <span class="number">32</span> LOAD_CONST               <span class="number">3</span> (<span class="string">&#x27;白い肌&#x27;</span>)<span class="comment">//加载字符串常量&quot;白い肌&quot;</span></span><br><span class="line">           <span class="number">34</span> CALL_FUNCTION            <span class="number">1</span><span class="comment">//函数调用, 参数为1个</span></span><br><span class="line">           <span class="number">36</span> POP_TOP<span class="comment">//将函数返回值从栈顶弹出去</span></span><br><span class="line">           <span class="number">38</span> JUMP_FORWARD             <span class="number">8</span> (to <span class="number">48</span>)<span class="comment">//整个if语句结束, 还是跳转到字节码偏移量为48的位置</span></span><br><span class="line">    						  <span class="comment">//这里参数是8, 所以if的跳转是采用相对跳跃, 分支不同跳跃的指令数也不同</span></span><br><span class="line"></span><br><span class="line"><span class="number">9</span>     &gt;&gt;   <span class="number">40</span> LOAD_NAME                <span class="number">1</span> (print) <span class="comment">//走到这里说明执行的是else分支, 加载符号print</span></span><br><span class="line">           <span class="number">42</span> LOAD_CONST               <span class="number">4</span> (<span class="string">&#x27;秀吉&#x27;</span>)<span class="comment">//加载字符串常量&quot;秀吉&quot;</span></span><br><span class="line">           <span class="number">44</span> CALL_FUNCTION            <span class="number">1</span><span class="comment">//函数调用</span></span><br><span class="line">           <span class="number">46</span> POP_TOP<span class="comment">//将函数返回值从栈顶弹出去,如果是执行else分支并且执行完毕, 显然就不需要再跳转了,</span></span><br><span class="line">    		       <span class="comment">//因为else分支位于整个if语句的最后面</span></span><br><span class="line">    </span><br><span class="line">      &gt;&gt;   <span class="number">48</span> LOAD_CONST               <span class="number">5</span> (None)<span class="comment">//这里便是整个if语句结束后的第一条指令, 加载常量None</span></span><br><span class="line">           <span class="number">50</span> RETURN_VALUE<span class="comment">//返回</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看到字节码中 “源代码行号” 和 “字节码偏移量” 之间有几个<code>&gt;&gt;</code>这样的符号，这是什么呢？仔细看一下应该就知道，这显然就是if语句中的每一个分支开始的地方，当然最后的<code>&gt;&gt;</code>是返回值。</strong></p>
<p><strong>但是经过分析，我们发现整个if语句的字节码指令还是很简单的。从上到下执行分支，如果某个分支成立，就执行该分支的代码，执行完毕后直接跳转到整个if语句下面的第一条指令；分支不成立那么就跳转到下一个分支。</strong></p>
<p><strong>核心指令就在于COMPARE_OP、POP_JUMP_IF_FALSE和JUMP_FORWARD，从结构上我们不难分析：</strong></p>
<ul>
<li><code>COMPARE_OP: 进行比较操作</code></li>
<li><code>POP_JUMP_IF_FALSE: 跳转到下一个分支</code></li>
<li><code>JUMP_FORWARD:跳转到整个if语句结束后的第一条指令</code></li>
</ul>
<p>​        <strong>我们首先分析COMPARE_OP，我们看到COMPARE_OP后面也是有参数的，比如 8 COMPARE_OP               2  (&#x3D;&#x3D;)，显然oparg<code>(字节码指令参数)</code>就是2，那么这个2代表啥呢？其实想都不用想，肯定代表的是&#x3D;&#x3D;，因为都已经告诉我们了。</strong>    </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// object.h</span></span><br><span class="line"><span class="comment">/* Rich comparison opcodes */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Py_LT 0 <span class="comment">//小于</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Py_LE 1 <span class="comment">//小于等于</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Py_EQ 2 <span class="comment">//等于</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Py_NE 3 <span class="comment">//不等于</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Py_GT 4 <span class="comment">//大于</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Py_GE 5 <span class="comment">//大于等于</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//opcode.h</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">cmp_op</span> &#123;</span>PyCmp_LT=Py_LT, PyCmp_LE=Py_LE, PyCmp_EQ=Py_EQ, PyCmp_NE=Py_NE,</span><br><span class="line">                PyCmp_GT=Py_GT, PyCmp_GE=Py_GE, PyCmp_IN, PyCmp_NOT_IN,</span><br><span class="line">                PyCmp_IS, PyCmp_IS_NOT, PyCmp_EXC_MATCH, PyCmp_BAD&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>下面我们来看看，虚拟机中是如何进行比较操作的。另外本章中如果没有指定源码位置，那么默认是在Python&#x2F;ceval.c里面</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">cmp_outcome</span><span class="params">(<span class="type">int</span> op, PyObject *v, PyObject *w)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">    <span class="comment">//python中的is, 在C的层面直接判断两个指针是否相等即可        </span></span><br><span class="line">    <span class="keyword">case</span> PyCmp_IS:</span><br><span class="line">        res = (v == w);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">//python中的is not, , 在C的层面直接判断两个指针是否不相等即可    </span></span><br><span class="line">    <span class="keyword">case</span> PyCmp_IS_NOT:</span><br><span class="line">        res = (v != w);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">//python中的in, 调用PySequence_Contains</span></span><br><span class="line">    <span class="keyword">case</span> PyCmp_IN:</span><br><span class="line">        res = PySequence_Contains(w, v);</span><br><span class="line">        <span class="keyword">if</span> (res &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">//python中的not in, 调用PySequence_Contains再取反        </span></span><br><span class="line">    <span class="keyword">case</span> PyCmp_NOT_IN:</span><br><span class="line">        res = PySequence_Contains(w, v);</span><br><span class="line">        <span class="keyword">if</span> (res &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        res = !res;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">//python中的异常      </span></span><br><span class="line">    <span class="keyword">case</span> PyCmp_EXC_MATCH:</span><br><span class="line">        <span class="comment">//这里判断给定的类是不是异常类, 比如我们肯定不能except int as e, 异常类一定要继承BaseException</span></span><br><span class="line">        <span class="comment">//如果是元组的话, 那么元组里面都要是异常类</span></span><br><span class="line">        <span class="keyword">if</span> (PyTuple_Check(w)) &#123;</span><br><span class="line">            Py_ssize_t i, length;</span><br><span class="line">            length = PyTuple_Size(w);</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i += <span class="number">1</span>) &#123;</span><br><span class="line">                PyObject *exc = PyTuple_GET_ITEM(w, i);</span><br><span class="line">                <span class="keyword">if</span> (!PyExceptionClass_Check(exc)) &#123;</span><br><span class="line">                    PyErr_SetString(PyExc_TypeError,</span><br><span class="line">                                    CANNOT_CATCH_MSG);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!PyExceptionClass_Check(w)) &#123;</span><br><span class="line">                PyErr_SetString(PyExc_TypeError,</span><br><span class="line">                                CANNOT_CATCH_MSG);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断指定的异常能否捕获相应的错误</span></span><br><span class="line">        res = PyErr_GivenExceptionMatches(v, w);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">//然后进行比较操作, 传入两个对象以及操作符, 即上面的Py_LT、Py_LE...之一</span></span><br><span class="line">        <span class="keyword">return</span> PyObject_RichCompare(v, w, op);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Py_True和Py_False就相当于Python中的True和False, 本质上是一个PyLongObject</span></span><br><span class="line">    <span class="comment">//根据res的结果返回True和False</span></span><br><span class="line">    v = res ? Py_True : Py_False;</span><br><span class="line">    Py_INCREF(v);</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>里面的比较函数PyObject_RichCompare很重要，我们来看一下，该函数位于Object&#x2F;object.c中。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先有一个PyObject_RichCompareBool, 它是用来判断两个对象是否相等或不等的</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">PyObject_RichCompareBool</span><span class="params">(PyObject *v, PyObject *w, <span class="type">int</span> op)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyObject *res;</span><br><span class="line">    <span class="type">int</span> ok;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果v和w相等的话, 说明这两个变量指向同一个对象</span></span><br><span class="line">    <span class="keyword">if</span> (v == w) &#123;</span><br><span class="line">        <span class="comment">//那么如果op是==, 显然返回True</span></span><br><span class="line">        <span class="keyword">if</span> (op == Py_EQ)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//如果op是!=, 显然返回False</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == Py_NE)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//可能有人问如果我们重写了__eq__怎么办? 所以这个方法只适用于内建的类的实例对象</span></span><br><span class="line">    <span class="comment">//如果是我们自定义的类会直接调用这里的PyObject_RichCompare</span></span><br><span class="line">    <span class="comment">//另外我们看到即便是内置的类的实例对象, 如果两个对象不相等, 或者相等、但是op不是==和!=的时候也会走这里的PyObject_RichCompare</span></span><br><span class="line">    res = PyObject_RichCompare(v, w, op);</span><br><span class="line">    <span class="comment">//通过PyObject_RichCompare进行比较</span></span><br><span class="line">    <span class="keyword">if</span> (res == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//如果返回的是布尔值, 那么判断是否和Py_True相等, 返回的是True那么比较的结果也是True, 否则是False</span></span><br><span class="line">    <span class="keyword">if</span> (PyBool_Check(res))</span><br><span class="line">        ok = (res == Py_True);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//返回的不是布尔值, 那么调用PyObject_IsTrue, 显然这相当于Python中的bool(res)</span></span><br><span class="line">        <span class="comment">//不是0的整数、长度不为0的字符串、元组、列表等等也是True</span></span><br><span class="line">        ok = PyObject_IsTrue(res);</span><br><span class="line">    Py_DECREF(res);</span><br><span class="line">    <span class="comment">//返回</span></span><br><span class="line">    <span class="keyword">return</span> ok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//重点来了, 我们来看看PyObject_RichCompare</span></span><br><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyObject_RichCompare</span><span class="params">(PyObject *v, PyObject *w, <span class="type">int</span> op)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyObject *res;</span><br><span class="line">    <span class="comment">//首先会对op进行判断, 要确保Py_LT &lt;= op &lt;= Py_GE, 即0 &lt;= op &lt;= 5, 要保证op是几个操作符中的一个</span></span><br><span class="line">    assert(Py_LT &lt;= op &amp;&amp; op &lt;= Py_GE);</span><br><span class="line">    <span class="comment">//首先v和w不能是C的空指针, 要确保它们都指向一个具体的PyObject, 但是说实话底层的这些检测我们在Python的层面基本不会遇到</span></span><br><span class="line">    <span class="keyword">if</span> (v == <span class="literal">NULL</span> || w == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!PyErr_Occurred())</span><br><span class="line">            PyErr_BadInternalCall();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//所以核心是下面的do_richcompare, 但是在do_richcompare之前我们看到这里调用了Py_EnterRecursiveCall</span></span><br><span class="line">    <span class="comment">//这和函数和递归有关, 比如我们在__eq__中又对self使用了==, 那么会不断调用__eq__, 这是会无限递归的</span></span><br><span class="line">    <span class="keyword">if</span> (Py_EnterRecursiveCall(<span class="string">&quot; in comparison&quot;</span>))</span><br><span class="line">        <span class="comment">//所以Py_EnterRecursiveCall是让解释器追踪递归的深度的</span></span><br><span class="line">	    <span class="comment">//如果递归层数过多, 超过了指定限制(默认是999, 可以通过sys.getrecursionlimit()查看), 那么能够及时抛出异常, 从递归中摆脱出来</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用do_richcompare, 还是这三个参数, 得到比较的结果</span></span><br><span class="line">    res = do_richcompare(v, w, op);</span><br><span class="line">    <span class="comment">//离开递归调用</span></span><br><span class="line">    Py_LeaveRecursiveCall();</span><br><span class="line">    <span class="comment">//返回res, 执行PyObject_RichCompareBool中下面的逻辑</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//所以我们看到核心其实是do_richcompare, 我们需要继续往下看</span></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">do_richcompare</span><span class="params">(PyObject *v, PyObject *w, <span class="type">int</span> op)</span></span><br><span class="line">&#123;</span><br><span class="line">    richcmpfunc f; <span class="comment">//富比较函数</span></span><br><span class="line">    PyObject *res; <span class="comment">//比较结果</span></span><br><span class="line">    <span class="type">int</span> checked_reverse_op = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//如果type(v)和type(w)不一样 &amp;&amp; type(w)是type(v)的子类 &amp;&amp; type(w)中定义了tp_richcompare</span></span><br><span class="line">    <span class="keyword">if</span> (v-&gt;ob_type != w-&gt;ob_type &amp;&amp;</span><br><span class="line">        PyType_IsSubtype(w-&gt;ob_type, v-&gt;ob_type) &amp;&amp;</span><br><span class="line">        (f = w-&gt;ob_type-&gt;tp_richcompare) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        checked_reverse_op = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//那么直接调用type(w)的to_richcompare进行比较</span></span><br><span class="line">        res = (*f)(w, v, _Py_SwappedOp[op]);</span><br><span class="line">        <span class="keyword">if</span> (res != Py_NotImplemented)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        Py_DECREF(res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//type(v)和type(w)不同, 或者 type(w) 不是 type(v) 的子类, 或者type(w)中没有定义tp_richcompare</span></span><br><span class="line">    <span class="comment">//如果type(v)定义了tp_richcompare</span></span><br><span class="line">    <span class="keyword">if</span> ((f = v-&gt;ob_type-&gt;tp_richcompare) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//调用type(v)的tp_richcompare方法</span></span><br><span class="line">        res = (*f)(v, w, op);</span><br><span class="line">        <span class="keyword">if</span> (res != Py_NotImplemented)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        Py_DECREF(res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//type(w) 不是 type(v) 的子类 &amp;&amp; type(v)中没有定义tp_richcompare &amp;&amp; type(w)中定义了tp_richcompare</span></span><br><span class="line">    <span class="keyword">if</span> (!checked_reverse_op &amp;&amp; (f = w-&gt;ob_type-&gt;tp_richcompare) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//那么执行w的tp_richcompare</span></span><br><span class="line">        res = (*f)(w, v, _Py_SwappedOp[op]);</span><br><span class="line">        <span class="keyword">if</span> (res != Py_NotImplemented)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        Py_DECREF(res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//所以以上三种情况就相当于: 如果type(w) 是 type(v) 的子类, 那么优先调用w的tp_richcompare</span></span><br><span class="line">    <span class="comment">//否则，type(v) 和 type(w) 中谁的tp_richcompare不为空就调用谁的</span></span><br><span class="line">    <span class="comment">//如果都没有那么就走下面的逻辑了</span></span><br><span class="line">    <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">    <span class="comment">//直接比较两者是否相等</span></span><br><span class="line">    <span class="keyword">case</span> Py_EQ:</span><br><span class="line">        res = (v == w) ? Py_True : Py_False;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">//比较两者是否不等        </span></span><br><span class="line">    <span class="keyword">case</span> Py_NE:</span><br><span class="line">        res = (v != w) ? Py_True : Py_False;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">//显然此时的两个对象只能判断相等或者不等, 如果是比大小那么显然是报错的, 下面的信息你一定很熟悉</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        PyErr_Format(PyExc_TypeError,</span><br><span class="line">                     <span class="string">&quot;&#x27;%s&#x27; not supported between instances of &#x27;%.100s&#x27; and &#x27;%.100s&#x27;&quot;</span>,</span><br><span class="line">                     opstrings[op],</span><br><span class="line">                     v-&gt;ob_type-&gt;tp_name,</span><br><span class="line">                     w-&gt;ob_type-&gt;tp_name);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Py_INCREF(res);</span><br><span class="line">    <span class="comment">//返回</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>另外，这里面又出现了tp_richcompare，如果我们自定义的类没有重写的话，那么默认调用的是基类object的tp_richcompare，包括内置的类也是调用object的tp_richcompare，有兴趣可以看一下。</strong></p>
<p>​        <strong>然后我们再来看看POP_JUMP_IF_FALSE</strong>    </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>           <span class="number">0</span> LOAD_CONST               <span class="number">0</span> (<span class="string">&#x27;男&#x27;</span>)</span><br><span class="line">            <span class="number">2</span> STORE_NAME               <span class="number">0</span> (gender)</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>           <span class="number">4</span> LOAD_NAME                <span class="number">0</span> (gender)</span><br><span class="line">            <span class="number">6</span> LOAD_CONST               <span class="number">0</span> (<span class="string">&#x27;男&#x27;</span>)</span><br><span class="line">            <span class="number">8</span> COMPARE_OP               <span class="number">2</span> (==)</span><br><span class="line">           <span class="number">10</span> POP_JUMP_IF_FALSE       <span class="number">22</span></span><br><span class="line">    </span><br><span class="line"><span class="number">5</span>          <span class="number">12</span> LOAD_NAME                <span class="number">1</span> (print) </span><br><span class="line">           <span class="number">14</span> LOAD_CONST               <span class="number">1</span> (<span class="string">&#x27;nice muscle&#x27;</span>)</span><br><span class="line">           <span class="number">16</span> CALL_FUNCTION            <span class="number">1</span></span><br><span class="line">           <span class="number">18</span> POP_TOP</span><br><span class="line">           <span class="number">20</span> JUMP_FORWARD            <span class="number">26</span> (to <span class="number">48</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">6</span>     &gt;&gt;   <span class="number">22</span> LOAD_NAME                <span class="number">0</span> (gender) </span><br><span class="line">           <span class="number">24</span> LOAD_CONST               <span class="number">2</span> (<span class="string">&#x27;女&#x27;</span>)</span><br><span class="line">           <span class="number">26</span> COMPARE_OP               <span class="number">2</span> (==)</span><br><span class="line">           <span class="number">28</span> POP_JUMP_IF_FALSE       <span class="number">40</span></span><br><span class="line"></span><br><span class="line"><span class="number">7</span>          <span class="number">30</span> LOAD_NAME                <span class="number">1</span> (print)</span><br><span class="line">           <span class="number">32</span> LOAD_CONST               <span class="number">3</span> (<span class="string">&#x27;白い肌&#x27;</span>)</span><br><span class="line">           <span class="number">34</span> CALL_FUNCTION            <span class="number">1</span></span><br><span class="line">           <span class="number">36</span> POP_TOP</span><br><span class="line">           <span class="number">38</span> JUMP_FORWARD             <span class="number">8</span> (to <span class="number">48</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">9</span>     &gt;&gt;   <span class="number">40</span> LOAD_NAME                <span class="number">1</span> (print) </span><br><span class="line">           <span class="number">42</span> LOAD_CONST               <span class="number">4</span> (<span class="string">&#x27;秀吉&#x27;</span>)</span><br><span class="line">           <span class="number">44</span> CALL_FUNCTION            <span class="number">1</span></span><br><span class="line">           <span class="number">46</span> POP_TOP</span><br><span class="line">    </span><br><span class="line">      &gt;&gt;   <span class="number">48</span> LOAD_CONST               <span class="number">5</span> (None)</span><br><span class="line">           <span class="number">50</span> RETURN_VALUE</span><br></pre></td></tr></table></figure>

<p><strong>我们看一下10 POP_JUMP_IF_FALSE       22这条字节码，这表是if语句不成立，那么会跳转到字节码偏移量为22的位置，所以这里有一个指令跳跃的动作。那么Python虚拟机是如何完成指令跳跃的呢？关键就在于一个名为 *predict* 的宏里面。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined(DYNAMIC_EXECUTION_PROFILE) || USE_COMPUTED_GOTOS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREDICT(op)             <span class="keyword">if</span> (0) goto PRED_##op</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREDICT(op) \</span></span><br><span class="line"><span class="meta">    do&#123; \</span></span><br><span class="line"><span class="meta">        _Py_CODEUNIT word = *next_instr; \</span></span><br><span class="line"><span class="meta">        opcode = _Py_OPCODE(word); \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (opcode == op)&#123; \</span></span><br><span class="line"><span class="meta">            oparg = _Py_OPARG(word); \</span></span><br><span class="line"><span class="meta">            next_instr++; \</span></span><br><span class="line"><span class="meta">            goto PRED_##op; \</span></span><br><span class="line"><span class="meta">        &#125; \</span></span><br><span class="line"><span class="meta">    &#125; while(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREDICTED(op)           PRED_##op:</span></span><br></pre></td></tr></table></figure>

<p><strong>在Python中，有一些字节码指令通常都是按照顺序出现的，通过上一个字节码指令直接预测下一个字节码指令是可能的。比如COMPARE_OP的后面通常都会紧跟着POP_JUMP_IF_TRUE或者POP_JUMP_IF_FALSE，这在上面的字节码中可以很清晰的看到。</strong></p>
<p><strong>为什么要有这样的一个预测功能呢？因为当字节码之间的指令搭配出现的概率非常高时，如果预测成功，能够省去很多无谓的操作，使得执行效率大幅提高。我们可以看到， <code>PREDICTED(POP_JUMP_IF_FALSE);</code>实际上就是检查下一条待处理的字节码是否是POP_JUMP_IF_FALSE。如果是，那么程序会直接跳转到PRED_POP_JUMP_IF_FALSE那里，如果将COMPARE_OP这个宏展开，可以看得更加清晰。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (*next_instr == POP_JUMP_IF_FALSE)</span><br><span class="line">    <span class="keyword">goto</span> PRED_POP_JUMP_IF_FALSE;</span><br><span class="line"><span class="keyword">if</span> (*next_instr == POP_JUMP_IF_TRUE)</span><br><span class="line">    <span class="keyword">goto</span> PRED_POP_JUMP_IF_TRUE</span><br></pre></td></tr></table></figure>

<p><strong>但是问题又来了，PRED_POP_JUMP_IF_TRUE和PRED_POP_JUMP_IF_FALSE这些标识在哪里呢？我们知道指令跳跃的目的是为了绕过一些无谓的操作，直接进入POP_JUMP_IF_TRUE或者POP_JUMP_IF_FALSE指令对应的case语句之前。</strong></p>
<p><strong>首先<code>if gender == &quot;男&quot;</code>这条字节码序列中，存在POP_JUMP_IF_FALSE指令，那么在COMPARE_OP指令的实现代码的最后，将执行<code>goto PRED_POP_JUMP_IF_FALSE;</code>，而显然这句代码要在<code>POP_JUMP_IF_FALSE</code>之前执行。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">PREDICTED(POP_JUMP_IF_FALSE);</span><br><span class="line">TARGET(POP_JUMP_IF_FALSE) &#123;</span><br><span class="line">    <span class="comment">//取出之前比较的结果。</span></span><br><span class="line">    PyObject *cond = POP();</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">    <span class="comment">//比较结果为True，顺序执行</span></span><br><span class="line">    <span class="keyword">if</span> (cond == Py_True) &#123;</span><br><span class="line">        Py_DECREF(cond);</span><br><span class="line">        FAST_DISPATCH();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//比较结果为False，进行跳转</span></span><br><span class="line">    <span class="keyword">if</span> (cond == Py_False) &#123;</span><br><span class="line">        Py_DECREF(cond);</span><br><span class="line">        JUMPTO(oparg);</span><br><span class="line">        FAST_DISPATCH();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//异常检测</span></span><br><span class="line">    err = PyObject_IsTrue(cond);</span><br><span class="line">    Py_DECREF(cond);</span><br><span class="line">    <span class="keyword">if</span> (err &gt; <span class="number">0</span>)</span><br><span class="line">        ;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (err == <span class="number">0</span>)</span><br><span class="line">        JUMPTO(oparg);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们看到这里的调用跳转使用的<code>JUMPTO</code>，在for循环中我们还会见到，这是一个宏。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> JUMPTO(x)       (next_instr = first_instr + (x) / sizeof(_Py_CODEUNIT))</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">_Py_CODEUNIT 是 uint16_t 的别名 typedef uint16_t _Py_CODEUNIT，占两个字节; </span></span><br><span class="line"><span class="comment">从名字也能看出这表示字节码的指令单元, 一条指令两个字节, 所以字节码指令对应的偏移量是0 2 4 6 8..., 每次增加2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">另外这里的first_str指向字节码偏移量为0的位置, 也就是第一条指令</span></span><br><span class="line"><span class="comment">next_str表示在first_str基础上跳转之后的指令, 所以如果x是12的话, 那么next_str = 0 + 6, 显然就是第7条指令</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="Python虚拟机中的for循环控制流"><a href="#Python虚拟机中的for循环控制流" class="headerlink" title="Python虚拟机中的for循环控制流"></a>Python虚拟机中的for循环控制流</h3><p><strong>我们在if语句中已经见识了最基本的控制，但是我们发现if里面只能向前，不管是哪个分支，都是通过<code>JUMP_FORWARD</code>。下面介绍for循环，我们会见到指令时可以回退的。但是在if语句的分支中，我们看到无论哪个分支、其指令的跳跃距离通常都是当前指令与目标指令的距离，相当于向前跳了多少步。那么指令回退时，是不是相当于向后跳了多少步呢？带着疑问，我们来往下看。</strong></p>
<h4 id="for字节码"><a href="#for字节码" class="headerlink" title="for字节码"></a>for字节码</h4><p><strong>我们来看看一个简单的for循环的字节码。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">lst = [1, 2]</span></span><br><span class="line"><span class="string">for item in lst:</span></span><br><span class="line"><span class="string">    print(item)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">import</span> dis</span><br><span class="line">    dis.dis(<span class="built_in">compile</span>(s, <span class="string">&quot;for&quot;</span>, <span class="string">&quot;exec&quot;</span>))</span><br><span class="line">  <span class="number">2</span>           <span class="number">0</span> LOAD_CONST               <span class="number">0</span> (<span class="number">1</span>) //加载常量<span class="number">1</span></span><br><span class="line">              <span class="number">2</span> LOAD_CONST               <span class="number">1</span> (<span class="number">2</span>) //加载常量<span class="number">2</span></span><br><span class="line">              <span class="number">4</span> BUILD_LIST               <span class="number">2</span>     //构建PyListObject对象, 元素个数为<span class="number">2</span></span><br><span class="line">              <span class="number">6</span> STORE_NAME               <span class="number">0</span> (lst) //使用符号<span class="string">&quot;lst&quot;</span>保存</span><br><span class="line"></span><br><span class="line">  <span class="number">3</span>           <span class="number">8</span> LOAD_NAME                <span class="number">0</span> (lst) //加载变量lst</span><br><span class="line">             <span class="number">10</span> GET_ITER					   //获取对应的迭代器</span><br><span class="line">        &gt;&gt;   <span class="number">12</span> FOR_ITER                <span class="number">12</span> (to <span class="number">26</span>)//开始<span class="keyword">for</span>循环, 循环结束跳转到字节码偏移量为<span class="number">26</span>的地方</span><br><span class="line">             <span class="number">14</span> STORE_NAME               <span class="number">1</span> (item) //将元素迭代出来, 使用符号<span class="string">&quot;item&quot;</span>保存</span><br><span class="line"></span><br><span class="line">  <span class="number">4</span>          <span class="number">16</span> LOAD_NAME                <span class="number">2</span> (<span class="built_in">print</span>) //加载函数<span class="built_in">print</span></span><br><span class="line">             <span class="number">18</span> LOAD_NAME                <span class="number">1</span> (item) //加载变量item</span><br><span class="line">             <span class="number">20</span> CALL_FUNCTION            <span class="number">1</span>        //函数调用</span><br><span class="line">             <span class="number">22</span> POP_TOP						    //从栈顶弹出<span class="built_in">print</span>函数的返回值, 这里是<span class="literal">None</span></span><br><span class="line">             <span class="number">24</span> JUMP_ABSOLUTE           <span class="number">12</span>		 //<span class="keyword">for</span>循环遍历一圈之后, 继续跳转回去, 遍历下一圈, 直到结束</span><br><span class="line">        &gt;&gt;   <span class="number">26</span> LOAD_CONST               <span class="number">2</span> (<span class="literal">None</span>) //走到这里<span class="keyword">for</span>循环就结束了, 加载常量<span class="literal">None</span>, 然后返回</span><br><span class="line">             <span class="number">28</span> RETURN_VALUE</span><br></pre></td></tr></table></figure>

<p><strong>我们再来详细分析一下上面的指令：</strong></p>
<blockquote>
<p><strong><code>lst = [1, 2]</code>我们就不分析了，当  for item in  lst:的时候，肯定首先要找到lst，所以指令是LOAD_NAME是没问题的。但是下面出现了GET_ITER，从字面上我们知道这是获取迭代器，其实即使不从源码的角度，我相信有的小伙伴对于for循环的机制也不是很了解。</strong></p>
<p><strong>实际上我们for循环遍历一个对象的时候，首先要满足后面的对象是一个可迭代对象，遍历这个对象的时候，会先调用这个对象的__iter__方法，把它变成一个迭代器。然后不断地调用这个迭代器的__next__方法，一步一步将里面的值全部迭代出来，然后再进行一次迭代出现StopIteration异常，for循环捕捉，然后退出。注意：for item in lst是先将lst对应的迭代器中的元素迭代出来，然后交给变量item。所以字节码中先是<code>12 FOR_ITER</code>，然后才是<code>14 STORE_NAME</code>。因此10个元素的迭代器，是需要迭代11次才能结束的，因为Python不知道迭代10次就能结束，它需要再迭代一次发现没有元素可以迭代、从而抛出StopIteration异常、再被for循环捕捉之后才能结束。</strong></p>
<p><strong>所以for循环后面如果跟的是一个迭代器，那么直接调用__next__方法，如果是可迭代对象，会先调用其内部的__iter__方法将其变成一个迭代器，然后再调用该迭代器的__next__方法。</strong></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Iterable, Iterator</span><br><span class="line"></span><br><span class="line">lst = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表、字符串、元组、字典、集合等等都是可迭代对象</span></span><br><span class="line"><span class="comment"># 但它们不是迭代器</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(lst, Iterable))  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(lst, Iterator))  <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 需要调用__iter__之后才是一个迭代器, 当然迭代器也是可迭代对象</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(<span class="built_in">iter</span>(lst), Iterable))  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(<span class="built_in">iter</span>(lst), Iterator))  <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<p><strong>然后我们看到 24 JUMP_ABSOLUTE，它是跳转到字节码偏移量为12、也就是FOR_ITER的位置，并没有跳到GET_ITER那里，所以for循环在遍历的时候只会创建一次迭代器。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">lst = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">lst_iter = <span class="built_in">iter</span>(lst)</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> lst_iter:</span><br><span class="line">    <span class="built_in">print</span>(item, end=<span class="string">&quot; &quot;</span>)  <span class="comment"># 1 2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> <span class="built_in">iter</span>(lst):</span><br><span class="line">    <span class="built_in">print</span>(item, end=<span class="string">&quot; &quot;</span>)  <span class="comment"># 1 2</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 我们看到结果是一样的, for item in iter(lst)和for item in lst是等价的</span></span><br><span class="line"><span class="comment"># 都会先创建迭代器, 并且只创建一次, 然后遍历这个迭代器</span></span><br></pre></td></tr></table></figure>

<h4 id="list迭代器"><a href="#list迭代器" class="headerlink" title="list迭代器"></a>list迭代器</h4><p><strong>Python虚拟机通过<code>LOAD_NAME 0 (lst)</code>指令，将刚创建的PyListObject对象压入运行时栈。然后再通过<code>GET_ITER</code>指令来获取PyListObject对象的迭代器。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="title function_">TARGET</span><span class="params">(GET_ITER)</span>: &#123;</span><br><span class="line">    <span class="comment">/* before: [obj]; after [getiter(obj)] */</span></span><br><span class="line">    <span class="comment">//从运行时栈获取PyListObject对象</span></span><br><span class="line">    PyObject *iterable = TOP();</span><br><span class="line">    <span class="comment">//获取该PyListObject对象的iterator</span></span><br><span class="line">    PyObject *iter = PyObject_GetIter(iterable);</span><br><span class="line">    Py_DECREF(iterable);</span><br><span class="line">    <span class="comment">//将iterator压入栈中, 设置在栈顶</span></span><br><span class="line">    SET_TOP(iter);</span><br><span class="line">    <span class="keyword">if</span> (iter == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    PREDICT(FOR_ITER);</span><br><span class="line">    PREDICT(CALL_FUNCTION);</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们看到获取迭代器是调用了PyObject_GetIter函数，我们看看这个函数长什么样子。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Objects/object.h</span></span><br><span class="line"><span class="keyword">typedef</span> PyObject *(*getiterfunc) (PyObject *);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Objects/abstract.c</span></span><br><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyObject_GetIter</span><span class="params">(PyObject *o)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//获取对象的类型</span></span><br><span class="line">    PyTypeObject *t = o-&gt;ob_type;</span><br><span class="line">    <span class="comment">//一个函数指针, 接收一个PyObject *, 返回一个PyObject *</span></span><br><span class="line">    getiterfunc f;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//调用类型对象的tp_iter</span></span><br><span class="line">    f = t-&gt;tp_iter;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//如果f是NULL, 并且还不是序列型对象, 那么直接抛出异常, &#x27;xxx&#x27; object is not iterable</span></span><br><span class="line">        <span class="keyword">if</span> (PySequence_Check(o))</span><br><span class="line">            <span class="keyword">return</span> PySeqIter_New(o);</span><br><span class="line">        <span class="keyword">return</span> type_error(<span class="string">&quot;&#x27;%.200s&#x27; object is not iterable&quot;</span>, o);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//调用tp_iter, 传入对象获取迭代器。我们获取迭代器是通过iter(lst)或者lst.__iter__()</span></span><br><span class="line">        <span class="comment">//但是在底层相当于list.__iter__(lst), 所以&quot;实例.方法(*args, **kwargs)&quot;等价于&quot;类.函数(self, *args, **kargs)&quot;</span></span><br><span class="line">        PyObject *res = (*f)(o);</span><br><span class="line">        <span class="comment">//如果res不为空、并且还不是迭代器</span></span><br><span class="line">        <span class="keyword">if</span> (res != <span class="literal">NULL</span> &amp;&amp; !PyIter_Check(res)) &#123;</span><br><span class="line">            <span class="comment">//那么报错TypeError, __iter__返回了一个非迭代器</span></span><br><span class="line">            PyErr_Format(PyExc_TypeError,</span><br><span class="line">                         <span class="string">&quot;iter() returned non-iterator &quot;</span></span><br><span class="line">                         <span class="string">&quot;of type &#x27;%.100s&#x27;&quot;</span>,</span><br><span class="line">                         res-&gt;ob_type-&gt;tp_name);</span><br><span class="line">            Py_DECREF(res);</span><br><span class="line">            res = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>因此我们可以看到，PyObject_GetIter是调用对象对应的类型对象中的tp_iter操作来获取与对象关联的迭代器的。我们说Python一切皆对象，那么这些迭代器也是一个实实在在的对象，那么也必然会有对应的类型对象，因为Python中对象对应的结构体都继承了PyObject，所以任何一个对象都有引用计数和类型。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//listobject.c</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_HEAD <span class="comment">//迭代器显然是不可变对象</span></span><br><span class="line">    Py_ssize_t it_index; <span class="comment">//迭代的元素的索引, 初始为0, 每迭代1个元素it_index就加1</span></span><br><span class="line">    PyListObject *it_seq; <span class="comment">//指向一个PyListObject对象, 显然迭代的就是这个PyListObject对象里面的元素, 当元素迭代完毕之后it_seq会被设置成NULL</span></span><br><span class="line">&#125; listiterobject;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PyTypeObject PyListIter_Type = &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, <span class="number">0</span>)</span><br><span class="line">    <span class="string">&quot;list_iterator&quot;</span>,                            <span class="comment">/* tp_name */</span></span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>然后PyList_Type中tp_iter域被设置为list_iter，显然这是PyObject_GetIter中的那个f，而这也正是创建迭代器的关键所在。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//listobject.c</span></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">list_iter</span><span class="params">(PyObject *seq)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//列表对应的迭代器的指针</span></span><br><span class="line">    listiterobject *it;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//如果seq不是列表，则报错</span></span><br><span class="line">    <span class="keyword">if</span> (!PyList_Check(seq)) &#123;</span><br><span class="line">        PyErr_BadInternalCall();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//为listiterobject申请空间</span></span><br><span class="line">    it = PyObject_GC_New(listiterobject, &amp;PyListIter_Type);</span><br><span class="line">    <span class="keyword">if</span> (it == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//迭代器的索引, 用来遍历列表的, 初始为0</span></span><br><span class="line">    it-&gt;it_index = <span class="number">0</span>;</span><br><span class="line">    Py_INCREF(seq);</span><br><span class="line">    <span class="comment">//这里的seq就是之前的PyListObject对象</span></span><br><span class="line">    it-&gt;it_seq = (PyListObject *)seq;</span><br><span class="line">    _PyObject_GC_TRACK(it);</span><br><span class="line">    <span class="keyword">return</span> (PyObject *)it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>可以看到PyListObject的迭代器对象只是对PyListObject对象做了一个简单的包装，在迭代器中，维护了迭代是要访问的元素在PyListObject对象中的索引：<code>it_index</code>。通过这个索引，listiterobject对象就可以实现PyListObject的遍历。</strong></p>
<blockquote>
<p><strong>所以我们看到迭代器的实现真的很简单，创建谁的迭代器就对谁进行一层包装罢了，迭代器内部有一个索引。每迭代1次索引就加1，迭代完毕之后将指针设置为NULL，然后再迭代就抛出异常。</strong></p>
</blockquote>
<p><strong>所以任何一个列表对应的迭代器的内存大小都是32字节，PyObject是16字节，再加上一个Py_ssize_t和一个指针，总共32字节。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;夏色祭&quot;</span> * <span class="number">1000</span></span><br><span class="line"><span class="built_in">print</span>(s.__sizeof__(), <span class="built_in">iter</span>(s).__sizeof__())  <span class="comment"># 6074 32</span></span><br><span class="line"></span><br><span class="line">lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] * <span class="number">1000</span></span><br><span class="line"><span class="built_in">print</span>(lst.__sizeof__(), <span class="built_in">iter</span>(lst).__sizeof__())  <span class="comment"># 24040 32</span></span><br><span class="line"></span><br><span class="line">tpl = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) * <span class="number">1000</span></span><br><span class="line"><span class="built_in">print</span>(tpl.__sizeof__(), <span class="built_in">iter</span>(tpl).__sizeof__())  <span class="comment"># 24024 32</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不光是列表, 包括字符串、元组也是一样的, 都是32字节</span></span><br></pre></td></tr></table></figure>

<p><strong>但是字典有些特殊，因为它的底层是通过哈希表存储的，它需要额外维护一些信息。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Objects/dictobject.c</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    PyDictObject *di_dict; <span class="comment">/* Set to NULL when iterator is exhausted */</span></span><br><span class="line">    Py_ssize_t di_used;</span><br><span class="line">    Py_ssize_t di_pos;</span><br><span class="line">    PyObject* di_result; <span class="comment">/* reusable result tuple for iteritems */</span></span><br><span class="line">    Py_ssize_t len;</span><br><span class="line">&#125; dictiterobject;</span><br></pre></td></tr></table></figure>

<p><strong>所以字典对应的迭代器是56字节，集合对应的迭代器则是48字节，关于集合可以去源码中查看，看看为什么会占48字节。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">d = <span class="built_in">dict</span>.fromkeys(<span class="built_in">range</span>(<span class="number">100000</span>), <span class="literal">None</span>)</span><br><span class="line"><span class="built_in">print</span>(d.__sizeof__(), <span class="built_in">iter</span>(d).__sizeof__())  <span class="comment"># 5242952 56</span></span><br><span class="line"></span><br><span class="line">s = <span class="built_in">set</span>(<span class="built_in">range</span>(<span class="number">100000</span>))</span><br><span class="line"><span class="built_in">print</span>(s.__sizeof__(), <span class="built_in">iter</span>(s).__sizeof__())  <span class="comment"># 4194504 48</span></span><br></pre></td></tr></table></figure>

<p><strong>在指令<code>GET_ITER</code>完成之后，Python虚拟机开始了<code>FOR_ITER</code>指令的预测动作，如你所知，这样的预测动作是为了提高执行的效率。</strong></p>
<h4 id="迭代控制"><a href="#迭代控制" class="headerlink" title="迭代控制"></a>迭代控制</h4><p><strong>源代码中的for循环，在虚拟机层面也一定对应着一个相应的循环控制结构。因为无论进行怎样的变换，都不可能在虚拟机层面利用顺序结构来实现源码层面上的循环结构，这也可以看成是程序的拓扑不变性。显然正如我们刚才分析的，当创建完迭代器之后，就正式开始进入for循环了，没错就是从<code>FOR ITER</code>开始，进入了Python虚拟机层面上的for循环。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="title function_">TARGET</span><span class="params">(FOR_ITER)</span>: &#123;</span><br><span class="line">    <span class="comment">//指令预测</span></span><br><span class="line">    PREDICTED(FOR_ITER);</span><br><span class="line">    <span class="comment">/* before: [iter]; after: [iter, iter()] *or* [] */</span></span><br><span class="line">    <span class="comment">/* 从栈顶获取iterator对象 */</span></span><br><span class="line">    PyObject *iter = TOP();</span><br><span class="line">    <span class="comment">//调用迭代器类型对象的tp_iternext方法、传入迭代器, 迭代出当前索引对应的元素, 然后索引+1, 然后下次迭代下一个元素</span></span><br><span class="line">    PyObject *next = (*iter-&gt;ob_type-&gt;tp_iternext)(iter);</span><br><span class="line">    <span class="comment">//如果next不为NULL, 那么将元素压入运行时栈, 显然要赋值给for循环的变量了</span></span><br><span class="line">    <span class="keyword">if</span> (next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        PUSH(next);</span><br><span class="line">        PREDICT(STORE_FAST);</span><br><span class="line">        PREDICT(UNPACK_SEQUENCE);</span><br><span class="line">        DISPATCH();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (_PyErr_Occurred(tstate)) &#123;</span><br><span class="line">        <span class="comment">//如果出现异常、并且没有捕获到, 那么报错</span></span><br><span class="line">        <span class="keyword">if</span> (!_PyErr_ExceptionMatches(tstate, PyExc_StopIteration)) &#123;</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//tstate指的是线程对象, 我们会后面分析, 这里与回溯栈相关</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tstate-&gt;c_tracefunc != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            call_exc_trace(tstate-&gt;c_tracefunc, tstate-&gt;c_traceobj, tstate, f);</span><br><span class="line">        &#125;</span><br><span class="line">        _PyErr_Clear(tstate);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 走到这里说明本次迭代正常结束</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    STACK_SHRINK(<span class="number">1</span>);</span><br><span class="line">    Py_DECREF(iter);</span><br><span class="line">    JUMPBY(oparg);</span><br><span class="line">    PREDICT(POP_BLOCK);</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>FOR_ITER的指令代码会首先从运行时栈中获得PyListObject对象的迭代器，然后调用迭代器的tp_iternext开始进行迭代，迭代出元素的同时将索引+1。如果抵达了迭代器的结束位置，那么tp_iternext将返回NULL，这个结果预示着遍历结束。</strong></p>
<p><strong>FOR_ITER的指令代码会检查tp_iternext的返回结果，如果得到的是一个有效的元素<code>(next!=NULL)</code>，那么将获得的这个元素压入到运行时栈中，并开始进行一系列的字节码预测动作。在我们当前的例子中，显然会预测失败，因此会执行<code>STORE_NAME</code>。那么如何获取迭代器的下一个元素呢？</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//listobject.c</span></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">listiter_next</span><span class="params">(listiterobject *it)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyListObject *seq;</span><br><span class="line">    PyObject *item;</span><br><span class="line"></span><br><span class="line">    assert(it != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//seq：显然是获取迭代器对象的PyListObject对象的指针</span></span><br><span class="line">    seq = it-&gt;it_seq;</span><br><span class="line">    <span class="keyword">if</span> (seq == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//一定是一个PyListObject对象</span></span><br><span class="line">    assert(PyList_Check(seq));</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//当前的索引小于列表的长度、即当前索引小于等于最大索引</span></span><br><span class="line">    <span class="keyword">if</span> (it-&gt;it_index &lt; PyList_GET_SIZE(seq)) &#123;</span><br><span class="line">        <span class="comment">//获得索引为it_index的对应元素</span></span><br><span class="line">        item = PyList_GET_ITEM(seq, it-&gt;it_index);</span><br><span class="line">        <span class="comment">//调整index, 使其自增1, 然后下一次遍历得到下一个元素</span></span><br><span class="line">        ++it-&gt;it_index;</span><br><span class="line">        <span class="comment">//增加引用计数、返回</span></span><br><span class="line">        Py_INCREF(item);</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//迭代完毕之后，设置为NULL，所以迭代器只能够顺序迭代一次</span></span><br><span class="line">    it-&gt;it_seq = <span class="literal">NULL</span>;</span><br><span class="line">    Py_DECREF(seq);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>之后python虚拟机将沿着字节码的顺序一条一条的执行下去，从而完成输出的动作。但是我们知道，for循环中肯定会有指令回退的动作，我们之前从字节码中也看到了，for循环遍历一次之后，会再次跳转到<code>FOR_ITER</code>，而跳转所使用的指令就是<code>JUMP_ABSOLUTE</code>。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">case</span> <span class="title function_">TARGET</span><span class="params">(JUMP_ABSOLUTE)</span>: &#123;</span><br><span class="line">            PREDICTED(JUMP_ABSOLUTE);</span><br><span class="line">            <span class="comment">//显然这里的oparg表示字节码偏移量, 表示直接跳转到偏移量为oparg的位置上</span></span><br><span class="line">            JUMPTO(oparg);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> FAST_LOOPS</span></span><br><span class="line">            FAST_DISPATCH();</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">            DISPATCH();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> JUMPTO(x)       (next_instr = first_instr + (x) / sizeof(_Py_CODEUNIT))</span></span><br></pre></td></tr></table></figure>

<p><strong>可以看到和if不一样，for循环使用的是绝对跳跃。JUMP_ABSOLUTE是强制设置next_instr的值，将next_instr设定到距离<code>f-&gt;f_code-&gt;co_code</code>开始地址的某一特定偏移的位置。这个偏移的量由JUMP_ABSOLUTE的指令参数决定，所以这条参数就成了for循环中指令回退动作的最关键的一点。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>           <span class="number">0</span> LOAD_CONST               <span class="number">0</span> (<span class="number">1</span>) </span><br><span class="line">            <span class="number">2</span> LOAD_CONST               <span class="number">1</span> (<span class="number">2</span>) </span><br><span class="line">            <span class="number">4</span> BUILD_LIST               <span class="number">2</span>     </span><br><span class="line">            <span class="number">6</span> STORE_NAME               <span class="number">0</span> (lst) </span><br><span class="line"></span><br><span class="line"><span class="number">3</span>           <span class="number">8</span> LOAD_NAME                <span class="number">0</span> (lst) </span><br><span class="line">           <span class="number">10</span> GET_ITER					   </span><br><span class="line">      &gt;&gt;   <span class="number">12</span> FOR_ITER                <span class="number">12</span> (to <span class="number">26</span>)</span><br><span class="line">           <span class="number">14</span> STORE_NAME               <span class="number">1</span> (item) </span><br><span class="line"></span><br><span class="line"><span class="number">4</span>          <span class="number">16</span> LOAD_NAME                <span class="number">2</span> (print)</span><br><span class="line">           <span class="number">18</span> LOAD_NAME                <span class="number">1</span> (item) </span><br><span class="line">           <span class="number">20</span> CALL_FUNCTION            <span class="number">1</span>        </span><br><span class="line">           <span class="number">22</span> POP_TOP						    </span><br><span class="line">           <span class="number">24</span> JUMP_ABSOLUTE           <span class="number">12</span>		 </span><br><span class="line">      &gt;&gt;   <span class="number">26</span> LOAD_CONST               <span class="number">2</span> (None) </span><br><span class="line">           <span class="number">28</span> RETURN_VALUE</span><br></pre></td></tr></table></figure>

<p><strong>我们看到JUMP_ABSOLUTE的参数是12，<code>next_str = 0 + 12 / 2 = 6</code>，表示跳转到字节码偏移量为12、或者说第7条指令的位置上，也就是<code>12 FOR_ITER</code>这条指令，那么Python虚拟机的下一步动作就是执行<code>FOR_ITER</code>指令，即通过PyListObject对象的迭代器获取PyListObject对象中的元素，然后依次向前，执行输出，遇到JUMP_ABSOLUTE再跳转回去。因此FOR_ITER指令和JUMP_ABSOLUTE指令之间构造出了一个循环结构，这个循环结构正是对应源码中的for循环结构。</strong></p>
<p><strong>但是我们发现，FOR_ITER后面跟了一个参数，这里是12，可是目前为止我们并没有看到有地方使用了这个12啊，那么它代表啥含义呢。其实，聪明如你肯定能猜到，因为从后面(to 26)也能看到，这是用于终止迭代的。表示从当前位置跳跃12个偏移量、等于24，或者在当前指令的基础上再跳转6条指令，也就是到达<code>26 LOAD_CONST</code>的位置。</strong></p>
<h4 id="终止迭代"><a href="#终止迭代" class="headerlink" title="终止迭代"></a>终止迭代</h4><p><strong>“天下没有不散的宴席”，for循环也是要退出的，不用想这个退出的动作只能落在FOR_ITER的身上。在FOR_ITER指令执行的过程中，如果通过PyListObject对象的迭代器获取的下一个元素不是有效的元素(会是NULL)，这就意味着迭代结束了。这个结果将直接导致Python虚拟机会将迭代器对象从运行时栈中弹出，同时执行一个JUMPBY的动作，向前跳跃，在字节码的层面上是向下，就是字节码偏移量增大的方向。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> JUMPBY(x)       (next_instr += (x) / sizeof(_Py_CODEUNIT))</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="title function_">TARGET</span><span class="params">(FOR_ITER)</span>: &#123;</span><br><span class="line">			</span><br><span class="line">            <span class="comment">/* </span></span><br><span class="line"><span class="comment">            ...</span></span><br><span class="line"><span class="comment">            ...</span></span><br><span class="line"><span class="comment">            ...</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//走到这里说明循环结束了</span></span><br><span class="line">            STACK_SHRINK(<span class="number">1</span>);</span><br><span class="line">            Py_DECREF(iter);</span><br><span class="line">            <span class="comment">//直接进行跳转</span></span><br><span class="line">            JUMPBY(oparg);</span><br><span class="line">            PREDICT(POP_BLOCK);</span><br><span class="line">            DISPATCH();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h3 id="python虚拟机中的while循环控制结构"><a href="#python虚拟机中的while循环控制结构" class="headerlink" title="python虚拟机中的while循环控制结构"></a>python虚拟机中的while循环控制结构</h3><p><strong>会了if、for，那么再来看while就简单了。不仅如此，我们还要分析两个关键字：break、continue，当然goto就别想了。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">a = 0</span></span><br><span class="line"><span class="string">while a &lt; 10:</span></span><br><span class="line"><span class="string">    a += 1</span></span><br><span class="line"><span class="string">    if a == 5:</span></span><br><span class="line"><span class="string">        continue</span></span><br><span class="line"><span class="string">    if a == 7:</span></span><br><span class="line"><span class="string">        break</span></span><br><span class="line"><span class="string">    print(a)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">import</span> dis</span><br><span class="line">    dis.dis(<span class="built_in">compile</span>(s, <span class="string">&quot;while&quot;</span>, <span class="string">&quot;exec&quot;</span>))</span><br></pre></td></tr></table></figure>

<p><strong>指令方面，while和for有很多是类似的。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>           <span class="number">0</span> LOAD_CONST               <span class="number">0</span> (<span class="number">0</span>)  <span class="comment">//加载常量0</span></span><br><span class="line">            <span class="number">2</span> STORE_NAME               <span class="number">0</span> (a)  <span class="comment">//使用变量a存储</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>     &gt;&gt;    <span class="number">4</span> LOAD_NAME                <span class="number">0</span> (a)  <span class="comment">//进入while循环了, 首先是a &lt; 10, 加载变量a</span></span><br><span class="line">            <span class="number">6</span> LOAD_CONST               <span class="number">1</span> (<span class="number">10</span>) <span class="comment">//加载常量10</span></span><br><span class="line">            <span class="number">8</span> COMPARE_OP               <span class="number">0</span> (&lt;)  <span class="comment">//比较操作</span></span><br><span class="line">           <span class="number">10</span> POP_JUMP_IF_FALSE       <span class="number">50</span>  <span class="comment">//为False直接结束循环, 跳转到字节码偏移量为50的位置, 也就是第26条指令</span></span><br><span class="line"></span><br><span class="line"><span class="number">4</span>          <span class="number">12</span> LOAD_NAME                <span class="number">0</span> (a) <span class="comment">//这里是进入循环了, 加载变量a</span></span><br><span class="line">           <span class="number">14</span> LOAD_CONST               <span class="number">2</span> (<span class="number">1</span>) <span class="comment">//加载常量1</span></span><br><span class="line">           <span class="number">16</span> INPLACE_ADD 		       <span class="comment">//执行a += 1操作, 这里相当于先执行了a + 1</span></span><br><span class="line">           <span class="number">18</span> STORE_NAME               <span class="number">0</span> (a) <span class="comment">//然后在重新让变量a指向相加之后的结果</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span>          <span class="number">20</span> LOAD_NAME                <span class="number">0</span> (a) <span class="comment">//进入a == 5, 加载变量a</span></span><br><span class="line">           <span class="number">22</span> LOAD_CONST               <span class="number">3</span> (<span class="number">5</span>) <span class="comment">//加载常量5</span></span><br><span class="line">           <span class="number">24</span> COMPARE_OP               <span class="number">2</span> (==) <span class="comment">//比较操作</span></span><br><span class="line">           <span class="number">26</span> POP_JUMP_IF_FALSE       <span class="number">30</span>  <span class="comment">//如果为False, 那么直接跳转到偏移量为30的位置, 也就是当前if语句的下一条指令</span></span><br><span class="line"></span><br><span class="line"><span class="number">6</span>          <span class="number">28</span> JUMP_ABSOLUTE            <span class="number">4</span>  <span class="comment">//如果a == 5成立, 那么绝对跳转, 跳到字节码偏移量为4的位置, 所以continue对一个绝对跳转, 目标是循环开始的地方</span></span><br><span class="line"></span><br><span class="line"><span class="number">7</span>     &gt;&gt;   <span class="number">30</span> LOAD_NAME                <span class="number">0</span> (a) <span class="comment">//走到这里说明a == 5不成立, 判断a == 7, 加载变量a</span></span><br><span class="line">           <span class="number">32</span> LOAD_CONST               <span class="number">4</span> (<span class="number">7</span>) <span class="comment">//加载常量7</span></span><br><span class="line">           <span class="number">34</span> COMPARE_OP               <span class="number">2</span> (==) <span class="comment">//比较是否相等</span></span><br><span class="line">           <span class="number">36</span> POP_JUMP_IF_FALSE       <span class="number">40</span>  <span class="comment">//如果为False, 跳转到偏移量为40的位置, 也就是print(a)</span></span><br><span class="line"></span><br><span class="line"><span class="number">8</span>          <span class="number">38</span> JUMP_ABSOLUTE           <span class="number">50</span>  <span class="comment">//如果a == 5成立, 那么也是跳转到字节码偏移量为50的地方, 因为是break, 也是结束循环</span></span><br><span class="line"></span><br><span class="line"><span class="number">9</span>     &gt;&gt;   <span class="number">40</span> LOAD_NAME                <span class="number">1</span> (print) <span class="comment">//加载变量print</span></span><br><span class="line">           <span class="number">42</span> LOAD_NAME                <span class="number">0</span> (a)  <span class="comment">//加载变量a</span></span><br><span class="line">           <span class="number">44</span> CALL_FUNCTION            <span class="number">1</span>  <span class="comment">//函数调用</span></span><br><span class="line">           <span class="number">46</span> POP_TOP		            <span class="comment">//从栈顶弹出返回值</span></span><br><span class="line">           <span class="number">48</span> JUMP_ABSOLUTE            <span class="number">4</span>  <span class="comment">//走到这里说明while循环执行一圈了, 那么再度跳转到while a &lt; 10的地方</span></span><br><span class="line">      &gt;&gt;   <span class="number">50</span> LOAD_CONST               <span class="number">5</span> (None)</span><br><span class="line">           <span class="number">52</span> RETURN_VALUE</span><br></pre></td></tr></table></figure>

<p><strong>所以有了for循环，再看while循环就简单多了，整体逻辑和for高度相似，当然里面还结合了if。另外我们看到break和continue都是使用了JUMP_ABSOLUTE实现的。JUMP_ABSOLUTE是跳转到指定位置，通过绝对跳转实现的。break是跳转到while语句结束后的第一条指令；continue则是跳转到while循环的开始位置。</strong></p>
<p><strong>然后执行一圈之后，遇到了<code>48 JUMP_ABSOLUTE </code>，再度跳转回去。当循环不满足的时候，通过<code>10 POP_JUMP_IF_FALSE       50</code>直接结束循环，所以while事实上比for还是要简单一些的。</strong></p>
<h3 id="Python虚拟机中的异常控制流"><a href="#Python虚拟机中的异常控制流" class="headerlink" title="Python虚拟机中的异常控制流"></a>Python虚拟机中的异常控制流</h3><p><strong>异常这个东西应该是最常见的了，程序在运行的过程中经常会遇到大量的错误，而Python中也定义了大量的异常类型供我们使用，下面我们来看看Python中的异常机制，因为这也是一个控制语句。</strong></p>
<h4 id="Python中的异常机制"><a href="#Python中的异常机制" class="headerlink" title="Python中的异常机制"></a>Python中的异常机制</h4><p>​        <strong>Python虚拟机自身抛出异常</strong>    </p>
<p><strong>Python有一套内建的异常捕捉机制，即使在python的脚本文件中没有出现try语句，python脚本执行出现的异常还是会被虚拟机捕捉到。首先我们就从<code>ZeroDivisionError</code>这个异常来分析。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">1 / 0</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">import</span> dis</span><br><span class="line">    dis.dis(<span class="built_in">compile</span>(s, <span class="string">&quot;while&quot;</span>, <span class="string">&quot;exec&quot;</span>))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">  2           0 LOAD_CONST               0 (1)</span></span><br><span class="line"><span class="string">              2 LOAD_CONST               1 (0)</span></span><br><span class="line"><span class="string">              4 BINARY_TRUE_DIVIDE</span></span><br><span class="line"><span class="string">              6 POP_TOP</span></span><br><span class="line"><span class="string">              8 LOAD_CONST               2 (None)</span></span><br><span class="line"><span class="string">             10 RETURN_VALUE</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看第3条字节码指令，异常也正是在执行这条指令的时候触发的。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="title function_">TARGET</span><span class="params">(BINARY_TRUE_DIVIDE)</span>: &#123;</span><br><span class="line">    <span class="comment">//co_consts -&gt; (0, 1)</span></span><br><span class="line">    PyObject *divisor = POP(); <span class="comment">//1</span></span><br><span class="line">    PyObject *dividend = TOP();<span class="comment">//0</span></span><br><span class="line">    <span class="comment">//调用__truediv__</span></span><br><span class="line">    PyObject *quotient = PyNumber_TrueDivide(dividend, divisor);</span><br><span class="line">    Py_DECREF(dividend);</span><br><span class="line">    Py_DECREF(divisor);</span><br><span class="line">    <span class="comment">//将结果设置在栈顶</span></span><br><span class="line">    SET_TOP(quotient);</span><br><span class="line">    <span class="comment">//如果结果是NULL, 那么就报错了</span></span><br><span class="line">    <span class="keyword">if</span> (quotient == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>逻辑很简单， 就是获取两个值，然后调用<code>PyNumber_TrueDivide</code>进行除法运算。正常情况下得到的肯定是一个数值，如果不能相除那么就返回NULL，如果接收的<code>quotient</code>是NULL，那么抛异常。因此我们来看看<code>PyNumber_TrueDivide</code>都干了些啥？</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//longobject.c</span></span><br><span class="line"><span class="comment">//最终调用的是long_true_divide</span></span><br><span class="line"><span class="comment">//代码很长我们截取一部分</span></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">long_true_divide</span><span class="params">(PyObject *v, PyObject *w)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//都是在计算除法时需要的临时变量</span></span><br><span class="line">    PyLongObject *a, *b, *x;</span><br><span class="line">    Py_ssize_t a_size, b_size, shift, extra_bits, diff, x_size, x_bits;</span><br><span class="line">    digit mask, low;</span><br><span class="line">    <span class="type">int</span> inexact, negate, a_is_small, b_is_small;</span><br><span class="line">    <span class="type">double</span> dx, result;</span><br><span class="line"></span><br><span class="line">    CHECK_BINOP(v, w);</span><br><span class="line">    <span class="comment">//将v和w中维护的整数值转存到a和b中</span></span><br><span class="line">    a = (PyLongObject *)v;</span><br><span class="line">    b = (PyLongObject *)w;</span><br><span class="line">    a_size = Py_ABS(Py_SIZE(a));</span><br><span class="line">    b_size = Py_ABS(Py_SIZE(b));</span><br><span class="line">    negate = (Py_SIZE(a) &lt; <span class="number">0</span>) ^ (Py_SIZE(b) &lt; <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//获取b_size, 就是b对应的ob_size, 我们在分析PyLongObject对象时说过, 如果这个对象维护的值为0，那么ob_size就是0，这是个特殊情况</span></span><br><span class="line">    <span class="comment">//并且这个ob_size还可以体现出维护的值的正负</span></span><br><span class="line">    <span class="comment">//我们看到如果b_size == 0, 那么抛出PyExc_ZeroDivisionError</span></span><br><span class="line">    <span class="keyword">if</span> (b_size == <span class="number">0</span>) &#123;</span><br><span class="line">        PyErr_SetString(PyExc_ZeroDivisionError,</span><br><span class="line">                        <span class="string">&quot;division by zero&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    ...    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所以如果除以0，那么直接设置异常信息。另外我们说过Python中一切皆对象，那么异常也是一个对象，是一个PyObject类型。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pyerrors.h</span></span><br><span class="line"><span class="comment">//这里面定义了大量的异常, 比如:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyException_HEAD</span><br><span class="line">&#125; PyBaseExceptionObject; <span class="comment">//BaseException, 所有异常的基类, Exception也继承自它</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyException_HEAD</span><br><span class="line">    PyObject *msg;</span><br><span class="line">    PyObject *filename;</span><br><span class="line">    PyObject *lineno;</span><br><span class="line">    PyObject *offset;</span><br><span class="line">    PyObject *text;</span><br><span class="line">    PyObject *print_file_and_line;</span><br><span class="line">&#125; PySyntaxErrorObject; <span class="comment">//语法异常</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyException_HEAD</span><br><span class="line">    PyObject *msg;</span><br><span class="line">    PyObject *name;</span><br><span class="line">    PyObject *path;</span><br><span class="line">&#125; PyImportErrorObject; <span class="comment">//导包异常</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyException_HEAD</span><br><span class="line">    PyObject *encoding;</span><br><span class="line">    PyObject *object;</span><br><span class="line">    Py_ssize_t start;</span><br><span class="line">    Py_ssize_t end;</span><br><span class="line">    PyObject *reason;</span><br><span class="line">&#125; PyUnicodeErrorObject;<span class="comment">//Unicode异常</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyException_HEAD</span><br><span class="line">    PyObject *value;</span><br><span class="line">&#125; PyStopIterationObject; <span class="comment">//StopIteration异常</span></span><br></pre></td></tr></table></figure>

<p>​        <strong>在线程状态对象中记录异常信息(线程的知识后续会说)</strong>    </p>
<p><strong>我们之前看到，异常信息是通过<code>PyErr_SetString(异常类型, 异常信息)</code>来设置的，而除了这个<code>PyErr_SetString</code>，还会经过<code>PyErr_SetObject</code>，最终到达<code>PyErr_Restore</code>。在<code>PyErr_Restore</code>中，Python将这个异常放置到了一个安全的地方。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Python/errors.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">PyErr_Restore</span><span class="params">(PyObject *type, PyObject *value, PyObject *traceback)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//获取线程对象</span></span><br><span class="line">    PyThreadState *tstate = _PyThreadState_GET();</span><br><span class="line">    _PyErr_Restore(tstate, type, value, traceback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line">_PyErr_Restore(PyThreadState *tstate, PyObject *type, PyObject *value,</span><br><span class="line">               PyObject *traceback)</span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//异常类型、异常值、异常的回溯栈, 对应Python中sys.exc_info()返回的元组里面的3个元组</span></span><br><span class="line">    PyObject *oldtype, *oldvalue, *oldtraceback;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//如果traceback不为空并且不是回溯栈, 那么将其设置为NULL</span></span><br><span class="line">    <span class="keyword">if</span> (traceback != <span class="literal">NULL</span> &amp;&amp; !PyTraceBack_Check(traceback)) &#123;</span><br><span class="line">        Py_DECREF(traceback);</span><br><span class="line">        traceback = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取以前的异常信息</span></span><br><span class="line">    oldtype = tstate-&gt;curexc_type;</span><br><span class="line">    oldvalue = tstate-&gt;curexc_value;</span><br><span class="line">    oldtraceback = tstate-&gt;curexc_traceback;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//设置当前的异常信息</span></span><br><span class="line">    tstate-&gt;curexc_type = type;</span><br><span class="line">    tstate-&gt;curexc_value = value;</span><br><span class="line">    tstate-&gt;curexc_traceback = traceback;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//将之前的异常信息的引用计数分别减1</span></span><br><span class="line">    Py_XDECREF(oldtype);</span><br><span class="line">    Py_XDECREF(oldvalue);</span><br><span class="line">    Py_XDECREF(oldtraceback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>最后在tstate<code>(PyThreadState对象)</code>的curexc_type中存下了<code>PyExc_ZeroDivisionError</code>，而cur_value中存下了字符串<code>division by zero</code>，curexc_traceback存下了回溯栈。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="number">1</span> / <span class="number">0</span></span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> e:</span><br><span class="line">    exc_type, exc_value, exc_tb = sys.exc_info()</span><br><span class="line">    <span class="built_in">print</span>(exc_type)  <span class="comment"># &lt;class &#x27;ZeroDivisionError&#x27;&gt;</span></span><br><span class="line">    <span class="built_in">print</span>(exc_value)  <span class="comment"># division by zero</span></span><br><span class="line">    <span class="built_in">print</span>(exc_tb)  <span class="comment"># &lt;traceback object at 0x000001C43F29F4C0&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># exc_tb也可以通过e.__traceback__获取</span></span><br><span class="line">    <span class="built_in">print</span>(e.__traceback__ <span class="keyword">is</span> exc_tb)  <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<p><strong>我们再来看看PyThreadState对象<code>(这里先简单看一下，后续会详细说)</code>，这个之前说了是与线程有关的，但是它只是线程信息的一个抽象描述，而真实的线程及状态肯定是由操作系统来维护和管理的。因为Python虚拟机在运行的时候总需要另外一些与线程相关的状态和信息，比如是否发生了异常等等，这些信息显然操作系统是没有办法提供的。而PyThreadState对象正是Python为线程准备的、在虚拟机层面保存线程状态信息的对象<code>(后面简称线程状态对象、或者线程对象)</code>。在这里，当前活动线程<code>(OS原生线程)</code>对应的PyThreadState对象可以通过PyThreadState_GET获得，在得到了线程状态对象之后，就将异常信息存放到线程状态对象中。</strong></p>
<p>​        <strong>展开栈帧</strong>    </p>
<p><strong>首先我们知道异常已经被记录在了线程的状态中了，现在可以回头看看，在跳出了分派字节码指令的switch块所在的for循环之后，发生了什么动作。</strong></p>
<blockquote>
<p><strong>我们知道在Python&#x2F;ceval.c中有一个 *_PyEval_EvalFrameDefault* 函数，它是执行字节码指令的。里面有一个for循环，会依次遍历每一条字节码，在这个for循环里面有一个巨型switch，里面case了所有指令出现的情况。当所有指令执行完毕之后，这个for循环就结束了。</strong></p>
</blockquote>
<p><strong>但这里还存在一个问题，那就是导致跳出那个巨大的switch块所在的for循环的原因：”1. 可以是执行完了所有的字节码之后正常跳出”，”2. 也可以是发生异常后跳出”，那么Python虚拟机到底如何区分这是哪一种呢？</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">PyObject* _Py_HOT_FUNCTION </span><br><span class="line">_PyEval_EvalFrameDefault(PyFrameObject *f, <span class="type">int</span> throwflag)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (opcode) &#123;</span><br><span class="line">            <span class="comment">// 一个超大的switch语句</span></span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">error: <span class="comment">//一旦出现异常, 会使用goto语句跳转到error标签这里</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> NDEBUG</span></span><br><span class="line">        <span class="keyword">if</span> (!_PyErr_Occurred(tstate)) &#123;</span><br><span class="line">            _PyErr_SetString(tstate, PyExc_SystemError,</span><br><span class="line">                             <span class="string">&quot;error return without exception set&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        assert(_PyErr_Occurred(tstate));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建traceback对象</span></span><br><span class="line">        PyTraceBack_Here(f);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tstate-&gt;c_tracefunc != <span class="literal">NULL</span>)</span><br><span class="line">            call_exc_trace(tstate-&gt;c_tracefunc, tstate-&gt;c_traceobj,</span><br><span class="line">                           tstate, f);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如果在执行switch语句的时候出现了异常，那么会跳转到error这里，否则会跳转到其它地方。当跳转到error标签的时候就代表出现异常了，注意：是在执行过程中出现异常之后Python虚拟机才获取到异常信息。</strong></p>
<p><strong>那么问题就来了，  如果在在涉及到函数调用的时候发生了异常该怎么办呢？首先在python虚拟机意识到有异常发生后，它就要开始进入异常处理的流程，这个流程会涉及到我们介绍PyFrameObject对象时所提到的那个PyFrameObject对象链表。在介绍PyFrameObject对象的时候，我们说过PyFrameObject实际上就是对栈帧的模拟，当发生函数函数调用，python会新创建一个栈帧，并将其内部的f_back连接到调用者对应的PyFrameObject，这样就形成了一条栈帧链。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">h</span>():</span><br><span class="line">    <span class="number">1</span> / <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">g</span>():</span><br><span class="line">    h()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line">    g()</span><br><span class="line">    </span><br><span class="line">f()</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Traceback (most recent call last):</span></span><br><span class="line"><span class="string">  File &quot;D:/satori/1.py&quot;, line 13, in &lt;module&gt;</span></span><br><span class="line"><span class="string">    f()</span></span><br><span class="line"><span class="string">  File &quot;D:/satori/1.py&quot;, line 10, in f</span></span><br><span class="line"><span class="string">    g()</span></span><br><span class="line"><span class="string">  File &quot;D:/satori/1.py&quot;, line 6, in g</span></span><br><span class="line"><span class="string">    h()</span></span><br><span class="line"><span class="string">  File &quot;D:/satori/1.py&quot;, line 2, in h</span></span><br><span class="line"><span class="string">    1 / 0</span></span><br><span class="line"><span class="string">ZeroDivisionError: division by zero</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>这是脚本运行时产生的输出，我们看到了函数调用的信息：比如在源代码的哪一行调用了哪一个函数，那么这些信息是从何而来的呢？而且我们发现输出的信息是一个链状的结构，是不是和栈帧链比较相似啊。没错，在Python虚拟机处理异常的时候，涉及到了一个traceback对象，在这个对象中记录栈帧链表的信息，Python虚拟机利用这个对象来将栈帧链表中的每一个栈帧的状态进行可视化，这个可视化的结果就是上面输出的异常信息。</strong></p>
<p><strong>回到我们的例子，当异常发生时，当前活动的栈帧是函数h对应的栈帧。在Python虚拟机开始处理异常的时候，它首先的动作就是创建一个traceback对象，用于记录异常发生时活动栈帧的状态。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">PyObject* _Py_HOT_FUNCTION </span><br><span class="line">_PyEval_EvalFrameDefault(PyFrameObject *f, <span class="type">int</span> throwflag)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (opcode) &#123;</span><br><span class="line">            <span class="comment">// 一个超大的switch语句</span></span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建traceback对象</span></span><br><span class="line">        PyTraceBack_Here(f);</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//这里tstate还是我们之前提到的与当前活动线程对应的线程对象</span></span><br><span class="line">        <span class="comment">//其中的c_tracefunc是用户自定义的追踪函数，主要用于编写python的debugger。</span></span><br><span class="line">        <span class="comment">//但是通常情况下这个值都是NULL，所以不考虑它。</span></span><br><span class="line">        <span class="comment">//我们主要看上面的PyTraceBack_Here(f)，它到底使用PyFrameObject对象创建了一个怎样的traceback</span></span><br><span class="line">        <span class="keyword">if</span> (tstate-&gt;c_tracefunc != <span class="literal">NULL</span>)</span><br><span class="line">            call_exc_trace(tstate-&gt;c_tracefunc, tstate-&gt;c_traceobj,</span><br><span class="line">                           tstate, f);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Python/traceback.c</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">PyTraceBack_Here</span><span class="params">(PyFrameObject *frame)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyObject *exc, *val, *tb, *newtb;</span><br><span class="line">    <span class="comment">//获取线程中保存线程状态的traceback对象, 进行设置</span></span><br><span class="line">    PyErr_Fetch(&amp;exc, &amp;val, &amp;tb);</span><br><span class="line">    <span class="comment">//_PyTraceBack_FromFrame创建新的traceback对象</span></span><br><span class="line">    newtb = _PyTraceBack_FromFrame(tb, frame);</span><br><span class="line">    <span class="keyword">if</span> (newtb == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        _PyErr_ChainExceptions(exc, val, tb);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将新的traceback对象交给线程状态对象</span></span><br><span class="line">    PyErr_Restore(exc, val, newtb);</span><br><span class="line">    Py_XDECREF(tb);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>原来traceback对象是保存在线程状态对象之中的，我们来看看这个traceback对象究竟长得什么样：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Include/cpython/traceback.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">traceback</span> &#123;</span></span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">traceback</span> *<span class="title">tb_next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">frame</span> *<span class="title">tb_frame</span>;</span></span><br><span class="line">    <span class="type">int</span> tb_lasti;</span><br><span class="line">    <span class="type">int</span> tb_lineno;</span><br><span class="line">&#125; PyTracebackObject;</span><br></pre></td></tr></table></figure>

<p><strong>可以看到里面有一个tb_next，所以很容易想到这个traceback也是一个链表结构。其实这个PyTracebackObject对象的链表结构应该跟PyFrameObject对象的链表结构是同构的、或者说一一对应的，即一个PyFrameObject对象应该对应一个PyTracebackObject对象。我们看看这个链表是怎么产生的，在PyTraceBack_Here函数中我们看到它是通过_PyTraceBack_FromFrame创建的，那么秘密就隐藏在这个函数中：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Python/traceback.h</span></span><br><span class="line">PyObject*</span><br><span class="line">_PyTraceBack_FromFrame(PyObject *tb_next, PyFrameObject *frame)</span><br><span class="line">&#123;</span><br><span class="line">    assert(tb_next == <span class="literal">NULL</span> || PyTraceBack_Check(tb_next));</span><br><span class="line">    assert(frame != <span class="literal">NULL</span>);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//底层调用了tb_create_raw, 参数分别是下一个traceback、当前栈帧、当前f_lasti、以及源代码行号</span></span><br><span class="line">    <span class="keyword">return</span> tb_create_raw((PyTracebackObject *)tb_next, frame, frame-&gt;f_lasti,</span><br><span class="line">                         PyFrame_GetLineNumber(frame));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">tb_create_raw</span><span class="params">(PyTracebackObject *next, PyFrameObject *frame, <span class="type">int</span> lasti,</span></span><br><span class="line"><span class="params">              <span class="type">int</span> lineno)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyTracebackObject *tb;</span><br><span class="line">    <span class="keyword">if</span> ((next != <span class="literal">NULL</span> &amp;&amp; !PyTraceBack_Check(next)) ||</span><br><span class="line">                    frame == <span class="literal">NULL</span> || !PyFrame_Check(frame)) &#123;</span><br><span class="line">        PyErr_BadInternalCall();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//申请内存</span></span><br><span class="line">    tb = PyObject_GC_New(PyTracebackObject, &amp;PyTraceBack_Type);</span><br><span class="line">    <span class="keyword">if</span> (tb != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//建立链表</span></span><br><span class="line">        Py_XINCREF(next);</span><br><span class="line">        <span class="comment">//这里的tb_next就是下一个traceback</span></span><br><span class="line">        tb-&gt;tb_next = next;</span><br><span class="line">        Py_XINCREF(frame);</span><br><span class="line">        <span class="comment">//设置栈帧, 所以我们可以通过e.__traceback__.tb_frame获取栈帧</span></span><br><span class="line">        tb-&gt;tb_frame = frame;</span><br><span class="line">        <span class="comment">//执行完毕时字节码偏移量</span></span><br><span class="line">        tb-&gt;tb_lasti = lasti;</span><br><span class="line">        <span class="comment">//源代码行号</span></span><br><span class="line">        tb-&gt;tb_lineno = lineno;</span><br><span class="line">        <span class="comment">//加入GC追踪, 参与垃圾回收</span></span><br><span class="line">        PyObject_GC_Track(tb);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (PyObject *)tb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>从源码中我们看到，tb_next是将两个traceback连接了起来，不过这个和PyFrameObject里面f_back正好相反。f_back指向的是上一个栈帧，而tb_next指向的是下一个traceback。另外在新创建的对象中，还使用tb_frame和对应的PyFrameObject对象建立了联系，当然还有最后执行完毕的字节码偏移量以及其在源代码中对应的行号。话说还记得PyCodeObject对象中的那个co_lnotab吗，这里的tb_lineno就是通过co_lnotab获取的。</strong></p>
<p><strong>Python虚拟机意识到有异常抛出，并创建了traceback对象之后，它会在当前栈帧中寻找except语句，来执行开发人员指定的捕捉异常的动作。如果没有找到，那么Python虚拟机将退出当前的活动栈帧，并沿着栈帧链回退到上一个栈帧，在上一个栈帧中寻找except语句。就像我们之前说的，出现函数调用会创建栈帧，当函数执行完毕或者出现异常的时候，会回退到上一级栈帧。一层一层创建、一层一层返回。至于回退的这个动作，则是在<code>PyEval_EvalFrameEx</code>的最后完成，当然准确的说应该是其内部调用的<code>_PyEval_EvalFrameDefault</code>的最后。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">        <span class="keyword">switch</span>(opcode)&#123;</span><br><span class="line">            <span class="comment">//巨型switch</span></span><br><span class="line">        &#125;</span><br><span class="line">exception_unwind:</span><br><span class="line">    <span class="comment">//如果发生了异常, 这里会将异常进行展开, 然后试图进行捕获</span></span><br><span class="line">    <span class="comment">//注意: exception_unwind是位于这个大大的for循环的内部的结束位置</span></span><br><span class="line">        <span class="keyword">while</span> (f-&gt;f_iblock &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//里面是和异常捕获相关的逻辑, 后面会分析</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//retval表示_PyEval_EvalFrameDefault函数的返回值, 返回值为NULL, 那么表示有异常发生	</span></span><br><span class="line">    assert(retval == <span class="literal">NULL</span>);</span><br><span class="line">    assert(_PyErr_Occurred(tstate));</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">exit_eval_frame:</span><br><span class="line">    <span class="keyword">if</span> (PyDTrace_FUNCTION_RETURN_ENABLED())</span><br><span class="line">        dtrace_function_return(f);</span><br><span class="line">    Py_LeaveRecursiveCall();</span><br><span class="line">    f-&gt;f_executing = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//将线程状态对象中的活动栈帧设置为上一个栈帧, 完成栈帧回退的动作</span></span><br><span class="line">    tstate-&gt;frame = f-&gt;f_back;</span><br><span class="line">    <span class="keyword">return</span> _Py_CheckFunctionResult(<span class="literal">NULL</span>, retval, <span class="string">&quot;PyEval_EvalFrameEx&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>如果开发人员没有任何的捕获异常的动作，那么将通过break跳出python执行字节码的那个for循环。最后，由于没有捕获到异常， 其返回值被设置为NULL，同时通过将当前线程状态对象中的活动栈帧，设置为上一级栈帧，从而完成栈帧回退的动作。</strong></p>
<p><strong>此时我们的例子就很好解释了，当虚拟机执行函数f时，它是在PyEval_EvalFrameEx<code>(内部调用的_PyEval_EvalFrameDefault)</code>中执行与f对应的<code>PyFrameObject</code>对象中的字节码指令序列。当在函数f中调用g时，Python虚拟机又会为函数g创建新的<code>PyFrameObject</code>对象，会把控制权交给函数g对应的<code>PyFrameObject</code>，当然调用的也是<code>PyEval_EvalFrameEx</code>，只不过这次是在执行与g对应的<code>PyFrameObject</code>对象中的字节码指令序列了。同理函数g调用函数h的时候，也是一样的。所以当在函数h中发生异常，没有异常捕获、导致<code>PyEval_EvalFrameEx</code>结束时，自然要返回到、或者把控制权再交给与函数g对应的<code>PyFrameObject</code>，由<code>PyEval_EvalFrameEx</code>继续执行。由于在返回时，retval被设置为NULL，所以回到g中，Python虚拟机再次意识到有异常产生，可由于函数g中调用的时候也没有异常捕获，那么同样也要退出，再把<code>PyEval_EvalFrameEx</code>执行栈帧的控制权交给函数f对应的栈帧，如果还没有异常捕获，那么回到py文件对应的栈帧，再没有的话就直接报错了。</strong></p>
<p><strong>这个沿着栈帧链不断回退的过程我们称之为<code>栈帧展开</code>，在这个栈帧展开的过程中，Python虚拟机不断地创建与各个栈帧对应的traceback，并将其链接成链表。</strong></p>
<p><img src="/2023/04/02/13-%E5%89%96%E6%9E%90Python%E7%9A%84%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/1229382-20200821012533952-1339104654.png" alt="img"></p>
<p><strong>由于我们没有设置任何的异常捕获的代码，那么python虚拟机的执行流程会一直返回到<code>PyRun_SimpleFileExFlags</code>中，这个<code>PyRun_SimpleFileExFlags</code>是干啥的我们先不管，以后分析Python运行时候的初始化时，就可以看到这个函数的作用了。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Python/pythonrun.c</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">PyRun_SimpleFileExFlags</span><span class="params">(FILE *fp, <span class="type">const</span> <span class="type">char</span> *filename, <span class="type">int</span> closeit,</span></span><br><span class="line"><span class="params">                        PyCompilerFlags *flags)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line">    <span class="keyword">if</span> (maybe_pyc_file(fp, filename, ext, closeit)) &#123;</span><br><span class="line">       <span class="comment">//......</span></span><br><span class="line">       <span class="comment">//执行pyc文件 </span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* When running from stdin, leave __main__.__loader__ alone */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(filename, <span class="string">&quot;&lt;stdin&gt;&quot;</span>) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">            set_main_loader(d, filename, <span class="string">&quot;SourceFileLoader&quot;</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;python: failed to set __main__.__loader__\n&quot;</span>);</span><br><span class="line">            ret = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//调用了PyRun_FileExFlags</span></span><br><span class="line">        v = PyRun_FileExFlags(fp, filename, Py_file_input, d, d,</span><br><span class="line">                              closeit, flags);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyRun_FileExFlags</span><span class="params">(FILE *fp, <span class="type">const</span> <span class="type">char</span> *filename_str, <span class="type">int</span> start, PyObject *globals,</span></span><br><span class="line"><span class="params">                  PyObject *locals, <span class="type">int</span> closeit, PyCompilerFlags *flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//调用了run_mod</span></span><br><span class="line">    ret = run_mod(mod, filename, globals, locals, flags, arena);</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>:</span><br><span class="line">    Py_XDECREF(filename);</span><br><span class="line">    <span class="keyword">if</span> (arena != <span class="literal">NULL</span>)</span><br><span class="line">        PyArena_Free(arena);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">run_mod</span><span class="params">(mod_ty mod, PyObject *filename, PyObject *globals, PyObject *locals,</span></span><br><span class="line"><span class="params">            PyCompilerFlags *flags, PyArena *arena)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//调用run_eval_code_obj</span></span><br><span class="line">    v = run_eval_code_obj(co, globals, locals);</span><br><span class="line">    Py_DECREF(co);</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">run_eval_code_obj</span><span class="params">(PyCodeObject *co, PyObject *globals, PyObject *locals)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//调用了PyEval_EvalCode</span></span><br><span class="line">    v = PyEval_EvalCode((PyObject*)co, globals, locals);</span><br><span class="line">    <span class="keyword">if</span> (!v &amp;&amp; PyErr_Occurred() == PyExc_KeyboardInterrupt) &#123;</span><br><span class="line">        _Py_UnhandledKeyboardInterrupt = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Python/ceval.c</span></span><br><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyEval_EvalCode</span><span class="params">(PyObject *co, PyObject *globals, PyObject *locals)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//调用了PyEval_EvalCodeEx</span></span><br><span class="line">    <span class="keyword">return</span> PyEval_EvalCodeEx(co,</span><br><span class="line">                      globals, locals,</span><br><span class="line">                      (PyObject **)<span class="literal">NULL</span>, <span class="number">0</span>,</span><br><span class="line">                      (PyObject **)<span class="literal">NULL</span>, <span class="number">0</span>,</span><br><span class="line">                      (PyObject **)<span class="literal">NULL</span>, <span class="number">0</span>,</span><br><span class="line">                      <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyEval_EvalCodeEx</span><span class="params">(PyObject *_co, PyObject *globals, PyObject *locals,</span></span><br><span class="line"><span class="params">                  PyObject *<span class="type">const</span> *args, <span class="type">int</span> argcount,</span></span><br><span class="line"><span class="params">                  PyObject *<span class="type">const</span> *kws, <span class="type">int</span> kwcount,</span></span><br><span class="line"><span class="params">                  PyObject *<span class="type">const</span> *defs, <span class="type">int</span> defcount,</span></span><br><span class="line"><span class="params">                  PyObject *kwdefs, PyObject *closure)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//调用了_PyEval_EvalCodeWithName</span></span><br><span class="line">    <span class="keyword">return</span> _PyEval_EvalCodeWithName(_co, globals, locals,</span><br><span class="line">                                    args, argcount,</span><br><span class="line">                                    kws, kws != <span class="literal">NULL</span> ? kws + <span class="number">1</span> : <span class="literal">NULL</span>,</span><br><span class="line">                                    kwcount, <span class="number">2</span>,</span><br><span class="line">                                    defs, defcount,</span><br><span class="line">                                    kwdefs, closure,</span><br><span class="line">                                    <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PyObject *</span><br><span class="line">_PyEval_EvalCodeWithName(PyObject *_co, PyObject *globals, PyObject *locals,</span><br><span class="line">           PyObject *<span class="type">const</span> *args, Py_ssize_t argcount,</span><br><span class="line">           PyObject *<span class="type">const</span> *kwnames, PyObject *<span class="type">const</span> *kwargs,</span><br><span class="line">           Py_ssize_t kwcount, <span class="type">int</span> kwstep,</span><br><span class="line">           PyObject *<span class="type">const</span> *defs, Py_ssize_t defcount,</span><br><span class="line">           PyObject *kwdefs, PyObject *closure,</span><br><span class="line">           PyObject *name, PyObject *qualname)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//调用了PyEval_EvalFrameEx, 里面的f就是在该函数中创建的栈帧对象</span></span><br><span class="line">    <span class="comment">//还记得这个返回值retval吗? 如果它是NULL, 那么代表该栈帧中有异常发生了</span></span><br><span class="line">    retval = PyEval_EvalFrameEx(f,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">fail: </span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//返回retval</span></span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyEval_EvalFrameEx</span><span class="params">(PyFrameObject *f, <span class="type">int</span> throwflag)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//创建一个线程对象, 里面会调用其它函数创建一个线程</span></span><br><span class="line">    PyInterpreterState *interp = _PyInterpreterState_GET_UNSAFE();</span><br><span class="line">    <span class="comment">//执行线程对象的eval_frame</span></span><br><span class="line">    <span class="keyword">return</span> interp-&gt;eval_frame(f, throwflag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Python/pystate.c</span></span><br><span class="line">PyInterpreterState *</span><br><span class="line"><span class="title function_">PyInterpreterState_New</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//你看到了什么? interp-&gt;eval_frame被设置成了_PyEval_EvalFrameDefault</span></span><br><span class="line">    interp-&gt;eval_frame = _PyEval_EvalFrameDefault;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>可以看到兜了这么多圈，最终<code>PyRun_SimpleFileExFlags</code>返回的值就是<code>PyEval_EvalFrameEx</code>返回的那个retval<code>(当然出现异常的话，就是NULL)</code>。所以接下来会调用<code>PyErr_Print</code>，然后在<code>PyErr_Print</code>中，Python虚拟机取出其维护的traceback，并遍历traceback链表，逐个输出其中的信息，也就是我们在python中看到的那个打印的异常信息。并且这个顺序是：.py文件、函数f、函数g、函数h，不是函数h、函数g、函数f、py文件。因为每一个栈帧对应一个traceback，而且是按照顺序遍历的，所以是：.py文件、函数f、g、h的顺序，当然从打印这一点也能看出来。</strong></p>
<blockquote>
<p><strong>因为是在函数h中报的错，所以退到函数g的栈帧中寻找异常捕获；如果retval为NULL，那么在退到函数f的栈帧中寻找异常捕获，再没有的话则退到模块对应的栈帧中。</strong></p>
<p><strong>模块中也没有异常捕获，那么报错。所以获取模块栈帧对应的traceback，打印异常信息，然后通过tb_next找到 *f*  对应的traceback打印其信息，依次下去……。事实上稍微想一下就能理解，虽然是在 *h* 中报的错，但根本原因是我们在模块中调用了 *f*，所以依次打印模块、f、g、h中traceback的异常信息。</strong></p>
</blockquote>
<h4 id="Python中的异常捕获"><a href="#Python中的异常捕获" class="headerlink" title="Python中的异常捕获"></a>Python中的异常捕获</h4><p><strong>目前我们知道了Python中的异常在虚拟机级别是什么，抛出异常这个动作在虚拟机层面上是怎样的一个行为，最后我们还知道了Python在处理异常时候的栈帧展开行为。但这只是Python虚拟机中内建的处理异常的动作，并没有使用Python语言中提供的异常捕获，下面我们就来看一下Python提供的异常捕获机制是如何影响Python虚拟机的异常处理流程的。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">try:</span></span><br><span class="line"><span class="string">    raise Exception(&quot;raise an exception&quot;)</span></span><br><span class="line"><span class="string">except Exception as e:</span></span><br><span class="line"><span class="string">    print(e)</span></span><br><span class="line"><span class="string">finally:</span></span><br><span class="line"><span class="string">    print(&quot;finally code&quot;)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">import</span> dis</span><br><span class="line">    dis.dis(<span class="built_in">compile</span>(s, <span class="string">&quot;exception&quot;</span>, <span class="string">&quot;exec&quot;</span>))</span><br><span class="line">  <span class="number">2</span>           <span class="number">0</span> SETUP_FINALLY           <span class="number">60</span> (to <span class="number">62</span>)</span><br><span class="line">              <span class="number">2</span> SETUP_FINALLY           <span class="number">12</span> (to <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">  <span class="number">3</span>           <span class="number">4</span> LOAD_NAME                <span class="number">1</span> (Exception)</span><br><span class="line">              <span class="number">6</span> LOAD_CONST               <span class="number">1</span> (<span class="string">&#x27;raise an exception&#x27;</span>)</span><br><span class="line">              <span class="number">8</span> CALL_FUNCTION            <span class="number">1</span></span><br><span class="line">             <span class="number">10</span> RAISE_VARARGS            <span class="number">1</span></span><br><span class="line">             <span class="number">12</span> POP_BLOCK</span><br><span class="line">             <span class="number">14</span> JUMP_FORWARD            <span class="number">42</span> (to <span class="number">58</span>)</span><br><span class="line"></span><br><span class="line">  <span class="number">4</span>     &gt;&gt;   <span class="number">16</span> DUP_TOP</span><br><span class="line">             <span class="number">18</span> LOAD_NAME                <span class="number">1</span> (Exception)</span><br><span class="line">             <span class="number">20</span> COMPARE_OP              <span class="number">10</span> (exception <span class="keyword">match</span>)</span><br><span class="line">             <span class="number">22</span> POP_JUMP_IF_FALSE       <span class="number">56</span></span><br><span class="line">             <span class="number">24</span> POP_TOP</span><br><span class="line">             <span class="number">26</span> STORE_NAME               <span class="number">2</span> (e)</span><br><span class="line">             <span class="number">28</span> POP_TOP</span><br><span class="line">             <span class="number">30</span> SETUP_FINALLY           <span class="number">12</span> (to <span class="number">44</span>)</span><br><span class="line"></span><br><span class="line">  <span class="number">5</span>          <span class="number">32</span> LOAD_NAME                <span class="number">0</span> (<span class="built_in">print</span>)</span><br><span class="line">             <span class="number">34</span> LOAD_NAME                <span class="number">2</span> (e)</span><br><span class="line">             <span class="number">36</span> CALL_FUNCTION            <span class="number">1</span></span><br><span class="line">             <span class="number">38</span> POP_TOP</span><br><span class="line">             <span class="number">40</span> POP_BLOCK</span><br><span class="line">             <span class="number">42</span> BEGIN_FINALLY</span><br><span class="line">        &gt;&gt;   <span class="number">44</span> LOAD_CONST               <span class="number">2</span> (<span class="literal">None</span>)</span><br><span class="line">             <span class="number">46</span> STORE_NAME               <span class="number">2</span> (e)</span><br><span class="line">             <span class="number">48</span> DELETE_NAME              <span class="number">2</span> (e)</span><br><span class="line">             <span class="number">50</span> END_FINALLY</span><br><span class="line">             <span class="number">52</span> POP_EXCEPT</span><br><span class="line">             <span class="number">54</span> JUMP_FORWARD             <span class="number">2</span> (to <span class="number">58</span>)</span><br><span class="line">        &gt;&gt;   <span class="number">56</span> END_FINALLY</span><br><span class="line">        &gt;&gt;   <span class="number">58</span> POP_BLOCK</span><br><span class="line">             <span class="number">60</span> BEGIN_FINALLY</span><br><span class="line"></span><br><span class="line">  <span class="number">7</span>     &gt;&gt;   <span class="number">62</span> LOAD_NAME                <span class="number">0</span> (<span class="built_in">print</span>)</span><br><span class="line">             <span class="number">64</span> LOAD_CONST               <span class="number">0</span> (<span class="string">&#x27;finally code&#x27;</span>)</span><br><span class="line">             <span class="number">66</span> CALL_FUNCTION            <span class="number">1</span></span><br><span class="line">             <span class="number">68</span> POP_TOP</span><br><span class="line">             <span class="number">70</span> END_FINALLY</span><br><span class="line">             <span class="number">72</span> LOAD_CONST               <span class="number">2</span> (<span class="literal">None</span>)</span><br><span class="line">             <span class="number">74</span> RETURN_VALUE</span><br></pre></td></tr></table></figure>

<p><strong>首先这个指令集比较复杂，因为要分好几种情况。try里面没有出现异常；try里面出现了异常、但是except语句没有捕获到；try里面出现了异常，except语句捕获到了。但我们知道无论是哪种情况，都要执行finally。</strong></p>
<p><strong>我们先看上面的SETUP_FINALLY指令，这里为包含finally语句做准备的：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">case</span> <span class="title function_">TARGET</span><span class="params">(SETUP_FINALLY)</span>: &#123;</span><br><span class="line">            <span class="comment">/* <span class="doctag">NOTE:</span> If you add any new block-setup opcodes that</span></span><br><span class="line"><span class="comment">               are not try/except/finally handlers, you may need</span></span><br><span class="line"><span class="comment">               to update the PyGen_NeedsFinalizing() function.</span></span><br><span class="line"><span class="comment">               */</span></span><br><span class="line">            <span class="comment">//我们看到仅仅是调用了一个PyFrame_BlockSetup函数</span></span><br><span class="line">            PyFrame_BlockSetup(f, SETUP_FINALLY, INSTR_OFFSET() + oparg,</span><br><span class="line">                               STACK_LEVEL());</span><br><span class="line">            DISPATCH();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Objects/frameobject.c</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">PyFrame_BlockSetup</span><span class="params">(PyFrameObject *f, <span class="type">int</span> type, <span class="type">int</span> handler, <span class="type">int</span> level)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//创建一个PyTryBlock *</span></span><br><span class="line">    PyTryBlock *b;</span><br><span class="line">    <span class="comment">//这个f_iblock为当前指令在f_blockstack上的索引, 还记得这个f_blockstack吗?我们在介绍栈帧的时候说过的,它可以用于try代码块</span></span><br><span class="line">    <span class="comment">//f_blockstack是一个数组, 内部存储了多个PyTryBlock对象</span></span><br><span class="line">    <span class="comment">//PyTryBlock f_blockstack[CO_MAXBLOCKS]; CO_MAXBLOCKS是一个宏，为20</span></span><br><span class="line">    <span class="keyword">if</span> (f-&gt;f_iblock &gt;= CO_MAXBLOCKS)</span><br><span class="line">        Py_FatalError(<span class="string">&quot;XXX block stack overflow&quot;</span>);</span><br><span class="line">    <span class="comment">//这里我们算是真正意义上第一次使用栈帧中的f_blockstack属性</span></span><br><span class="line">    <span class="comment">//这里得到的b显然是个PyTryBlock结构体实例</span></span><br><span class="line">    b = &amp;f-&gt;f_blockstack[f-&gt;f_iblock++];</span><br><span class="line">    <span class="comment">//设置属性</span></span><br><span class="line">    b-&gt;b_type = type;</span><br><span class="line">    b-&gt;b_level = level;</span><br><span class="line">    b-&gt;b_handler = handler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//frameobject.h</span></span><br><span class="line"><span class="comment">//我们看看PyTryBlock长什么样</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> b_type;                 <span class="comment">/* what kind of block this is */</span></span><br><span class="line">    <span class="type">int</span> b_handler;              <span class="comment">/* where to jump to find handler */</span></span><br><span class="line">    <span class="type">int</span> b_level;                <span class="comment">/* value stack level to pop to */</span></span><br><span class="line">&#125; PyTryBlock;</span><br><span class="line"><span class="comment">//显然PyFrameObject对象中的f_blockstack是一个由PyTryBlock对象组成的数组，而SETUP_FINALLY指令所做的就是从这个数组中获得了一块PyTryBlock对象</span></span><br><span class="line"><span class="comment">//并在这个对象中存放了一些Python虚拟机当前的状态信息。比如当前执行的字节码指令，当前运行时栈的深度等等。</span></span><br><span class="line"><span class="comment">//那么这个结构在try控制结构中起着什么样的作用呢？我们后面就会知晓</span></span><br><span class="line"><span class="comment">//我们注意到PyTryBlock中有一个b_type域，注释写着这个域是用来表示是block的种类, 也就意味着存在着多种不同用途的PyTryBlock对象。</span></span><br><span class="line"><span class="comment">//从PyFrame_BlockSetup中可以看到，这个b_type实际上被设置为当前Python虚拟机正在执行的字节码指令，以字节码指令作为区分PyTryBlock的不同用途</span></span><br></pre></td></tr></table></figure>

<p><strong>但我们看到开头有两个SETUP_FINALLY，其实在Python3.8之前，第二个SETUP_FINALLY应该是SETUP_EXCEPT，但是在3.8中都变成了SETUP_FINALLY。</strong></p>
<p><img src="/2023/04/02/13-%E5%89%96%E6%9E%90Python%E7%9A%84%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/1229382-20200821012542306-595809675.png" alt="img"></p>
<p><strong>在这里分出两块PyTryBlock，肯定是要在捕捉异常的时候用。不过别着急，我们先回到抛出异常的地方看看：<code>10 RAISE_VARARGS 1</code>。在<code>RAISE_VARARGS</code>之前，通过<code>LOAD_NAME</code>、<code>LOAD_CONST</code>、<code>CALL_FUNCTION</code>构造出了一个异常对象，当然尽管Exception是一个类，但调用的指令也同样是CALL_FUNCTION<code>(至于这个指令的剖析和对象的创建后面章节会介绍，这里只需要知道一个异常已经被创建出来了)</code>，并将这个异常压入栈中。而<code>RAISE_VARARGS</code>指令的工作就从把这个异常对象从运行时栈取出开始。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="title function_">TARGET</span><span class="params">(RAISE_VARARGS)</span>: &#123;</span><br><span class="line">    PyObject *cause = <span class="literal">NULL</span>, *exc = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">switch</span> (oparg) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        cause = POP(); <span class="comment">/* cause */</span></span><br><span class="line">        <span class="comment">/* fall through */</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        exc = POP(); <span class="comment">/* exc */</span></span><br><span class="line">        <span class="comment">/* fall through */</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> (do_raise(tstate, exc, cause)) &#123;</span><br><span class="line">            <span class="keyword">goto</span> exception_unwind;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        _PyErr_SetString(tstate, PyExc_SystemError,</span><br><span class="line">                         <span class="string">&quot;bad RAISE_VARARGS oparg&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">goto</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这里RAISE_VARARGS后面的参数是1，所以直接将异常对象取出赋给exc，然后调用do_raise函数。在do_raise中，最终调用之前的说过的<code>PyErr_Restore</code>函数，将异常对象存储到当前的线程对象中。在经过了一系列繁复的动作之后<code>(比如创建并设置traceback)</code>，通过do_raise，Python虚拟机将携带着<code>(f_iblock=2)</code>信息抵达真正捕捉异常的代码，我们看到跳转到了标签为exception_unwind的地方进行异常捕获，并且在最后，Python虚拟机通过一个break的动作跳出了分发字节码指令的那个巨大的switch语句所在的for循环。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">exception_unwind:</span><br><span class="line">        <span class="comment">/* Unwind stacks if an exception occurred */</span></span><br><span class="line">        <span class="keyword">while</span> (f-&gt;f_iblock &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            PyTryBlock *b = &amp;f-&gt;f_blockstack[--f-&gt;f_iblock];</span><br><span class="line">            <span class="keyword">if</span> (b-&gt;b_type == SETUP_FINALLY) &#123;</span><br><span class="line">                PyObject *exc, *val, *tb;</span><br><span class="line">                <span class="type">int</span> handler = b-&gt;b_handler;</span><br><span class="line">                _PyErr_StackItem *exc_info = tstate-&gt;exc_info;</span><br><span class="line">                <span class="comment">/* Beware, this invalidates all b-&gt;b_* fields */</span></span><br><span class="line">                PyFrame_BlockSetup(f, EXCEPT_HANDLER, <span class="number">-1</span>, STACK_LEVEL());</span><br><span class="line">                PUSH(exc_info-&gt;exc_traceback);</span><br><span class="line">                PUSH(exc_info-&gt;exc_value);</span><br><span class="line">                <span class="keyword">if</span> (exc_info-&gt;exc_type != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    PUSH(exc_info-&gt;exc_type);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    Py_INCREF(Py_None);</span><br><span class="line">                    PUSH(Py_None);</span><br><span class="line">                &#125;</span><br><span class="line">                _PyErr_Fetch(tstate, &amp;exc, &amp;val, &amp;tb);</span><br><span class="line">                <span class="comment">/* Make the raw exception data</span></span><br><span class="line"><span class="comment">                   available to the handler,</span></span><br><span class="line"><span class="comment">                   so a program can emulate the</span></span><br><span class="line"><span class="comment">                   Python main loop. */</span></span><br><span class="line">                _PyErr_NormalizeException(tstate, &amp;exc, &amp;val, &amp;tb);</span><br><span class="line">                <span class="keyword">if</span> (tb != <span class="literal">NULL</span>)</span><br><span class="line">                    PyException_SetTraceback(val, tb);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    PyException_SetTraceback(val, Py_None);</span><br><span class="line">                Py_INCREF(exc);</span><br><span class="line">                exc_info-&gt;exc_type = exc;</span><br><span class="line">                Py_INCREF(val);</span><br><span class="line">                exc_info-&gt;exc_value = val;</span><br><span class="line">                exc_info-&gt;exc_traceback = tb;</span><br><span class="line">                <span class="keyword">if</span> (tb == <span class="literal">NULL</span>)</span><br><span class="line">                    tb = Py_None;</span><br><span class="line">                Py_INCREF(tb);</span><br><span class="line">                PUSH(tb);</span><br><span class="line">                PUSH(val);</span><br><span class="line">                PUSH(exc);</span><br><span class="line">                JUMPTO(handler);</span><br><span class="line">                <span class="comment">/* Resume normal execution */</span></span><br><span class="line">                <span class="keyword">goto</span> main_loop;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="comment">/* unwind stack */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* End the loop as we still have an error */</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="comment">/* main loop */</span></span><br><span class="line"></span><br><span class="line">    assert(retval == <span class="literal">NULL</span>);</span><br><span class="line">    assert(_PyErr_Occurred(tstate));</span><br></pre></td></tr></table></figure>

<p><strong>Python虚拟机首先从当前的<code>PyFrameObject</code>对象中的<code>f_blockstack</code>中弹出一个<code>PyTryBlock</code>来，从代码中能看到弹出的是<code>b_type = SETUP_FINALLY, b_handler=16</code>的PyTryBlock。另一方面，Python虚拟机通过<code>PyErr_Fetch</code>得到了当前线程状态对象中存储的最新的异常对象和traceback对象：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Python/errors.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">PyErr_Fetch</span><span class="params">(PyObject **p_type, PyObject **p_value, PyObject **p_traceback)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyThreadState *tstate = _PyThreadState_GET();</span><br><span class="line">    _PyErr_Fetch(tstate, p_type, p_value, p_traceback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line">_PyErr_Fetch(PyThreadState *tstate, PyObject **p_type, PyObject **p_value,</span><br><span class="line">             PyObject **p_traceback)</span><br><span class="line">&#123;</span><br><span class="line">    *p_type = tstate-&gt;curexc_type;</span><br><span class="line">    *p_value = tstate-&gt;curexc_value;</span><br><span class="line">    *p_traceback = tstate-&gt;curexc_traceback;</span><br><span class="line"></span><br><span class="line">    tstate-&gt;curexc_type = <span class="literal">NULL</span>;</span><br><span class="line">    tstate-&gt;curexc_value = <span class="literal">NULL</span>;</span><br><span class="line">    tstate-&gt;curexc_traceback = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>回到exception_unwind，我们看到之后python虚拟机调用PUSH将tb、val、exc分别压入运行时栈中，而且Python知道此时程序猿已经为异常处理做好了准备，所以接下来的异常处理工作，则需要交给程序员指定的代码来解决，这个动作通过JUMP_FORWARD<code>(JUMPTO(b-&gt;b_handler))</code>来完成。JUMPTO其实仅仅是进行了一下指令的跳跃，将Python虚拟机将要执行的下一条指令设置为异常处理代码编译后所得到的第一条字节码指令。</strong></p>
<p><strong>因为f_blockstack是从后往前弹出的，所以第一个弹出的是PyTryBlock中b_handler为16的SETUP_FINALLY，那么Python虚拟机将要执行的下一条指令就是偏移量为16的那条指令，而这条指令就是DUP_TOP，异常处理代码对应的第一条字节码指令。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="title function_">TARGET</span><span class="params">(DUP_TOP)</span>: &#123;</span><br><span class="line">    PyObject *top = TOP();</span><br><span class="line">    Py_INCREF(top);</span><br><span class="line">    PUSH(top);</span><br><span class="line">    FAST_DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>首先我们<code>except Exception</code>，毫无疑问要LOAD_NAME，把这个异常给load进来，然后调用指令COMPARE_OP，这个显然就是比较我们指定捕获的异常和运行时栈中存在的那个被捕获的异常是否匹配。POP_JUMP_IF_FALSE如果为Py_True表示匹配，那么继续往下执行print(e)对应的字节码指令，POP_TOP将异常从栈顶弹出，赋值给e，然后打印等等。如果POP_JUMP_IF_FALSE为Py_False表示不匹配，那么我们发现直接跳转到了<code>56 END_FINALLY</code>，因为异常不匹配的话，那么异常的相关信息还是要重新放回线程对象当中，让Python重新引发异常，而这个动作就由END_FINALLY完成，通过PyErr_Restore函数将异常信息重新写回线程对象中。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="title function_">TARGET</span><span class="params">(END_FINALLY)</span>: &#123;</span><br><span class="line">    PREDICTED(END_FINALLY);</span><br><span class="line">    <span class="comment">/* At the top of the stack are 1 or 6 values:</span></span><br><span class="line"><span class="comment">       Either:</span></span><br><span class="line"><span class="comment">        - TOP = NULL or an integer</span></span><br><span class="line"><span class="comment">       or:</span></span><br><span class="line"><span class="comment">        - (TOP, SECOND, THIRD) = exc_info()</span></span><br><span class="line"><span class="comment">        - (FOURTH, FITH, SIXTH) = previous exception for EXCEPT_HANDLER</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    PyObject *exc = POP();</span><br><span class="line">    <span class="keyword">if</span> (exc == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        FAST_DISPATCH();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (PyLong_CheckExact(exc)) &#123;</span><br><span class="line">        <span class="type">int</span> ret = _PyLong_AsInt(exc);</span><br><span class="line">        Py_DECREF(exc);</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">-1</span> &amp;&amp; _PyErr_Occurred(tstate)) &#123;</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">        &#125;</span><br><span class="line">        JUMPTO(ret);</span><br><span class="line">        FAST_DISPATCH();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        assert(PyExceptionClass_Check(exc));</span><br><span class="line">        PyObject *val = POP();</span><br><span class="line">        PyObject *tb = POP();</span><br><span class="line">        <span class="comment">//将异常信息又写入到了线程状态对象当中了</span></span><br><span class="line">        _PyErr_Restore(tstate, exc, val, tb);</span><br><span class="line">        <span class="keyword">goto</span> exception_unwind;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>然而不管异常是否匹配，最终处理异常的两条岔路都会在<code>58 POP_BLOCK</code>处汇合。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PREDICTED(POP_BLOCK);</span><br><span class="line">TARGET(POP_BLOCK) &#123;</span><br><span class="line">    <span class="comment">//这里将当前PyFrameObject的f_blockstack中还剩下的那个与SETUP_FINALLY对应的PyTryBlock对象弹出</span></span><br><span class="line">    <span class="comment">//然后python虚拟机的流程就进入了与finally表达式对应的字节码指令了。</span></span><br><span class="line">    PyTryBlock *b = PyFrame_BlockPop(f);</span><br><span class="line">    UNWIND_BLOCK(b);</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>因此在Python异常机制的实现中，最终要的就是虚拟机状态以及PyFrameObject对象中f_blockstack里存放的PyTryBlock对象了。首先根据Python虚拟机状态可以判断当前是否发生了异常，而PyTryBlock对象则告诉python虚拟机，程序员是否为异常设置了except代码块和finally代码块，python虚拟机异常处理的流程就是在虚拟机所处的状态和PyTryBlock的共同作用下完成的。</strong></p>
<blockquote>
<p><strong>还是那句话，在3.8之前Python的指令集中存在一个SETUP_EXCEPT，但是在3.8的时候只有SETUP_FINALLY了。</strong></p>
</blockquote>
<p><img src="/2023/04/02/13-%E5%89%96%E6%9E%90Python%E7%9A%84%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/1229382-20200821012551427-2065530599.png" alt="img"></p>
<p><strong>总之Python中一旦出现异常了，那么会将异常类型、异常值、异常回溯栈设置在线程状态对象中，然后栈帧一步一步的后退寻找异常捕获代码<code>(从内向外)</code>。如果退到了模块级别还没有发现异常捕获，那么从外向内打印traceback中的信息，当走到最后一层的时候再将线程中设置的异常类型和异常值打印出来。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">h</span>():</span><br><span class="line">    <span class="number">1</span> / <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">g</span>():</span><br><span class="line">    h()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line">    g()</span><br><span class="line">    </span><br><span class="line">f()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 首先是在模块中调用了f、f调用了g、g调用了h, 所以在h中出现了异常、发现又没有异常捕获, 所以将执行权交给函数g对应的栈帧</span></span><br><span class="line"><span class="comment"># 但是g也没有异常捕获, 所以再将执行权交给函数f对应的栈帧, 所以调用的时候栈帧一层一层创建, 执行完毕、或者出现异常, 栈帧一层一层向后退</span></span><br><span class="line"><span class="comment"># 所以h的f_back指向g、g的f_back指向f、f的f_back指向模块、模块的f_back为None</span></span><br><span class="line"><span class="comment"># 但是对应的traceback则是模块的tb_next指向f、f的tb_next指向g、g的tb_next指向h、h的tb_next为None</span></span><br><span class="line"><span class="comment"># 而我们说栈帧层层后退, 退到模块对应的栈帧的时候要是还没有发现异常捕获, 那么就报错了</span></span><br><span class="line"><span class="comment"># 所以此时会打印模块对应的traceback的信息, 然后依次是f、g、h, 因为栈帧是从&quot;函数h到模块&quot;、但traceback则是从&quot;模块到函数h&quot;</span></span><br><span class="line"><span class="comment"># 所以我们仔细观察一下输出的异常信息, 不难印证我们的结论</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Traceback (most recent call last):  # traceback回溯栈</span></span><br><span class="line"><span class="string">  File &quot;D:/satori/1.py&quot;, line 13, in &lt;module&gt;  # 打印模块的traceback</span></span><br><span class="line"><span class="string">    f()</span></span><br><span class="line"><span class="string">  File &quot;D:/satori/1.py&quot;, line 10, in f  # 打印f的traceback</span></span><br><span class="line"><span class="string">    g()</span></span><br><span class="line"><span class="string">  File &quot;D:/satori/1.py&quot;, line 6, in g   # 打印g的traceback</span></span><br><span class="line"><span class="string">    h()</span></span><br><span class="line"><span class="string">  File &quot;D:/satori/1.py&quot;, line 2, in h   # 打印h的traceback</span></span><br><span class="line"><span class="string">    1 / 0</span></span><br><span class="line"><span class="string">ZeroDivisionError: division by zero  # h的tb_next为None, 证明是在h中发生了错误, 所以再将之前设置线程状态对象中异常类型和异常值打印出来即可</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>至于Python在处理异常的时候都经历哪些历程，我们虽然分析了，但其实还不够详细。因为Python的异常机制牵扯到底层的方方面面，并且涉及到了很多的宏，有兴趣可以自己再仔细深入研究。另外需要注意的是：Python3.8变化还是比较大的，在字节码方面你通过和3.7对比就可以发现。</strong></p>
<p>​        <strong>最后再看一个思考题</strong>    </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">e = <span class="number">2.718</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">&quot;我要引发异常了&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># 我要引发异常了</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(e)</span><br><span class="line"><span class="comment"># NameError: name &#x27;e&#x27; is not defined</span></span><br></pre></td></tr></table></figure>

<p><strong>why？我们发现在外面打印e的时候，告诉我们e没有被定义。这是为什么呢？首先可以肯定的是，肯定是<code>except Exception as e</code>导致的，因为我们as的也是e，和外面的e重名了，如果我们as的是e1呢？</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">e = <span class="number">2.718</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">&quot;我要引发异常了&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e1:</span><br><span class="line">    <span class="built_in">print</span>(e1)  <span class="comment"># 我要引发异常了</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(e)  <span class="comment"># 2.718</span></span><br></pre></td></tr></table></figure>

<p><strong>可以看到as的是e1就没有问题了，但是为什么呢？即便不知道原因，也能推测出来。因为外面的变量叫e，而我们捕获异常as的也是e，此时e的指向就变了，而当异常处理结束的时候，e这个变量就被销毁了，所以外面就找不到了。然而事实上也确实如此。我们可以看一下字节码，通过观察我们上面例子的字节码，就能很清晰地看出端倪了。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>           <span class="number">0</span> LOAD_CONST               <span class="number">0</span> (<span class="number">2.718</span>)</span><br><span class="line">            <span class="number">2</span> STORE_NAME               <span class="number">0</span> (e)</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>           <span class="number">4</span> SETUP_FINALLY           <span class="number">12</span> (to <span class="number">18</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>           <span class="number">6</span> LOAD_NAME                <span class="number">1</span> (Exception)</span><br><span class="line">            <span class="number">8</span> LOAD_CONST               <span class="number">1</span> (<span class="string">&#x27;我要引发异常了&#x27;</span>)</span><br><span class="line">           <span class="number">10</span> CALL_FUNCTION            <span class="number">1</span></span><br><span class="line">           <span class="number">12</span> RAISE_VARARGS            <span class="number">1</span></span><br><span class="line">           <span class="number">14</span> POP_BLOCK</span><br><span class="line">           <span class="number">16</span> JUMP_FORWARD            <span class="number">42</span> (to <span class="number">60</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>     &gt;&gt;   <span class="number">18</span> DUP_TOP</span><br><span class="line">           <span class="number">20</span> LOAD_NAME                <span class="number">1</span> (Exception)</span><br><span class="line">           <span class="number">22</span> COMPARE_OP              <span class="number">10</span> (exception match)</span><br><span class="line">           <span class="number">24</span> POP_JUMP_IF_FALSE       <span class="number">58</span></span><br><span class="line">           <span class="number">26</span> POP_TOP</span><br><span class="line">           <span class="number">28</span> STORE_NAME               <span class="number">0</span> (e)</span><br><span class="line">           <span class="number">30</span> POP_TOP</span><br><span class="line">           <span class="number">32</span> SETUP_FINALLY           <span class="number">12</span> (to <span class="number">46</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>          <span class="number">34</span> LOAD_NAME                <span class="number">2</span> (print)</span><br><span class="line">           <span class="number">36</span> LOAD_NAME                <span class="number">0</span> (e)</span><br><span class="line">           <span class="number">38</span> CALL_FUNCTION            <span class="number">1</span></span><br><span class="line">           <span class="number">40</span> POP_TOP</span><br><span class="line">           <span class="number">42</span> POP_BLOCK</span><br><span class="line">           <span class="number">44</span> BEGIN_FINALLY</span><br><span class="line">      &gt;&gt;   <span class="number">46</span> LOAD_CONST               <span class="number">2</span> (None)</span><br><span class="line">           <span class="number">48</span> STORE_NAME               <span class="number">0</span> (e)</span><br><span class="line">           <span class="number">50</span> DELETE_NAME              <span class="number">0</span> (e)</span><br><span class="line">           <span class="number">52</span> END_FINALLY</span><br><span class="line">           <span class="number">54</span> POP_EXCEPT</span><br><span class="line">           <span class="number">56</span> JUMP_FORWARD             <span class="number">2</span> (to <span class="number">60</span>)</span><br><span class="line">      &gt;&gt;   <span class="number">58</span> END_FINALLY</span><br><span class="line">      &gt;&gt;   <span class="number">60</span> LOAD_CONST               <span class="number">2</span> (None)</span><br><span class="line">           <span class="number">62</span> RETURN_VALUE</span><br></pre></td></tr></table></figure>

<p><strong>字节码很长，但是我们只需要看偏移量为50的那个字节码即可。你看到了什么，<code>DELETE_NAME</code>直接把e这个变量给删了，所以我们就找不到了，因此代码相当于下面这样：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">e = <span class="number">2.718</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">&quot;我要引发异常了&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span>(e)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="keyword">del</span> e</span><br></pre></td></tr></table></figure>

<p><strong>因此在异常处理的时候，如果把异常赋予了一个变量，那么这个变量异常处理结束会被删掉，因此只能在except里面使用，这就是原因。但是原因有了，可动机呢？Python这么做的动机是什么？根据官网文档解释：</strong></p>
<blockquote>
<p><strong>当使用 as 将目标赋值为一个异常时，它将在 except  子句结束时被清除，这意味着异常必须赋值给一个不同的名称(不同于外部指定的变量)，才能在 except  子句之后引用它(外部指定的变量)。异常会被清除是因为在附加了回溯信息的情况下，它们会形成堆栈帧的循环引用，使得所有局部变量保持存活直到发生下一次垃圾回收。</strong></p>
</blockquote>
<p>​        <strong>try、except、finally的返回值问题</strong>    </p>
<p><strong>我们看看这三者的返回值之间的关系：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">456</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 由于没有发生异常, 所以返回了try指定的返回值</span></span><br><span class="line"><span class="built_in">print</span>(f1())  <span class="comment"># 123</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f2</span>():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="number">1</span> / <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">456</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时发生异常, 所以返回了except指定的返回值</span></span><br><span class="line"><span class="built_in">print</span>(f2())  <span class="comment"># 456</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f3</span>():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">456</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回的还是try指定的返回值, 因为finally中没有指定返回值</span></span><br><span class="line"><span class="built_in">print</span>(f3())  <span class="comment"># 123</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f4</span>():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">456</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 一旦finally中出现了return, 那么在没有报错的情况下返回的都是finally指定的返回值</span></span><br><span class="line"><span class="built_in">print</span>(f4())  <span class="comment"># None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f5</span>():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">456</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">789</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们函数一旦出现了return, 那么就表示结束函数直接返回了</span></span><br><span class="line"><span class="comment"># 但是return如果是在try中, 那么可以认为将返回值存起来了, 执行完finally之后再返回</span></span><br><span class="line"><span class="comment"># 如果finally也指定了return, 那么会返回finally指定的返回值, 否则还是返回之前的</span></span><br><span class="line"><span class="comment"># 总之一句话, 只要在try或者except中出现了return(前提是没有异常、或者异常被成功捕获)</span></span><br><span class="line"><span class="comment"># 那么在finally执行完毕之后, 会立即返回, 不会执行finally下面的代码</span></span><br><span class="line"><span class="built_in">print</span>(f5())  <span class="comment"># 123</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f6</span>():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">456</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">789</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 没有异常, 所以except的return没啥卵用, 但是try和finally中也没有return</span></span><br><span class="line"><span class="comment"># 所以程序会继续往下走</span></span><br><span class="line"><span class="built_in">print</span>(f6())  <span class="comment"># 789</span></span><br></pre></td></tr></table></figure>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><strong>这一次我们就分析了Python的控制语句，if、for、while都比较简单。但Python中的异常捕获算是比较复杂的，主要是牵扯的东西比较多，有时候分析某一个地方需要跳好几个源文件，进行查找。因此有兴趣的话，可以杀进源码中自由翱翔，但是注意Python的版本，我们说3.8版本和3.8之前的版本之间区别还是蛮大的。</strong></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Lin Li</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/04/02/13-%E5%89%96%E6%9E%90Python%E7%9A%84%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/">http://example.com/2023/04/02/13-%E5%89%96%E6%9E%90Python%E7%9A%84%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">LinLi's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/CPython/">CPython</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/04/02/14-%E5%87%BD%E6%95%B0%E5%9C%A8%E5%BA%95%E5%B1%82%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BB%A5%E5%8F%8A%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F/" title="14-函数在底层的数据结构以及创建方式"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">14-函数在底层的数据结构以及创建方式</div></div></a></div><div class="next-post pull-right"><a href="/2023/03/29/12-%E5%89%96%E6%9E%90%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4/" title="12-剖析字节码指令"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">12-剖析字节码指令</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/03/29/01-%E7%BC%96%E8%AF%91Cpython/" title="01-编译Cpython"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">01-编译Cpython</div></div></a></div><div><a href="/2023/03/29/02-%E4%B8%80%E5%88%87%E5%AF%B9%E8%B1%A1%E7%9A%86PyObject/" title="02-一切对象皆PyObject"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">02-一切对象皆PyObject</div></div></a></div><div><a href="/2023/03/29/04-%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/" title="04-浮点数的底层实现"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">04-浮点数的底层实现</div></div></a></div><div><a href="/2023/03/29/06-Bytes%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BA%95%E5%B1%82%E6%93%8D%E4%BD%9C/" title="06-Bytes对象的底层操作"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">06-Bytes对象的底层操作</div></div></a></div><div><a href="/2023/03/29/03-Python%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E5%99%A8%E5%92%8C%E5%BA%95%E5%B1%82%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86/" title="03-Python引用计数器和底层对象管理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">03-Python引用计数器和底层对象管理</div></div></a></div><div><a href="/2023/03/29/05-Python%E6%95%B4%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/" title="05-Python整数的底层实现"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">05-Python整数的底层实现</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Lin Li</div><div class="author-info__description">今日事，今日毕</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">63</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#13-%E5%89%96%E6%9E%90Python%E7%9A%84%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5%EF%BC%88if%E3%80%81for%E3%80%81while%EF%BC%89%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7%E6%9C%BA%E5%88%B6"><span class="toc-number">1.</span> <span class="toc-text">13-剖析Python的流程控制语句（if、for、while），以及异常捕获机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A5%94%E5%AD%90"><span class="toc-number">1.1.</span> <span class="toc-text">楔子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Python%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E7%9A%84if%E6%8E%A7%E5%88%B6%E6%B5%81"><span class="toc-number">1.2.</span> <span class="toc-text">Python虚拟机中的if控制流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#if%E5%AD%97%E8%8A%82%E7%A0%81"><span class="toc-number">1.2.1.</span> <span class="toc-text">if字节码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Python%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E7%9A%84for%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6%E6%B5%81"><span class="toc-number">1.3.</span> <span class="toc-text">Python虚拟机中的for循环控制流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#for%E5%AD%97%E8%8A%82%E7%A0%81"><span class="toc-number">1.3.1.</span> <span class="toc-text">for字节码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#list%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">1.3.2.</span> <span class="toc-text">list迭代器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E6%8E%A7%E5%88%B6"><span class="toc-number">1.3.3.</span> <span class="toc-text">迭代控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%88%E6%AD%A2%E8%BF%AD%E4%BB%A3"><span class="toc-number">1.3.4.</span> <span class="toc-text">终止迭代</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#python%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E7%9A%84while%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.</span> <span class="toc-text">python虚拟机中的while循环控制结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Python%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81"><span class="toc-number">1.5.</span> <span class="toc-text">Python虚拟机中的异常控制流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Python%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6"><span class="toc-number">1.5.1.</span> <span class="toc-text">Python中的异常机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Python%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7"><span class="toc-number">1.5.2.</span> <span class="toc-text">Python中的异常捕获</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">1.6.</span> <span class="toc-text">小结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/09/History-Driven-Build-Failure-Fixing-How-Far-Are-We/" title="History-Driven Build Failure Fixing: How Far Are We?">History-Driven Build Failure Fixing: How Far Are We?</a><time datetime="2023-07-09T07:58:11.000Z" title="发表于 2023-07-09 15:58:11">2023-07-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/09/HireBuild-An-Automatic-Approach-to-History-Driven-Repair-of-Build-Scripts/" title="HireBuild: An Automatic Approach to History-Driven Repair of Build Scripts">HireBuild: An Automatic Approach to History-Driven Repair of Build Scripts</a><time datetime="2023-07-09T07:57:05.000Z" title="发表于 2023-07-09 15:57:05">2023-07-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/07/Automated-API-Usage-Update-for-Android-Apps/" title="Automated API-Usage Update for Android Apps">Automated API-Usage Update for Android Apps</a><time datetime="2023-07-07T08:20:20.000Z" title="发表于 2023-07-07 16:20:20">2023-07-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/07/Automated-Deprecated-API-Usage-Update-for-Android-Apps-How-Far-Are-We/" title="Automated Deprecated-API Usage Update for Android Apps How Far Are We">Automated Deprecated-API Usage Update for Android Apps How Far Are We</a><time datetime="2023-07-07T08:19:22.000Z" title="发表于 2023-07-07 16:19:22">2023-07-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/06/28/AexPy-Detecting-API-Breaking-Changes-in-Python-Packages/" title="AexPy Detecting API Breaking Changes in Python Packages">AexPy Detecting API Breaking Changes in Python Packages</a><time datetime="2023-06-28T12:42:06.000Z" title="发表于 2023-06-28 20:42:06">2023-06-28</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Lin Li</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>