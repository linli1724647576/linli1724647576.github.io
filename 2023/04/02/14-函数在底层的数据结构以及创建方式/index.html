<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>14-函数在底层的数据结构以及创建方式 | LinLi's Blog</title><meta name="author" content="Lin Li"><meta name="copyright" content="Lin Li"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="14-函数在底层的数据结构、以及它的创建方式楔子函数是任何一门编程语言都具备的基本元素，它可以将多个动作组合起来，一个函数代表了一系列的动作。当然我们之前说函数也是一个变量，该变量指向一个函数。而且在调用函数时会干什么来着，没错，要在运行时栈中创建栈帧，用于函数的执行。 那么下面就来看看函数在C中是如何实现的，生得一副什么模样。 PyFunctionObject对象我们说过Python中一切皆对象">
<meta property="og:type" content="article">
<meta property="og:title" content="14-函数在底层的数据结构以及创建方式">
<meta property="og:url" content="http://example.com/2023/04/02/14-%E5%87%BD%E6%95%B0%E5%9C%A8%E5%BA%95%E5%B1%82%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BB%A5%E5%8F%8A%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F/index.html">
<meta property="og:site_name" content="LinLi&#39;s Blog">
<meta property="og:description" content="14-函数在底层的数据结构、以及它的创建方式楔子函数是任何一门编程语言都具备的基本元素，它可以将多个动作组合起来，一个函数代表了一系列的动作。当然我们之前说函数也是一个变量，该变量指向一个函数。而且在调用函数时会干什么来着，没错，要在运行时栈中创建栈帧，用于函数的执行。 那么下面就来看看函数在C中是如何实现的，生得一副什么模样。 PyFunctionObject对象我们说过Python中一切皆对象">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2023-04-02T08:18:50.000Z">
<meta property="article:modified_time" content="2023-04-12T02:38:30.601Z">
<meta property="article:author" content="Lin Li">
<meta property="article:tag" content="CPython">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/04/02/14-%E5%87%BD%E6%95%B0%E5%9C%A8%E5%BA%95%E5%B1%82%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BB%A5%E5%8F%8A%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '14-函数在底层的数据结构以及创建方式',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-04-12 10:38:30'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">106</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="LinLi's Blog"><span class="site-name">LinLi's Blog</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">14-函数在底层的数据结构以及创建方式</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-04-02T08:18:50.000Z" title="发表于 2023-04-02 16:18:50">2023-04-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-04-12T02:38:30.601Z" title="更新于 2023-04-12 10:38:30">2023-04-12</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="14-函数在底层的数据结构以及创建方式"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="14-函数在底层的数据结构、以及它的创建方式"><a href="#14-函数在底层的数据结构、以及它的创建方式" class="headerlink" title="14-函数在底层的数据结构、以及它的创建方式"></a>14-函数在底层的数据结构、以及它的创建方式</h2><h3 id="楔子"><a href="#楔子" class="headerlink" title="楔子"></a>楔子</h3><p><strong>函数是任何一门编程语言都具备的基本元素，它可以将多个动作组合起来，一个函数代表了一系列的动作。当然我们之前说函数也是一个变量，该变量指向一个函数。而且在调用函数时会干什么来着，没错，要在运行时栈中创建栈帧，用于函数的执行。</strong></p>
<p><strong>那么下面就来看看函数在C中是如何实现的，生得一副什么模样。</strong></p>
<h3 id="PyFunctionObject对象"><a href="#PyFunctionObject对象" class="headerlink" title="PyFunctionObject对象"></a>PyFunctionObject对象</h3><p><strong>我们说过Python中一切皆对象，函数也不例外。在Python中，函数这种抽象机制是通过<code>PyFunctionObject</code>对象实现的，位于 *Include&#x2F;funcobject.h* 中。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_HEAD               <span class="comment">/* 头部信息, 不用多说 */</span></span><br><span class="line">    PyObject *func_code;        <span class="comment">/* 函数的PyCodeObject对象, 因为函数就是根据该PyCodeObject对象创建的 */</span></span><br><span class="line">    PyObject *func_globals;     <span class="comment">/* 函数的global名字空间 */</span></span><br><span class="line">    PyObject *func_defaults;    <span class="comment">/* 函数参数的默认值, 一个元组或者空 */</span></span><br><span class="line">    PyObject *func_kwdefaults;  <span class="comment">/* 只能通过关键字参数传递的&quot;参数&quot;和&quot;该参数的默认值&quot;, 一个字典或者空 */</span></span><br><span class="line">    PyObject *func_closure;     <span class="comment">/* 获取闭包对象 */</span></span><br><span class="line">    PyObject *func_doc;         <span class="comment">/* 函数的doc */</span></span><br><span class="line">    PyObject *func_name;        <span class="comment">/* 函数名 */</span></span><br><span class="line">    PyObject *func_dict;        <span class="comment">/* 属性字典, 一般为空 */</span></span><br><span class="line">    PyObject *func_weakreflist; <span class="comment">/* 弱引用列表 */</span></span><br><span class="line">    PyObject *func_module;      <span class="comment">/* 函数所在的模块 */</span></span><br><span class="line">    PyObject *func_annotations; <span class="comment">/* 函数参数的注解, 一个字典或者空 */</span></span><br><span class="line">    PyObject *func_qualname;    <span class="comment">/* 函数的全限定名, 我们后面会说它和func_name之间的区别 */</span></span><br><span class="line">    vectorcallfunc vectorcall;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Invariant:</span></span><br><span class="line"><span class="comment">     *     func_closure contains the bindings for func_code-&gt;co_freevars, so</span></span><br><span class="line"><span class="comment">     *     PyTuple_Size(func_closure) == PyCode_GetNumFree(func_code)</span></span><br><span class="line"><span class="comment">     *     (func_closure may be NULL if PyCode_GetNumFree(func_code) == 0).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125; PyFunctionObject;</span><br></pre></td></tr></table></figure>

<p><strong>PyFunctionObject的这些成员都是以func开头的，比如：func_name，但是我们在Python中获取的时候直接通过__name__获取即可。</strong></p>
<p><strong>func_code：函数的字节码</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">a, b, c</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">code = foo.__code__</span><br><span class="line"><span class="built_in">print</span>(code)  <span class="comment"># &lt;code object foo at 0x000001D250B9D3A0, file &quot;C:/Users/satori/Desktop/三无少女/2.py&quot;, line 1&gt;</span></span><br><span class="line"><span class="built_in">print</span>(code.co_varnames)  <span class="comment"># (&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;)</span></span><br></pre></td></tr></table></figure>

<p><strong>func_globals：global命名空间</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">a, b, c</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">name = <span class="string">&quot;夏色祭&quot;</span></span><br><span class="line"><span class="comment"># __globals__其实就是外部的global名字空间</span></span><br><span class="line"><span class="built_in">print</span>(foo.__globals__)  <span class="comment"># &#123;......, &#x27;name&#x27;: &#x27;夏色祭&#x27;&#125;</span></span><br><span class="line"><span class="built_in">print</span>(foo.__globals__ == <span class="built_in">globals</span>())  <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<p><strong>func_defaults：函数参数的默认值</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">name=<span class="string">&quot;夏色祭&quot;</span>, age=-<span class="number">1</span></span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印的是默认值</span></span><br><span class="line"><span class="built_in">print</span>(foo.__defaults__)  <span class="comment"># (&#x27;夏色祭&#x27;, -1)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bar</span>(): </span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 没有默认值的话, __defaults__为None</span></span><br><span class="line"><span class="built_in">print</span>(bar.__defaults__)  <span class="comment"># None</span></span><br></pre></td></tr></table></figure>

<p><strong>func_kwdefaults：只能通过关键字参数传递的”参数”和”该参数的默认值”</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">name=<span class="string">&quot;夏色祭&quot;</span>, age=-<span class="number">1</span></span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印是为None的, 这是因为虽然有默认值, 但是它并不要求必须通过关键字的方式传递</span></span><br><span class="line"><span class="built_in">print</span>(foo.__kwdefaults__)  <span class="comment"># None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果在前面加上一个*, 表示后面的参数就必须通过关键字的方式传递</span></span><br><span class="line"><span class="comment"># 因为如果不通过关键字的话, 那么无论多少个位置参数都会被*给吸收掉, 无论如何也不可能传递给name、age</span></span><br><span class="line"><span class="comment"># 我们经常会看到*args, 这是因为我们需要函数调用时传递过来的值, 所以可以通过args以元组的形式来拿到这些值</span></span><br><span class="line"><span class="comment"># 但是这里我们不需要, 我们只是希望后面的参数必须通过关键字参数传递, 因此前面写一个*即可</span></span><br><span class="line"><span class="comment"># 当然写*args或者其他的也可以, 但是我们用不到, 所以写一个*即可</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bar</span>(<span class="params">*, name=<span class="string">&quot;夏色祭&quot;</span>, age=-<span class="number">1</span></span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时就打印了默认值，因为这是只能通过kw(关键字)传递的参数的默认值</span></span><br><span class="line"><span class="built_in">print</span>(bar.__kwdefaults__)  <span class="comment"># &#123;&#x27;name&#x27;: &#x27;satori&#x27;, &#x27;age&#x27;: 16&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>func_closure：闭包对象</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    name = <span class="string">&quot;夏色祭&quot;</span></span><br><span class="line">    age = -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bar</span>():</span><br><span class="line">        <span class="keyword">nonlocal</span> name</span><br><span class="line">        <span class="keyword">nonlocal</span> age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bar</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看的是闭包里面nonlocal的值</span></span><br><span class="line"><span class="comment"># 这里有两个nonlocal，所以foo().__closure__是一个有两个元素的元组</span></span><br><span class="line"><span class="built_in">print</span>(foo().__closure__)  <span class="comment"># (&lt;cell at 0x000001FD1D3B02B0: int object at 0x00007FFDE559D660&gt;,</span></span><br><span class="line">                          <span class="comment"># &lt;cell at 0x000001FD1D42E310: str object at 0x000001FD1D3DA090&gt;)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(foo().__closure__[<span class="number">0</span>].cell_contents)  <span class="comment"># -1</span></span><br><span class="line"><span class="built_in">print</span>(foo().__closure__[<span class="number">1</span>].cell_contents)  <span class="comment"># 夏色祭</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意：查看闭包属性我们使用的是内层函数，不是外层的foo</span></span><br></pre></td></tr></table></figure>

<p><strong>func_doc：函数的文档</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">name, age</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    接收一个name和age，</span></span><br><span class="line"><span class="string">    返回一句话</span></span><br><span class="line"><span class="string">    my name is $name, age is $age</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;my name is <span class="subst">&#123;name&#125;</span>, age is <span class="subst">&#123;age&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(foo.__doc__)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    接收一个name和age，</span></span><br><span class="line"><span class="string">    返回一句话</span></span><br><span class="line"><span class="string">    my name is $name, age is $age</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>func_name：函数名</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">name, age</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(foo.__name__)  <span class="comment"># foo</span></span><br></pre></td></tr></table></figure>

<p><strong>func_dict：属性字典</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">name, age</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 一般函数的属性字典都会空，属性字典基本上在类里面使用</span></span><br><span class="line"><span class="built_in">print</span>(foo.__dict__)  <span class="comment"># &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>func_weakreflist：弱引用列表</strong></p>
<p><strong>Python无法获取这个属性，底层没有提供相应的接口。</strong></p>
<p><strong>func_module：函数所在的模块</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">name, age</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(foo.__module__)  <span class="comment"># __main__</span></span><br></pre></td></tr></table></figure>

<p><strong>func_annotations：注解</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">name: <span class="built_in">str</span>, age: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Python3.5的时候新增的语法</span></span><br><span class="line"><span class="built_in">print</span>(foo.__annotations__)  <span class="comment"># &#123;&#x27;name&#x27;: &lt;class &#x27;str&#x27;&gt;, &#x27;age&#x27;: &lt;class &#x27;int&#x27;&gt;&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>func_qualname：全限定名</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(foo.__name__, foo.__qualname__)  <span class="comment"># foo foo</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(A.foo.__name__, A.foo.__qualname__)  <span class="comment"># foo A.foo</span></span><br></pre></td></tr></table></figure>

<p><strong>在PyFunctionObject的定义中，我们看到一个func_code成员，指向了一个PyCodeObject对象，我们说函数就是根据这个PyCodeObject对象创建的。因为我们知道一个PyCodeObject对象是对一段代码的静态表示，Python编译器在将源代码进行编译之后，对里面的每一个代码块<code>(code block)</code>都会生成一个、并且是唯一一个PyCodeObject对象，这个PyCodeObject对象中包含了这个代码块中的一些静态信息，也就是可以从源代码中看到的信息。</strong></p>
<blockquote>
<p><strong>比如：某个函数对应的code block中有一个 name &#x3D; “夏色祭” 这样的表达式，那么符号”a”和对应的值1、以及它们之间的联系就是静态信息。这些信息会被静态存储起来，符号”a”会被存在符号表<code>co_varnames</code>中、值1会被存在常量池<code>co_consts</code>中、这两者之间是一个赋值，因此会有两条指令LOAD_CONSTS和STORE_FAST存在字节码指令序列<code>co_code</code>中。</strong></p>
<p><strong>这些信息是编译的时候就可以得到的，因此PyCodeObject对象是编译时候的结果。</strong></p>
</blockquote>
<p><strong>但是PyFunctionObject对象是何时产生的呢？实际上PyFunctionObject对象是Python代码在运行时动态产生的，更准确的说，是在执行一个def语句的时候创建的。</strong></p>
<blockquote>
<p><strong>当Python虚拟机在当前栈帧中执行字节码时发现了def语句，那么就代表发现了新的PyCodeObject对象，因为它们是可以层层嵌套的。所以虚拟机会根据这个PyCodeObject对象创建对应的PyFunctionObject对象，然后将函数名和函数体对应的PyFunctionObject对象组成键值对放在当前的local空间中。</strong></p>
<p><strong>显然在PyFunctionObject对象中，也会包含这些函数的静态信息，这些信息存储在func_code中，实际上，func_code一定会指向与函数对应的PyCodeObject对象。除此之外，PyFunctionObject对象中还包含了一些函数在执行时所必须的动态信息，即上下文信息。比如func_globals，就是函数在执行时关联的global作用域(globals)，说白了就是让你在局部变量找不到的时候能够找全局变量，可如果连global空间都没有的话，那即便想找也无从下手呀。而global作用域中的符号和值必须在运行时才能确定，所以这部分必须在运行时动态创建，无法存储在PyCodeObject中，所以要根据PyCodeObject对象创建PyFunctionObject对象，相当于一个封装。总之一切的目的，都是为了更好的执行字节码。</strong></p>
</blockquote>
<p><strong>我们举个栗子：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先虚拟机从上到下执行字节码</span></span><br><span class="line">name = <span class="string">&quot;夏色祭&quot;</span></span><br><span class="line">age = -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># pia, 出现了一个def</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 那么知道源代码进入了一个新的作用域了, 这里遇到一个新的PyCodeObject对象了</span></span><br><span class="line"><span class="comment"># 而通过def知道这是一个函数, 所以会进行封装, 将PyCodeObject对象封装成PyFunctionObject</span></span><br><span class="line"><span class="comment"># 所以当执行完def语句之后, 一个函数就被创建了, 放在当前的local空间中, 当然对于模块来说: local空间也是global空间</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">locals</span>())  <span class="comment"># &#123;......, &#x27;foo&#x27;: &lt;function foo at 0x000001B299FAF3A0&gt;&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数的类型是&lt;class &#x27;function&#x27;&gt;, 当然这个类Python没有暴露给我们</span></span><br><span class="line"><span class="comment"># 当我们调用函数foo的时候, 会从local空间中取出符号&quot;foo&quot;对应的PyFunctionObject对象</span></span><br><span class="line"><span class="comment"># 然后根据这个PyFunctionObject对象创建PyFrameObject对象, 也就是为函数创建一个栈帧</span></span><br><span class="line"><span class="comment"># 然后将执行权交给新创建的栈帧, 在新创建的栈帧中执行字节码</span></span><br></pre></td></tr></table></figure>

<h4 id="PyFrameObject和PyFunctionObject对象的区别与联系"><a href="#PyFrameObject和PyFunctionObject对象的区别与联系" class="headerlink" title="PyFrameObject和PyFunctionObject对象的区别与联系"></a>PyFrameObject和PyFunctionObject对象的区别与联系</h4><p><code>PyFrameObject</code>和<code>PyFunctionObject</code>是Python解释器内部用于实现函数调用和执行的两个重要数据结构。它们之间有以下区别和联系：</p>
<ol>
<li>区别：</li>
</ol>
<ul>
<li><code>PyFrameObject</code>表示Python解释器的执行栈帧，包含了函数调用时的局部变量、参数、返回值等信息。每当Python解释器执行一个函数时，就会在执行栈上创建一个新的<code>PyFrameObject</code>，并将该栈帧推入执行栈中。当函数执行完毕时，该栈帧将被弹出执行栈。</li>
<li><code>PyFunctionObject</code>表示Python中的函数对象，包含了函数的代码、参数、默认值等信息。每当Python解释器遇到一个函数定义时，就会创建一个新的<code>PyFunctionObject</code>对象，并将其保存在内存中。在函数调用时，Python解释器会创建一个新的<code>PyFrameObject</code>对象，并将其绑定到相应的<code>PyFunctionObject</code>对象上，从而完成函数调用。</li>
</ul>
<ol>
<li>联系：</li>
</ol>
<p><code>PyFrameObject</code>和<code>PyFunctionObject</code>之间存在密切的联系，因为它们一起实现了Python解释器中的函数调用和执行过程。具体来说，当Python解释器执行一个函数时，它会创建一个新的<code>PyFrameObject</code>对象，并将其绑定到相应的<code>PyFunctionObject</code>对象上。在函数执行过程中，<code>PyFrameObject</code>对象将存储函数的局部变量、参数和返回值等信息，并通过Python解释器的执行栈来管理函数调用的层次关系。当函数执行完毕时，Python解释器会弹出执行栈，并将<code>PyFrameObject</code>对象从内存中释放掉。</p>
<p>总的来说，<code>PyFrameObject</code>和<code>PyFunctionObject</code>是Python解释器中实现函数调用和执行的两个重要数据结构。<code>PyFrameObject</code>用于存储函数调用时的局部变量、参数和返回值等信息，而<code>PyFunctionObject</code>用于存储函数的代码、参数和默认值等信息。它们之间紧密地协作，以实现Python函数的调用和执行过程。</p>
<h3 id="函数对象如何创建"><a href="#函数对象如何创建" class="headerlink" title="函数对象如何创建"></a>函数对象如何创建</h3><p><strong>我们现在已经看清了函数的模样，它在底层对应PyFunctionObject对象，并且它和PyCodeObject对象关系密切。那么Python底层又是如何完成PyCodeObject对象到PyFunctionObject对象之间的转变呢？想了解这其中的奥秘，就必须要从字节码入手。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">name = &quot;夏色祭&quot;</span></span><br><span class="line"><span class="string">def foo(a, b):</span></span><br><span class="line"><span class="string">    print(a, b)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">foo(1, 2)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> dis</span><br><span class="line">dis.dis(<span class="built_in">compile</span>(s, <span class="string">&quot;func&quot;</span>, <span class="string">&quot;exec&quot;</span>))</span><br><span class="line">  <span class="number">2</span>           <span class="number">0</span> LOAD_CONST               <span class="number">0</span> (<span class="string">&#x27;夏色祭&#x27;</span>)</span><br><span class="line">              <span class="number">2</span> STORE_NAME               <span class="number">0</span> (name)</span><br><span class="line"></span><br><span class="line">  <span class="number">3</span>           <span class="number">4</span> LOAD_CONST               <span class="number">1</span> (&lt;code <span class="built_in">object</span> foo at <span class="number">0x000001EE0CBA72F0</span>, file <span class="string">&quot;func&quot;</span>, line <span class="number">3</span>&gt;)</span><br><span class="line">              <span class="number">6</span> LOAD_CONST               <span class="number">2</span> (<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">              <span class="number">8</span> MAKE_FUNCTION            <span class="number">0</span></span><br><span class="line">             <span class="number">10</span> STORE_NAME               <span class="number">1</span> (foo)</span><br><span class="line"></span><br><span class="line">  <span class="number">6</span>          <span class="number">12</span> LOAD_NAME                <span class="number">1</span> (foo)</span><br><span class="line">             <span class="number">14</span> LOAD_CONST               <span class="number">3</span> (<span class="number">1</span>)</span><br><span class="line">             <span class="number">16</span> LOAD_CONST               <span class="number">4</span> (<span class="number">2</span>)</span><br><span class="line">             <span class="number">18</span> CALL_FUNCTION            <span class="number">2</span></span><br><span class="line">             <span class="number">20</span> POP_TOP</span><br><span class="line">             <span class="number">22</span> LOAD_CONST               <span class="number">5</span> (<span class="literal">None</span>)</span><br><span class="line">             <span class="number">24</span> RETURN_VALUE</span><br><span class="line"></span><br><span class="line">Disassembly of &lt;code <span class="built_in">object</span> foo at <span class="number">0x000001EE0CBA72F0</span>, file <span class="string">&quot;func&quot;</span>, line <span class="number">3</span>&gt;:</span><br><span class="line">  <span class="number">4</span>           <span class="number">0</span> LOAD_GLOBAL              <span class="number">0</span> (<span class="built_in">print</span>)</span><br><span class="line">              <span class="number">2</span> LOAD_FAST                <span class="number">0</span> (a)</span><br><span class="line">              <span class="number">4</span> LOAD_FAST                <span class="number">1</span> (b)</span><br><span class="line">              <span class="number">6</span> CALL_FUNCTION            <span class="number">2</span></span><br><span class="line">              <span class="number">8</span> POP_TOP</span><br><span class="line">             <span class="number">10</span> LOAD_CONST               <span class="number">0</span> (<span class="literal">None</span>)</span><br><span class="line">             <span class="number">12</span> RETURN_VALUE</span><br></pre></td></tr></table></figure>

<p><strong>显然这个代码中出现了两个PyCodeObject对象，一个对应整个py文件，另一个则是对应函数foo。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">name = &quot;夏色祭&quot;</span></span><br><span class="line"><span class="string">def foo(a, b):</span></span><br><span class="line"><span class="string">    print(a, b)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">foo(1, 2)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 把字符串当成是一个py文件来进行编译</span></span><br><span class="line">co = <span class="built_in">compile</span>(s, <span class="string">&quot;func&quot;</span>, <span class="string">&quot;exec&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(co.co_consts)  </span><br><span class="line"><span class="comment"># (&#x27;夏色祭&#x27;, &lt;code object foo at 0x00000183F9101450, file &quot;func&quot;, line 3&gt;, &#x27;foo&#x27;, 1, 2, None)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(co.co_name)  <span class="comment"># &lt;module&gt;</span></span><br><span class="line"><span class="built_in">print</span>(co.co_consts[<span class="number">1</span>].co_name)  <span class="comment"># foo</span></span><br></pre></td></tr></table></figure>

<p><strong>可以看到，”函数foo对应的PyCodeObject对象”是”py文件对应的PyCodeObject对象”的常量池co_consts中的一个元素。因为在对py文件创建PyCodeObject对象的时候，发现了一个函数代码块foo，那么会对函数代码块foo继续创建一个PyCodeObject对象(每一个代码块都会对应一个PyCodeObject对象)，而函数foo对应的PyCodeObject对象则是py文件对应的PyCodeObject对象的co_consts常量池当中的一个元素。</strong></p>
<blockquote>
<p><strong>通过以上例子，我们发现PyCodeObject对象是嵌套的。之前我们我们说过，每一个code block<code>(函数、类等等)</code>都会对应一个PyCodeObject对象。现在我们又看到了，根据层级来分的话，”内层代码块对应的PyCodeObject对象”是”最近的外层代码块对应的PyCodeObject对象”的常量池co_consts中的一个元素。而最外层则是模块对应的PyCodeObject对象，因此这就意味着我们通过最外层的PyCodeObject对象可以找到所有的PyCodeObject对象，显然这是毋庸置疑的。而这里和栈帧也是对应的，栈帧我们说过也是层层嵌套的，而内层栈帧通过f_back可以找到外层、也就是调用者对应的栈帧，当然这里我们之前的章节已经说过了，这里再提一遍。</strong></p>
</blockquote>
<p><strong>这里再来重新看一下上面的字节码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">2</span>           <span class="number">0</span> LOAD_CONST               <span class="number">0</span> (<span class="string">&#x27;夏色祭&#x27;</span>)</span><br><span class="line">              <span class="number">2</span> STORE_NAME               <span class="number">0</span> (name)</span><br><span class="line"></span><br><span class="line">  <span class="number">3</span>           <span class="number">4</span> LOAD_CONST               <span class="number">1</span> (&lt;code object foo at <span class="number">0x000001EE0CBA72F0</span>, file <span class="string">&quot;func&quot;</span>, line <span class="number">3</span>&gt;)</span><br><span class="line">              <span class="number">6</span> LOAD_CONST               <span class="number">2</span> (<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">              <span class="number">8</span> MAKE_FUNCTION            <span class="number">0</span></span><br><span class="line">             <span class="number">10</span> STORE_NAME               <span class="number">1</span> (foo)</span><br><span class="line"></span><br><span class="line">  <span class="number">6</span>          <span class="number">12</span> LOAD_NAME                <span class="number">1</span> (foo)</span><br><span class="line">             <span class="number">14</span> LOAD_CONST               <span class="number">3</span> (<span class="number">1</span>)</span><br><span class="line">             <span class="number">16</span> LOAD_CONST               <span class="number">4</span> (<span class="number">2</span>)</span><br><span class="line">             <span class="number">18</span> CALL_FUNCTION            <span class="number">2</span></span><br><span class="line">             <span class="number">20</span> POP_TOP</span><br><span class="line">             <span class="number">22</span> LOAD_CONST               <span class="number">5</span> (None)</span><br><span class="line">             <span class="number">24</span> RETURN_VALUE</span><br><span class="line"></span><br><span class="line">Disassembly of &lt;code object foo at <span class="number">0x000001EE0CBA72F0</span>, file <span class="string">&quot;func&quot;</span>, line <span class="number">3</span>&gt;:</span><br><span class="line">  <span class="number">4</span>           <span class="number">0</span> LOAD_GLOBAL              <span class="number">0</span> (print)</span><br><span class="line">              <span class="number">2</span> LOAD_FAST                <span class="number">0</span> (a)</span><br><span class="line">              <span class="number">4</span> LOAD_FAST                <span class="number">1</span> (b)</span><br><span class="line">              <span class="number">6</span> CALL_FUNCTION            <span class="number">2</span></span><br><span class="line">              <span class="number">8</span> POP_TOP</span><br><span class="line">             <span class="number">10</span> LOAD_CONST               <span class="number">0</span> (None)</span><br><span class="line">             <span class="number">12</span> RETURN_VALUE</span><br></pre></td></tr></table></figure>

<p><strong>显然dis模块自动帮我们分成了两部分，上面是模块的字节码，下面是函数的字节码。首先函数很简单我们就不看了，直接看模块的。</strong></p>
<p><strong>首先开头的LOAD_CONST和STORE_NAME显然是 name &#x3D; “夏色祭” 对应的指令。然后我们看<code>4 LOAD_CONST</code>，这条指令也是加载了一个常量，但这个常量是一个PyCodeObject对象；<code>6 LOAD_CONST</code>则是将字符串常量”foo”、即函数名加载了进来，然后通过MAKE_FUNCTION指令构建一个PyFunctionObject对象；然后<code>10 STORE_NAME</code>，让符号foo指向这个PyFunctionObject对象。再下面就是函数调用了，函数调用的具体细节我们之后会详细说。</strong></p>
<p><strong>并且我们还看到一个有趣的现象，那就是源代码的行号。我们发现之前看到源代码的行号都是从上往下、依次增大的，这很好理解，毕竟一条一条解释嘛。但是这里却发生了变化，先执行了第6行，之后再执行第4行。如果是从Python层面的函数调用来理解的话，很容易一句话就解释了，因为函数只有在调用的时候才会执行。但是从字节码的角度来理解的话，我们发现函数的声明和实现是分离的，是在不同的PyCodeObject对象中。确实如此，虽然一个函数名和函数体是一个整体，但是Python虚拟机在实现这个函数的时候，却在物理上将它们分离开了，构建函数的字节码指令序列必须在模块对应的PyCodeObject对象中。</strong></p>
<blockquote>
<p><strong>我们之前说过，函数即变量。我们是可以把函数当成是普通的变量来处理的，函数名就相当于变量名，函数体就相当于是变量指向的值。而foo函数显然是在全局中定义的一个函数，那么foo是不是要出现在py文件对应的PyCodeObject对象的符号表co_names里面呢？foo对应的PyCodeObject对象是不是要出现在py文件对应的PyCodeObject对象的常量池co_consts里面呢？</strong></p>
</blockquote>
<p><strong>至此，函数的结构就已经非常清晰了。</strong></p>
<p><img src="/2023/04/02/14-%E5%87%BD%E6%95%B0%E5%9C%A8%E5%BA%95%E5%B1%82%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BB%A5%E5%8F%8A%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F/1229382-20200822015055004-867736003.png" alt="img"></p>
<p><strong>所以函数名和函数体是分离的，它们存在不同的PyCodeObject对象当中。分析完结构之后，我们的重点就在于那个MAKE_FUNCTION指令了，我们说当遇到<code>def foo(a, b)</code>的时候，在语法上将这是函数的声明语句，但是从虚拟机的角度来看这其实是函数对象的创建语句。所以下面我们就要分析一下这个指令，看看它到底是怎么将一个PyCodeObject对象变成一个PyFunctionObject对象的。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="title function_">TARGET</span><span class="params">(MAKE_FUNCTION)</span>: &#123;</span><br><span class="line">    PyObject *qualname = POP(); <span class="comment">//弹出符号表中的函数名</span></span><br><span class="line">    PyObject *codeobj = POP();  <span class="comment">//弹出对应的字节码对象</span></span><br><span class="line">    <span class="comment">//创建PyFunctionObject对象, 接收三个参数, 首先第一个参数和第三个参数很好理解, 但重点是第二个参数</span></span><br><span class="line">    <span class="comment">//首先f指的就是当前所在的栈帧, 对于我们目前这个里而言就是模块、或者py文件对应的栈帧</span></span><br><span class="line">    <span class="comment">//然后将f_globals、也就是global名字空间传递了进去, 所以我们现在明白了为什么函数可以调用__globals__了</span></span><br><span class="line">    <span class="comment">//当然也明白为什么函数可以在局部变量找不到的时候去找全局变量了</span></span><br><span class="line">    PyFunctionObject *func = (PyFunctionObject *)</span><br><span class="line">        PyFunction_NewWithQualName(codeobj, f-&gt;f_globals, qualname);</span><br><span class="line"></span><br><span class="line">    Py_DECREF(codeobj);</span><br><span class="line">    Py_DECREF(qualname);</span><br><span class="line">    <span class="keyword">if</span> (func == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">			</span><br><span class="line">    <span class="comment">//下面是设置闭包、注解、参数默认值等属性</span></span><br><span class="line">    <span class="keyword">if</span> (oparg &amp; <span class="number">0x08</span>) &#123;</span><br><span class="line">        assert(PyTuple_CheckExact(TOP()));</span><br><span class="line">        func -&gt;func_closure = POP();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (oparg &amp; <span class="number">0x04</span>) &#123;</span><br><span class="line">        assert(PyDict_CheckExact(TOP()));</span><br><span class="line">        func-&gt;func_annotations = POP();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (oparg &amp; <span class="number">0x02</span>) &#123;</span><br><span class="line">        assert(PyDict_CheckExact(TOP()));</span><br><span class="line">        func-&gt;func_kwdefaults = POP();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (oparg &amp; <span class="number">0x01</span>) &#123;</span><br><span class="line">        assert(PyTuple_CheckExact(TOP()));</span><br><span class="line">        func-&gt;func_defaults = POP();</span><br><span class="line">    &#125;</span><br><span class="line">			</span><br><span class="line">    <span class="comment">//将函数或者说函数对象压入运行时栈</span></span><br><span class="line">    PUSH((PyObject *)func);</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们看到在MAKE FUNCTION之前，先进行了LOAD  CONST，显然是将foo对应的字节码对象和符号foo压入到了栈中。所以在执行MAKE  FUNCTION的时候，首先就是将这个字节码对象以及对应符号弹出栈，然后再加上当前PyFrameObject对象中维护的global名字空间f_globals对象，三者作为参数传入PyFunction_NewWithQualName函数中，从而构建出相应的PyFunctionObject对象。</strong></p>
<p><strong>下面我们来看看PyFunction_NewWithQualName是如何构造出一个函数的，它位于 *Objects&#x2F;funcobject.c* 中。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyFunction_NewWithQualName</span><span class="params">(PyObject *code, PyObject *globals, PyObject *qualname)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//要返回的PyFunctionObject *, 这里先声明一下</span></span><br><span class="line">    PyFunctionObject *op;</span><br><span class="line">    <span class="comment">//函数的doc、PyCodeObject的co_consts、函数所在的模块</span></span><br><span class="line">    PyObject *doc, *consts, *module;</span><br><span class="line">    <span class="type">static</span> PyObject *__name__ = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__name__ == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        __name__ = PyUnicode_InternFromString(<span class="string">&quot;__name__&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (__name__ == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//通过PyObject_GC_New为函数对象申请空间</span></span><br><span class="line">    op = PyObject_GC_New(PyFunctionObject, &amp;PyFunction_Type);</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//下面就是设置PyFunctionObject对象的成员属性了</span></span><br><span class="line">    op-&gt;func_weakreflist = <span class="literal">NULL</span>;</span><br><span class="line">    Py_INCREF(code);</span><br><span class="line">    op-&gt;func_code = code;</span><br><span class="line">    Py_INCREF(globals);</span><br><span class="line">    op-&gt;func_globals = globals;</span><br><span class="line">    op-&gt;func_name = ((PyCodeObject *)code)-&gt;co_name;</span><br><span class="line">    Py_INCREF(op-&gt;func_name);</span><br><span class="line">    op-&gt;func_defaults = <span class="literal">NULL</span>; <span class="comment">/* No default arguments */</span></span><br><span class="line">    op-&gt;func_kwdefaults = <span class="literal">NULL</span>; <span class="comment">/* No keyword only defaults */</span></span><br><span class="line">    op-&gt;func_closure = <span class="literal">NULL</span>;</span><br><span class="line">    op-&gt;vectorcall = _PyFunction_Vectorcall;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//通过PyCodeObject对象获取常量池</span></span><br><span class="line">    consts = ((PyCodeObject *)code)-&gt;co_consts;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//我们知道函数的doc其实就是一个字符串, 显然它也是常量池的一个常量, 并且是常量池的第一个元素</span></span><br><span class="line">    <span class="comment">//否则的话它就是不能成为doc</span></span><br><span class="line">    <span class="keyword">if</span> (PyTuple_Size(consts) &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//所以如果consts&gt;=1, 并且第一个元素是字符串, 那么它就是函数的doc</span></span><br><span class="line">        doc = PyTuple_GetItem(consts, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (!PyUnicode_Check(doc))</span><br><span class="line">            doc = Py_None;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//否则doc就是None</span></span><br><span class="line">        doc = Py_None;</span><br><span class="line">    Py_INCREF(doc);</span><br><span class="line">    <span class="comment">//下面也是设置PyFunctionObject对象的成员</span></span><br><span class="line">    op-&gt;func_doc = doc;</span><br><span class="line"></span><br><span class="line">    op-&gt;func_dict = <span class="literal">NULL</span>;</span><br><span class="line">    op-&gt;func_module = <span class="literal">NULL</span>;</span><br><span class="line">    op-&gt;func_annotations = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* __module__: If module name is in globals, use it.</span></span><br><span class="line"><span class="comment">       Otherwise, use None. */</span></span><br><span class="line">    module = PyDict_GetItemWithError(globals, __name__);</span><br><span class="line">    <span class="keyword">if</span> (module) &#123;</span><br><span class="line">        Py_INCREF(module);</span><br><span class="line">        op-&gt;func_module = module;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (PyErr_Occurred()) &#123;</span><br><span class="line">        Py_DECREF(op);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (qualname)</span><br><span class="line">        op-&gt;func_qualname = qualname;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        op-&gt;func_qualname = op-&gt;func_name;</span><br><span class="line">    Py_INCREF(op-&gt;func_qualname);</span><br><span class="line"></span><br><span class="line">    _PyObject_GC_TRACK(op);</span><br><span class="line">    <span class="keyword">return</span> (PyObject *)op;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所以通过MAKE_FUNCTION我们便创建了PyFunctionObject对象，然后它会被压入栈中，再通过STORE_NAME将符号foo和PyFunctionObject对象组成一个entry，存储在当前栈帧的local名字空间中，当然也是global名字空间。只不过为了和函数保持统一，我们都说成local名字空间，只不过不同的作用域对应的local空间是不一样的。</strong></p>
<p><strong>当然了我们说函数对象的类型是<code>&lt;class &#39;function&#39;&gt;</code>，但是这个类底层没有暴露给我们，但是我们依旧可以通过曲线救国的方式进行获取。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(f))  <span class="comment"># &lt;class &#x27;function&#x27;&gt;</span></span><br><span class="line"><span class="comment"># lambda匿名函数的类型也是&lt;class &#x27;function&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="keyword">lambda</span>: <span class="literal">None</span>))  <span class="comment"># &lt;class &#x27;function&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>所以我们可以仿照底层的思路，通过<code>&lt;class &#39;function&#39;&gt;</code>来创建一个函数对象。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">gender = <span class="string">&quot;female&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">name, age</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;name: <span class="subst">&#123;name&#125;</span>, age: <span class="subst">&#123;age&#125;</span>, gender: <span class="subst">&#123;gender&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到PyCodeObject对象</span></span><br><span class="line">code = f.__code__</span><br><span class="line"><span class="comment"># 根据class function创建函数对象, 接收三个参数: PyCodeObject对象、名字空间、函数名</span></span><br><span class="line">new_f = <span class="built_in">type</span>(f)(code, <span class="built_in">globals</span>(), <span class="string">&quot;根据f创建的new_f&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印函数名</span></span><br><span class="line"><span class="built_in">print</span>(new_f.__name__)  <span class="comment"># 根据f创建的new_f</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用函数</span></span><br><span class="line"><span class="built_in">print</span>(new_f(<span class="string">&quot;夏色祭&quot;</span>, -<span class="number">1</span>))  <span class="comment"># name: 夏色祭, age: -1, gender: female</span></span><br></pre></td></tr></table></figure>

<p><strong>是不是很神奇呢？另外我们说函数在访问gender指向的对象时，显然先从自身的符号表中找，如果没有那么回去找全局变量。这是因为，我们在创建函数的时候将global名字空间传进去了，如果我们不传递呢？</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">gender = <span class="string">&quot;female&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">name, age</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;name: <span class="subst">&#123;name&#125;</span>, age: <span class="subst">&#123;age&#125;</span>, gender: <span class="subst">&#123;gender&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">code = f.__code__</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    new_f = <span class="built_in">type</span>(f)(code, <span class="literal">None</span>, <span class="string">&quot;根据f创建的new_f&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> TypeError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># function() argument &#x27;globals&#x27; must be dict, not None</span></span><br><span class="line"><span class="comment"># 这里告诉我们function的第二个参数globals必须是一个字典</span></span><br><span class="line"><span class="comment"># 我们传递一个空字典</span></span><br><span class="line">new_f1 = <span class="built_in">type</span>(f)(code, &#123;&#125;, <span class="string">&quot;根据f创建的new_f1&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印函数名</span></span><br><span class="line"><span class="built_in">print</span>(new_f1.__name__)  <span class="comment"># 根据f创建的new_f1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用函数</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(new_f1(<span class="string">&quot;夏色祭&quot;</span>, -<span class="number">1</span>))</span><br><span class="line"><span class="keyword">except</span> NameError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># name &#x27;gender&#x27; is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们看到告诉我们gender没有定义</span></span><br></pre></td></tr></table></figure>

<p><strong>因此现在我们又在Python的角度上理解了一遍，为什么Python中的函数能够在局部变量找不到的时候，去找全局变量，原因就在于构建函数的时候，将global名字空间交给了函数。使得函数可以在global空间进行变量查找，所以它才能够找到全局变量。而我们这里给了一个空字典，那么显然就找不到gender这个变量了。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">gender = <span class="string">&quot;female&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">name, age</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;name: <span class="subst">&#123;name&#125;</span>, age: <span class="subst">&#123;age&#125;</span>, gender: <span class="subst">&#123;gender&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">code = f.__code__</span><br><span class="line">new_f = <span class="built_in">type</span>(f)(code, &#123;<span class="string">&quot;gender&quot;</span>: <span class="string">&quot;萌妹子&quot;</span>&#125;, <span class="string">&quot;根据f创建的new_f&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们可以手动传递一个字典进去, 此时我们传递的字典对于函数来说就是global名字空间</span></span><br><span class="line"><span class="comment"># 所以在函数内部找不到某个变量的时候, 就会去我们指定的名字空间中找</span></span><br><span class="line"><span class="built_in">print</span>(new_f(<span class="string">&quot;夏色祭&quot;</span>, -<span class="number">1</span>))  <span class="comment"># name: 夏色祭, age: -1, gender: 萌妹子</span></span><br><span class="line"><span class="comment"># 所以此时的gender不再是外部的&quot;female&quot;, 而是我们指定的&quot;萌妹子&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>此外我们还可以为函数指定默认值：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">gender = <span class="string">&quot;female&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">name, age</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;name: <span class="subst">&#123;name&#125;</span>, age: <span class="subst">&#123;age&#125;</span>, gender: <span class="subst">&#123;gender&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">code = f.__code__</span><br><span class="line">new_f = <span class="built_in">type</span>(f)(code, &#123;<span class="string">&quot;gender&quot;</span>: <span class="string">&quot;屑女仆&quot;</span>&#125;, <span class="string">&quot;根据f创建的new_f&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 必须接收一个PyTupleObject对象</span></span><br><span class="line">new_f.__defaults__ = (<span class="string">&quot;神乐mea&quot;</span>, <span class="number">38</span>)</span><br><span class="line"><span class="comment"># 即使我们不传递参数, 也是完全可以的, 因为已经有默认值了</span></span><br><span class="line"><span class="built_in">print</span>(new_f())  <span class="comment"># name: 神乐mea, age: 38, gender: 屑女仆</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们也可以指定部分默认参数</span></span><br><span class="line">new_f1 = <span class="built_in">type</span>(f)(code, &#123;<span class="string">&quot;gender&quot;</span>: <span class="string">&quot;屑女仆&quot;</span>&#125;, <span class="string">&quot;根据f创建的new_f1&quot;</span>)</span><br><span class="line"><span class="comment"># 这里的在设置默认值的时候是从后往前设置的, 比如: (&quot;神乐mea&quot;, 38)</span></span><br><span class="line"><span class="comment"># 是将38设置为age的默认值, &quot;神乐mea&quot;设置为name的默认值</span></span><br><span class="line"><span class="comment"># 所以这里的(38,) , 会将38设置为age的默认值, 不是name</span></span><br><span class="line"><span class="comment"># 那name怎么办? 如果没有对应的默认值了, 那么它就必须在函数调用的时候由我们显式的传递</span></span><br><span class="line">new_f1.__defaults__ = (<span class="number">38</span>,)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    new_f1()</span><br><span class="line"><span class="keyword">except</span> TypeError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># f() missing 1 required positional argument: &#x27;name&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(new_f1(<span class="string">&quot;神楽めあ&quot;</span>))  <span class="comment"># name: 神楽めあ, age: 38, gender: 屑女仆</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">但是问题来了, 为什么在设置默认值的时候要从后往前呢?</span></span><br><span class="line"><span class="string">首先如果默认值的个数和参数的个数正好匹配, 那么相安无事, 如果不匹配那么只能是默认值的个数小于参数个数</span></span><br><span class="line"><span class="string">如果是从后往前, 那么(38,)就意味着38设置为age的默认值, name就必须由我们在调用的时候传递</span></span><br><span class="line"><span class="string">但如果是从前往后, 那么(38,)就意味着38设置为name的默认值, age就必须由我们在调用的时候来传递</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">但是问题来了, 如果38设置为name的默认值, 这会是什么情况? 显然等价于:</span></span><br><span class="line"><span class="string">def new_f1(name=38, age):</span></span><br><span class="line"><span class="string">    ......</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">你认为这样的函数能够通过编译吗?显然是不行的, 因为默认参数必须在非默认参数的后面</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 所以Python的这个做法是完全正确的, 必须要从后往前进行设置</span></span><br></pre></td></tr></table></figure>

<p><strong>当然，这种设置默认值的方式显然也可以使用于通过def定义的函数，因为我们上面的new_f、new_f1和f都是<code>&lt;class &#39;function&#39;&gt;</code>对象。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">gender = <span class="string">&quot;female&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">name, age</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;name: <span class="subst">&#123;name&#125;</span>, age: <span class="subst">&#123;age&#125;</span>, gender: <span class="subst">&#123;gender&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(f.__defaults__)  <span class="comment"># None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置默认值</span></span><br><span class="line">f.__defaults__ = (<span class="string">&quot;夏色祭&quot;</span>, -<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果你用的是pycharm, 那么会在f()这个位置给你做上标记, 提示你参数没有传递</span></span><br><span class="line"><span class="comment"># 但我们知道由于使用__defaults__已经设置了默认值, 所以这里是不会报错的, 只不过pycharm没有检测到, 当然基本上所有的ide都无法做到这一点</span></span><br><span class="line"><span class="built_in">print</span>(f())  <span class="comment"># name: 夏色祭, age: -1, gender: female</span></span><br></pre></td></tr></table></figure>

<p><strong>另外我们说，默认值的个数一定要小于等于参数的个数，但如果大于呢？</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">gender = <span class="string">&quot;female&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">name, age</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;name: <span class="subst">&#123;name&#125;</span>, age: <span class="subst">&#123;age&#125;</span>, gender: <span class="subst">&#123;gender&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(f.__defaults__)  <span class="comment"># None</span></span><br><span class="line"></span><br><span class="line">f.__defaults__ = (<span class="string">&quot;夏色祭&quot;</span>, -<span class="number">1</span>, <span class="string">&quot;神乐mea&quot;</span>, <span class="number">38</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(f())  <span class="comment"># name: 神乐mea, age: 38, gender: female</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 依旧从后往前, 38给age、&quot;神乐mea&quot;给name</span></span><br><span class="line"><span class="comment"># 参数都有默认值了, 那么就结束了</span></span><br><span class="line"><span class="comment"># 当然如果是__defaults__指向的元组先结束, 那么没有得到默认值的参数就必须由我们来传递了</span></span><br></pre></td></tr></table></figure>

<p>​        *<em>想不到Python中的函数可以玩出这么多新花样，现在你是不是对函数有了一个更深刻的认识了呢？当然目前介绍的只是函数的一小部分内容，还有函数如何调用、位置参数和关键字参数如何解析、对于有默认值的参数如何在我们不传递的时候使用默认值以及在我们传递的时候使用我们传递的值、*args和*<em>kwargs又如何解析、闭包怎么做到的、还有装饰器等等等等，这些我们接下来会单独用几篇博客详细说。</em></em>    </p>
<p>​        <strong>因为放在一篇博客里面的话，字数至少要好几万，而我使用的Markdown编辑器typora在字数达到一万五的时候就会出现明显卡顿，要是一下子都写完的话，绝对卡到爆，而且越往后越卡，这对我而言也是个痛苦。而且函数的内容也比较多，我们就多用一些篇幅去介绍它吧。</strong>    </p>
<h3 id="判断函数都有哪些参数"><a href="#判断函数都有哪些参数" class="headerlink" title="判断函数都有哪些参数"></a>判断函数都有哪些参数</h3><p><strong>最后我们再来看看我们如何检测一个函数有哪些参数，首先函数的局部变量<code>(包括参数)</code>在编译是就已经确定，会存在符号表co_varnames中。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意: 在定义函数的时候*和**最多只能出现一次</span></span><br><span class="line"><span class="comment"># 显然a和b必须通过位置参数传递</span></span><br><span class="line"><span class="comment"># c和d可以通过位置参数或者关键字参数传递</span></span><br><span class="line"><span class="comment"># e和f必须通过关键字参数传递</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">a, b, /, c, d, *args, e, f, **kwargs</span>):</span><br><span class="line">    g = <span class="number">1</span></span><br><span class="line">    h = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">varnames = f.__code__.co_varnames</span><br><span class="line"><span class="built_in">print</span>(varnames)</span><br><span class="line"><span class="comment"># (&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;args&#x27;, &#x27;kwargs&#x27;, &#x27;g&#x27;, &#x27;h&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">首先co_varnames打印的符号表是有顺序的, 参数永远在函数内部定义的局部变量的前面</span></span><br><span class="line"><span class="string">g和h就是函数内部定义的局部变量, 所以它在所有的后面</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">如果是参数的话, 那么*和**会位于最后面, 其它参数位置不变, 所以除了g和h, 最后面的就是args和kwargs</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 接下来, 我们就可以进行判断了</span></span><br><span class="line"><span class="comment"># 1. 寻找必须通过位置参数传递的参数</span></span><br><span class="line">posonlyargcount = f.__code__.co_posonlyargcount</span><br><span class="line"><span class="built_in">print</span>(posonlyargcount)  <span class="comment"># 2</span></span><br><span class="line"><span class="built_in">print</span>(varnames[: posonlyargcount])  <span class="comment"># (&#x27;a&#x27;, &#x27;b&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 寻找可以通过位置参数传递或者关键字参数传递的参数</span></span><br><span class="line">argcount = f.__code__.co_argcount</span><br><span class="line"><span class="built_in">print</span>(argcount)  <span class="comment"># 4</span></span><br><span class="line"><span class="built_in">print</span>(varnames[: <span class="number">4</span>])  <span class="comment"># (&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;)</span></span><br><span class="line"><span class="built_in">print</span>(varnames[posonlyargcount: <span class="number">4</span>])  <span class="comment"># (&#x27;c&#x27;, &#x27;d&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 寻找必须通过关键字参数传递的参数</span></span><br><span class="line">kwonlyargcount = f.__code__.co_kwonlyargcount</span><br><span class="line"><span class="built_in">print</span>(kwonlyargcount)  <span class="comment"># 2</span></span><br><span class="line"><span class="built_in">print</span>(varnames[argcount: argcount + kwonlyargcount])  <span class="comment"># (&#x27;e&#x27;, &#x27;f&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 寻找*args和**kwargs</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">在介绍PyCodeObject对象的时候, 我们说里面有一个co_flags成员</span></span><br><span class="line"><span class="string">它是专门用来判断参数中是否有*args和**kwargs的</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">flags = f.__code__.co_flags</span><br><span class="line"><span class="comment"># 如果flags和4进行按位与之后为真, 那么就代表有*args, 否则没有</span></span><br><span class="line"><span class="comment"># 如果flags和8进行按位与之后为真, 那么就代表有**kwargs, 否则没有</span></span><br><span class="line">step = argcount + kwonlyargcount</span><br><span class="line"><span class="keyword">if</span> flags &amp; <span class="number">0x04</span>:</span><br><span class="line">    <span class="built_in">print</span>(varnames[step])  <span class="comment"># args</span></span><br><span class="line">    step += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> flags &amp; <span class="number">0x08</span>:</span><br><span class="line">    <span class="built_in">print</span>(varnames[step])  <span class="comment"># kwargs</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 虽然我们这里打印的是args和kwargs, 但主要取决定义的时候使用的名字</span></span><br><span class="line"><span class="comment"># 如果定义的时候是*ARGS和**KWARGS, 那么这里就是ARGS和KWARGS, 只不过一般我们都叫做*args和**kwargs</span></span><br></pre></td></tr></table></figure>

<p><strong>如果我们定义的不是*args，只是一个*，那么它就不是参数了。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">a, b, *, c</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们看到此时只有a、b、c</span></span><br><span class="line"><span class="built_in">print</span>(f.__code__.co_varnames)  <span class="comment"># (&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(f.__code__.co_flags &amp; <span class="number">0x04</span>)  <span class="comment"># 0</span></span><br><span class="line"><span class="built_in">print</span>(f.__code__.co_flags &amp; <span class="number">0x08</span>)  <span class="comment"># 0</span></span><br><span class="line"><span class="comment"># 显然此时也都为假</span></span><br></pre></td></tr></table></figure>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><strong>这一次我们简单的分析了一下函数在底层对应的数据结构，以及如何创建一个函数，并且还在Python的层面上做了一些小trick。最后我们也分析了如何通过PyCodeObject对象来检索Python中的参数，以及相关种类，当然标准库中的inspect模块也是这么做的。当然说白了，其实是我们模仿人家的思路做的。</strong></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Lin Li</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/04/02/14-%E5%87%BD%E6%95%B0%E5%9C%A8%E5%BA%95%E5%B1%82%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BB%A5%E5%8F%8A%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F/">http://example.com/2023/04/02/14-%E5%87%BD%E6%95%B0%E5%9C%A8%E5%BA%95%E5%B1%82%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BB%A5%E5%8F%8A%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">LinLi's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/CPython/">CPython</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/04/02/15-%E5%87%BD%E6%95%B0%E5%9C%A8%E5%BA%95%E5%B1%82%E6%98%AF%E5%A6%82%E4%BD%95%E8%A2%AB%E8%B0%83%E7%94%A8%E7%9A%84/" title="15-函数在底层是如何被调用的"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">15-函数在底层是如何被调用的</div></div></a></div><div class="next-post pull-right"><a href="/2023/04/02/13-%E5%89%96%E6%9E%90Python%E7%9A%84%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/" title="13-剖析Python的流程控制语句"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">13-剖析Python的流程控制语句</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/03/29/01-%E7%BC%96%E8%AF%91Cpython/" title="01-编译Cpython"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">01-编译Cpython</div></div></a></div><div><a href="/2023/03/29/02-%E4%B8%80%E5%88%87%E5%AF%B9%E8%B1%A1%E7%9A%86PyObject/" title="02-一切对象皆PyObject"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">02-一切对象皆PyObject</div></div></a></div><div><a href="/2023/03/29/04-%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/" title="04-浮点数的底层实现"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">04-浮点数的底层实现</div></div></a></div><div><a href="/2023/03/29/06-Bytes%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BA%95%E5%B1%82%E6%93%8D%E4%BD%9C/" title="06-Bytes对象的底层操作"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">06-Bytes对象的底层操作</div></div></a></div><div><a href="/2023/03/29/03-Python%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E5%99%A8%E5%92%8C%E5%BA%95%E5%B1%82%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86/" title="03-Python引用计数器和底层对象管理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">03-Python引用计数器和底层对象管理</div></div></a></div><div><a href="/2023/03/29/05-Python%E6%95%B4%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/" title="05-Python整数的底层实现"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">05-Python整数的底层实现</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Lin Li</div><div class="author-info__description">今日事，今日毕</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">106</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#14-%E5%87%BD%E6%95%B0%E5%9C%A8%E5%BA%95%E5%B1%82%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E4%BB%A5%E5%8F%8A%E5%AE%83%E7%9A%84%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F"><span class="toc-number">1.</span> <span class="toc-text">14-函数在底层的数据结构、以及它的创建方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A5%94%E5%AD%90"><span class="toc-number">1.1.</span> <span class="toc-text">楔子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PyFunctionObject%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.2.</span> <span class="toc-text">PyFunctionObject对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#PyFrameObject%E5%92%8CPyFunctionObject%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%81%94%E7%B3%BB"><span class="toc-number">1.2.1.</span> <span class="toc-text">PyFrameObject和PyFunctionObject对象的区别与联系</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA"><span class="toc-number">1.3.</span> <span class="toc-text">函数对象如何创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E5%87%BD%E6%95%B0%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8F%82%E6%95%B0"><span class="toc-number">1.4.</span> <span class="toc-text">判断函数都有哪些参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">1.5.</span> <span class="toc-text">小结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/22/MASTERKEY-Automated-Jailbreaking-of-Large-Language-Model-Chatbots/" title="MASTERKEY: Automated Jailbreaking of Large Language Model Chatbots">MASTERKEY: Automated Jailbreaking of Large Language Model Chatbots</a><time datetime="2024-11-22T13:32:36.000Z" title="发表于 2024-11-22 21:32:36">2024-11-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/19/How-Effective-Are-They-Exploring-Large-Language-Model-Based-Fuzz-Driver-Generation/" title="How Effective Are They? Exploring Large Language Model Based Fuzz Driver Generation">How Effective Are They? Exploring Large Language Model Based Fuzz Driver Generation</a><time datetime="2024-11-19T09:24:19.000Z" title="发表于 2024-11-19 17:24:19">2024-11-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/19/METAL-Metamorphic-Testing-Framework-for-Analyzing-Large-Language-Model-Qualities/" title="METAL Metamorphic Testing Framework for Analyzing Large-Language Model Qualities">METAL Metamorphic Testing Framework for Analyzing Large-Language Model Qualities</a><time datetime="2024-11-19T02:47:44.000Z" title="发表于 2024-11-19 10:47:44">2024-11-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/19/SMT-Solver-Validation-Empowered-by-Large-Pre-trained-Language-Models/" title="SMT Solver Validation Empowered by Large Pre-trained Language Models">SMT Solver Validation Empowered by Large Pre-trained Language Models</a><time datetime="2024-10-19T12:57:20.000Z" title="发表于 2024-10-19 20:57:20">2024-10-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/13/MR-Adopt-Automatic-Deduction-of-Input-Transformation-Function-for-Metamorphic-Testing/" title="MR-Adopt: Automatic Deduction of Input Transformation Function for Metamorphic Testing">MR-Adopt: Automatic Deduction of Input Transformation Function for Metamorphic Testing</a><time datetime="2024-10-13T03:09:01.000Z" title="发表于 2024-10-13 11:09:01">2024-10-13</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Lin Li</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>