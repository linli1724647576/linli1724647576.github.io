<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>24-Python运行时的环境初始化 | LinLi's Blog</title><meta name="author" content="Lin Li"><meta name="copyright" content="Lin Li"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="24-Python运行时的环境初始化楔子我们之前分析了Python的核心–字节码、以及虚拟机的剖析工作，但这仅仅只是一部分，而其余的部分则被遮在了幕后。记得我们在分析虚拟机的时候，曾这么说过：  当Python启动后，首先会进行 “运行时环境” 的初始化，而关于  “运行时环境” 的初始化是一个非常复杂的过程。并且 “运行时环境” 和 “执行环境” 是不同的， “运行时环境” 是一个全局的概念，而">
<meta property="og:type" content="article">
<meta property="og:title" content="24-Python运行时的环境初始化">
<meta property="og:url" content="http://example.com/2023/04/20/24-Python%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E7%8E%AF%E5%A2%83%E5%88%9D%E5%A7%8B%E5%8C%96/index.html">
<meta property="og:site_name" content="LinLi&#39;s Blog">
<meta property="og:description" content="24-Python运行时的环境初始化楔子我们之前分析了Python的核心–字节码、以及虚拟机的剖析工作，但这仅仅只是一部分，而其余的部分则被遮在了幕后。记得我们在分析虚拟机的时候，曾这么说过：  当Python启动后，首先会进行 “运行时环境” 的初始化，而关于  “运行时环境” 的初始化是一个非常复杂的过程。并且 “运行时环境” 和 “执行环境” 是不同的， “运行时环境” 是一个全局的概念，而">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2023-04-20T08:50:12.000Z">
<meta property="article:modified_time" content="2023-04-20T08:50:40.739Z">
<meta property="article:author" content="Lin Li">
<meta property="article:tag" content="CPython">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/04/20/24-Python%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E7%8E%AF%E5%A2%83%E5%88%9D%E5%A7%8B%E5%8C%96/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '24-Python运行时的环境初始化',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-04-20 16:50:40'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">95</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="LinLi's Blog"><span class="site-name">LinLi's Blog</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">24-Python运行时的环境初始化</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-04-20T08:50:12.000Z" title="发表于 2023-04-20 16:50:12">2023-04-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-04-20T08:50:40.739Z" title="更新于 2023-04-20 16:50:40">2023-04-20</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="24-Python运行时的环境初始化"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="24-Python运行时的环境初始化"><a href="#24-Python运行时的环境初始化" class="headerlink" title="24-Python运行时的环境初始化"></a>24-Python运行时的环境初始化</h2><h3 id="楔子"><a href="#楔子" class="headerlink" title="楔子"></a>楔子</h3><p><strong>我们之前分析了Python的核心–字节码、以及虚拟机的剖析工作，但这仅仅只是一部分，而其余的部分则被遮在了幕后。记得我们在分析虚拟机的时候，曾这么说过：</strong></p>
<blockquote>
<p><strong>当Python启动后，首先会进行 “运行时环境” 的初始化，而关于  “运行时环境” 的初始化是一个非常复杂的过程。并且 “运行时环境” 和 “执行环境” 是不同的， “运行时环境” 是一个全局的概念，而  “执行环境”  是一个栈帧。关于”运行时环境”我们后面将用单独的一章进行剖析，这里就假设初始化动作已经完成，我们已经站在了Python虚拟机的门槛外面，只需要轻轻推动一下第一张骨牌，整个执行过程就像多米诺骨牌一样，一环扣一环地展开。</strong></p>
</blockquote>
<p><strong>所以这次，我们将回到时间的起点，从Python的应用程序被执行开始，一步一步紧紧跟随Python的轨迹，完整地展示Python在启动之初的所有动作。当我们根据Python完成所有的初始化动作之后，也就能对Python执行引擎执行字节码指令时的整个运行环境了如执掌了。</strong></p>
<h3 id="线程环境初始化"><a href="#线程环境初始化" class="headerlink" title="线程环境初始化"></a>线程环境初始化</h3><p><strong>我们知道线程是操作系统调度的最小单元，那么Python中的线程又是怎么样的呢？</strong></p>
<h4 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h4><p><strong>我们之前介绍栈帧的时候说过，通过Python启动一个线程，那么底层会通过C来启动一个线程，然后启动操作系统的一个原生线程(OS线程)。所以Python中的线程实际上是对OS线程的一个封装，因此Python中的线程是货真价实的。</strong></p>
<p><strong>然后Python还提供了一个PyThreadState(线程状态)对象，维护OS线程执行的状态信息，相当于是OS线程的一个抽象描述。虽然真正用来执行的线程及其状态肯定是由操作系统进行维护的，但是Python虚拟机在运行的时候总需要另外一些与线程相关的状态和信息，比如是否发生了异常等等，这些信息显然操作系统是没有办法提供的。而PyThreadState对象正是Python为OS线程准备的、在虚拟机层面保存其状态信息的对象，也就是线程状态对象。而在Python中，当前活动的OS线程对应的PyThreadState对象可以通过PyThreadState_GET获得，有了线程状态对象之后，就可以设置一些额外信息了。具体内容，我们后面会说。</strong></p>
<p><strong>当然除了线程状态对象之外，还有进程状态对象，我们来看看两者在Python底层的定义是什么？它们位于 *Include&#x2F;pystate.h* 中。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">is</span> <span class="title">PyInterpreterState</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">ts</span> <span class="title">PyThreadState</span>;</span></span><br></pre></td></tr></table></figure>

<p><strong>里面的 *PyInterpreterState* 表示进程状态对象， *PyThreadState* 表示线程状态对象。但是我们看到它们都是typedef起得一个别名，而定义的结构体 *struct _is* 位于 *Include&#x2F;cpython&#x2F;pystate.h* 中， *struct _ts* 位于 *Include&#x2F;internal&#x2F;pycore_pystate.h*中。</strong></p>
<p><strong>线程状态对象：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">ts</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">ts</span> *<span class="title">prev</span>;</span>  <span class="comment">//多个线程状态对象也像链表一样串起来, 因为一个进程里面是可以包含多个线程的, prev指向上一个线程状态对象</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">ts</span> *<span class="title">next</span>;</span>  <span class="comment">//指向下一个线程状态对象</span></span><br><span class="line">    PyInterpreterState *interp;  <span class="comment">//进程状态对象, 标识对应的线程是属于哪一个进程的</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">frame</span> *<span class="title">frame</span>;</span> <span class="comment">//栈帧对象, 模拟线程中函数的调用堆栈</span></span><br><span class="line">    <span class="type">int</span> recursion_depth;  <span class="comment">//递归深度</span></span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    <span class="type">uint64_t</span> id; <span class="comment">//线程id</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>进程状态对象：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">is</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">is</span> *<span class="title">next</span>;</span> <span class="comment">//当前进程的下一个进程</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">ts</span> *<span class="title">tstate_head</span>;</span> <span class="comment">//进程环境中的线程状态对象的集合, 我们说线程状态对象会形成一个链表, 这里就是链表的头结点</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int64_t</span> id; <span class="comment">//线程id</span></span><br><span class="line"> 	<span class="comment">//....</span></span><br><span class="line">    PyObject *audit_hooks;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>我们说 *PyInterpreterState* 对象是对进程的模拟， *PyThreadState* 是对线程的模拟。我们之前分析虚拟机的时候说过其执行环境，如果再将运行时环境加进去的话。</strong></p>
<p><img src="/2023/04/20/24-Python%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E7%8E%AF%E5%A2%83%E5%88%9D%E5%A7%8B%E5%8C%96/1229382-20200909213714167-397884335.png" alt="img"></p>
<h4 id="线程环境的初始化"><a href="#线程环境的初始化" class="headerlink" title="线程环境的初始化"></a>线程环境的初始化</h4><p><strong>在Python启动之后，初始化的动作是从 *Py_NewInterpreter* 函数开始的，然后这个函数调用了 *new_interpreter* 函数完成初始化，我们分析会先从 *new_interpreter* 函数开始，当然 *Py_NewInterpreter* 里面也做了一些工作，具体的后面会说。</strong></p>
<p><strong>我们知道在Windows平台上，当执行一个可执行文件时，操作系统首先创建一个进程内核。同理在Python中亦是如此，会在 *new_interpreter* 中调用 *PyInterpreterState_New* 创建一个崭新的 *PyInterpreterState*对象。该函数位于 *Python&#x2F;pystate.c* 中。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">PyInterpreterState *</span><br><span class="line"><span class="title function_">PyInterpreterState_New</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//申请进程状态对象所需要的内存</span></span><br><span class="line">    PyInterpreterState *interp = PyMem_RawMalloc(<span class="keyword">sizeof</span>(PyInterpreterState));</span><br><span class="line">    <span class="keyword">if</span> (interp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//设置属性</span></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="keyword">return</span> interp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关于进程状态对象我们不做过多解释，只需要知道Python解释器在启动时，会创建一个、或者多个 *PyInterpreterState* 对象，然后通过内部的next指针将多个 *PyInterpreterState* 串成一个链表结构。</strong></p>
<p><strong>在调用 *PyInterpreterState_New* 成功创建 *PyInterpreterState*之后，会再接再厉，调用 *PyThreadState_New* 创建一个全新的线程状态对象，相关函数定义同样位于 *Python&#x2F;pystate.c* 中。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">PyThreadState *</span><br><span class="line"><span class="title function_">PyThreadState_New</span><span class="params">(PyInterpreterState *interp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//我们注意到这个函数接收一个PyInterpreterState</span></span><br><span class="line">    <span class="comment">//这些说明了线程是依赖于进程的，因为需要进程分配资源，而且这个函数又调用了new_threadstate</span></span><br><span class="line">    <span class="comment">//除了传递PyInterpreterState之外，还传了一个1，想也不用想肯定是创建的线程数量</span></span><br><span class="line">    <span class="comment">//这里创建1个，也就是主线程(main thread)</span></span><br><span class="line">    <span class="keyword">return</span> new_threadstate(interp, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyThreadState *</span><br><span class="line"><span class="title function_">new_threadstate</span><span class="params">(PyInterpreterState *interp, <span class="type">int</span> init)</span></span><br><span class="line">&#123;	</span><br><span class="line">    _PyRuntimeState *runtime = &amp;_PyRuntime;</span><br><span class="line">    <span class="comment">//为线程状态对象申请内存</span></span><br><span class="line">    PyThreadState *tstate = (PyThreadState *)PyMem_RawMalloc(<span class="keyword">sizeof</span>(PyThreadState));</span><br><span class="line">    <span class="keyword">if</span> (tstate == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//设置从线程中获取函数调用栈的操作</span></span><br><span class="line">    <span class="keyword">if</span> (_PyThreadState_GetFrame == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        _PyThreadState_GetFrame = threadstate_getframe;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//设置该线程所在的进程</span></span><br><span class="line">    tstate-&gt;interp = interp;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//下面就是设置内部的成员属性</span></span><br><span class="line">    tstate-&gt;frame = <span class="literal">NULL</span>;  <span class="comment">//栈帧</span></span><br><span class="line">    tstate-&gt;recursion_depth = <span class="number">0</span>; <span class="comment">//递归深度</span></span><br><span class="line">    tstate-&gt;id = ++interp-&gt;tstate_next_unique_id;<span class="comment">//线程id</span></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    tstate-&gt;prev = <span class="literal">NULL</span>; <span class="comment">//上一个线程状态对象</span></span><br><span class="line">    tstate-&gt;next = interp-&gt;tstate_head;<span class="comment">//当前线程状态对象的next, 我们看到指向了线程状态对象链表的头结点, 说明是头插法</span></span><br><span class="line">    <span class="keyword">if</span> (tstate-&gt;next)</span><br><span class="line">        <span class="comment">//因为每个线程状态对象的prev指针都要指向它的上一个线程状态对象, 如果是头结点的话, 那么prev就指向NULL</span></span><br><span class="line">        <span class="comment">//但由于新的线程状态对象在插入之后显然就变成了链表的头结点, 因此还需要将插入之间的头结点的prev指向新插入的线程状态对象</span></span><br><span class="line">        tstate-&gt;next-&gt;prev = tstate;</span><br><span class="line">    <span class="comment">//将tstate_head设置为新的线程状态对象(链表的头结点)</span></span><br><span class="line">    interp-&gt;tstate_head = tstate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回线程状态对象</span></span><br><span class="line">    <span class="keyword">return</span> tstate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>和 *PyInterpreterState_New* 相同， *PyThreadState_New* 申请内存，创建 *PyThreadState* 对象，并且对其中每个成员进行初始化。而且其中的prev指针和next指针分别指向了上一个线程状态对象和下一个线程状态对象。而且也肯定会存在某一时刻，存在多个 *PyThreadState* 对象形成一个链表，那么什么时刻会发生这种情况呢？显然用鼻子想也知道这是在Python启动多线程(下一章分析)的时候。</strong></p>
<blockquote>
<p><strong>此外我们看到Python在插入线程状态对象的时候采用的是头插法。</strong></p>
</blockquote>
<p><strong>我们说Python设置了从线程中获取函数调用栈的操作，所谓函数调用栈就是我们前面章节说的PyFrameObject对象链表。而且在源码中，我们看到了 *PyThreadState* 关联了 *PyInterpreterState* ， *PyInterpreterState* 也关联了 *PyInterpreterState* 。到目前为止，仅有的两个对象建立起了联系。对应到Windows，或者说操作系统，我们说进程和线程建立了联系</strong></p>
<p><strong>在 *PyInterpreterState* 和 *PyThreadState* 建立了联系之后，那么就很容易在 *PyInterpreterState* 和*PyThreadState* 之间穿梭。并且在Python运行时环境中，会有一个变量<code>(先买个关子)</code>一直维护着当前活动的线程，更准确的说是当前活动线程(OS线程)对应的 *PyThreadState* 对象。初始时，该变量为NULL。在Python启动之后创建了第一个 *PyThreadState* 之后，会用该 *PyThreadState* 对象调用 *PyThreadState_Swap* 函数来设置这个变量，函数位于 *Python&#x2F;pystate.c* 中。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">PyThreadState *</span><br><span class="line"><span class="title function_">PyThreadState_Swap</span><span class="params">(PyThreadState *newts)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//调用了_PyThreadState_Swap, 里面传入了两个参数, 第一个我们后面说, 显然从名字上看我们知道这是个GIL相关的</span></span><br><span class="line">    <span class="comment">//第二个参数就是创建的线程状态对象</span></span><br><span class="line">    <span class="keyword">return</span> _PyThreadState_Swap(&amp;_PyRuntime.gilstate, newts);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PyThreadState *</span><br><span class="line">_PyThreadState_Swap(<span class="keyword">struct</span> _gilstate_runtime_state *gilstate, PyThreadState *newts)</span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//这里是获取当前的线程状态对象, 并且保证线程的安全性</span></span><br><span class="line">    PyThreadState *oldts = _PyRuntimeGILState_GetThreadState(gilstate);</span><br><span class="line">    <span class="comment">//将GIL交给newts</span></span><br><span class="line">    _PyRuntimeGILState_SetThreadState(gilstate, newts);</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    <span class="keyword">return</span> oldts;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过&amp;(gilstate)-&gt;tstate_current获取当前线程</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _PyRuntimeGILState_GetThreadState(gilstate) \</span></span><br><span class="line"><span class="meta">    ((PyThreadState*)_Py_atomic_load_relaxed(&amp;(gilstate)-&gt;tstate_current))</span></span><br><span class="line"><span class="comment">//将newts设置为当前线程, 可以理解为发生了线程的切换</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _PyRuntimeGILState_SetThreadState(gilstate, value) \</span></span><br><span class="line"><span class="meta">    _Py_atomic_store_relaxed(&amp;(gilstate)-&gt;tstate_current, \</span></span><br><span class="line"><span class="meta">                             (uintptr_t)(value))</span></span><br></pre></td></tr></table></figure>

<p><strong>然后我们看到这两个宏里面出现了 *_Py_atomic_load_relaxed* 、 *_Py_atomic_store_relaxed* 和 *&amp;(gilstate)-&gt;tstate_current* ，这些又是什么呢？还有到底哪个变量在维护这当前的活动线程对应的状态对象呢？其实那两个宏已经告诉你了。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Include/internal/pycore_pystate.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">gilstate_runtime_state</span> &#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//宏里面出现的gilstate就是该结构体实例, tstate_current指的就是当前活动的OS线程对应的状态对象</span></span><br><span class="line">    <span class="comment">//同时也是获取到GIL的Python线程</span></span><br><span class="line">    _Py_atomic_address tstate_current;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Include/internal/pycore_atomic.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _Py_atomic_load_relaxed(ATOMIC_VAL) \</span></span><br><span class="line"><span class="meta">    _Py_atomic_load_explicit((ATOMIC_VAL), _Py_memory_order_relaxed)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _Py_atomic_store_relaxed(ATOMIC_VAL, NEW_VAL) \</span></span><br><span class="line"><span class="meta">    _Py_atomic_store_explicit((ATOMIC_VAL), (NEW_VAL), _Py_memory_order_relaxed)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _Py_atomic_load_explicit(ATOMIC_VAL, ORDER) \</span></span><br><span class="line"><span class="meta">    atomic_load_explicit(&amp;((ATOMIC_VAL)-&gt;_value), ORDER)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _Py_atomic_store_explicit(ATOMIC_VAL, NEW_VAL, ORDER) \</span></span><br><span class="line"><span class="meta">    atomic_store_explicit(&amp;((ATOMIC_VAL)-&gt;_value), NEW_VAL, ORDER)</span></span><br><span class="line"><span class="comment">//_Py_atomic_load_relaxed用到了_Py_atomic_load_explicit, _Py_atomic_load_explicit用到了atomic_load_explicit</span></span><br><span class="line"><span class="comment">//_Py_atomic_store_relaxed用到了_Py_atomic_store_explicit, _Py_atomic_store_explicit用到了atomic_store_explicit</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//而atomic_load_explicit和atomic_store_explicit是系统头文件stdatomic.h中定义的api，这是在系统的api中修改的，所以说是线程安全的</span></span><br></pre></td></tr></table></figure>

<p><strong>介绍完中间部分的内容，那么我们可以从头开始分析Python运行时的初始化了，我们说它是在 *new_interpreter* 函数中调用 *_PyRuntime_Initialize* 函数时开始的，函数位于 *Python&#x2F;pylifecycle.c* 中。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">PyThreadState *</span><br><span class="line"><span class="title function_">Py_NewInterpreter</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//线程状态对象</span></span><br><span class="line">    PyThreadState *tstate = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//传入线程对象, 调用new_interpreter</span></span><br><span class="line">    PyStatus status = new_interpreter(&amp;tstate);</span><br><span class="line">    <span class="comment">//异常检测</span></span><br><span class="line">    <span class="keyword">if</span> (_PyStatus_EXCEPTION(status)) &#123;</span><br><span class="line">        Py_ExitStatusException(status);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回线程状态对象, 显然不会返回一个NULL, 这就说明在new_interpreter中线程状态对象就已经被设置了</span></span><br><span class="line">    <span class="keyword">return</span> tstate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>另外里面出现了一个 *PyStatus*， 表示程序执行的状态， 会检测是否发生了异常，该结构体定义在 *Include&#x2F;cpython&#x2F;initconfig.h* 中。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">        _PyStatus_TYPE_OK=<span class="number">0</span>,</span><br><span class="line">        _PyStatus_TYPE_ERROR=<span class="number">1</span>,</span><br><span class="line">        _PyStatus_TYPE_EXIT=<span class="number">2</span></span><br><span class="line">    &#125; _type;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *func;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *err_msg;</span><br><span class="line">    <span class="type">int</span> exitcode;</span><br><span class="line">&#125; PyStatus;</span><br></pre></td></tr></table></figure>

<p><strong>然后我们的重点是 *new_interpreter*函数，我们进程状态对象的创建就是在这个函数里面发生的，该函数位于*Python&#x2F;pylifecycle.c*中。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> PyStatus</span><br><span class="line"><span class="title function_">new_interpreter</span><span class="params">(PyThreadState **tstate_p)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyStatus status; <span class="comment">//状态对象</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">//运行时初始化, 如果出现异常直接返回</span></span><br><span class="line">    status = _PyRuntime_Initialize();</span><br><span class="line">    <span class="keyword">if</span> (_PyStatus_EXCEPTION(status)) &#123;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">// 创建一个进程状态对象</span></span><br><span class="line">    PyInterpreterState *interp = PyInterpreterState_New();</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//根据进程状态对象创建一个线程状态对象, 维护对应OS线程的状态</span></span><br><span class="line">    PyThreadState *tstate = PyThreadState_New(interp);</span><br><span class="line">    <span class="comment">//将GIL的控制权交给创建的线程</span></span><br><span class="line">    PyThreadState *save_tstate = PyThreadState_Swap(tstate);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Python在初始化运行时环境时，肯定也要对类型系统进行初始化等等，整体是一个非常庞大的过程。有兴趣的话，可以追根溯源对着源码阅读以下。</strong></p>
<p><strong>到这里，我们对 *new_interpreter* 算是有了一个阶段性的成功，我们创建了代表进程和线程概念的 *PyInterpreterState* 和 *PyThreadState* 对象，并且在它们之间建立的联系。下面， *new_interpreter* 将进行入另一个环节，设置系统module。</strong></p>
<h4 id="创建-builtins"><a href="#创建-builtins" class="headerlink" title="创建__builtins__"></a>创建__builtins__</h4><p><strong>在 *new_interpreter* 中当Python解释器创建了 *PyInterpreterState* 和 *PyThreadState* 对象之后，就会开始设置系统的__builtins__了。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> PyStatus</span><br><span class="line"><span class="title function_">new_interpreter</span><span class="params">(PyThreadState **tstate_p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    <span class="comment">//申请一个PyDictObject对象, 用于存储所有的module对象</span></span><br><span class="line">    <span class="comment">//而我们说Python中的module对象都是存在sys.modules中的, 所以这里的modules指的就是Python中的sys.modules</span></span><br><span class="line">    PyObject *modules = PyDict_New();</span><br><span class="line">    <span class="keyword">if</span> (modules == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> _PyStatus_ERR(<span class="string">&quot;can&#x27;t make modules dictionary&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//然后让interp -&gt; modules维护modules</span></span><br><span class="line">    <span class="comment">//我们翻看到这个interp表示的时进程实例对象, 这说明什么? 显然是该进程内的多个线程共享同一个内置名字空间</span></span><br><span class="line">    interp-&gt;modules = modules;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//加载sys模块, 我们说所有的module对象都在sys.modules中</span></span><br><span class="line">    PyObject *sysmod = _PyImport_FindBuiltin(<span class="string">&quot;sys&quot;</span>, modules);</span><br><span class="line">    <span class="keyword">if</span> (sysmod != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        interp-&gt;sysdict = PyModule_GetDict(sysmod);</span><br><span class="line">        <span class="keyword">if</span> (interp-&gt;sysdict == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> handle_error;</span><br><span class="line">        &#125;</span><br><span class="line">        Py_INCREF(interp-&gt;sysdict);</span><br><span class="line">        PyDict_SetItemString(interp-&gt;sysdict, <span class="string">&quot;modules&quot;</span>, modules);</span><br><span class="line">        <span class="keyword">if</span> (_PySys_InitMain(runtime, interp) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> _PyStatus_ERR(<span class="string">&quot;can&#x27;t finish initializing sys&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//加载内置模块, builtins是内置模块, 可以import builtins, 并且builtins.list等价于list</span></span><br><span class="line">    PyObject *bimod = _PyImport_FindBuiltin(<span class="string">&quot;builtins&quot;</span>, modules);</span><br><span class="line">    <span class="keyword">if</span> (bimod != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        interp-&gt;builtins = PyModule_GetDict(bimod);</span><br><span class="line">        <span class="keyword">if</span> (interp-&gt;builtins == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">goto</span> handle_error;</span><br><span class="line">        Py_INCREF(interp-&gt;builtins);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>整体还是比较清晰和直观的，另外我们说内置名字空间是由进程来维护的，因为进程就是用来为线程提供资源的。但是我们也能看出，这意味着一个进程内的多个线程共享同一个内置作用域，显然这是非常合理的，不可能每开启一个线程，就为其创建一个__builtins__。我们来从Python的角度证明这一点：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> builtins</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo1</span>():</span><br><span class="line">    builtins.<span class="built_in">list</span>, builtins.<span class="built_in">tuple</span> = builtins.<span class="built_in">tuple</span>, builtins.<span class="built_in">list</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo2</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;猜猜下面代码会输出什么：&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;list:&quot;</span>, <span class="built_in">list</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;tuple:&quot;</span>, <span class="built_in">tuple</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f1 = threading.Thread(target=foo1)</span><br><span class="line">f1.start()</span><br><span class="line">f1.join()</span><br><span class="line">threading.Thread(target=foo2).start()</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">猜猜下面代码会输出什么：</span></span><br><span class="line"><span class="string">list: (1, 2, 3, 4, 5)</span></span><br><span class="line"><span class="string">tuple: [1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>我们说所有的内建对象和内置函数都在内置名字空间里面，我们可以通过  import  builtins获取、也可以直接通过__builtins__这个变量来获取。我们在foo1中把list和tuple互换了，而这个结果显然也影响到了foo2函数。这也说明了__builtins__是属于进程级别的，它是被多个线程共享的。所以是<code>interp -&gt; modules = modules</code>，当然这个modules是sys.modules，因为不止内置名字空间，所有的module对象都是被多个线程共享的。</strong></p>
<p><strong>而对__builts__的初始化时在 *_PyBuiltin_Init* 函数中进行的，它位于 *Python&#x2F;bltinmodule.c* 中。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">PyObject *</span><br><span class="line">_PyBuiltin_Init(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    PyObject *mod, *dict, *debug;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> PyConfig *config = &amp;_PyInterpreterState_GET_UNSAFE()-&gt;config;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PyType_Ready(&amp;PyFilter_Type) &lt; <span class="number">0</span> ||</span><br><span class="line">        PyType_Ready(&amp;PyMap_Type) &lt; <span class="number">0</span> ||</span><br><span class="line">        PyType_Ready(&amp;PyZip_Type) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//创建并设置__builtins__ module</span></span><br><span class="line">    mod = _PyModule_CreateInitialized(&amp;builtinsmodule, PYTHON_API_VERSION);</span><br><span class="line">    <span class="keyword">if</span> (mod == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//将所有python内建对象加入到__builtins__ module中</span></span><br><span class="line">    dict = PyModule_GetDict(mod);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//老铁们，下面这些东西应该不陌生吧   </span></span><br><span class="line">    SETBUILTIN(<span class="string">&quot;None&quot;</span>,                  Py_None);</span><br><span class="line">    SETBUILTIN(<span class="string">&quot;Ellipsis&quot;</span>,              Py_Ellipsis);</span><br><span class="line">    SETBUILTIN(<span class="string">&quot;NotImplemented&quot;</span>,        Py_NotImplemented);</span><br><span class="line">    SETBUILTIN(<span class="string">&quot;False&quot;</span>,                 Py_False);</span><br><span class="line">    SETBUILTIN(<span class="string">&quot;True&quot;</span>,                  Py_True);</span><br><span class="line">    SETBUILTIN(<span class="string">&quot;bool&quot;</span>,                  &amp;PyBool_Type);</span><br><span class="line">    SETBUILTIN(<span class="string">&quot;memoryview&quot;</span>,        &amp;PyMemoryView_Type);</span><br><span class="line">    SETBUILTIN(<span class="string">&quot;bytearray&quot;</span>,             &amp;PyByteArray_Type);</span><br><span class="line">    SETBUILTIN(<span class="string">&quot;bytes&quot;</span>,                 &amp;PyBytes_Type);</span><br><span class="line">    SETBUILTIN(<span class="string">&quot;classmethod&quot;</span>,           &amp;PyClassMethod_Type);</span><br><span class="line">    SETBUILTIN(<span class="string">&quot;complex&quot;</span>,               &amp;PyComplex_Type);</span><br><span class="line">    SETBUILTIN(<span class="string">&quot;dict&quot;</span>,                  &amp;PyDict_Type);</span><br><span class="line">    SETBUILTIN(<span class="string">&quot;enumerate&quot;</span>,             &amp;PyEnum_Type);</span><br><span class="line">    SETBUILTIN(<span class="string">&quot;filter&quot;</span>,                &amp;PyFilter_Type);</span><br><span class="line">    SETBUILTIN(<span class="string">&quot;float&quot;</span>,                 &amp;PyFloat_Type);</span><br><span class="line">    SETBUILTIN(<span class="string">&quot;frozenset&quot;</span>,             &amp;PyFrozenSet_Type);</span><br><span class="line">    SETBUILTIN(<span class="string">&quot;property&quot;</span>,              &amp;PyProperty_Type);</span><br><span class="line">    SETBUILTIN(<span class="string">&quot;int&quot;</span>,                   &amp;PyLong_Type);</span><br><span class="line">    SETBUILTIN(<span class="string">&quot;list&quot;</span>,                  &amp;PyList_Type);</span><br><span class="line">    SETBUILTIN(<span class="string">&quot;map&quot;</span>,                   &amp;PyMap_Type);</span><br><span class="line">    SETBUILTIN(<span class="string">&quot;object&quot;</span>,                &amp;PyBaseObject_Type);</span><br><span class="line">    SETBUILTIN(<span class="string">&quot;range&quot;</span>,                 &amp;PyRange_Type);</span><br><span class="line">    SETBUILTIN(<span class="string">&quot;reversed&quot;</span>,              &amp;PyReversed_Type);</span><br><span class="line">    SETBUILTIN(<span class="string">&quot;set&quot;</span>,                   &amp;PySet_Type);</span><br><span class="line">    SETBUILTIN(<span class="string">&quot;slice&quot;</span>,                 &amp;PySlice_Type);</span><br><span class="line">    SETBUILTIN(<span class="string">&quot;staticmethod&quot;</span>,          &amp;PyStaticMethod_Type);</span><br><span class="line">    SETBUILTIN(<span class="string">&quot;str&quot;</span>,                   &amp;PyUnicode_Type);</span><br><span class="line">    SETBUILTIN(<span class="string">&quot;super&quot;</span>,                 &amp;PySuper_Type);</span><br><span class="line">    SETBUILTIN(<span class="string">&quot;tuple&quot;</span>,                 &amp;PyTuple_Type);</span><br><span class="line">    SETBUILTIN(<span class="string">&quot;type&quot;</span>,                  &amp;PyType_Type);</span><br><span class="line">    SETBUILTIN(<span class="string">&quot;zip&quot;</span>,                   &amp;PyZip_Type);</span><br><span class="line">    debug = PyBool_FromLong(config-&gt;optimization_level == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (PyDict_SetItemString(dict, <span class="string">&quot;__debug__&quot;</span>, debug) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        Py_DECREF(debug);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Py_DECREF(debug);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mod;</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> ADD_TO_ALL</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> SETBUILTIN</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>整个 *<em>PyBuiltin__Init* 函数的功能就是设置好__builtins</em>_ module，而这个过程是分为两步的。</strong></p>
<ul>
<li><code>通过_PyModule_CreateInitialized函数创建PyModuleObject对象，我们知道这是Python中模块对象的底层实现;</code></li>
<li><code>设置module，将python中所有的内建对象都塞到__builtins__中</code></li>
</ul>
<p><strong>但是我们看到设置的东西似乎少了不少，比如dir、hasattr、setattr等等，这些明显也是内置的，但是它们到哪里去了。别急，我们刚才说创建__builtins__分为两步，第一步是创建PyModuleObject，而使用的函数就是 *_PyModule_CreateInitialized* ，而在这个函数里面就已经完成了大部分设置__builtins__的工作。该函数位于 *Object&#x2F;moduleobject.c* 。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">PyObject *</span><br><span class="line">_PyModule_CreateInitialized(<span class="keyword">struct</span> PyModuleDef* module, <span class="type">int</span> module_api_version)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* name;</span><br><span class="line">    PyModuleObject *m;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">if</span> (!PyModuleDef_Init(module))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//拿到module的name，对于当前来说，这里显然是__builtins__</span></span><br><span class="line">    name = module-&gt;m_name;</span><br><span class="line">    <span class="comment">//这里比较有意思，这是检测模块版本的，针对的是需要导入的py文件。</span></span><br><span class="line">    <span class="comment">//我们说编译成PyCodeObject对象之后，会直接从当前目录的__pycache__里面导入</span></span><br><span class="line">    <span class="comment">//而那里面都是pyc文件，介绍字节码的时候我们说，pyc文件的文件名是有Python解释器的版本号的</span></span><br><span class="line">    <span class="comment">//这里就是比较版本是否一致，不一致则不导入pyc文件，而是会重新编译py文件    </span></span><br><span class="line">    <span class="keyword">if</span> (!check_api_version(name, module_api_version)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (module-&gt;m_slots) &#123;</span><br><span class="line">        PyErr_Format(</span><br><span class="line">            PyExc_SystemError,</span><br><span class="line">            <span class="string">&quot;module %s: PyModule_Create is incompatible with m_slots&quot;</span>, name);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建一个PyModuleObject </span></span><br><span class="line">    <span class="keyword">if</span> ((m = (PyModuleObject*)PyModule_New(name)) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line">    <span class="keyword">if</span> (module-&gt;m_methods != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//遍历methods中指定的module对象中应包含的操作集合</span></span><br><span class="line">        <span class="keyword">if</span> (PyModule_AddFunctions((PyObject *) m, module-&gt;m_methods) != <span class="number">0</span>) &#123;</span><br><span class="line">            Py_DECREF(m);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (module-&gt;m_doc != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//设置docstring</span></span><br><span class="line">        <span class="keyword">if</span> (PyModule_SetDocString((PyObject *) m, module-&gt;m_doc) != <span class="number">0</span>) &#123;</span><br><span class="line">            Py_DECREF(m);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    m-&gt;md_def = module;</span><br><span class="line">    <span class="keyword">return</span> (PyObject*)m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>根据上面的代码我们可以得出如下信息：</strong></p>
<ul>
<li><code>1. name：module对象的名称，在这里就是__builtins__</code></li>
<li><code>2. module_api_version：python内部使用的version值，用于比较</code></li>
<li><code>3. PyModule_New：用于创建一个PyModuleObject对象</code></li>
<li><code>4. methods：该module中所包含的函数的集合，在这里是builtin_methods</code></li>
<li><code>5. PyModule_AddFunctions：设置methods中的函数操作</code></li>
<li><code>6. PyModule_SetDocString：设置docstring</code></li>
</ul>
<h5 id="创建module对象"><a href="#创建module对象" class="headerlink" title="创建module对象"></a>创建module对象</h5><p><strong>我们说Python中的module对象在底层cpython中对应的结构体是PyModuleObject对象，我们来看看它长什么样子吧，定义在 *Objects&#x2F;moduleobject.c* 中。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_HEAD  <span class="comment">//头部信息</span></span><br><span class="line">    PyObject *md_dict;  <span class="comment">//属性字典, 所有的属性和值都在里面</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PyModuleDef</span> *<span class="title">md_def</span>;</span>  <span class="comment">//module对象包含的操作集合, 里面是一些结构体, 每个结构体包含一个函数的相关信息</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    PyObject *md_name;  <span class="comment">//模块名</span></span><br><span class="line">&#125; PyModuleObject;</span><br></pre></td></tr></table></figure>

<p><strong>而这个对象我们知道是通过PyModule_New创建的。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyModule_New</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//module对象的name、PyModuleObject</span></span><br><span class="line">    PyObject *nameobj, *module;</span><br><span class="line">    nameobj = PyUnicode_FromString(name);</span><br><span class="line">    <span class="keyword">if</span> (nameobj == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//根据创建PyModuleObject</span></span><br><span class="line">    module = PyModule_NewObject(nameobj);</span><br><span class="line">    Py_DECREF(nameobj);</span><br><span class="line">    <span class="keyword">return</span> module;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyModule_NewObject</span><span class="params">(PyObject *name)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//创建一个module对象</span></span><br><span class="line">    PyModuleObject *m;</span><br><span class="line">    <span class="comment">//申请空间</span></span><br><span class="line">    m = PyObject_GC_New(PyModuleObject, &amp;PyModule_Type);</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//设置相应属性, 初始化为NULL</span></span><br><span class="line">    m-&gt;md_def = <span class="literal">NULL</span>;</span><br><span class="line">    m-&gt;md_state = <span class="literal">NULL</span>;</span><br><span class="line">    m-&gt;md_weaklist = <span class="literal">NULL</span>;</span><br><span class="line">    m-&gt;md_name = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//属性字典</span></span><br><span class="line">    m-&gt;md_dict = PyDict_New();</span><br><span class="line">    <span class="comment">//调用module_init_dict</span></span><br><span class="line">    <span class="keyword">if</span> (module_init_dict(m, m-&gt;md_dict, name, <span class="literal">NULL</span>) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    PyObject_GC_Track(m);</span><br><span class="line">    <span class="keyword">return</span> (PyObject *)m;</span><br><span class="line"></span><br><span class="line"> fail:</span><br><span class="line">    Py_DECREF(m);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">module_init_dict</span><span class="params">(PyModuleObject *mod, PyObject *md_dict,</span></span><br><span class="line"><span class="params">                 PyObject *name, PyObject *doc)</span></span><br><span class="line">&#123;</span><br><span class="line">    _Py_IDENTIFIER(__name__);</span><br><span class="line">    _Py_IDENTIFIER(__doc__);</span><br><span class="line">    _Py_IDENTIFIER(__package__);</span><br><span class="line">    _Py_IDENTIFIER(__loader__);</span><br><span class="line">    _Py_IDENTIFIER(__spec__);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (md_dict == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (doc == <span class="literal">NULL</span>)</span><br><span class="line">        doc = Py_None;</span><br><span class="line">	<span class="comment">//模块的一些属性、__name__、__doc__等等</span></span><br><span class="line">    <span class="keyword">if</span> (_PyDict_SetItemId(md_dict, &amp;PyId___name__, name) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (_PyDict_SetItemId(md_dict, &amp;PyId___doc__, doc) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (_PyDict_SetItemId(md_dict, &amp;PyId___package__, Py_None) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (_PyDict_SetItemId(md_dict, &amp;PyId___loader__, Py_None) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (_PyDict_SetItemId(md_dict, &amp;PyId___spec__, Py_None) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (PyUnicode_CheckExact(name)) &#123;</span><br><span class="line">        Py_INCREF(name);</span><br><span class="line">        Py_XSETREF(mod-&gt;md_name, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这里虽然创建了一个module对象，但是这仅仅是一个空的module对象，却并没有包含相应的操作和数据。我们看到只设置了name和doc等属性。</strong></p>
<h5 id="设置module对象"><a href="#设置module对象" class="headerlink" title="设置module对象"></a>设置module对象</h5><p><strong>在PyModule_New结束之后，程序继续执行 *_PyModule_CreateInitialized* 下面的代码，然后我们知道通过 *PyModule_AddFunctions* 完成了对__builtins__几乎全部属性的设置。这个设置的属性依赖于第二个参数methods，在这里为builtin_methods。然后会遍历builtin_methods，并处理每一项元素，我们还是来看看长什么样子。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Python/bltinmodule.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyMethodDef builtin_methods[] = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;__build_class__&quot;</span>, (PyCFunction)(<span class="type">void</span>(*)(<span class="type">void</span>))builtin___build_class__,</span><br><span class="line">     METH_FASTCALL | METH_KEYWORDS, build_class_doc&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;__import__&quot;</span>,      (PyCFunction)(<span class="type">void</span>(*)(<span class="type">void</span>))builtin___import__, METH_VARARGS | METH_KEYWORDS, import_doc&#125;,</span><br><span class="line">    BUILTIN_ABS_METHODDEF</span><br><span class="line">    BUILTIN_ALL_METHODDEF</span><br><span class="line">    BUILTIN_ANY_METHODDEF</span><br><span class="line">    BUILTIN_ASCII_METHODDEF</span><br><span class="line">    BUILTIN_BIN_METHODDEF</span><br><span class="line">    &#123;<span class="string">&quot;breakpoint&quot;</span>,      (PyCFunction)(<span class="type">void</span>(*)(<span class="type">void</span>))builtin_breakpoint, METH_FASTCALL | METH_KEYWORDS, breakpoint_doc&#125;,</span><br><span class="line">    BUILTIN_CALLABLE_METHODDEF</span><br><span class="line">    BUILTIN_CHR_METHODDEF</span><br><span class="line">    BUILTIN_COMPILE_METHODDEF</span><br><span class="line">    BUILTIN_DELATTR_METHODDEF</span><br><span class="line">    &#123;<span class="string">&quot;dir&quot;</span>,             builtin_dir,        METH_VARARGS, dir_doc&#125;,</span><br><span class="line">    BUILTIN_DIVMOD_METHODDEF</span><br><span class="line">    BUILTIN_EVAL_METHODDEF</span><br><span class="line">    BUILTIN_EXEC_METHODDEF</span><br><span class="line">    BUILTIN_FORMAT_METHODDEF</span><br><span class="line">    &#123;<span class="string">&quot;getattr&quot;</span>,         (PyCFunction)(<span class="type">void</span>(*)(<span class="type">void</span>))builtin_getattr, METH_FASTCALL, getattr_doc&#125;,</span><br><span class="line">    BUILTIN_GLOBALS_METHODDEF</span><br><span class="line">    BUILTIN_HASATTR_METHODDEF</span><br><span class="line">    BUILTIN_HASH_METHODDEF</span><br><span class="line">    BUILTIN_HEX_METHODDEF</span><br><span class="line">    BUILTIN_ID_METHODDEF</span><br><span class="line">    BUILTIN_INPUT_METHODDEF</span><br><span class="line">    BUILTIN_ISINSTANCE_METHODDEF</span><br><span class="line">    BUILTIN_ISSUBCLASS_METHODDEF</span><br><span class="line">    &#123;<span class="string">&quot;iter&quot;</span>,            (PyCFunction)(<span class="type">void</span>(*)(<span class="type">void</span>))builtin_iter,       METH_FASTCALL, iter_doc&#125;,</span><br><span class="line">    BUILTIN_LEN_METHODDEF</span><br><span class="line">    BUILTIN_LOCALS_METHODDEF</span><br><span class="line">    &#123;<span class="string">&quot;max&quot;</span>,             (PyCFunction)(<span class="type">void</span>(*)(<span class="type">void</span>))builtin_max,        METH_VARARGS | METH_KEYWORDS, max_doc&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;min&quot;</span>,             (PyCFunction)(<span class="type">void</span>(*)(<span class="type">void</span>))builtin_min,        METH_VARARGS | METH_KEYWORDS, min_doc&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;next&quot;</span>,            (PyCFunction)(<span class="type">void</span>(*)(<span class="type">void</span>))builtin_next,       METH_FASTCALL, next_doc&#125;,</span><br><span class="line">    BUILTIN_OCT_METHODDEF</span><br><span class="line">    BUILTIN_ORD_METHODDEF</span><br><span class="line">    BUILTIN_POW_METHODDEF</span><br><span class="line">    &#123;<span class="string">&quot;print&quot;</span>,           (PyCFunction)(<span class="type">void</span>(*)(<span class="type">void</span>))builtin_print,      METH_FASTCALL | METH_KEYWORDS, print_doc&#125;,</span><br><span class="line">    BUILTIN_REPR_METHODDEF</span><br><span class="line">    BUILTIN_ROUND_METHODDEF</span><br><span class="line">    BUILTIN_SETATTR_METHODDEF</span><br><span class="line">    BUILTIN_SORTED_METHODDEF</span><br><span class="line">    BUILTIN_SUM_METHODDEF</span><br><span class="line">    &#123;<span class="string">&quot;vars&quot;</span>,            builtin_vars,       METH_VARARGS, vars_doc&#125;,</span><br><span class="line">    &#123;<span class="literal">NULL</span>,              <span class="literal">NULL</span>&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>怎么样，是不是看到了玄机。</strong></p>
<p><strong>总结一下就是：在 *Py_NewInterpreter* 中调用 *new_interpreter* 函数，然后在 *new_interpreter* 这个函数里面，通过 *PyInterpreterState_New* 创建 *PyInterpreterState* ，然后传递 *PyInterpreterState* 调用 *PyThreadState_New* 得到 *PyThreadState* 对象。</strong></p>
<p><strong>接着就是执行各种初始化动作，然后在 *new_interpreter* 中调用 *_PyBuiltin_Init* 设置内建属性，在代码的最后会设置大量的内置属性<code>(函数、对象)</code>。但是有几个却不在里面，比如：dir、getattr等等。所以中间调用的 *_PyModule_CreateInitialized* 不仅仅是初始化一个module对象，还会在初始化之后将我们没有看到的一些属性设置进去，在 *_PyModule_CreateInitialized* 里面，先是使用 *PyModule_New* 创建一个PyModuleObject，在里面设置了name和doc等属性之后，再通过 *PyModule_AddFunctions* 设置methods，在这里面我们看到了dir、getattr等内置属性。当这些属性设置完之后，退回到 *_PyBuiltin_Init* 函数中，再设置剩余的大量属性。之后，__builtins__就完成了。</strong></p>
<p><strong>另外 builtin_methods 是一个 PyMethodDef 类型的数组，里面是一个个的 PyMethodDef 结构体，而这个结构体定义在 *Include&#x2F;methodobject.h* 中。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PyMethodDef</span> &#123;</span></span><br><span class="line">    <span class="comment">/* 内置的函数或者方法名 */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>  *ml_name;   </span><br><span class="line">    <span class="comment">/* 实现对应逻辑的C函数，但是需要转成PyCFunction类型，主要是为了更好的处理关键字参数 */</span></span><br><span class="line">    PyCFunction ml_meth;    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 参数类型 </span></span><br><span class="line"><span class="comment">    #define METH_VARARGS  0x0001  扩展位置参数</span></span><br><span class="line"><span class="comment">    #define METH_KEYWORDS 0x0002  扩展关键字参数</span></span><br><span class="line"><span class="comment">    #define METH_NOARGS   0x0004  不需要参数</span></span><br><span class="line"><span class="comment">    #define METH_O        0x0008  需要一个参数</span></span><br><span class="line"><span class="comment">    #define METH_CLASS    0x0010  被classmethod装饰</span></span><br><span class="line"><span class="comment">    #define METH_STATIC   0x0020  被staticmethod装饰   </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">int</span>         ml_flags;   </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//函数的__dic__</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>  *ml_doc; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PyMethodDef</span> <span class="title">PyMethodDef</span>;</span></span><br></pre></td></tr></table></figure>

<p><strong>对于这里面每一个 *PyMethodDef* ，*_PyModule_CreateInitialized* 都会基于它创建一个 *PyCFunctionObject* 对象， 这个对象Python对函数指针的包装， 当然里面好包含了其它信息。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_HEAD  <span class="comment">//头部信息</span></span><br><span class="line">    PyMethodDef *m_ml;  <span class="comment">//PyMethodDef</span></span><br><span class="line">    PyObject    *m_self;  <span class="comment">//self参数</span></span><br><span class="line">    PyObject    *m_module;  <span class="comment">//__module__属性</span></span><br><span class="line">    PyObject    *m_weakreflist;  <span class="comment">//弱引用列表, 不讨论</span></span><br><span class="line">    vectorcallfunc vectorcall;</span><br><span class="line">&#125; PyCFunctionObject;</span><br></pre></td></tr></table></figure>

<p><strong>而 *PyCFunctionObject* 对象则是通过 *PyCFunction_New* 完成的，该函数位于 *Objects&#x2F;methodobject.c* 中。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyCFunction_New</span><span class="params">(PyMethodDef *ml, PyObject *self)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> PyCFunction_NewEx(ml, self, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyCFunction_NewEx</span><span class="params">(PyMethodDef *ml, PyObject *self, PyObject *module)</span></span><br><span class="line">&#123;</span><br><span class="line">    vectorcallfunc vectorcall;</span><br><span class="line">    <span class="comment">//判断参数类型</span></span><br><span class="line">    <span class="keyword">switch</span> (ml-&gt;ml_flags &amp; (METH_VARARGS | METH_FASTCALL | METH_NOARGS | METH_O | METH_KEYWORDS))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> METH_VARARGS:</span><br><span class="line">        <span class="keyword">case</span> METH_VARARGS | METH_KEYWORDS:</span><br><span class="line">            vectorcall = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> METH_FASTCALL:</span><br><span class="line">            vectorcall = cfunction_vectorcall_FASTCALL;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> METH_FASTCALL | METH_KEYWORDS:</span><br><span class="line">            vectorcall = cfunction_vectorcall_FASTCALL_KEYWORDS;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> METH_NOARGS:</span><br><span class="line">            vectorcall = cfunction_vectorcall_NOARGS;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> METH_O:</span><br><span class="line">            vectorcall = cfunction_vectorcall_O;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            PyErr_Format(PyExc_SystemError,</span><br><span class="line">                         <span class="string">&quot;%s() method: bad call flags&quot;</span>, ml-&gt;ml_name);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PyCFunctionObject *op;</span><br><span class="line">    <span class="comment">//我们看到这里也采用了缓存池的策略</span></span><br><span class="line">    op = free_list;</span><br><span class="line">    <span class="keyword">if</span> (op != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        free_list = (PyCFunctionObject *)(op-&gt;m_self);</span><br><span class="line">        (<span class="type">void</span>)PyObject_INIT(op, &amp;PyCFunction_Type);</span><br><span class="line">        numfree--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//否则重新申请</span></span><br><span class="line">        op = PyObject_GC_New(PyCFunctionObject, &amp;PyCFunction_Type);</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置属性</span></span><br><span class="line">    op-&gt;m_weakreflist = <span class="literal">NULL</span>;</span><br><span class="line">    op-&gt;m_ml = ml;</span><br><span class="line">    Py_XINCREF(self);</span><br><span class="line">    op-&gt;m_self = self;</span><br><span class="line">    Py_XINCREF(module);</span><br><span class="line">    op-&gt;m_module = module;</span><br><span class="line">    op-&gt;vectorcall = vectorcall;</span><br><span class="line">    _PyObject_GC_TRACK(op);</span><br><span class="line">    <span class="keyword">return</span> (PyObject *)op;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在 *_PyBuiltin__Init* 之后，Python会把PyModuleObject对象中维护的那个PyDictObject对象抽取出来，将其赋值给 *interp -&gt; builtins* 。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//moduleobject.c</span></span><br><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyModule_GetDict</span><span class="params">(PyObject *m)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyObject *d;</span><br><span class="line">    <span class="keyword">if</span> (!PyModule_Check(m)) &#123;</span><br><span class="line">        PyErr_BadInternalCall();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    d = ((PyModuleObject *)m) -&gt; md_dict;</span><br><span class="line">    assert(d != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyStatus</span><br><span class="line"><span class="title function_">new_interpreter</span><span class="params">(PyThreadState **tstate_p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    PyObject *bimod = _PyImport_FindBuiltin(<span class="string">&quot;builtins&quot;</span>, modules);</span><br><span class="line">    <span class="keyword">if</span> (bimod != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//通过PyModule_GetDict获取属性字典, 赋值给builtins</span></span><br><span class="line">        interp-&gt;builtins = PyModule_GetDict(bimod);</span><br><span class="line">        <span class="keyword">if</span> (interp-&gt;builtins == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">goto</span> handle_error;</span><br><span class="line">        Py_INCREF(interp-&gt;builtins);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (PyErr_Occurred()) &#123;</span><br><span class="line">        <span class="keyword">goto</span> handle_error;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>以后Python在需要访问__builtins__时，直接访问 *interp-&gt;builtins* 就可以了，不需要再到 *interp-&gt;modules* 里面去找了。因为对于内置函数、属性的使用在Python中会比较频繁，所以这种加速机制是很有效的。</strong></p>
<h4 id="创建sys-module"><a href="#创建sys-module" class="headerlink" title="创建sys module"></a>创建sys module</h4><p><strong>Python在创建并设置了__builtins__之后，会照猫画虎，用同样的流程来设置sys module，并像设置 *interp-&gt;builtins* 一样设置 *interp-&gt;sysdict* 。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Python/pylifecycle.c</span></span><br><span class="line"><span class="type">static</span> PyStatus</span><br><span class="line"><span class="title function_">new_interpreter</span><span class="params">(PyThreadState **tstate_p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line">    PyObject *sysmod = _PyImport_FindBuiltin(<span class="string">&quot;sys&quot;</span>, modules);</span><br><span class="line">    <span class="keyword">if</span> (sysmod != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        interp-&gt;sysdict = PyModule_GetDict(sysmod);</span><br><span class="line">        <span class="keyword">if</span> (interp-&gt;sysdict == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> handle_error;</span><br><span class="line">        &#125;</span><br><span class="line">        Py_INCREF(interp-&gt;sysdict);</span><br><span class="line">        <span class="comment">//设置</span></span><br><span class="line">        PyDict_SetItemString(interp-&gt;sysdict, <span class="string">&quot;modules&quot;</span>, modules);</span><br><span class="line">        <span class="keyword">if</span> (_PySys_InitMain(runtime, interp) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> _PyStatus_ERR(<span class="string">&quot;can&#x27;t finish initializing sys&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Python在创建了sys module之后，会在此module中设置一个Python搜索module时的默认路径集合。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Python/pylifecycle.c</span></span><br><span class="line"><span class="type">static</span> PyStatus</span><br><span class="line"><span class="title function_">new_interpreter</span><span class="params">(PyThreadState **tstate_p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line">    status = add_main_module(interp);</span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyStatus</span><br><span class="line"><span class="title function_">add_main_module</span><span class="params">(PyInterpreterState *interp)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyObject *m, *d, *loader, *ann_dict;</span><br><span class="line">    <span class="comment">//将__main__添加进sys.modules中</span></span><br><span class="line">    m = PyImport_AddModule(<span class="string">&quot;__main__&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> _PyStatus_ERR(<span class="string">&quot;can&#x27;t create __main__ module&quot;</span>);</span><br><span class="line"></span><br><span class="line">    d = PyModule_GetDict(m);</span><br><span class="line">    ann_dict = PyDict_New();</span><br><span class="line">    <span class="keyword">if</span> ((ann_dict == <span class="literal">NULL</span>) ||</span><br><span class="line">        (PyDict_SetItemString(d, <span class="string">&quot;__annotations__&quot;</span>, ann_dict) &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> _PyStatus_ERR(<span class="string">&quot;Failed to initialize __main__.__annotations__&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Py_DECREF(ann_dict);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PyDict_GetItemString(d, <span class="string">&quot;__builtins__&quot;</span>) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        PyObject *bimod = PyImport_ImportModule(<span class="string">&quot;builtins&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (bimod == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> _PyStatus_ERR(<span class="string">&quot;Failed to retrieve builtins module&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (PyDict_SetItemString(d, <span class="string">&quot;__builtins__&quot;</span>, bimod) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> _PyStatus_ERR(<span class="string">&quot;Failed to initialize __main__.__builtins__&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Py_DECREF(bimod);</span><br><span class="line">    &#125;</span><br><span class="line">    loader = PyDict_GetItemString(d, <span class="string">&quot;__loader__&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (loader == <span class="literal">NULL</span> || loader == Py_None) &#123;</span><br><span class="line">        PyObject *loader = PyObject_GetAttrString(interp-&gt;importlib,</span><br><span class="line">                                                  <span class="string">&quot;BuiltinImporter&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (loader == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> _PyStatus_ERR(<span class="string">&quot;Failed to retrieve BuiltinImporter&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (PyDict_SetItemString(d, <span class="string">&quot;__loader__&quot;</span>, loader) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> _PyStatus_ERR(<span class="string">&quot;Failed to initialize __main__.__loader__&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Py_DECREF(loader);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _PyStatus_OK();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>根据我们使用Python的经验，我们知道最终Python肯定会创建一个PyListObject对象，也就是Python中的sys.path，里面包含了一组PyUnicodeObject，每一个PyUnicodeObject的内容就代表了一个搜索路径。但是这一步不是在这里完成的，至于是在哪里完成的，我们后面会说。</strong></p>
<p><strong>另外，我们需要注意的是：在上面的逻辑中，解释器将__main__这个模块添加进去了，这个__main__估计不用我多说了。之前在 *PyModule_New* 中，创建一个PyModuleObject对象之后，会在其属性字典<code>(md_dict获取)</code>中插入一个名为”<strong>name</strong>“的key，value就是 “<strong>main</strong>“。但是对于当然模块来说，这个模块也可以叫做__main__。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&quot;神楽七奈&quot;</span></span><br><span class="line"><span class="keyword">import</span> __main__</span><br><span class="line"><span class="built_in">print</span>(__main__.name)  <span class="comment"># 神楽七奈</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">print</span>(sys.modules[<span class="string">&quot;__main__&quot;</span>] <span class="keyword">is</span> __main__)  <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<p><strong>我们发现这样也是可以导入的，因为这个__main__就是这个模块本身。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> PyStatus</span><br><span class="line"><span class="title function_">add_main_module</span><span class="params">(PyInterpreterState *interp)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyObject *m, *d, *loader, *ann_dict;</span><br><span class="line">    <span class="comment">//创建__main__ module，并将其插入到interp-&gt;modules中</span></span><br><span class="line">    m = PyImport_AddModule(<span class="string">&quot;__main__&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> _PyStatus_ERR(<span class="string">&quot;can&#x27;t create __main__ module&quot;</span>);</span><br><span class="line">    <span class="comment">//获取__main__的属性字典</span></span><br><span class="line">    d = PyModule_GetDict(m);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取interp-&gt;modules中的__builtins__ module</span></span><br><span class="line">    <span class="keyword">if</span> (PyDict_GetItemString(d, <span class="string">&quot;__builtins__&quot;</span>) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        PyObject *bimod = PyImport_ImportModule(<span class="string">&quot;builtins&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (bimod == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> _PyStatus_ERR(<span class="string">&quot;Failed to retrieve builtins module&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将(&quot;__builtins__&quot;, __builtins__)插入到__main__ module的dict中</span></span><br><span class="line">        <span class="keyword">if</span> (PyDict_SetItemString(d, <span class="string">&quot;__builtins__&quot;</span>, bimod) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> _PyStatus_ERR(<span class="string">&quot;Failed to initialize __main__.__builtins__&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Py_DECREF(bimod);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>因此我们算是知道了，为什么python  xxx.py执行的时候，__name__是__main__了，因为我们这里设置了。而Python沿着名字空间寻找的时候，最终会在__main__的local空间中发现__name__，且值为字符串”<strong>main</strong>“。但如果是以import的方式加载的，那么__name__则不是”<strong>main</strong>“，而是模块名,后面我们会继续说。</strong></p>
<p><img src="/2023/04/20/24-Python%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E7%8E%AF%E5%A2%83%E5%88%9D%E5%A7%8B%E5%8C%96/1229382-20191226190436915-1589229349.png" alt="2.png"></p>
<p><strong>其实这个__main__我们是再熟悉不过的了，当输入dir()的时候，就会显示__main__的内容。dir是可以不加参数的，如果不加参数，那么默认访问当前的py文件，也就是__main__。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>__name__</span><br><span class="line"><span class="string">&#x27;__main__&#x27;</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>__builtins__.__name__</span><br><span class="line"><span class="string">&#x27;builtins&#x27;</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.__name__</span><br><span class="line"><span class="string">&#x27;numpy&#x27;</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>所以说，访问模块就类似访问变量一样。modules里面存放了所有的(module name,  PyModuleObject)，当我们调用np的时候，是会找到name为”numpy”的值，然后这个值里面也维护了一个字典，其中就有一个key为__name__的entry。</strong></p>
<h4 id="设置site-specific的module的搜索路径"><a href="#设置site-specific的module的搜索路径" class="headerlink" title="设置site-specific的module的搜索路径"></a>设置site-specific的module的搜索路径</h4><p><strong>Python是一个非常开放的体系，它的强大来源于丰富的第三方库，这些库由外部的py文件来提供，当使用这些第三方库的时候，只需要简单的进行import即可。一般来说，这些第三方库都放在<code>/lib/site-packages</code>中，如果程序想使用这些库，直接把库放在这里面即可。</strong></p>
<p><strong>但是到目前为止，我们好像也没看到python将site-packages路径设置到搜索路径里面去啊。其实在完成了__main__的创建之后，Python才腾出手来，收拾这个site-package。这个关键的动作在于Python的一个标准库：site.py。</strong></p>
<p><strong>我们先来将Lib目录下的site.py删掉，然后导入一个第三方模块，看看会有什么后果。</strong></p>
<p><img src="/2023/04/20/24-Python%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E7%8E%AF%E5%A2%83%E5%88%9D%E5%A7%8B%E5%8C%96/1229382-20200909213801726-2007195328.png" alt="img"></p>
<p><strong>因此我们发现，Python在初始化的过程中确实导入了site.py，所以才有了如下的输出。而这个site.py也正是Python能正确加载位于site-packages目录下第三方包的关键所在。我们可以猜测，应该就是这个site.py将site-packages目录加入到了前面的sys.path中，而这个动作是由 *init_import_size* 完成的。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> PyStatus</span><br><span class="line"><span class="title function_">new_interpreter</span><span class="params">(PyThreadState **tstate_p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">        <span class="keyword">if</span> (config-&gt;site_import) &#123;</span><br><span class="line">            status = init_import_size();</span><br><span class="line">            <span class="keyword">if</span> (_PyStatus_EXCEPTION(status)) &#123;</span><br><span class="line">                <span class="keyword">return</span> status;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyStatus</span><br><span class="line"><span class="title function_">init_import_size</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyObject *m;</span><br><span class="line">    m = PyImport_ImportModule(<span class="string">&quot;site&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//这里的报错信息是不是和上图中显示的一样呢？</span></span><br><span class="line">        <span class="keyword">return</span> _PyStatus_ERR(<span class="string">&quot;Failed to import the site module&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Py_DECREF(m);</span><br><span class="line">    <span class="keyword">return</span> _PyStatus_OK();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在 *init_import_size* 中，只调用了 *PyImport_ImportModule* 函数，这个函数是Python中import机制的核心所在。PyImport_ImportModule(“numpy”)等价于python中的 import numpy 即可。</strong></p>
<h3 id="激活python虚拟机"><a href="#激活python虚拟机" class="headerlink" title="激活python虚拟机"></a>激活python虚拟机</h3><p><strong>Python运行方式有两种，一种是在命令行中运行的交互式环境；另一种则是以python xxx.py方式运行脚本文件。尽管方式不同，但是却殊途同归，进入同一个字节码虚拟机。</strong></p>
<p><strong>Python在 *Py_Initialize* 完成之后，最终会通过 *pymain_run_file* 调用 *PyRun_AnyFileExFlags*。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Modules/main.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">pymain_run_file</span><span class="params">(PyConfig *config, PyCompilerFlags *cf)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//那么获取文件名</span></span><br><span class="line">    <span class="type">const</span> <span class="type">wchar_t</span> *filename = config-&gt;run_filename;</span><br><span class="line">    <span class="keyword">if</span> (PySys_Audit(<span class="string">&quot;cpython.run_file&quot;</span>, <span class="string">&quot;u&quot;</span>, filename) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> pymain_exit_err_print();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打开文件</span></span><br><span class="line">    FILE *fp = _Py_wfopen(filename, <span class="string">L&quot;rb&quot;</span>);</span><br><span class="line">    <span class="comment">//如果fp为NULL, 证明文件打开失败</span></span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="type">char</span> *cfilename_buffer;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *cfilename;</span><br><span class="line">        <span class="type">int</span> err = errno;</span><br><span class="line">        cfilename_buffer = _Py_EncodeLocaleRaw(filename, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (cfilename_buffer != <span class="literal">NULL</span>)</span><br><span class="line">            cfilename = cfilename_buffer;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cfilename = <span class="string">&quot;&lt;unprintable file name&gt;&quot;</span>;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%ls: can&#x27;t open file &#x27;%s&#x27;: [Errno %d] %s\n&quot;</span>,</span><br><span class="line">                config-&gt;program_name, cfilename, err, strerror(err));</span><br><span class="line">        PyMem_RawFree(cfilename_buffer);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//调用PyRun_AnyFileExFlags</span></span><br><span class="line">    <span class="type">int</span> run = PyRun_AnyFileExFlags(fp, filename_str, <span class="number">1</span>, cf);</span><br><span class="line">    Py_XDECREF(bytes);</span><br><span class="line">    <span class="keyword">return</span> (run != <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Python/pythonrun.c</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">PyRun_AnyFileExFlags</span><span class="params">(FILE *fp, <span class="type">const</span> <span class="type">char</span> *filename, <span class="type">int</span> closeit,</span></span><br><span class="line"><span class="params">                     PyCompilerFlags *flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (filename == <span class="literal">NULL</span>)</span><br><span class="line">        filename = <span class="string">&quot;???&quot;</span>;</span><br><span class="line">    <span class="comment">//根据fp是否代表交互环境，对程序进行流程控制</span></span><br><span class="line">    <span class="keyword">if</span> (Py_FdIsInteractive(fp, filename)) &#123;</span><br><span class="line">        <span class="comment">//如果是交互环境，那么调用PyRun_InteractiveLoopFlags</span></span><br><span class="line">        <span class="type">int</span> err = PyRun_InteractiveLoopFlags(fp, filename, flags);</span><br><span class="line">        <span class="keyword">if</span> (closeit)</span><br><span class="line">            fclose(fp);</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//否则说明是一个普通的python脚本，执行PyRun_SimpleFileExFlags</span></span><br><span class="line">        <span class="keyword">return</span> PyRun_SimpleFileExFlags(fp, filename, closeit, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们看到交互式和py脚本式走的两条不同的路径，但是别着急，最终你会看到它们又会分久必合、走向同一条路径。</strong></p>
<h4 id="交互式运行"><a href="#交互式运行" class="headerlink" title="交互式运行"></a>交互式运行</h4><p><strong>先来看看交互式运行时候的情形，不过在此之前先来看一下提示符。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> a == <span class="number">1</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.ps1 = <span class="string">&quot;matsuri:&quot;</span></span><br><span class="line">matsuri:a = <span class="number">1</span></span><br><span class="line">matsuri:a</span><br><span class="line"><span class="number">1</span></span><br><span class="line">matsuri:</span><br><span class="line">matsuri:sys.ps2 = <span class="string">&quot;fubuki:&quot;</span></span><br><span class="line">matsuri:<span class="keyword">if</span> a == <span class="number">1</span>:</span><br><span class="line">fubuki:    <span class="keyword">pass</span></span><br><span class="line">fubuki:</span><br><span class="line">matsuri:</span><br></pre></td></tr></table></figure>

<p><strong>我们每输入一行，开头都是<code>&gt;&gt;&gt; </code>，这个是sys.ps1，而输入语句块的时候，没输入完的时候，那么显示<code>...</code>，这个是sys.ps2。如果修改了，那么就是我们自己定义的了。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">PyRun_InteractiveLoopFlags</span><span class="params">(FILE *fp, <span class="type">const</span> <span class="type">char</span> *filename_str, PyCompilerFlags *flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    <span class="comment">//创建交互式提示符 </span></span><br><span class="line">    v = _PySys_GetObjectId(&amp;PyId_ps1);</span><br><span class="line">    <span class="keyword">if</span> (v == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        _PySys_SetObjectId(&amp;PyId_ps1, v = PyUnicode_FromString(<span class="string">&quot;&gt;&gt;&gt; &quot;</span>));</span><br><span class="line">        Py_XDECREF(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//同理这个也是一样</span></span><br><span class="line">    v = _PySys_GetObjectId(&amp;PyId_ps2);</span><br><span class="line">    <span class="keyword">if</span> (v == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        _PySys_SetObjectId(&amp;PyId_ps2, v = PyUnicode_FromString(<span class="string">&quot;... &quot;</span>));</span><br><span class="line">        Py_XDECREF(v);</span><br><span class="line">    &#125;</span><br><span class="line">    err = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//这里就进入了交互式环境，我们看到每次都调用了PyRun_InteractiveOneObjectEx</span></span><br><span class="line">        <span class="comment">//直到下面的ret != E_EOF不成立 停止循环，一般情况就是我们输入exit()图此处了</span></span><br><span class="line">        ret = PyRun_InteractiveOneObjectEx(fp, filename, flags);</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">-1</span> &amp;&amp; PyErr_Occurred()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (PyErr_ExceptionMatches(PyExc_MemoryError)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (++nomem_count &gt; <span class="number">16</span>) &#123;</span><br><span class="line">                    PyErr_Clear();</span><br><span class="line">                    err = <span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nomem_count = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            PyErr_Print();</span><br><span class="line">            flush_io();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nomem_count = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (ret != E_EOF);</span><br><span class="line">    Py_DECREF(filename);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">PyRun_InteractiveOneObjectEx</span><span class="params">(FILE *fp, PyObject *filename,</span></span><br><span class="line"><span class="params">                             PyCompilerFlags *flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyObject *m, *d, *v, *w, *oenc = <span class="literal">NULL</span>, *mod_name;</span><br><span class="line">    mod_ty mod;</span><br><span class="line">    PyArena *arena;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *ps1 = <span class="string">&quot;&quot;</span>, *ps2 = <span class="string">&quot;&quot;</span>, *enc = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> errcode = <span class="number">0</span>;</span><br><span class="line">    _Py_IDENTIFIER(encoding);</span><br><span class="line">    _Py_IDENTIFIER(__main__);</span><br><span class="line"></span><br><span class="line">    mod_name = _PyUnicode_FromId(&amp;PyId___main__); <span class="comment">/* borrowed */</span></span><br><span class="line">    <span class="keyword">if</span> (mod_name == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="built_in">stdin</span>) &#123;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line">    v = _PySys_GetObjectId(&amp;PyId_ps1);</span><br><span class="line">    <span class="keyword">if</span> (v != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line">    w = _PySys_GetObjectId(&amp;PyId_ps2);</span><br><span class="line">    <span class="keyword">if</span> (w != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//.....</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//编译用户在交互式环境下输入的python语句</span></span><br><span class="line">    arena = PyArena_New();</span><br><span class="line">    <span class="keyword">if</span> (arena == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Py_XDECREF(v);</span><br><span class="line">        Py_XDECREF(w);</span><br><span class="line">        Py_XDECREF(oenc);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//生成抽象语法树</span></span><br><span class="line">    mod = PyParser_ASTFromFileObject(fp, filename, enc,</span><br><span class="line">                                     Py_single_input, ps1, ps2,</span><br><span class="line">                                     flags, &amp;errcode, arena);</span><br><span class="line">    Py_XDECREF(v);</span><br><span class="line">    Py_XDECREF(w);</span><br><span class="line">    Py_XDECREF(oenc);</span><br><span class="line">    <span class="keyword">if</span> (mod == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        PyArena_Free(arena);</span><br><span class="line">        <span class="keyword">if</span> (errcode == E_EOF) &#123;</span><br><span class="line">            PyErr_Clear();</span><br><span class="line">            <span class="keyword">return</span> E_EOF;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取&lt;module __main__&gt;中维护的dict</span></span><br><span class="line">    m = PyImport_AddModuleObject(mod_name);</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        PyArena_Free(arena);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    d = PyModule_GetDict(m);</span><br><span class="line">    <span class="comment">//执行用户输入的python语句</span></span><br><span class="line">    v = run_mod(mod, filename, d, d, flags, arena);</span><br><span class="line">    PyArena_Free(arena);</span><br><span class="line">    <span class="keyword">if</span> (v == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Py_DECREF(v);</span><br><span class="line">    flush_io();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们发现在run_mod之前，python会将<code>__main__</code>中维护的PyDictObject对象取出，作为参数传递给run_mod，这个参数关系极为重要，实际上这里的参数d就将作为Python虚拟机开始执行时当前活动的frame对象的local名字空间和global名字空间。</strong></p>
<h4 id="脚本文件运行方式"><a href="#脚本文件运行方式" class="headerlink" title="脚本文件运行方式"></a>脚本文件运行方式</h4><p><strong>接下来，我们看一看直接运行脚本文件的方式。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//.include/compile.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Py_file_input 257</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Python/pythonrun.c</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">PyRun_SimpleFileExFlags</span><span class="params">(FILE *fp, <span class="type">const</span> <span class="type">char</span> *filename, <span class="type">int</span> closeit,</span></span><br><span class="line"><span class="params">                        PyCompilerFlags *flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyObject *m, *d, *v;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *ext;</span><br><span class="line">    <span class="type">int</span> set_file_name = <span class="number">0</span>, ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">size_t</span> len;</span><br><span class="line">    <span class="comment">//__main__就是当前文件</span></span><br><span class="line">    m = PyImport_AddModule(<span class="string">&quot;__main__&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    Py_INCREF(m);</span><br><span class="line">    <span class="comment">//还记得这个d吗?当前活动的frame对象的local和global名字空间</span></span><br><span class="line">    d = PyModule_GetDict(m);</span><br><span class="line">    <span class="comment">//在__main__中设置__file__属性</span></span><br><span class="line">    <span class="keyword">if</span> (PyDict_GetItemString(d, <span class="string">&quot;__file__&quot;</span>) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        PyObject *f;</span><br><span class="line">        f = PyUnicode_DecodeFSDefault(filename);</span><br><span class="line">        <span class="keyword">if</span> (f == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line">        <span class="keyword">if</span> (PyDict_SetItemString(d, <span class="string">&quot;__file__&quot;</span>, f) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            Py_DECREF(f);</span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (PyDict_SetItemString(d, <span class="string">&quot;__cached__&quot;</span>, Py_None) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            Py_DECREF(f);</span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line">        &#125;</span><br><span class="line">        set_file_name = <span class="number">1</span>;</span><br><span class="line">        Py_DECREF(f);</span><br><span class="line">    &#125;</span><br><span class="line">    len = <span class="built_in">strlen</span>(filename);</span><br><span class="line">    ext = filename + len - (len &gt; <span class="number">4</span> ? <span class="number">4</span> : <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//如果是pyc</span></span><br><span class="line">    <span class="keyword">if</span> (maybe_pyc_file(fp, filename, ext, closeit)) &#123;</span><br><span class="line">        FILE *pyc_fp;</span><br><span class="line">        <span class="comment">//二进制模式打开</span></span><br><span class="line">        <span class="keyword">if</span> (closeit)</span><br><span class="line">            fclose(fp);</span><br><span class="line">        <span class="keyword">if</span> ((pyc_fp = _Py_fopen(filename, <span class="string">&quot;rb&quot;</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;python: Can&#x27;t reopen .pyc file\n&quot;</span>);</span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (set_main_loader(d, filename, <span class="string">&quot;SourcelessFileLoader&quot;</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;python: failed to set __main__.__loader__\n&quot;</span>);</span><br><span class="line">            ret = <span class="number">-1</span>;</span><br><span class="line">            fclose(pyc_fp);</span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line">        &#125;</span><br><span class="line">        v = run_pyc_file(pyc_fp, filename, d, d, flags);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(filename, <span class="string">&quot;&lt;stdin&gt;&quot;</span>) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">            set_main_loader(d, filename, <span class="string">&quot;SourceFileLoader&quot;</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;python: failed to set __main__.__loader__\n&quot;</span>);</span><br><span class="line">            ret = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//执行脚本文件</span></span><br><span class="line">        v = PyRun_FileExFlags(fp, filename, Py_file_input, d, d,</span><br><span class="line">                              closeit, flags);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyRun_FileExFlags</span><span class="params">(FILE *fp, <span class="type">const</span> <span class="type">char</span> *filename_str, <span class="type">int</span> start, PyObject *globals,</span></span><br><span class="line"><span class="params">                  PyObject *locals, <span class="type">int</span> closeit, PyCompilerFlags *flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyObject *ret = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//编译</span></span><br><span class="line">    mod = PyParser_ASTFromFileObject(fp, filename, <span class="literal">NULL</span>, start, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                                     flags, <span class="literal">NULL</span>, arena);</span><br><span class="line">    <span class="keyword">if</span> (closeit)</span><br><span class="line">        fclose(fp);</span><br><span class="line">    <span class="keyword">if</span> (mod == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//执行, 依旧是调用了runmod</span></span><br><span class="line">    ret = run_mod(mod, filename, globals, locals, flags, arena);</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>:</span><br><span class="line">    Py_XDECREF(filename);</span><br><span class="line">    <span class="keyword">if</span> (arena != <span class="literal">NULL</span>)</span><br><span class="line">        PyArena_Free(arena);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>很显然，脚本文件和交互式之间的执行流程是不同的，但是最终都进入了run_mod，而且同样也将与<code>__main__</code>中维护的PyDictObject对象作为local名字空间和global名字空间传入了run_mod。</strong></p>
<h4 id="启动虚拟机"><a href="#启动虚拟机" class="headerlink" title="启动虚拟机"></a>启动虚拟机</h4><p><strong>是的你没有看错，下面才是启动虚拟机，之前做了那么工作都是前戏。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">run_mod</span><span class="params">(mod_ty mod, PyObject *filename, PyObject *globals, PyObject *locals,</span></span><br><span class="line"><span class="params">            PyCompilerFlags *flags, PyArena *arena)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyCodeObject *co;</span><br><span class="line">    PyObject *v;</span><br><span class="line">    <span class="comment">//基于ast编译字节码指令序列，创建PyCodeObject对象</span></span><br><span class="line">    co = PyAST_CompileObject(mod, filename, flags, <span class="number">-1</span>, arena);</span><br><span class="line">    <span class="keyword">if</span> (co == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PySys_Audit(<span class="string">&quot;exec&quot;</span>, <span class="string">&quot;O&quot;</span>, co) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        Py_DECREF(co);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//创建PyFrameObject，执行PyCodeObject对象中的字节码指令序列</span></span><br><span class="line">    v = run_eval_code_obj(co, globals, locals);</span><br><span class="line">    Py_DECREF(co);</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>run_mod接手传来的ast，然后传到 *PyAST_CompileObject*  中，创建了一个我们已经非常熟悉的PyCodeObject对象。关于这个完整的编译过程，就又是另一个话题了，总之先是scanner进行词法分析、将源代码切分成一个个的token，然后parser在词法分析之后的结果之上进行语法分析、通过切分好的token生成抽象语法树(AST，abstract syntax  tree)，然后将AST编译PyCodeObject对象，最后再由虚拟机执行。知道这么一个大致的流程即可，至于到底是怎么分词、怎么建立语法树的，这就又是一个难点了，个人觉得甚至比研究Python虚拟机还难。有兴趣的话可以去看Python源码中Parser目录，如果能把Python的分词、语法树的建立给了解清楚，那我觉得你完全可以手写一个正则表达式的引擎、以及各种模板语言。</strong></p>
<p><strong>而接下来，Python已经做好一切工作，开始通过 *run_eval_code_obj* 着手唤醒字节码虚拟机。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">run_eval_code_obj</span><span class="params">(PyCodeObject *co, PyObject *globals, PyObject *locals)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyObject *v;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    v = PyEval_EvalCode((PyObject*)co, globals, locals);</span><br><span class="line">    <span class="keyword">if</span> (!v &amp;&amp; PyErr_Occurred() == PyExc_KeyboardInterrupt) &#123;</span><br><span class="line">        _Py_UnhandledKeyboardInterrupt = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>函数中调用了 *PyEval_EvalCode*，根据前面介绍函数的时候，我们知道最终一定会走到 *PyEval_EvalFrameEx*。</strong></p>
<p><strong>从操作系统创建进程，进程创建线程，线程设置builtins(包括设置<code>__name__</code>、内建对象、内置函数方法等等)、设置缓存池，然后各种初始化，设置搜索路径。最后分词、编译、激活虚拟机执行。而执行的这个过程就是曾经与我们朝夕相处的 *PyEval_EvalFrameEx* ，掌控Python世界中无数对象的生生灭灭。参数f就是PyFrameObject对象，我们曾经探索了很久，现在一下子就回到了当初。有种梦回<code>栈帧对象</code>的感觉。目前的话，Python的骨架我们已经看清了，虽然还有很多细节隐藏在幕后。至少神秘的面纱已经被撤掉了。</strong></p>
<h4 id="名字空间"><a href="#名字空间" class="headerlink" title="名字空间"></a>名字空间</h4><p><strong>现在我们来看一下有趣的东西，看看在激活字节码虚拟机、创建 *PyFrameObject* 对象时，所设置的3个名字空间：local、global、builtin。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Objects/frameobject.c</span></span><br><span class="line">PyFrameObject*</span><br><span class="line"><span class="title function_">PyFrame_New</span><span class="params">(PyThreadState *tstate, PyCodeObject *code,</span></span><br><span class="line"><span class="params">            PyObject *globals, PyObject *locals)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyFrameObject *f = _PyFrame_New_NoTrack(tstate, code, globals, locals);</span><br><span class="line">    <span class="keyword">if</span> (f)</span><br><span class="line">        _PyObject_GC_TRACK(f);</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PyFrameObject* _Py_HOT_FUNCTION</span><br><span class="line">_PyFrame_New_NoTrack(PyThreadState *tstate, PyCodeObject *code,</span><br><span class="line">                     PyObject *globals, PyObject *locals)</span><br><span class="line">&#123;</span><br><span class="line">    PyFrameObject *back = tstate-&gt;frame;</span><br><span class="line">    PyFrameObject *f;</span><br><span class="line">    PyObject *builtins;</span><br><span class="line">    Py_ssize_t i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置builtin名字空间</span></span><br><span class="line">    <span class="keyword">if</span> (back == <span class="literal">NULL</span> || back-&gt;f_globals != globals) &#123;</span><br><span class="line">        <span class="comment">//但是我们发现设置builtins，居然是从globals里面获取的</span></span><br><span class="line">        <span class="comment">//带着这个疑问，看看下面更大的疑问        </span></span><br><span class="line">        builtins = _PyDict_GetItemIdWithError(globals, &amp;PyId___builtins__);</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* If we share the globals, we share the builtins.</span></span><br><span class="line"><span class="comment">           Save a lookup and a call. */</span></span><br><span class="line">        builtins = back-&gt;f_builtins;</span><br><span class="line">        assert(builtins != <span class="literal">NULL</span>);</span><br><span class="line">        Py_INCREF(builtins);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line">    <span class="comment">//设置builtins</span></span><br><span class="line">    f-&gt;f_builtins = builtins;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    <span class="comment">//设置globals</span></span><br><span class="line">    f-&gt;f_globals = globals;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((code-&gt;co_flags &amp; (CO_NEWLOCALS | CO_OPTIMIZED)) ==</span><br><span class="line">        (CO_NEWLOCALS | CO_OPTIMIZED))</span><br><span class="line">        ; <span class="comment">/* f_locals = NULL; will be set by PyFrame_FastToLocals() */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (code-&gt;co_flags &amp; CO_NEWLOCALS) &#123;</span><br><span class="line">        locals = PyDict_New();</span><br><span class="line">        <span class="keyword">if</span> (locals == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            Py_DECREF(f);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        f-&gt;f_locals = locals;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (locals == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="comment">//如果locals为NULL，那么等同于globals，显然这是针对模块来的</span></span><br><span class="line">            locals = globals;</span><br><span class="line">        Py_INCREF(locals);</span><br><span class="line">        f-&gt;f_locals = locals;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    f-&gt;f_lasti = <span class="number">-1</span>;</span><br><span class="line">    f-&gt;f_lineno = code-&gt;co_firstlineno;</span><br><span class="line">    f-&gt;f_iblock = <span class="number">0</span>;</span><br><span class="line">    f-&gt;f_executing = <span class="number">0</span>;</span><br><span class="line">    f-&gt;f_gen = <span class="literal">NULL</span>;</span><br><span class="line">    f-&gt;f_trace_opcodes = <span class="number">0</span>;</span><br><span class="line">    f-&gt;f_trace_lines = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们说内置名字空间是从global名字空间里面获取的，我们用Python来演示一下。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 代表了globals()里面存放了builtins</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">globals</span>()[<span class="string">&quot;__builtins__&quot;</span>])  <span class="comment"># &lt;module &#x27;builtins&#x27; (built-in)&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们说builtins里面包含了所有的内置对象、函数等等，显然调用int是可以的</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">globals</span>()[<span class="string">&quot;__builtins__&quot;</span>].<span class="built_in">int</span>(<span class="string">&quot;123&quot;</span>))  <span class="comment"># 123</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 但是,我居然能从builtins里面拿到globals</span></span><br><span class="line"><span class="comment"># 不过也很好理解，因为globals是一个内置函数，肯定是在builtins里面</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">globals</span>()[<span class="string">&quot;__builtins__&quot;</span>].<span class="built_in">globals</span>)  <span class="comment"># &lt;built-in function globals&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 于是拿到了globals，继续调用，然后获取__builtins__，又拿到了builtins，而且我们是可以调用list的</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">globals</span>()[<span class="string">&quot;__builtins__&quot;</span>].<span class="built_in">globals</span>()[<span class="string">&quot;__builtins__&quot;</span>].<span class="built_in">list</span>(<span class="string">&quot;abcd&quot;</span>))  <span class="comment"># [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;]</span></span><br></pre></td></tr></table></figure>

<p><strong>所以不管套娃多少次，都是可以的，因为它们都是指针。</strong></p>
<p><strong>可以看到builtin和global空间里面都存储一个能够获取对方空间的一个函数指针， 所以这两者是并不冲突的。当然除此之外，还有一个<code>__name__</code>，注意我们之前说设置<code>__name__</code>只是builtins的<code>__name__</code>，并不是当前模块的。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 我们看到，builtins里面获取的__name__居然不是__main__，而是builtins</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">globals</span>()[<span class="string">&quot;__builtins__&quot;</span>].__name__)  <span class="comment"># builtins</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 首先按照local  global builtin的顺序查找是没问题的</span></span><br><span class="line"><span class="comment"># 而对于模块来说，我们知道local空间为NULL的话，然后直接把global空间交给local空间了</span></span><br><span class="line"><span class="comment"># 而local里面有__name__，就是__main__，所以__name__和builtins.__name__不是一个东西</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">globals</span>()[<span class="string">&quot;__name__&quot;</span>])  <span class="comment"># __main__</span></span><br><span class="line"><span class="comment"># 初始化builtins的时候，那个__name__指的是builtins这个PyModuleObject的__name__</span></span><br><span class="line"><span class="comment"># 而对于我们py文件这个模块来说，__name__是设置在global名字空间里面的</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果将global空间或者local空间里面的__name__删掉，那么按照顺序就会寻找builtin里面的__name__，此时就会打印builtins了。</span></span><br><span class="line"><span class="built_in">globals</span>().pop(<span class="string">&quot;__name__&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(__name__)  <span class="comment"># builtins</span></span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/20/24-Python%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E7%8E%AF%E5%A2%83%E5%88%9D%E5%A7%8B%E5%8C%96/1229382-20200909213825050-2076588242.png" alt="img"></p>
<p><strong>所以我们看到__name__这个属性是在启动之后动态设置的，如果执行的文件和该文件是同一个文件，那么__name__就会是__main__；如果不是同一个文件，证明这个文件是作为模块被导入进来的，那么此时它的__name__就是文件名。</strong></p>
<p><strong>更多细节可以前往源码中查看，Python运行环境初始化还是比较复杂的。</strong></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><strong>这一次我们说了Python运行环境的初始化，或者说当Python启动的时候都做了哪些事情。可以看到，做的事情不是一般的多，真的准备了大量的工作。因为Python是动态语言，这就意味很多操作都要发生在运行时。</strong></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Lin Li</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/04/20/24-Python%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E7%8E%AF%E5%A2%83%E5%88%9D%E5%A7%8B%E5%8C%96/">http://example.com/2023/04/20/24-Python%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E7%8E%AF%E5%A2%83%E5%88%9D%E5%A7%8B%E5%8C%96/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">LinLi's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/CPython/">CPython</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/04/20/25-%E8%A7%A3%E5%AF%86Python%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%89%EF%BC%9A%E5%88%9D%E8%AF%86GIL%E3%80%81%E4%BB%A5%E5%8F%8A%E5%A4%9A%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E8%B0%83%E5%BA%A6%E6%9C%BA%E5%88%B6/" title="25-解密Python中的多线程（第一部分）：初识GIL、以及多个线程之间的调度机制"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">25-解密Python中的多线程（第一部分）：初识GIL、以及多个线程之间的调度机制</div></div></a></div><div class="next-post pull-right"><a href="/2023/04/20/23-%E5%89%96%E6%9E%90Python%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97%E5%AF%BC%E5%85%A5%E6%9C%BA%E5%88%B6%E3%80%81Python%E6%98%AF%E5%A6%82%E4%BD%95%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9D%97%E7%9A%84/" title="23-剖析Python中的模块导入机制、Python是如何加载模块的"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">23-剖析Python中的模块导入机制、Python是如何加载模块的</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/03/29/01-%E7%BC%96%E8%AF%91Cpython/" title="01-编译Cpython"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">01-编译Cpython</div></div></a></div><div><a href="/2023/03/29/02-%E4%B8%80%E5%88%87%E5%AF%B9%E8%B1%A1%E7%9A%86PyObject/" title="02-一切对象皆PyObject"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">02-一切对象皆PyObject</div></div></a></div><div><a href="/2023/03/29/04-%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/" title="04-浮点数的底层实现"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">04-浮点数的底层实现</div></div></a></div><div><a href="/2023/03/29/06-Bytes%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BA%95%E5%B1%82%E6%93%8D%E4%BD%9C/" title="06-Bytes对象的底层操作"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">06-Bytes对象的底层操作</div></div></a></div><div><a href="/2023/03/29/03-Python%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E5%99%A8%E5%92%8C%E5%BA%95%E5%B1%82%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86/" title="03-Python引用计数器和底层对象管理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">03-Python引用计数器和底层对象管理</div></div></a></div><div><a href="/2023/03/29/05-Python%E6%95%B4%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/" title="05-Python整数的底层实现"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">05-Python整数的底层实现</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Lin Li</div><div class="author-info__description">今日事，今日毕</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">95</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#24-Python%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E7%8E%AF%E5%A2%83%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.</span> <span class="toc-text">24-Python运行时的环境初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A5%94%E5%AD%90"><span class="toc-number">1.1.</span> <span class="toc-text">楔子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%8E%AF%E5%A2%83%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.2.</span> <span class="toc-text">线程环境初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.2.1.</span> <span class="toc-text">线程模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%8E%AF%E5%A2%83%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.2.2.</span> <span class="toc-text">线程环境的初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA-builtins"><span class="toc-number">1.2.3.</span> <span class="toc-text">创建__builtins__</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAmodule%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">创建module对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AEmodule%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">设置module对象</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAsys-module"><span class="toc-number">1.2.4.</span> <span class="toc-text">创建sys module</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AEsite-specific%E7%9A%84module%E7%9A%84%E6%90%9C%E7%B4%A2%E8%B7%AF%E5%BE%84"><span class="toc-number">1.2.5.</span> <span class="toc-text">设置site-specific的module的搜索路径</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BF%80%E6%B4%BBpython%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="toc-number">1.3.</span> <span class="toc-text">激活python虚拟机</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%A4%E4%BA%92%E5%BC%8F%E8%BF%90%E8%A1%8C"><span class="toc-number">1.3.1.</span> <span class="toc-text">交互式运行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%84%9A%E6%9C%AC%E6%96%87%E4%BB%B6%E8%BF%90%E8%A1%8C%E6%96%B9%E5%BC%8F"><span class="toc-number">1.3.2.</span> <span class="toc-text">脚本文件运行方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="toc-number">1.3.3.</span> <span class="toc-text">启动虚拟机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8D%E5%AD%97%E7%A9%BA%E9%97%B4"><span class="toc-number">1.3.4.</span> <span class="toc-text">名字空间</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">1.4.</span> <span class="toc-text">小结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/17/Movery-A-Precise-Approach-for-Modified-Vulnerable-Code-Clone-Discovery-from-Modified-Open-Source-Software-Components/" title="Movery A Precise Approach for Modified Vulnerable Code Clone Discovery from Modified Open-Source Software Components">Movery A Precise Approach for Modified Vulnerable Code Clone Discovery from Modified Open-Source Software Components</a><time datetime="2024-08-17T14:09:41.000Z" title="发表于 2024-08-17 22:09:41">2024-08-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/30/Translating-between-SQL-Dialects-for-Cloud-Migration/" title="Translating between SQL Dialects for Cloud Migration">Translating between SQL Dialects for Cloud Migration</a><time datetime="2024-07-30T07:48:40.000Z" title="发表于 2024-07-30 15:48:40">2024-07-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/30/Mallet-SQL-Dialect-Translation-with-LLM-Rule-Generation/" title="Mallet: SQL Dialect Translation with LLM Rule Generation">Mallet: SQL Dialect Translation with LLM Rule Generation</a><time datetime="2024-07-30T07:47:16.000Z" title="发表于 2024-07-30 15:47:16">2024-07-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/11/Keep-It-Simple-Testing-Databases-via-Differential-Query-Plans/" title="Keep It Simple: Testing Databases via Differential Query Plans">Keep It Simple: Testing Databases via Differential Query Plans</a><time datetime="2024-07-11T03:23:01.000Z" title="发表于 2024-07-11 11:23:01">2024-07-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/08/WINGFUZZ-Implementing-Continuous-Fuzzing-for-DBMSs/" title="WINGFUZZ: Implementing Continuous Fuzzing for DBMSs">WINGFUZZ: Implementing Continuous Fuzzing for DBMSs</a><time datetime="2024-07-08T05:48:21.000Z" title="发表于 2024-07-08 13:48:21">2024-07-08</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Lin Li</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>