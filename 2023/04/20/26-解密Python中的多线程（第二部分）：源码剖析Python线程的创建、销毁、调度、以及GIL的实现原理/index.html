<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>26-解密Python中的多线程（第二部分）：源码剖析Python线程的创建、销毁、调度、以及GIL的实现原理 | LinLi's Blog</title><meta name="author" content="Lin Li"><meta name="copyright" content="Lin Li"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="26-解密Python中的多线程（第二部分）：源码剖析Python线程的创建、销毁、调度、以及GIL的实现原理初见Python的_thread模块下面我们来说一下Python中线程的创建，我们知道在创建多线程的时候会使用threading这个标准库，这个库是以一个py文件存在的形式存在的，不过这个模块依赖于_thread模块，我们来看看它长什么样子。  _thread是真正用来创建线程的模块，这个">
<meta property="og:type" content="article">
<meta property="og:title" content="26-解密Python中的多线程（第二部分）：源码剖析Python线程的创建、销毁、调度、以及GIL的实现原理">
<meta property="og:url" content="http://example.com/2023/04/20/26-%E8%A7%A3%E5%AF%86Python%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%89%EF%BC%9A%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90Python%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E3%80%81%E9%94%80%E6%AF%81%E3%80%81%E8%B0%83%E5%BA%A6%E3%80%81%E4%BB%A5%E5%8F%8AGIL%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/index.html">
<meta property="og:site_name" content="LinLi&#39;s Blog">
<meta property="og:description" content="26-解密Python中的多线程（第二部分）：源码剖析Python线程的创建、销毁、调度、以及GIL的实现原理初见Python的_thread模块下面我们来说一下Python中线程的创建，我们知道在创建多线程的时候会使用threading这个标准库，这个库是以一个py文件存在的形式存在的，不过这个模块依赖于_thread模块，我们来看看它长什么样子。  _thread是真正用来创建线程的模块，这个">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2023-04-20T08:51:28.000Z">
<meta property="article:modified_time" content="2023-04-20T08:51:53.789Z">
<meta property="article:author" content="Lin Li">
<meta property="article:tag" content="CPython">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/04/20/26-%E8%A7%A3%E5%AF%86Python%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%89%EF%BC%9A%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90Python%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E3%80%81%E9%94%80%E6%AF%81%E3%80%81%E8%B0%83%E5%BA%A6%E3%80%81%E4%BB%A5%E5%8F%8AGIL%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '26-解密Python中的多线程（第二部分）：源码剖析Python线程的创建、销毁、调度、以及GIL的实现原理',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-04-20 16:51:53'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">122</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="LinLi's Blog"><span class="site-name">LinLi's Blog</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">26-解密Python中的多线程（第二部分）：源码剖析Python线程的创建、销毁、调度、以及GIL的实现原理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-04-20T08:51:28.000Z" title="发表于 2023-04-20 16:51:28">2023-04-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-04-20T08:51:53.789Z" title="更新于 2023-04-20 16:51:53">2023-04-20</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="26-解密Python中的多线程（第二部分）：源码剖析Python线程的创建、销毁、调度、以及GIL的实现原理"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="26-解密Python中的多线程（第二部分）：源码剖析Python线程的创建、销毁、调度、以及GIL的实现原理"><a href="#26-解密Python中的多线程（第二部分）：源码剖析Python线程的创建、销毁、调度、以及GIL的实现原理" class="headerlink" title="26-解密Python中的多线程（第二部分）：源码剖析Python线程的创建、销毁、调度、以及GIL的实现原理"></a>26-解密Python中的多线程（第二部分）：源码剖析Python线程的创建、销毁、调度、以及GIL的实现原理</h2><h3 id="初见Python的-thread模块"><a href="#初见Python的-thread模块" class="headerlink" title="初见Python的_thread模块"></a>初见Python的_thread模块</h3><p><strong>下面我们来说一下Python中线程的创建，我们知道在创建多线程的时候会使用threading这个标准库，这个库是以一个py文件存在的形式存在的，不过这个模块依赖于_thread模块，我们来看看它长什么样子。</strong></p>
<p><img src="/2023/04/20/26-%E8%A7%A3%E5%AF%86Python%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%89%EF%BC%9A%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90Python%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E3%80%81%E9%94%80%E6%AF%81%E3%80%81%E8%B0%83%E5%BA%A6%E3%80%81%E4%BB%A5%E5%8F%8AGIL%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/1229382-20200912035621242-1036825105.png" alt="img"></p>
<p><strong>_thread是真正用来创建线程的模块，这个模块是由C编写，内嵌在解释器里面。我们可以import调用，但是在Python安装目录里面则是看不到的。像这种底层由C编写、内嵌在解释器里面的模块，以及那些无法使用文本打开的pyd文件，pycharm都会给你做一个抽象，并且把注释给你写好。</strong></p>
<p><strong>记得我们之前说过Python源码中的Modules目录，这个目录里面存放了大量使用C编写的模块，我们在编译完Python之后就，这些模块就内嵌在解释器里面了。而这些模块都是针对那些性能要求比较高的，而要求不高的则由Python编写，存放在Lib目录下。像我们平时调用random、collections、threading，其实它们背后会调用_random、_collections、_thread。再比如我们使用的re模块，真正用来做正则匹配的逻辑实际上位于 *Modules&#x2F;_sre.c* 里面。</strong></p>
<p><strong>说了这么多，只是为引出_thread是在Modules里面。玛德，前戏真长啊。Python中 _thread 的底层实现是在 _threadmodule.c中，我们来看看它都提供了哪些接口。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> PyMethodDef thread_methods[] = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;start_new_thread&quot;</span>,        (PyCFunction)thread_PyThread_start_new_thread,</span><br><span class="line">     METH_VARARGS, start_new_doc&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;start_new&quot;</span>,               (PyCFunction)thread_PyThread_start_new_thread,</span><br><span class="line">     METH_VARARGS, start_new_doc&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;allocate_lock&quot;</span>,           thread_PyThread_allocate_lock,</span><br><span class="line">     METH_NOARGS, allocate_doc&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;allocate&quot;</span>,                thread_PyThread_allocate_lock,</span><br><span class="line">     METH_NOARGS, allocate_doc&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;exit_thread&quot;</span>,             thread_PyThread_exit_thread,</span><br><span class="line">     METH_NOARGS, exit_doc&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;exit&quot;</span>,                    thread_PyThread_exit_thread,</span><br><span class="line">     METH_NOARGS, exit_doc&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;interrupt_main&quot;</span>,          thread_PyThread_interrupt_main,</span><br><span class="line">     METH_NOARGS, interrupt_doc&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;get_ident&quot;</span>,               thread_get_ident,</span><br><span class="line">     METH_NOARGS, get_ident_doc&#125;,</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PY_HAVE_THREAD_NATIVE_ID</span></span><br><span class="line">    &#123;<span class="string">&quot;get_native_id&quot;</span>,           thread_get_native_id,</span><br><span class="line">     METH_NOARGS, get_native_id_doc&#125;,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#123;<span class="string">&quot;_count&quot;</span>,                  thread__count,</span><br><span class="line">     METH_NOARGS, _count_doc&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;stack_size&quot;</span>,              (PyCFunction)thread_stack_size,</span><br><span class="line">     METH_VARARGS, stack_size_doc&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;_set_sentinel&quot;</span>,           thread__set_sentinel,</span><br><span class="line">     METH_NOARGS, _set_sentinel_doc&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;_excepthook&quot;</span>,              thread_excepthook,</span><br><span class="line">     METH_O, excepthook_doc&#125;,</span><br><span class="line">    &#123;<span class="literal">NULL</span>,                      <span class="literal">NULL</span>&#125;           <span class="comment">/* sentinel */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>我们看到第一个 *start_new_thread* 和第二个 *start_new* ，发现它们都对应 *thread_PyThread_start_new_thread* 这个函数，这些接口和_thread.py中对应的是一致的。</strong></p>
<h4 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h4><p><strong>当我们使用threading模块创建一个线程的时候，threading会调用_thread模块来创建，而在_thread中显然是通过里面 *start_new_thread* 对应的 *thread_PyThread_start_new_thread* 来创建，下面我们就来看看这个函数。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Modules/_threadmodule.c</span></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">thread_PyThread_start_new_thread</span><span class="params">(PyObject *self, PyObject *fargs)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyObject *func, *args, *keyw = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bootstate</span> *<span class="title">boot</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ident;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//下面都是参数检测逻辑, thread.Thread()里面我们一般传递target、args、kwargs</span></span><br><span class="line">    <span class="keyword">if</span> (!PyArg_UnpackTuple(fargs, <span class="string">&quot;start_new_thread&quot;</span>, <span class="number">2</span>, <span class="number">3</span>,</span><br><span class="line">                           &amp;func, &amp;args, &amp;keyw))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//target必须可调用</span></span><br><span class="line">    <span class="keyword">if</span> (!PyCallable_Check(func)) &#123;</span><br><span class="line">        PyErr_SetString(PyExc_TypeError,</span><br><span class="line">                        <span class="string">&quot;first arg must be callable&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//args是个元组</span></span><br><span class="line">    <span class="keyword">if</span> (!PyTuple_Check(args)) &#123;</span><br><span class="line">        PyErr_SetString(PyExc_TypeError,</span><br><span class="line">                        <span class="string">&quot;2nd arg must be a tuple&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//kwargs是个字典</span></span><br><span class="line">    <span class="keyword">if</span> (keyw != <span class="literal">NULL</span> &amp;&amp; !PyDict_Check(keyw)) &#123;</span><br><span class="line">        PyErr_SetString(PyExc_TypeError,</span><br><span class="line">                        <span class="string">&quot;optional 3rd arg must be a dictionary&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建bootstate结构体实例</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    struct bootstate &#123;</span></span><br><span class="line"><span class="comment">        PyInterpreterState *interp;</span></span><br><span class="line"><span class="comment">        PyObject *func;</span></span><br><span class="line"><span class="comment">        PyObject *args;</span></span><br><span class="line"><span class="comment">        PyObject *keyw;</span></span><br><span class="line"><span class="comment">        PyThreadState *tstate;</span></span><br><span class="line"><span class="comment">    &#125;;    </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    boot = PyMem_NEW(<span class="keyword">struct</span> bootstate, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (boot == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> PyErr_NoMemory();</span><br><span class="line">    <span class="comment">//获取进程状态对象、函数、args、kwargs</span></span><br><span class="line">    boot-&gt;interp = _PyInterpreterState_Get();</span><br><span class="line">    boot-&gt;func = func;</span><br><span class="line">    boot-&gt;args = args;</span><br><span class="line">    boot-&gt;keyw = keyw;</span><br><span class="line">    boot-&gt;tstate = _PyThreadState_Prealloc(boot-&gt;interp);</span><br><span class="line">    <span class="keyword">if</span> (boot-&gt;tstate == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        PyMem_DEL(boot);</span><br><span class="line">        <span class="keyword">return</span> PyErr_NoMemory();</span><br><span class="line">    &#125;</span><br><span class="line">    Py_INCREF(func);</span><br><span class="line">    Py_INCREF(args);</span><br><span class="line">    Py_XINCREF(keyw);</span><br><span class="line">    <span class="comment">//初始化多线程环境，记住这一步</span></span><br><span class="line">    PyEval_InitThreads(); <span class="comment">/* Start the interpreter&#x27;s thread-awareness */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建线程, 返回id</span></span><br><span class="line">    ident = PyThread_start_new_thread(t_bootstrap, (<span class="type">void</span>*) boot);</span><br><span class="line">    <span class="keyword">if</span> (ident == PYTHREAD_INVALID_THREAD_ID) &#123;</span><br><span class="line">        PyErr_SetString(ThreadError, <span class="string">&quot;can&#x27;t start new thread&quot;</span>);</span><br><span class="line">        Py_DECREF(func);</span><br><span class="line">        Py_DECREF(args);</span><br><span class="line">        Py_XDECREF(keyw);</span><br><span class="line">        PyThreadState_Clear(boot-&gt;tstate);</span><br><span class="line">        PyMem_DEL(boot);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> PyLong_FromUnsignedLong(ident);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>因此在这个函数中，我们看到Python虚拟机通过三个主要的动作完成一个线程的创建。</strong></p>
<ul>
<li><code>1. 创建并初始化bootstate结构体实例对象boot，在boot中，会保存一些相关信息</code></li>
<li><code>2. 初始化Python的多线程环境</code></li>
<li><code>3. 以boot为参数，创建子线程，子线程也会对应操作系统的原生线程</code></li>
</ul>
<p><strong>另外我们看到了这一步：<code>boot-&gt;interp = _PyInterpreterState_Get();</code>，说明boost保存了Python的 *PyInterpreterState* 对象，这个对象中携带了Python的<code>模块对象池(module pool)</code>这样的全局信息，Python中所有的thread都会保存这些全局信息。</strong></p>
<p><strong>我们在下面还看到了多线程环境的初始化动作，这一点需要注意，Python在启动的时候是不支持多线程的。换言之，Python中支持多线程的数据结构、以及GIL都是没有被创建的。因为对多线程的支持是需要代价的，如果上来就激活了多线程，但是程序却只有一个主线程，那么Python仍然会执行所谓的线程调度机制，只不过调度完了还是它自己，所以这无异于在做无用功。因此Python将开启多线程的权利交给了程序员，自己在启动的时候是单线程的，既然是单线程，自然就不存在线程调度了、当然也没有GIL。一旦用户调用了<code>threading.Thread(...).start() =&gt; _thread.start_new_thread()</code>，则代表明确地指示虚拟机要创建新的线程了，这个时候Python虚拟机就知道自己该创建与多线程相关的东西了，比如：数据结构、环境、以及那个至关重要的GIL。</strong></p>
<h4 id="建立多线程环境"><a href="#建立多线程环境" class="headerlink" title="建立多线程环境"></a>建立多线程环境</h4><p><strong>多线程环境的建立，说的直白一点，主要就是创建GIL。我们已经知道了GIL对于Python的多线程机制的重要意义，那么这个GIL是如何实现的呢？这是一个比较有趣的问题，下面我们就来看看GIL长什么样子吧。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//include/internal/pycore_pystate.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">ceval_runtime_state</span> &#123;</span></span><br><span class="line">    <span class="comment">/* 递归限制, 可以通过sys.getrecursionlimit()查看 */</span></span><br><span class="line">    <span class="type">int</span> recursion_limit;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">   	记录是否对任意线程启用跟踪，同时计算 tstate-&gt;c_tracefunc 为空的线程数。</span></span><br><span class="line"><span class="comment">   	如果该值为0，那么将不会检查该线程的 c_tracefunc</span></span><br><span class="line"><span class="comment">   	这会加快 PyEval_EvalFrameEx() 中 fast_next_opcode 后的if语句</span></span><br><span class="line"><span class="comment">   	</span></span><br><span class="line"><span class="comment">   	这里我们不做深入讨论</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">int</span> tracing_possible;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//eval循环中所有跳出快速通道的请求, 不深入讨论</span></span><br><span class="line">    _Py_atomic_int eval_breaker;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//放弃GIL的请求</span></span><br><span class="line">    _Py_atomic_int gil_drop_request;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//线程调度相关, 比如: 加锁</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">pending_calls</span> <span class="title">pending</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//信号检测相关</span></span><br><span class="line">    _Py_atomic_int signals_pending;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//重点来了, GIL, 我们看到GIL是一个struct _gil_runtime_state</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">gil_runtime_state</span> <span class="title">gil</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>所以GIL在Python的底层是一个结构体，这个结构体藏身于 *include&#x2F;internal&#x2F;pycore_gil* 中。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Python/ceval_gil.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_INTERVAL 5000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//include/internal/pycore_gil</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">gil_runtime_state</span> &#123;</span></span><br><span class="line">    <span class="comment">/* 一个线程拥有gil的间隔，默认是5000微妙，也就是我们上面用sys.getswitchinterval()得到的0.005 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> interval;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*最后一个持有GIL的PyThreadState(线程)，</span></span><br><span class="line"><span class="comment">    这有助于我们知道在丢弃GIL后是否还有其他线程被调度    </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    _Py_atomic_address last_holder;</span><br><span class="line">    <span class="comment">/* GIL是否被获取，这个是原子性的，因为在ceval.c中不需要任何锁就能够读取它 */</span></span><br><span class="line">    _Py_atomic_int locked;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 从GIL创建之后，总共切换的次数 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> switch_number;</span><br><span class="line">    <span class="comment">/* cond允许一个或多个线程等待，直到GIL被释放 */</span></span><br><span class="line">    PyCOND_T cond;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* mutex则是负责保护上面的变量 */</span></span><br><span class="line">    PyMUTEX_T mutex;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> FORCE_SWITCHING</span></span><br><span class="line">    <span class="comment">/* &quot;GIL等待线程&quot;在被调度获取GIL之前, &quot;GIL释放线程&quot;一致处于等待状态 */</span></span><br><span class="line">    PyCOND_T switch_cond;</span><br><span class="line">    PyMUTEX_T switch_mutex;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>所以我们看到gil是*struct _gil_runtime_state* 类型，然后内嵌在结构体 *struct _ceval_runtime_state* 里面。</strong></p>
<p><strong>gil是一个结构体实例，根据里面的gil.locked判断这个gil有没有人获取，而这个locked可以看成是一个布尔变量，其访问受到gil.mutex保护，是否改变则取决于gil.cond。在持有gil的线程中，主循环(PyEval_EvalFrameEx)必须能通过另一个线程来按需释放gil。</strong></p>
</blockquote>
<p><strong>并且我们知道在创建多线程的时候，首先是需要调用 *PyEval_InitThreads* 进行初始化的。我们就来看看这个函数，位于 *Python&#x2F;ceval.c* 中。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">PyEval_InitThreads</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//获取运行时状态对象</span></span><br><span class="line">    _PyRuntimeState *runtime = &amp;_PyRuntime;</span><br><span class="line">    <span class="comment">//拿到ceval, struct _ceval_runtime_state类型, gil就在里面</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">ceval_runtime_state</span> *<span class="title">ceval</span> =</span> &amp;runtime-&gt;ceval;</span><br><span class="line">    <span class="comment">//获取gil</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">gil_runtime_state</span> *<span class="title">gil</span> =</span> &amp;ceval-&gt;gil;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果gil已经创建，那么直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (gil_created(gil)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//线程的初始化</span></span><br><span class="line">    PyThread_init_thread();</span><br><span class="line">    <span class="comment">//创建gil</span></span><br><span class="line">    create_gil(gil);</span><br><span class="line">    <span class="comment">//获取线程状态对象</span></span><br><span class="line">    PyThreadState *tstate = _PyRuntimeState_GetThreadState(runtime);</span><br><span class="line">    <span class="comment">//gil创建了，那么就要拿到这个gil</span></span><br><span class="line">    take_gil(ceval, tstate);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//我们说这个是和线程调度相关的</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">pending_calls</span> *<span class="title">pending</span> =</span> &amp;ceval-&gt;pending;</span><br><span class="line">    <span class="comment">//如果拿到gil了，其它线程就不能获取了，那么不好意思这个时候要加锁</span></span><br><span class="line">    pending-&gt;lock = PyThread_allocate_lock();</span><br><span class="line">    <span class="keyword">if</span> (pending-&gt;lock == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Py_FatalError(<span class="string">&quot;Can&#x27;t initialize threads for pending calls&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>然后我们看看 *gil_created* 、 *create_gil* 、 *take_gil*  这三个函数，我们说它是用来检测 gil是否被创建、创建gil、和获取gil，定义在 *Python&#x2F;ceval_gil.h* 中。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gil_created</span><span class="params">(<span class="keyword">struct</span> _gil_runtime_state *gil)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//我们看到这个gil_created就是用来检测gil有没有被创建的</span></span><br><span class="line">    <span class="keyword">return</span> (_Py_atomic_load_explicit(&amp;gil-&gt;locked, _Py_memory_order_acquire) &gt;= <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">create_gil</span><span class="params">(<span class="keyword">struct</span> _gil_runtime_state *gil)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//这里是创建gil</span></span><br><span class="line">    <span class="comment">//我们看到这里负责初始化gil里面的成员</span></span><br><span class="line">    MUTEX_INIT(gil-&gt;mutex);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> FORCE_SWITCHING</span></span><br><span class="line">    MUTEX_INIT(gil-&gt;switch_mutex);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    COND_INIT(gil-&gt;cond);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> FORCE_SWITCHING</span></span><br><span class="line">    COND_INIT(gil-&gt;switch_cond);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    _Py_atomic_store_relaxed(&amp;gil-&gt;last_holder, <span class="number">0</span>);</span><br><span class="line">    _Py_ANNOTATE_RWLOCK_CREATE(&amp;gil-&gt;locked);</span><br><span class="line">    _Py_atomic_store_explicit(&amp;gil-&gt;locked, <span class="number">0</span>, _Py_memory_order_release);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">take_gil</span><span class="params">(<span class="keyword">struct</span> _ceval_runtime_state *ceval, PyThreadState *tstate)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (tstate == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Py_FatalError(<span class="string">&quot;take_gil: NULL tstate&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">gil_runtime_state</span> *<span class="title">gil</span> =</span> &amp;ceval-&gt;gil;</span><br><span class="line">    <span class="type">int</span> err = errno;</span><br><span class="line">    MUTEX_LOCK(gil-&gt;mutex);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//判断gil是否被释放, 如果被释放, 那么直接跳转到_ready</span></span><br><span class="line">    <span class="keyword">if</span> (!_Py_atomic_load_relaxed(&amp;gil-&gt;locked)) &#123;</span><br><span class="line">        <span class="keyword">goto</span> _ready;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (_Py_atomic_load_relaxed(&amp;gil-&gt;locked)) &#123;</span><br><span class="line">        <span class="type">int</span> timed_out = <span class="number">0</span>;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> saved_switchnum;</span><br><span class="line">        <span class="comment">//如果没有释放，代表gil被人使用了，会一直循环请求获取gil</span></span><br><span class="line">        <span class="comment">//.....</span></span><br><span class="line">        <span class="comment">//.....</span></span><br><span class="line">    &#125;</span><br><span class="line">_ready:</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> FORCE_SWITCHING</span></span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">    <span class="comment">/* 获取到gil的时候，那么会通过_Py_atomic_store_relaxed对其再次上锁 */</span></span><br><span class="line">    _Py_atomic_store_relaxed(&amp;gil-&gt;locked, <span class="number">1</span>);</span><br><span class="line">    _Py_ANNOTATE_RWLOCK_ACQUIRED(&amp;gil-&gt;locked, <span class="comment">/*is_write=*/</span><span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>事实上，Python的多线程机制和平台有关系，需要进行统一的封装。比如：线程的销毁，Windows系统下就位于 *Python&#x2F;thread_nt.h* 中，可以自己看一看。</strong></p>
<p><strong>总之Python的线程在获取gil的时候，会检查当前gil是否可用。而其中的locked域就是指示当前gil是否可用，如果这个值为0，那么代表可用，那么就必须要将gil的locked设置为1，表示当前gil已被占用。一旦当该线程释放gil的时候，就一定要将该值减去1，这样gil的值才会从1变成0，才能被其他线程使用，所以官方把gil的locked说成是布尔类型也不是没道理的。</strong></p>
<p><strong>最终在一个线程释放gil时，会通知所有在等待gil的线程，这些线程会被操作系统唤醒。但是这个时候会选择哪一个线程执行呢？之前说了，这个时候Python会直接借用操作系统的调度机制随机选择一个。</strong></p>
<h4 id="线程状态保护机制"><a href="#线程状态保护机制" class="headerlink" title="线程状态保护机制"></a>线程状态保护机制</h4><p><strong>要剖析线程状态的保护机制，我们首先需要回顾一下线程状态对象。在Python中肯定要有对象负责记录对应线程的状态信息，这个对象就是PyThreadState对象。</strong></p>
<p><strong>每一个PyThreadState对象中都保存着当前的线程的PyFrameObject、线程id这样的信息，因为这些信息是需要被线程访问的。假设线程A访问线程对象，但是线程对象里面存储的却是B的id，这样的话就完蛋了。因此Python内部必须有一套机制，这套机制与操作系统管理进程的机制非常类似。在线程切换的时候，会保存当前线程的上下文，并且还能够进行恢复。在Python内部，维护这一个全局变量，当前活动线程所对应的线程状态对象就保存在该变量里。当Python调度线程时，会将被激活的线程所对应的线程状态对象赋给这个全局变量，让其始终保存活动线程的状态对象。</strong></p>
<p><strong>但是这样就引入了一个问题：Python如何在调度线程时，获得被激活线程对应的状态对象呢？其实Python内部会通过一个单项链表来管理所有的Python线程状态对象，当需要寻找一个线程对应的状态对象时，就遍历这个链表，搜索其对应的状态对象。</strong></p>
<p><strong>而对这个状态对象链表的访问，则不必在gil的保护下进行。因为对于这个状态对象链表，python会专门创建一个独立的锁，专职对这个链表进行保护，而且这个锁的创建是在python初始化的时候完成的。</strong></p>
<p><img src="/2023/04/20/26-%E8%A7%A3%E5%AF%86Python%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%89%EF%BC%9A%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90Python%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E3%80%81%E9%94%80%E6%AF%81%E3%80%81%E8%B0%83%E5%BA%A6%E3%80%81%E4%BB%A5%E5%8F%8AGIL%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/1229382-20200912035628568-1560244594.png" alt="img"></p>
<h4 id="从gil到字节码解释器"><a href="#从gil到字节码解释器" class="headerlink" title="从gil到字节码解释器"></a>从gil到字节码解释器</h4><p><strong>我们知道创建线程对象是通过 *PyThreadState_New* 函数创建的：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Python/pystate.c</span></span><br><span class="line">PyThreadState *</span><br><span class="line"><span class="title function_">PyThreadState_New</span><span class="params">(PyInterpreterState *interp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> new_threadstate(interp, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyThreadState *</span><br><span class="line"><span class="title function_">new_threadstate</span><span class="params">(PyInterpreterState *interp, <span class="type">int</span> init)</span></span><br><span class="line">&#123;	</span><br><span class="line">    _PyRuntimeState *runtime = &amp;_PyRuntime;</span><br><span class="line">    <span class="comment">//创建线程对象</span></span><br><span class="line">    PyThreadState *tstate = (PyThreadState *)PyMem_RawMalloc(<span class="keyword">sizeof</span>(PyThreadState));</span><br><span class="line">    <span class="keyword">if</span> (tstate == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//用于获取当前线程的frame</span></span><br><span class="line">    <span class="keyword">if</span> (_PyThreadState_GetFrame == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        _PyThreadState_GetFrame = threadstate_getframe;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//下面是线程的相关属性</span></span><br><span class="line">    tstate-&gt;interp = interp;</span><br><span class="line"></span><br><span class="line">    tstate-&gt;frame = <span class="literal">NULL</span>;</span><br><span class="line">    tstate-&gt;recursion_depth = <span class="number">0</span>;</span><br><span class="line">    tstate-&gt;overflowed = <span class="number">0</span>;</span><br><span class="line">    tstate-&gt;recursion_critical = <span class="number">0</span>;</span><br><span class="line">    tstate-&gt;stackcheck_counter = <span class="number">0</span>;</span><br><span class="line">    tstate-&gt;tracing = <span class="number">0</span>;</span><br><span class="line">    tstate-&gt;use_tracing = <span class="number">0</span>;</span><br><span class="line">    tstate-&gt;gilstate_counter = <span class="number">0</span>;</span><br><span class="line">    tstate-&gt;async_exc = <span class="literal">NULL</span>;</span><br><span class="line">    tstate-&gt;thread_id = PyThread_get_thread_ident();</span><br><span class="line"></span><br><span class="line">    tstate-&gt;dict = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    tstate-&gt;curexc_type = <span class="literal">NULL</span>;</span><br><span class="line">    tstate-&gt;curexc_value = <span class="literal">NULL</span>;</span><br><span class="line">    tstate-&gt;curexc_traceback = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    tstate-&gt;exc_state.exc_type = <span class="literal">NULL</span>;</span><br><span class="line">    tstate-&gt;exc_state.exc_value = <span class="literal">NULL</span>;</span><br><span class="line">    tstate-&gt;exc_state.exc_traceback = <span class="literal">NULL</span>;</span><br><span class="line">    tstate-&gt;exc_state.previous_item = <span class="literal">NULL</span>;</span><br><span class="line">    tstate-&gt;exc_info = &amp;tstate-&gt;exc_state;</span><br><span class="line"></span><br><span class="line">    tstate-&gt;c_profilefunc = <span class="literal">NULL</span>;</span><br><span class="line">    tstate-&gt;c_tracefunc = <span class="literal">NULL</span>;</span><br><span class="line">    tstate-&gt;c_profileobj = <span class="literal">NULL</span>;</span><br><span class="line">    tstate-&gt;c_traceobj = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    tstate-&gt;trash_delete_nesting = <span class="number">0</span>;</span><br><span class="line">    tstate-&gt;trash_delete_later = <span class="literal">NULL</span>;</span><br><span class="line">    tstate-&gt;on_delete = <span class="literal">NULL</span>;</span><br><span class="line">    tstate-&gt;on_delete_data = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    tstate-&gt;coroutine_origin_tracking_depth = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    tstate-&gt;async_gen_firstiter = <span class="literal">NULL</span>;</span><br><span class="line">    tstate-&gt;async_gen_finalizer = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    tstate-&gt;context = <span class="literal">NULL</span>;</span><br><span class="line">    tstate-&gt;context_ver = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    tstate-&gt;id = ++interp-&gt;tstate_next_unique_id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (init) &#123;</span><br><span class="line">        <span class="comment">//其它的都是设置属性，我们在前面章节已经见过了</span></span><br><span class="line">        <span class="comment">//之所以又拿出来，是因为关键的这一步</span></span><br><span class="line">        _PyThreadState_Init(runtime, tstate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HEAD_LOCK(runtime);</span><br><span class="line">    tstate-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">    tstate-&gt;next = interp-&gt;tstate_head;</span><br><span class="line">    <span class="keyword">if</span> (tstate-&gt;next)</span><br><span class="line">        tstate-&gt;next-&gt;prev = tstate;</span><br><span class="line">    interp-&gt;tstate_head = tstate;</span><br><span class="line">    HEAD_UNLOCK(runtime);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tstate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//这一步_PyThreadState_Init就表示将线程对应的线程对象放入到我们刚才说的那个&quot;线程状态对象链表&quot;当中</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line">_PyThreadState_Init(_PyRuntimeState *runtime, PyThreadState *tstate)</span><br><span class="line">&#123;</span><br><span class="line">    _PyGILState_NoteThreadState(&amp;runtime-&gt;gilstate, tstate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这里有一个特别需要注意的地方，就是当前活动的Python线程不一定获得了gil。比如主线程获得了gil，但是子线程还没有申请gil，那么操作系统也不会将其挂起。由于主线程和子线程都对应操作系统的原生线程，所以操作系统系统是可能在主线程和子线程之间切换的，因为操作系统级别的线程调度和Python级别的线程调度是不同的。当所有的线程都完成了初始化动作之后，操作系统的线程调度和Python的线程调度才会统一。那时python的线程调度会迫使当前活动线程释放gil，而这一操作会触发操作系统内核的用于管理线程调度的对象，进而触发操作系统对线程的调度。所以我们说，Python对线程的调度是交给操作系统的<code>(使用的是操作系统内核调度线程的调度机制)</code>，当操作系统随机选择一个线程的时候，Python就会根据这个线程去<code>线程状态对象链表</code>当中找到对应的线程状态对象，并赋值给那个保存当前线程活动状态对象的全局变量。从而开始获取gil，执行字节码，执行一段时间，再次被强迫释放gil，然后操作系统再次调度，选择一个线程，再获取对应的线程状态对象，然后该线程获取gil，执行一段时间字节码，再次被强迫释放gil，然后操作系统再次随机选择，依次往复。。。。。。</strong></p>
<p><strong>显然，当子线程还没有获取gil的时候，相安无事。然而一旦 *PyThreadState_New* 之后，多线程机制初始化完成，那么子线程就开始互相争夺话语权了。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Modules/_threadmodule.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">t_bootstrap</span><span class="params">(<span class="type">void</span> *boot_raw)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//线程信息都在里面</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bootstate</span> *<span class="title">boot</span> =</span> (<span class="keyword">struct</span> bootstate *) boot_raw;</span><br><span class="line">    <span class="comment">//线程状态对象</span></span><br><span class="line">    PyThreadState *tstate;</span><br><span class="line">    PyObject *res;</span><br><span class="line">    <span class="comment">//获取线程状态对象</span></span><br><span class="line">    tstate = boot-&gt;tstate;</span><br><span class="line">    <span class="comment">//拿到线程id</span></span><br><span class="line">    tstate-&gt;thread_id = PyThread_get_thread_ident();</span><br><span class="line">    _PyThreadState_Init(&amp;_PyRuntime, tstate);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//下面说</span></span><br><span class="line">    PyEval_AcquireThread(tstate);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//进程内部的线程数量+1</span></span><br><span class="line">    tstate-&gt;interp-&gt;num_threads++;</span><br><span class="line">    <span class="comment">//执行字节码</span></span><br><span class="line">    res = PyObject_Call(boot-&gt;func, boot-&gt;args, boot-&gt;keyw);</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (PyErr_ExceptionMatches(PyExc_SystemExit))</span><br><span class="line">            <span class="comment">/* SystemExit is ignored silently */</span></span><br><span class="line">            PyErr_Clear();</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            _PyErr_WriteUnraisableMsg(<span class="string">&quot;in thread started by&quot;</span>, boot-&gt;func);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Py_DECREF(res);</span><br><span class="line">    &#125;</span><br><span class="line">    Py_DECREF(boot-&gt;func);</span><br><span class="line">    Py_DECREF(boot-&gt;args);</span><br><span class="line">    Py_XDECREF(boot-&gt;keyw);</span><br><span class="line">    PyMem_DEL(boot_raw);</span><br><span class="line">    tstate-&gt;interp-&gt;num_threads--;</span><br><span class="line">    PyThreadState_Clear(tstate);</span><br><span class="line">    PyThreadState_DeleteCurrent();</span><br><span class="line">    PyThread_exit_thread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这里面有一个 *PyEval_AcquireThread* ，之前我们没有说，但如果我要说它是做什么的你就知道了。在 *PyEval_AcquireThread* 中，子线程进行了最后的冲刺，于是在里面它通过 *PyThread_acquire_lock*  争取gil。到了这一步，子线程将自己挂起了，操作系统没办法靠自己的力量将其唤醒，只能等待Python的线程调度机制强迫主线程放弃gil后，触发操作系统内核的线程调度，子线程才会被唤醒。然而当子线程被唤醒之后，主线程却又陷入了苦苦的等待当中，同样苦苦地等待这Python强迫子线程放弃gil的那一刻。<code>(假设我们这里只有一个主线程和一个子线程)</code></strong></p>
<p><strong>当子线程被Python的线程调度机制唤醒之后，它所做的第一件事就是通过 *PyThreadState_Swap* 将Python维护的当前线程状态对象设置为其自身的状态对象，就如同操作系统进程的上下文环境恢复一样。这个 *PyThreadState_Swap* 我们也没有详细展开说，因为有些东西我们只需要知道是干什么的就行。</strong></p>
<p><strong>子线程获取了gil之后，还不算成功，因为它还没有进入字节码解释器<code>(想象成大大的for循环，里面有一个巨大的switch)</code>。当Python线程唤醒子线程之后，子线程将回到<code>t_bootstrap</code>，并进入 *PyObject_Call* ，从这里一路往前，最终调用 *PyEval_EvalFrameEx* ，才算是成功。因为 *PyEval_EvalFrameEx* 执行的是字节码指令，而Python最终执行的也是一个字节码，所以此时才算是真正的执行，之前的都只能说是初始化。当进入 *PyEval_EvalFrameEx* 的那一刻，子线程就和主线程一样，完全受Python线程度调度机制控制了。</strong></p>
<h3 id="Python的线程调度"><a href="#Python的线程调度" class="headerlink" title="Python的线程调度"></a>Python的线程调度</h3><h4 id="标准调度"><a href="#标准调度" class="headerlink" title="标准调度"></a>标准调度</h4><p><strong>当主线程和子线程都进入了Python解释器后，Python的线程之间的切换就完全由Python的线程调度机制掌控了。Python的线程调度机制肯定是在Python解释器核心 *PyEval_EvalFrameEx* 里面的，因为线程是在执行字节码的时候切换的，那么肯定是在 *PyEval_EvalFrameEx* 里面。而在分析字节码的时候，我们看到过 *PyEval_EvalFrameEx* ，尽管说它是字节码执行的核心，但是它实际上调用了其它的函数，但毕竟是从它开始的，所以我们还是说字节码核心是 *PyEval_EvalFrameEx* 。总之，在分析字节码的时候，我们并没有看线程的调度机制，那么下面我们就来分析一下。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ceval.c</span></span><br><span class="line">PyObject* _Py_HOT_FUNCTION</span><br><span class="line">_PyEval_EvalFrameDefault(PyFrameObject *f, <span class="type">int</span> throwflag)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">/* Give another thread a chance */</span></span><br><span class="line">        <span class="keyword">if</span> (_PyThreadState_Swap(&amp;runtime-&gt;gilstate, <span class="literal">NULL</span>) != tstate) &#123;</span><br><span class="line">            Py_FatalError(<span class="string">&quot;ceval: tstate mix-up&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//释放gil，给其他线程一个机会</span></span><br><span class="line">        drop_gil(ceval, tstate);</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Other threads may run now */</span></span><br><span class="line">        <span class="comment">//你一旦释放了，那么就必须要再次申请，才能等待下一次被调度。</span></span><br><span class="line">        take_gil(tstate);       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>主线程获得了gil执行字节码，但是我们知道在Python2中是通过执行字节码数量<code>(_Py_Ticker)</code>判断的，每执行一条字节码这个<code>_Py_Ticker</code>将减少1，初始为100。而在Python3中，则是通过执行时间来判断的，默认是0.005秒。一旦达到了执行时间，那么主线程就会将维护当前线程状态对象的全局变量设置为NULL并释放掉gil，这时候由于等待gil而被挂起的子线程被操作系统的线程调度机制重新唤醒，从而进入 *PyEval_EvalFrameEx* 。而对于主线程，虽然它失去了gil，但是由于它没有被挂起，所以对于操作系统的线程调度机制，它是可以再次被切换为活动线程的。</strong></p>
<p><strong>当操作系统的调度机制将主线程切换为活动线程的时候，主线程将主动申请gil，但由于gil被子线程占有，主线程将自身挂起。从这时开始，操作系统就不能再将主线程切换为活动线程了。所以我们发现，线程释放gil并不是马上就被挂起的，而是在释放完之后重新申请gil的时候才被挂起的。然后子线程执行0.005s之后，又会释放gil，申请gil，将自身挂起。而释放gil，会触发操作系统线程调度机制，唤醒主线程，如果是多个子线程的话，那么会从挂起的主线程和其它子线程中随机选择一个恢复。当主线程执行一段时间之后，又给子线程，如此反复，从而实现对Python多线程的支持。</strong></p>
<h4 id="阻塞调度"><a href="#阻塞调度" class="headerlink" title="阻塞调度"></a>阻塞调度</h4><p><strong>标准调度就是Python的调度机制掌控的，每个线程都是相当公平的。但是如果仅仅只有标准调度的话，那么可以说Python的多线程没有任何意义，但为什么可以很多场合使用多线程呢？就是因为调度除了标准调度之外，还存在阻塞调度。</strong></p>
<p><strong>阻塞调度是指，当某个线程遇到io阻塞的时候，会主动释放gil，让其它线程执行，因为io是不耗费cpu的。假设time.sleep，或者从网络上请求数据等等，这些都是处于io阻塞，那么会发生线程调度，当阻塞的线程可以执行了<code>(如：sleep结束，请求的数据成功返回)</code>，那么再切换回来。除了这一种情况之外，还有一种情况，也会导致线程不得不挂起，那就是input函数等待用户输入，这个时候也不得不释放gil。</strong></p>
<h3 id="Python子线程的销毁"><a href="#Python子线程的销毁" class="headerlink" title="Python子线程的销毁"></a>Python子线程的销毁</h3><p><strong>我们创建一个子线程的时候，往往是执行一个函数，或者重写一个类继承自threading.Thread，当然Python的threading模块我们后面会介绍。当一个子线程执行结束之后，Python肯定是要把对应的子线程销毁的，当然销毁主线程和销毁子线程是不同的，销毁主线程必须要销毁Python的运行时环境，而子线程的销毁则不需要这些动作，因此我们只看子线程的销毁。</strong></p>
<p><strong>通过前面的分析我们知道，线程的主体框架是在t_bootstrap中：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Modules/_threadmodule.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">t_bootstrap</span><span class="params">(<span class="type">void</span> *boot_raw)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bootstate</span> *<span class="title">boot</span> =</span> (<span class="keyword">struct</span> bootstate *) boot_raw;</span><br><span class="line">    PyThreadState *tstate;</span><br><span class="line">    PyObject *res;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    Py_DECREF(boot-&gt;func);</span><br><span class="line">    Py_DECREF(boot-&gt;args);</span><br><span class="line">    Py_XDECREF(boot-&gt;keyw);</span><br><span class="line">    PyMem_DEL(boot_raw);</span><br><span class="line">    tstate-&gt;interp-&gt;num_threads--;</span><br><span class="line">    PyThreadState_Clear(tstate);</span><br><span class="line">    PyThreadState_DeleteCurrent();</span><br><span class="line">    PyThread_exit_thread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Python首先会将进程内部的线程数量自减1，然后通过 *PyThreadState_Clear* 清理当前线程所对应的线程状态对象。所谓清理实际上比较简单，就是改变引用计数。随后，Python通过 *PyThreadState_DeleteCurrent* 函数释放gil。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Modules/pystate.c</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">PyThreadState_DeleteCurrent</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    _PyThreadState_DeleteCurrent(&amp;_PyRuntime);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">_PyThreadState_DeleteCurrent(_PyRuntimeState *runtime)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">gilstate_runtime_state</span> *<span class="title">gilstate</span> =</span> &amp;runtime-&gt;gilstate;</span><br><span class="line">    PyThreadState *tstate = _PyRuntimeGILState_GetThreadState(gilstate);</span><br><span class="line">    <span class="keyword">if</span> (tstate == <span class="literal">NULL</span>)</span><br><span class="line">        Py_FatalError(</span><br><span class="line">            <span class="string">&quot;PyThreadState_DeleteCurrent: no current tstate&quot;</span>);</span><br><span class="line">    tstate_delete_common(runtime, tstate);</span><br><span class="line">    <span class="keyword">if</span> (gilstate-&gt;autoInterpreterState &amp;&amp;</span><br><span class="line">        PyThread_tss_get(&amp;gilstate-&gt;autoTSSkey) == tstate)</span><br><span class="line">    &#123;</span><br><span class="line">        PyThread_tss_set(&amp;gilstate-&gt;autoTSSkey, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    _PyRuntimeGILState_SetThreadState(gilstate, <span class="literal">NULL</span>);</span><br><span class="line">    PyEval_ReleaseLock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>然后首先会删除当前的线程状态对象，然后通过 *PyEval_ReleaseLock* 释放gil。当然这只是完成了绝大部分的销毁工作，至于剩下的收尾工作就依赖于对应的操作系统了，当然这跟我们也就没关系了。</strong></p>
<h3 id="Python线程的用户级互斥与同步"><a href="#Python线程的用户级互斥与同步" class="headerlink" title="Python线程的用户级互斥与同步"></a>Python线程的用户级互斥与同步</h3><p><strong>我们知道，Python的线程在gil的控制之下，线程之间对Python提供的c  api访问都是互斥的，并且每次在字节码执行的过程中不会被打断，这可以看做是Python的内核级的用户互斥。但是这种互斥不是我们能够控制的，内核级通过gil的互斥保护了内核共享资源，比如<code>del obj</code>，它对应的指令是DELETE_NAME，这个是不会被打断的。但是像<code>n += 1</code>这种一行代码对应多条字节码，即便是有gil，但由于在执行到一半的时候，碰巧gil释放了，那么也会出岔子。所以我们还需要一种互斥，也就是用户级互斥。</strong></p>
<p><strong>实现用户级互斥的一种方法就是加锁，我们来看看Python提供的锁。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> PyMethodDef lock_methods[] = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;acquire_lock&quot;</span>, (PyCFunction)(<span class="type">void</span>(*)(<span class="type">void</span>))lock_PyThread_acquire_lock,</span><br><span class="line">     METH_VARARGS | METH_KEYWORDS, acquire_doc&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;acquire&quot;</span>,      (PyCFunction)(<span class="type">void</span>(*)(<span class="type">void</span>))lock_PyThread_acquire_lock,</span><br><span class="line">     METH_VARARGS | METH_KEYWORDS, acquire_doc&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;release_lock&quot;</span>, (PyCFunction)lock_PyThread_release_lock,</span><br><span class="line">     METH_NOARGS, release_doc&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;release&quot;</span>,      (PyCFunction)lock_PyThread_release_lock,</span><br><span class="line">     METH_NOARGS, release_doc&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;locked_lock&quot;</span>,  (PyCFunction)lock_locked_lock,</span><br><span class="line">     METH_NOARGS, locked_doc&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;locked&quot;</span>,       (PyCFunction)lock_locked_lock,</span><br><span class="line">     METH_NOARGS, locked_doc&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;__enter__&quot;</span>,    (PyCFunction)(<span class="type">void</span>(*)(<span class="type">void</span>))lock_PyThread_acquire_lock,</span><br><span class="line">     METH_VARARGS | METH_KEYWORDS, acquire_doc&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;__exit__&quot;</span>,    (PyCFunction)lock_PyThread_release_lock,</span><br><span class="line">     METH_VARARGS, release_doc&#125;,</span><br><span class="line">    &#123;<span class="literal">NULL</span>,           <span class="literal">NULL</span>&#125;              <span class="comment">/* sentinel */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>这些方法我们肯定都见过，acquire表示上锁、release就是释放。假设有两个线程A和B，A线程执行了lock.acquire()，然后执行下面的代码。这个时候依旧会进行线程调度，线程B执行的时候，也遇到了lock.acquire()，那么不好意思B线程就只能在这里等着了。没错，是轮到B线程执行了，但是由于我们在用户级层面上设置了一把锁lock，而这把锁已经被A线程获取了，那么即使后面切换到B线程，但是在A还没有lock.release()的时候，B也只能卡在lock.acquire()上面。因为A先拿到了锁，那么只要A不释放，B就拿不到锁，从而一直卡在lock.acquire()上面。</strong></p>
<blockquote>
<p><strong>用户级互斥：即便你拿到了GIL，你也无法执行。</strong></p>
</blockquote>
<h3 id="Python的threading模块"><a href="#Python的threading模块" class="headerlink" title="Python的threading模块"></a>Python的threading模块</h3><p><strong>上面说了这么多，那么我们来看看Python中的threading模块，下面就是从Python层面上介绍这个模块的使用方法、api。</strong></p>
<h4 id="创建一个线程"><a href="#创建一个线程" class="headerlink" title="创建一个线程"></a>创建一个线程</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个线程</span></span><br><span class="line">t = threading.Thread(target=hello, name=<span class="string">&quot;线程1&quot;</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">target：执行的函数</span></span><br><span class="line"><span class="string">args：位置参数</span></span><br><span class="line"><span class="string">kwargs：关键字参数</span></span><br><span class="line"><span class="string">name：线程名字</span></span><br><span class="line"><span class="string">daemon：布尔类型。表示是否设置为守护线程。设置为守护线程，那么当主线程执行结束会立即自杀</span></span><br><span class="line"><span class="string">        默认不是守护线程，表示主线程执行完毕但不会退出，而是等待子线程执行结束才会退出。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们调用threading.Thread会创建一个线程</span></span><br><span class="line"><span class="comment"># 介绍几个简单的属性吧</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.拿到线程名字,等价于t.getName()</span></span><br><span class="line"><span class="built_in">print</span>(t.name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.查看是否是守护线程，等价于t.isDaemon()</span></span><br><span class="line"><span class="built_in">print</span>(t.daemon)  <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.线程创建之后，还可以重新设置名字、或者守护线程</span></span><br><span class="line">t.setName(<span class="string">&quot;线程2&quot;</span>)</span><br><span class="line">t.setDaemon(<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(t.getName())  <span class="comment"># 线程2</span></span><br><span class="line"><span class="built_in">print</span>(t.isDaemon())  <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<h4 id="启动线程"><a href="#启动线程" class="headerlink" title="启动线程"></a>启动线程</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">l = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello</span>():</span><br><span class="line">    <span class="keyword">import</span> time</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    l.append(<span class="number">123</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个线程</span></span><br><span class="line">t = threading.Thread(target=hello, name=<span class="string">&quot;线程1&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 线程创建好了，但是我们如何启动呢？</span></span><br><span class="line"><span class="comment"># 直接调用t.start()即可。</span></span><br><span class="line">t.start()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(l)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">[]</span></span><br><span class="line"><span class="string">hello world</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看到启动一个子线程之后，主线程是不会等待子线程的，而是会继续往下走。因此在子线程进行append之前，主线程就已经打印了。那么如何等待子线程执行完毕之后，再让主线程往下走呢？</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">l = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello</span>():</span><br><span class="line">    <span class="keyword">import</span> time</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    l.append(<span class="number">123</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个线程</span></span><br><span class="line">t = threading.Thread(target=hello, name=<span class="string">&quot;线程1&quot;</span>)</span><br><span class="line">t.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里就表示必须等t这个线程执行完毕，主线程才能向下走。</span></span><br><span class="line"><span class="comment"># 当然这里面是可以传递一个超时时间的，如果执行完毕那么主线程往下走</span></span><br><span class="line"><span class="comment"># 但是执行完毕之前，时间到了，主线程也会向下走</span></span><br><span class="line">t.join()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(l)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">hello world</span></span><br><span class="line"><span class="string">[123]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 由于多个线程操作系统调度，所以无法决定谁先打印。</span></span><br><span class="line"><span class="comment"># 但是我们看到确实是等待子线程结束之后才向下走的</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果我们没有写t.jojn()</span></span><br><span class="line"><span class="comment"># 那么主线程执行完毕之后，会在最后默认执行一个join，不然它就直接结束了。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果是守护线程的话，那么就不用等了，直接结束</span></span><br><span class="line"><span class="comment"># 如果是多个子线程，同样的逻辑</span></span><br></pre></td></tr></table></figure>

<p><strong>突然发现这个模块的api实在简单，没啥可介绍的。可以直接网上搜索。</strong></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><strong>这次我们算是将Python的多线程分析完毕了，很多人都说Python的多线程比较”鸡肋”，主要就是因为GIL导致Python无法利用多核。但是GIL也是有它的优点的，所以关于GIL也是仁者见仁智者见智吧。</strong></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Lin Li</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/04/20/26-%E8%A7%A3%E5%AF%86Python%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%89%EF%BC%9A%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90Python%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E3%80%81%E9%94%80%E6%AF%81%E3%80%81%E8%B0%83%E5%BA%A6%E3%80%81%E4%BB%A5%E5%8F%8AGIL%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">http://example.com/2023/04/20/26-%E8%A7%A3%E5%AF%86Python%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%89%EF%BC%9A%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90Python%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E3%80%81%E9%94%80%E6%AF%81%E3%80%81%E8%B0%83%E5%BA%A6%E3%80%81%E4%BB%A5%E5%8F%8AGIL%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">LinLi's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/CPython/">CPython</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/04/25/27-Python%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%EF%BC%9A%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90Python%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9E%B6%E6%9E%84%E3%80%81%E5%86%85%E5%AD%98%E6%B1%A0%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" title="27-Python内存管理与垃圾回收(第一部分)：深度剖析Python内存管理架构、内存池的实现原理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">27-Python内存管理与垃圾回收(第一部分)：深度剖析Python内存管理架构、内存池的实现原理</div></div></a></div><div class="next-post pull-right"><a href="/2023/04/20/25-%E8%A7%A3%E5%AF%86Python%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%89%EF%BC%9A%E5%88%9D%E8%AF%86GIL%E3%80%81%E4%BB%A5%E5%8F%8A%E5%A4%9A%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E8%B0%83%E5%BA%A6%E6%9C%BA%E5%88%B6/" title="25-解密Python中的多线程（第一部分）：初识GIL、以及多个线程之间的调度机制"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">25-解密Python中的多线程（第一部分）：初识GIL、以及多个线程之间的调度机制</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/03/29/01-%E7%BC%96%E8%AF%91Cpython/" title="01-编译Cpython"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">01-编译Cpython</div></div></a></div><div><a href="/2023/03/29/02-%E4%B8%80%E5%88%87%E5%AF%B9%E8%B1%A1%E7%9A%86PyObject/" title="02-一切对象皆PyObject"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">02-一切对象皆PyObject</div></div></a></div><div><a href="/2023/03/29/04-%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/" title="04-浮点数的底层实现"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">04-浮点数的底层实现</div></div></a></div><div><a href="/2023/03/29/06-Bytes%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BA%95%E5%B1%82%E6%93%8D%E4%BD%9C/" title="06-Bytes对象的底层操作"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">06-Bytes对象的底层操作</div></div></a></div><div><a href="/2023/03/29/03-Python%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E5%99%A8%E5%92%8C%E5%BA%95%E5%B1%82%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86/" title="03-Python引用计数器和底层对象管理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">03-Python引用计数器和底层对象管理</div></div></a></div><div><a href="/2023/03/29/05-Python%E6%95%B4%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/" title="05-Python整数的底层实现"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">05-Python整数的底层实现</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Lin Li</div><div class="author-info__description">今日事，今日毕</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">122</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#26-%E8%A7%A3%E5%AF%86Python%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%89%EF%BC%9A%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90Python%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E3%80%81%E9%94%80%E6%AF%81%E3%80%81%E8%B0%83%E5%BA%A6%E3%80%81%E4%BB%A5%E5%8F%8AGIL%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">26-解密Python中的多线程（第二部分）：源码剖析Python线程的创建、销毁、调度、以及GIL的实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E8%A7%81Python%E7%9A%84-thread%E6%A8%A1%E5%9D%97"><span class="toc-number">1.1.</span> <span class="toc-text">初见Python的_thread模块</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">1.1.1.</span> <span class="toc-text">线程的创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%8E%AF%E5%A2%83"><span class="toc-number">1.1.2.</span> <span class="toc-text">建立多线程环境</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6"><span class="toc-number">1.1.3.</span> <span class="toc-text">线程状态保护机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8Egil%E5%88%B0%E5%AD%97%E8%8A%82%E7%A0%81%E8%A7%A3%E9%87%8A%E5%99%A8"><span class="toc-number">1.1.4.</span> <span class="toc-text">从gil到字节码解释器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Python%E7%9A%84%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="toc-number">1.2.</span> <span class="toc-text">Python的线程调度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E8%B0%83%E5%BA%A6"><span class="toc-number">1.2.1.</span> <span class="toc-text">标准调度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E8%B0%83%E5%BA%A6"><span class="toc-number">1.2.2.</span> <span class="toc-text">阻塞调度</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Python%E5%AD%90%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%94%80%E6%AF%81"><span class="toc-number">1.3.</span> <span class="toc-text">Python子线程的销毁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Python%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%A8%E6%88%B7%E7%BA%A7%E4%BA%92%E6%96%A5%E4%B8%8E%E5%90%8C%E6%AD%A5"><span class="toc-number">1.4.</span> <span class="toc-text">Python线程的用户级互斥与同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Python%E7%9A%84threading%E6%A8%A1%E5%9D%97"><span class="toc-number">1.5.</span> <span class="toc-text">Python的threading模块</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.5.1.</span> <span class="toc-text">创建一个线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.5.2.</span> <span class="toc-text">启动线程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">1.6.</span> <span class="toc-text">小结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/08/%E8%A7%A3%E5%86%B3Camera-ready-%E2%9C%98-Problem-Not-all-fonts-are-embedded-%E9%97%AE%E9%A2%98/" title="解决Camera ready ✘ Problem: Not all fonts are embedded. 问题">解决Camera ready ✘ Problem: Not all fonts are embedded. 问题</a><time datetime="2025-04-08T14:19:21.000Z" title="发表于 2025-04-08 22:19:21">2025-04-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/21/Sequence-Oriented-DBMS-Fuzzing/" title="Sequence-Oriented DBMS Fuzzing">Sequence-Oriented DBMS Fuzzing</a><time datetime="2025-02-21T09:35:08.000Z" title="发表于 2025-02-21 17:35:08">2025-02-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/18/AGENTLESS-Demystifying-LLM-based-Software-Engineering-Agents/" title="AGENTLESS: Demystifying LLM-based Software Engineering Agents">AGENTLESS: Demystifying LLM-based Software Engineering Agents</a><time datetime="2025-02-18T12:16:29.000Z" title="发表于 2025-02-18 20:16:29">2025-02-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/01/DeepSeek-R1-Incentivizing-Reasoning-Capability-in-LLMs-via-Reinforcement-Learning/" title="DeepSeek-R1: Incentivizing Reasoning Capability in LLMs via Reinforcement Learning">DeepSeek-R1: Incentivizing Reasoning Capability in LLMs via Reinforcement Learning</a><time datetime="2025-02-01T11:11:48.000Z" title="发表于 2025-02-01 19:11:48">2025-02-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/01/DeepSeek-Coder-When-the-Large-Language-Model-Meets-Programming-The-Rise-of-Code-Intelligence/" title="DeepSeek-Coder: When the Large Language Model Meets Programming - The Rise of Code Intelligence">DeepSeek-Coder: When the Large Language Model Meets Programming - The Rise of Code Intelligence</a><time datetime="2025-02-01T02:43:19.000Z" title="发表于 2025-02-01 10:43:19">2025-02-01</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Lin Li</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>