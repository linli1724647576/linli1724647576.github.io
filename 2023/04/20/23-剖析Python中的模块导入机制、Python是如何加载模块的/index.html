<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>23-剖析Python中的模块导入机制、Python是如何加载模块的 | LinLi's Blog</title><meta name="author" content="Lin Li"><meta name="copyright" content="Lin Li"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="23-剖析Python中的模块导入机制、Python是如何加载模块的楔子上一篇我们介绍了生成器，本来这里应该介绍协程的，但是大致阅读了一下，感觉如果从源码的角度来介绍协程的话，工作量太大。而且个人精力有限，所以推荐我写的这一篇博客：https:&#x2F;&#x2F;www.cnblogs.com&#x2F;traditional&#x2F;p&#x2F;11828780.html，是用来介绍asyncio的，当然也从Python的角度介绍了Py">
<meta property="og:type" content="article">
<meta property="og:title" content="23-剖析Python中的模块导入机制、Python是如何加载模块的">
<meta property="og:url" content="http://example.com/2023/04/20/23-%E5%89%96%E6%9E%90Python%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97%E5%AF%BC%E5%85%A5%E6%9C%BA%E5%88%B6%E3%80%81Python%E6%98%AF%E5%A6%82%E4%BD%95%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9D%97%E7%9A%84/index.html">
<meta property="og:site_name" content="LinLi&#39;s Blog">
<meta property="og:description" content="23-剖析Python中的模块导入机制、Python是如何加载模块的楔子上一篇我们介绍了生成器，本来这里应该介绍协程的，但是大致阅读了一下，感觉如果从源码的角度来介绍协程的话，工作量太大。而且个人精力有限，所以推荐我写的这一篇博客：https:&#x2F;&#x2F;www.cnblogs.com&#x2F;traditional&#x2F;p&#x2F;11828780.html，是用来介绍asyncio的，当然也从Python的角度介绍了Py">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2023-04-20T08:49:26.000Z">
<meta property="article:modified_time" content="2023-04-20T08:50:00.493Z">
<meta property="article:author" content="Lin Li">
<meta property="article:tag" content="CPython">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/04/20/23-%E5%89%96%E6%9E%90Python%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97%E5%AF%BC%E5%85%A5%E6%9C%BA%E5%88%B6%E3%80%81Python%E6%98%AF%E5%A6%82%E4%BD%95%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9D%97%E7%9A%84/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '23-剖析Python中的模块导入机制、Python是如何加载模块的',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-04-20 16:50:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">87</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="LinLi's Blog"><span class="site-name">LinLi's Blog</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">23-剖析Python中的模块导入机制、Python是如何加载模块的</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-04-20T08:49:26.000Z" title="发表于 2023-04-20 16:49:26">2023-04-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-04-20T08:50:00.493Z" title="更新于 2023-04-20 16:50:00">2023-04-20</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="23-剖析Python中的模块导入机制、Python是如何加载模块的"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="23-剖析Python中的模块导入机制、Python是如何加载模块的"><a href="#23-剖析Python中的模块导入机制、Python是如何加载模块的" class="headerlink" title="23-剖析Python中的模块导入机制、Python是如何加载模块的"></a>23-剖析Python中的模块导入机制、Python是如何加载模块的</h2><h3 id="楔子"><a href="#楔子" class="headerlink" title="楔子"></a>楔子</h3><p><strong>上一篇我们介绍了生成器，本来这里应该介绍协程的，但是大致阅读了一下，感觉如果从源码的角度来介绍协程的话，工作量太大。而且个人精力有限，所以推荐我写的这一篇博客：<code>https://www.cnblogs.com/traditional/p/11828780.html</code>，是用来介绍asyncio的，当然也从Python的角度介绍了Python中的协程。</strong></p>
<p><strong>这一次我们说一下Python模块的加载机制，我们之前所考察的所有内容都具有一个相同的特征，那就是它们都局限在一个py文件中。然而现实中不可能只有一个py文件，而是存在多个，而多个py文件之间存在引用和交互，这些也是程序的一个重要组成部分。那么这里我们就来分析，Python中模块的导入机制。</strong></p>
<p><strong>在这里我们必须强调一点，Python中一个单独的py文件、或者pyd文件，我们称之为一个 *模块* ；而多个模块组合起来放在一个目录中，这个目录我们称之为 *包* 。</strong></p>
<p><strong>但是不管是模块，还是包，它们在Python的底层都是PyModuleObject结构体实例，类型为PyModule_Type，而在Python中则都是一个<code>&lt;class &#39;module&#39;&gt;</code>对象。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Objects/moduleobject.c</span></span><br><span class="line">PyTypeObject PyModule_Type = &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, <span class="number">0</span>)</span><br><span class="line">    <span class="string">&quot;module&quot;</span>,                                   <span class="comment">/* tp_name */</span></span><br><span class="line">    <span class="keyword">sizeof</span>(PyModuleObject),                     <span class="comment">/* tp_basicsize */</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Python中的&lt;class &#x27;module&#x27;&gt;对应底层的PyModule_Type</span></span><br><span class="line"><span class="comment">//而导入进来的模块对象 则对应底层的 PyModuleObject</span></span><br></pre></td></tr></table></figure>

<p><strong>所以模块和包导入进来之后也是一个对象，下面我们通过Python来演示一下。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> pandas</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(os)  <span class="comment"># &lt;module &#x27;os&#x27; from &#x27;C:\\python38\\lib\\os.py&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(pandas)  <span class="comment"># &lt;module &#x27;pandas&#x27; from &#x27;C:\\python38\\lib\\site-packages\\pandas\\__init__.py&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(os))  <span class="comment"># &lt;class &#x27;module&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(pandas))  <span class="comment"># &lt;class &#x27;module&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>因此不管是模块还是包，在Python中都是一样的，我们后面会详细说。总之它们都是一个PyModuleObject，只不过为了区分，我们把单独的py文件、pyd文件叫做模块，一个目录叫做包，但是在Python的底层则并没有区分那么明显，它们都是一样的。</strong></p>
<p><strong>所以为了不产生歧义，我们这里做一个约定，从现在开始本系列中出现的”模块”：指的就是单独的可导入文件；出现的”包”：指的就是目录；而”模块”和”包”组合起来，我们称之为module对象，因为这两者本来就是<code>&lt;class &#39;module&#39;&gt;</code>的实例对象。</strong></p>
<h3 id="import前奏曲"><a href="#import前奏曲" class="headerlink" title="import前奏曲"></a>import前奏曲</h3><p><strong>我们以一个简单的import为序幕，看看相应的字节码；</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">  <span class="number">1</span>           <span class="number">0</span> LOAD_CONST               <span class="number">0</span> (<span class="number">0</span>)</span><br><span class="line">              <span class="number">2</span> LOAD_CONST               <span class="number">1</span> (<span class="literal">None</span>)</span><br><span class="line">              <span class="number">4</span> IMPORT_NAME              <span class="number">0</span> (sys)</span><br><span class="line">              <span class="number">6</span> STORE_NAME               <span class="number">0</span> (sys)</span><br><span class="line">              <span class="number">8</span> LOAD_CONST               <span class="number">1</span> (<span class="literal">None</span>)</span><br><span class="line">             <span class="number">10</span> RETURN_VALUE</span><br></pre></td></tr></table></figure>

<p><strong>我们发现对应的字节码真的是简单无比。先不管开头的两个LOAD_CONST，我们在第三行看到了IMPORT_NAME，这个可以类比之前的LOAD_NAME。表示将sys这个module对象加载进来，然后通过STORE_NAME存储在当前的local名字空间中，然后当我们调用sys.path的时候，虚拟机就能很轻松地通过sys来获取path这个属性所对应的值了。因此就像我们之前说的那样，创建函数、类、导入模块等等，它们本质上和通过赋值语句创建一个变量是没有什么区别的，关键就是这个IMPORT_NAME，我们看看它的实现，知道从哪里看吗？我们说Python中所有指令集的实现都在 *ceval.c* 的那个无限for循环的巨型switch中。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="title function_">TARGET</span><span class="params">(IMPORT_NAME)</span>: &#123;</span><br><span class="line">    <span class="comment">//PyUnicodeObject对象，比如import pandas，那么这个name就是字符串pandas</span></span><br><span class="line">    PyObject *name = GETITEM(names, oparg);</span><br><span class="line">    <span class="comment">//我们看到这里有一个fromlist和level，显然需要从运行时栈中获取对应的值，那么显然要先将值压入运行时栈</span></span><br><span class="line">    <span class="comment">//我们再看一下刚才的字节码，我们发现在IMPORT_NAME之前有两个LOAD_CONST，将0和None压入了运行时栈</span></span><br><span class="line">    <span class="comment">//因此这里会从运行时栈中获取到None和0，然后分别赋值给fromlist和level，至于这两个是干啥的，我们后面说</span></span><br><span class="line">    PyObject *fromlist = POP();</span><br><span class="line">    PyObject *level = TOP();</span><br><span class="line">    PyObject *res; <span class="comment">//一个PyModuleObject *，也就是模块对象</span></span><br><span class="line">    <span class="comment">//调用import_name, 将该函数的返回值赋值给res</span></span><br><span class="line">    res = import_name(tstate, f, name, fromlist, level);</span><br><span class="line">    Py_DECREF(level);</span><br><span class="line">    Py_DECREF(fromlist);</span><br><span class="line">    SET_TOP(res);</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>因此重点在import_name这个函数中，但是在此之前我们需要重点关注一下这个fromlist和level，而这一点我们可以从Python的层面来介绍。我们知道在python中，我们导入一个模块直接通过import关键字即可，  但是除了import，我们还可以使用__import__函数来进行导入，这个__import__是解释器使用的一个函数，不推荐我们直接使用，但是我想说的是import os就等价于os &#x3D; <strong>import</strong>(“os”)。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">os = <span class="built_in">__import__</span>(<span class="string">&quot;os&quot;</span>)</span><br><span class="line">SYS = <span class="built_in">__import__</span>(<span class="string">&quot;sys&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(os)  <span class="comment"># &lt;module &#x27;os&#x27; from &#x27;C:\\python38\\lib\\os.py&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(SYS.prefix)  <span class="comment"># C:\python38</span></span><br></pre></td></tr></table></figure>

<p><strong>但是问题来了：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">m1 = <span class="built_in">__import__</span>(<span class="string">&quot;os.path&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(m1)  <span class="comment"># &lt;module &#x27;os&#x27; from &#x27;C:\\python38\\lib\\os.py&#x27;&gt;</span></span><br><span class="line"><span class="comment"># 我们惊奇地发现，居然还是os模块，按理说应该是os.path(windows系统对应ntpath)啊</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">m2 = <span class="built_in">__import__</span>(<span class="string">&quot;os.path&quot;</span>, fromlist=[<span class="string">&quot;&quot;</span>])</span><br><span class="line"><span class="built_in">print</span>(m2)  <span class="comment"># &lt;module &#x27;ntpath&#x27; from &#x27;C:\\python38\\lib\\ntpath.py&#x27;&gt;</span></span><br><span class="line"><span class="comment"># 你看到了什么，fromlist，没错，我们加上一个fromlist，就能导入子模块</span></span><br></pre></td></tr></table></figure>

<p><strong>为什么会这样呢？我们来看看<code>__import__</code>这个函数的解释，这个是pycharm给抽象出来的。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__import__</span>(<span class="params">name, <span class="built_in">globals</span>=<span class="literal">None</span>, <span class="built_in">locals</span>=<span class="literal">None</span>, fromlist=(<span class="params"></span>), level=<span class="number">0</span></span>): </span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    __import__(name, globals=None, locals=None, fromlist=(), level=0) -&gt; module</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Import a module. Because this function is meant for use by the Python</span></span><br><span class="line"><span class="string">    interpreter and not for general use, it is better to use</span></span><br><span class="line"><span class="string">    importlib.import_module() to programmatically import a module.</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    The globals argument is only used to determine the context;</span></span><br><span class="line"><span class="string">    they are not modified.  The locals argument is unused.  The fromlist</span></span><br><span class="line"><span class="string">    should be a list of names to emulate ``from name import ...&#x27;&#x27;, or an</span></span><br><span class="line"><span class="string">    empty list to emulate ``import name&#x27;&#x27;.</span></span><br><span class="line"><span class="string">    When importing a module from a package, note that __import__(&#x27;A.B&#x27;, ...)</span></span><br><span class="line"><span class="string">    returns package A when fromlist is empty, but its submodule B when</span></span><br><span class="line"><span class="string">    fromlist is not empty.  The level argument is used to determine whether to</span></span><br><span class="line"><span class="string">    perform absolute or relative imports: 0 is absolute, while a positive number</span></span><br><span class="line"><span class="string">    is the number of parent directories to search relative to the current module.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p><strong>大意就是，此函数会由import语句调用，当我们import的时候，解释器底层就会调用__import__。比如import  os表示将”os”这个字符串传入__import__中，从指定目录加载os.py(也可能是os.pyd、或者一个名为os的目录也可以)得到一个module对象，并将返回值再次赋值给符号os，也就是os &#x3D;  <strong>import</strong>(“os”)。虽然我们可以通过这种方式来导入模块，但是Python不建议我们这么做。而globals参数则是确定import语句包的上下文，一般直接传globals()即可，但是locals参数我们基本不用，不过一般情况下globals和locals我们都不用管。</strong></p>
<p><strong>fromlist我们刚才已经说了，<strong>import</strong>(“os.path”)，如果是这种情况的话，那么导入的不是os.path，还是os这个外层模块。如果想导入os.path，那么只需要给fromlist传入一个非空列表即可，其实不仅仅是非空列表，只要是一个非空的可迭代对象就行。而level如果是0，那么表示仅执行绝对导入，如果是一个正整数，表示要搜索的父目录的数量。一般这个值也不需要传递。</strong></p>
<p><strong>那这个方法有什么作用呢？假设如果我们有一个字符串a，其值为”pandas”，我想导入这个模块，该怎么做呢？显然就可以使用这种方式，但是这种方式导入的话，python官方不推荐使用__import__，而是希望我们使用一个叫做importlib的模块。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> importlib</span><br><span class="line"></span><br><span class="line">a = <span class="string">&quot;pandas&quot;</span></span><br><span class="line">pd = importlib.import_module(a)</span><br><span class="line"><span class="comment"># 很方便的就导入了, 字节通过字符串的方式导入一个module对象</span></span><br><span class="line"><span class="built_in">print</span>(pd)  </span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;module &#x27;pandas&#x27; from &#x27;C:\\python38\\lib\\site-packages\\pandas\\__init__.py&#x27;&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果想导入一个&quot;模块中导入的另一个模块&quot;, 比如: 模块a中导入了模块b, 我们希望导入a.b</span></span><br><span class="line"><span class="comment"># 或者导入一个包下面的子模块等等, 比如: pandas.core.frame</span></span><br><span class="line">sub_mod = importlib.import_module(<span class="string">&quot;pandas.core.frame&quot;</span>)</span><br><span class="line"><span class="comment"># 我们看到可以自动导入pandas.core.frame</span></span><br><span class="line"><span class="built_in">print</span>(sub_mod)  </span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;module &#x27;pandas.core.frame&#x27; from &#x27;C:\\python38\\lib\\site-packages\\pandas\\core\\frame.py&#x27;&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 但如果是__import__, 默认的话是不行的, 导入的依旧是最外层pandas</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">__import__</span>(<span class="string">&quot;pandas.core.frame&quot;</span>))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;module &#x27;pandas&#x27; from &#x27;C:\\python38\\lib\\site-packages\\pandas\\__init__.py&#x27;&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以通过给fromlist指定一个非空列表来实现</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">__import__</span>(<span class="string">&quot;pandas.core.frame&quot;</span>, fromlist=[<span class="string">&quot;&quot;</span>]))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;module &#x27;pandas.core.frame&#x27; from &#x27;C:\\python38\\lib\\site-packages\\pandas\\core\\frame.py&#x27;&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>扯了这么多，我们来看看之前源码中说的import_name。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ceval.c</span></span><br><span class="line">        <span class="keyword">case</span> <span class="title function_">TARGET</span><span class="params">(IMPORT_NAME)</span>: &#123;</span><br><span class="line">            <span class="comment">// 这个函数接收了五个参数，tstate：线程状态对象、f：栈帧、name：模块名、fromlist：一个None、level：0</span></span><br><span class="line">            res = import_name(tstate, f, name, fromlist, level);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">import_name</span><span class="params">(PyThreadState *tstate, PyFrameObject *f,</span></span><br><span class="line"><span class="params">            PyObject *name, PyObject *fromlist, PyObject *level)</span></span><br><span class="line">&#123;</span><br><span class="line">    _Py_IDENTIFIER(__import__);</span><br><span class="line">    PyObject *import_func, *res;</span><br><span class="line">    PyObject* <span class="built_in">stack</span>[<span class="number">5</span>];</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//获取内建函数__import__</span></span><br><span class="line">    import_func = _PyDict_GetItemIdWithError(f-&gt;f_builtins, &amp;PyId___import__);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//为NULL获取失败, 显然这些都是Python底层做的检测, 在Python使用上不会出现</span></span><br><span class="line">    <span class="comment">//如果出现, 只能说明解释器出问题了</span></span><br><span class="line">    <span class="keyword">if</span> (import_func == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!_PyErr_Occurred(tstate)) &#123;</span><br><span class="line">            _PyErr_SetString(tstate, PyExc_ImportError, <span class="string">&quot;__import__ not found&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断__import__是否被重载了</span></span><br><span class="line">    <span class="keyword">if</span> (import_func == tstate-&gt;interp-&gt;import_func) &#123;</span><br><span class="line">        <span class="type">int</span> ilevel = _PyLong_AsInt(level);</span><br><span class="line">        <span class="keyword">if</span> (ilevel == <span class="number">-1</span> &amp;&amp; _PyErr_Occurred(tstate)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//未重载的话，调用PyImport_ImportModuleLevelObject</span></span><br><span class="line">        res = PyImport_ImportModuleLevelObject(</span><br><span class="line">                        name,</span><br><span class="line">                        f-&gt;f_globals,</span><br><span class="line">                        f-&gt;f_locals == <span class="literal">NULL</span> ? Py_None : f-&gt;f_locals,</span><br><span class="line">                        fromlist,</span><br><span class="line">                        ilevel);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Py_INCREF(import_func);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">stack</span>[<span class="number">0</span>] = name;</span><br><span class="line">    <span class="built_in">stack</span>[<span class="number">1</span>] = f-&gt;f_globals;</span><br><span class="line">    <span class="built_in">stack</span>[<span class="number">2</span>] = f-&gt;f_locals == <span class="literal">NULL</span> ? Py_None : f-&gt;f_locals;</span><br><span class="line">    <span class="built_in">stack</span>[<span class="number">3</span>] = fromlist;</span><br><span class="line">    <span class="built_in">stack</span>[<span class="number">4</span>] = level;</span><br><span class="line">    res = _PyObject_FastCall(import_func, <span class="built_in">stack</span>, <span class="number">5</span>);</span><br><span class="line">    Py_DECREF(import_func);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>然后我们看到底层又调用了 *PyImport_ImportModuleLevelObject* ，我们来看一下它的实现。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Python/import.c</span></span><br><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyImport_ImportModuleLevelObject</span><span class="params">(PyObject *name, PyObject *globals,</span></span><br><span class="line"><span class="params">                                 PyObject *locals, PyObject *fromlist,</span></span><br><span class="line"><span class="params">                                 <span class="type">int</span> level)</span></span><br><span class="line">&#123;</span><br><span class="line">    _Py_IDENTIFIER(_handle_fromlist);</span><br><span class="line">    PyObject *abs_name = <span class="literal">NULL</span>;</span><br><span class="line">    PyObject *final_mod = <span class="literal">NULL</span>;</span><br><span class="line">    PyObject *mod = <span class="literal">NULL</span>;</span><br><span class="line">    PyObject *package = <span class="literal">NULL</span>;</span><br><span class="line">    PyInterpreterState *interp = _PyInterpreterState_GET_UNSAFE();</span><br><span class="line">    <span class="type">int</span> has_from;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//名字不可以为空</span></span><br><span class="line">    <span class="keyword">if</span> (name == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        PyErr_SetString(PyExc_ValueError, <span class="string">&quot;Empty module name&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//名字必须是PyUnicodeObject</span></span><br><span class="line">    <span class="keyword">if</span> (!PyUnicode_Check(name)) &#123;</span><br><span class="line">        PyErr_SetString(PyExc_TypeError, <span class="string">&quot;module name must be a string&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//level不可以小于0</span></span><br><span class="line">    <span class="keyword">if</span> (level &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        PyErr_SetString(PyExc_ValueError, <span class="string">&quot;level must be &gt;= 0&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//level大于0</span></span><br><span class="line">    <span class="keyword">if</span> (level &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//在相应的父目录寻找，得到abs_name</span></span><br><span class="line">        abs_name = resolve_name(name, globals, level);</span><br><span class="line">        <span class="keyword">if</span> (abs_name == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;  <span class="comment">//否则的话，说明level==0，因为level要求是一个大于等于0的整数</span></span><br><span class="line">        <span class="keyword">if</span> (PyUnicode_GET_LENGTH(name) == <span class="number">0</span>) &#123;</span><br><span class="line">            PyErr_SetString(PyExc_ValueError, <span class="string">&quot;Empty module name&quot;</span>);</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时直接将name赋值给abs_name</span></span><br><span class="line">        <span class="comment">//因为此时是绝对导入</span></span><br><span class="line">        abs_name = name;</span><br><span class="line">        Py_INCREF(abs_name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用PyImport_GetModule获取module对象</span></span><br><span class="line">    <span class="comment">//注意：这个module对象会从sys.modules里面获取，并不会重新加载</span></span><br><span class="line">    <span class="comment">//我们说在Python中，导入一个module对象的时候会从sys.modules里面查找</span></span><br><span class="line">    <span class="comment">//如果没有，那么才从硬盘上加载。一旦加载，那么会直接设置在sys.modules里面</span></span><br><span class="line">    <span class="comment">//在下一次导入的时候，直接从sys.modules中获取，具体细节后面聊</span></span><br><span class="line">    mod = PyImport_GetModule(abs_name);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span> (mod == <span class="literal">NULL</span> &amp;&amp; PyErr_Occurred()) &#123;</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//...    </span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//调用函数，导入模块</span></span><br><span class="line">        final_mod = _PyObject_CallMethodIdObjArgs(interp-&gt;importlib,</span><br><span class="line">                                                  &amp;PyId__handle_fromlist, mod,</span><br><span class="line">                                                  fromlist, interp-&gt;import_func,</span><br><span class="line">                                                  <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  error:</span><br><span class="line">    Py_XDECREF(abs_name);</span><br><span class="line">    Py_XDECREF(mod);</span><br><span class="line">    Py_XDECREF(package);</span><br><span class="line">    <span class="keyword">if</span> (final_mod == <span class="literal">NULL</span>)</span><br><span class="line">        remove_importlib_frames();</span><br><span class="line">    <span class="keyword">return</span> final_mod;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>另外关于module对象的导入方式，Python也提供了非常丰富的写法，比如：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> numpy.random <span class="keyword">as</span> _random</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> random <span class="keyword">as</span> _random</span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure>

<p><strong>从import的目标来说，可以是”包”，也可以是模块。而模块可以通过py文件作为载体，也可以通过dll<code>(pyd)</code>或者so等二进制文件作为载体，下面我们就来一一介绍。</strong></p>
<h3 id="import机制的黑盒探测"><a href="#import机制的黑盒探测" class="headerlink" title="import机制的黑盒探测"></a>import机制的黑盒探测</h3><p><strong>同C++的namespace，Python通过模块和包来实现对系统复杂度的分解，以及保护名字空间不受污染。通过模块和包，我们可以将某个功能、某种抽象进行独立的实现和维护，在module对象的基础之上构建软件，这样不仅使得软件的架构清晰，而且也能很好的实现代码复用。</strong></p>
<h4 id="标准import"><a href="#标准import" class="headerlink" title="标准import"></a>标准import</h4><h5 id="Python内建module"><a href="#Python内建module" class="headerlink" title="Python内建module"></a>Python内建module</h5><p><strong>sys这个模块恐怕是使用最频繁的module对象之一了，我们就从这位老铁入手。Python中有一个内置函数dir，这个小工具是我们探测import的杀手锏。如果你在交互式环境下输入dir()，那么会打印当前local名字空间的所有符号，如果有参数，则将参数视为对象，输出该对象的所有属性。我们先来看看import动作对当前名字空间的影响：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dir</span>()</span><br><span class="line">[<span class="string">&#x27;__annotations__&#x27;</span>, <span class="string">&#x27;__builtins__&#x27;</span>, <span class="string">&#x27;__doc__&#x27;</span>, <span class="string">&#x27;__loader__&#x27;</span>, <span class="string">&#x27;__name__&#x27;</span>, <span class="string">&#x27;__package__&#x27;</span>, <span class="string">&#x27;__spec__&#x27;</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dir</span>()</span><br><span class="line">[<span class="string">&#x27;__annotations__&#x27;</span>, <span class="string">&#x27;__builtins__&#x27;</span>, <span class="string">&#x27;__doc__&#x27;</span>, <span class="string">&#x27;__loader__&#x27;</span>, <span class="string">&#x27;__name__&#x27;</span>, <span class="string">&#x27;__package__&#x27;</span>, <span class="string">&#x27;__spec__&#x27;</span>, <span class="string">&#x27;sys&#x27;</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>我们看到当我们进行了import动作之后，当前的local名字空间增加了一个sys符号。而且通过type操作，我们看到这个sys符号指向一个module对象，我们说在底层它是一个PyModuleObject。当然虽然写着类型是<code>&lt;class &#39;module&#39;&gt;</code>，但是我们在Python中是无法直接使用module这个类的。不过它既然是一个class，那么就一定继承object，并且元类为type。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.__class__.__class__</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;type&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.__class__.__base__</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;object&#x27;</span>&gt;</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>这与我们的分析是一致的。言归正传，我们看到import机制影响了当前local名字空间，使得加载的module对象在local空间成为可见的。实际上，这和我们创建一个变量的时候，也会影响local名字空间。引用该module的方法正是通过module的名字，即这里的sys。</strong></p>
<p><strong>不过这里还有一个问题，我们来看一下：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys</span><br><span class="line">&lt;module <span class="string">&#x27;sys&#x27;</span> (built-<span class="keyword">in</span>)&gt;</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>我们看到sys是内置的，说明模块除了真实存在文件之外，还可以内嵌在解释器里面。但既然如此，那为什么我们不能直接使用，还需要导入呢？其实不光是sys，在Python初始化的时候，就已经将一大批的module对象加载到了内存中。但是为了使得当前local名字空间能够达到最干净的效果，Python并没有将这些符号暴露在local名字空间中，而是需要用户显式的使用import机制来将这个符号引入到local名字空间中，才能让程序使用这个符号背后的对象。</strong></p>
<p><strong>我们知道，凡是加载进内存的module对象都保存在sys.modules里面，尽管当前的local空间里面没有，但是sys.modules里面是跑不掉的。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="comment"># 这个modules是一个字典，里面分别为 module对象的名字 和 对应的PyModuleObject</span></span><br><span class="line"><span class="comment"># 里面有很多模块，我就不打印了，另外感到意味的是，居然把numpy也加载进来了</span></span><br><span class="line">modules = sys.modules</span><br><span class="line"></span><br><span class="line">np = modules[<span class="string">&quot;numpy&quot;</span>]</span><br><span class="line">arr = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="built_in">print</span>(np.<span class="built_in">sum</span>(arr))  <span class="comment"># 15</span></span><br><span class="line"></span><br><span class="line">os_ = modules[<span class="string">&quot;os&quot;</span>]</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(os) == <span class="built_in">id</span>(os_))  <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<p><strong>一开始这些module对象是不在local空间里面的，除非我们显式导入，但是即便我们导入，这些module对象也不会被二次加载，因为已经在初始化的时候就被加载到内存里面了。因此对于已经在sys.modules里面的module对象来说，导入的时候只是加到local空间里面去，所以代码中的os和os_的id是一样的。如果我们在Python启动之后，导入一个sys.modules中不存在的module对象，那么才会进行加载、然后同时进入local空间和sys.modules。</strong></p>
<h5 id="用户自定义module"><a href="#用户自定义module" class="headerlink" title="用户自定义module"></a>用户自定义module</h5><p><strong>我们知道，对于那些内嵌在解释器里面的module对象，如果import，只是将该module对象暴露在了local名字空间中。下面我们看看对于那些没有在初始化的时候加载到内存的module对象进行import的时候，会出现什么样动作。这里就以模块为例，当然正如我们之前说的，一个模块的载体可以是py文件或者二进制文件，py文件可以是自己编写的、也可以是标准库中的、或者第三方库中的。不过我们目前不区分那么多，通过自己编写的py文件作为例子，探探路。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># a.py</span></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a&quot;</span> <span class="keyword">in</span> sys.modules)  <span class="comment"># False</span></span><br><span class="line"><span class="keyword">import</span> a</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a&quot;</span> <span class="keyword">in</span> sys.modules)  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>())  </span><br><span class="line"><span class="comment"># [&#x27;__annotations__&#x27;, &#x27;__builtins__&#x27;, &#x27;__cached__&#x27;, &#x27;__doc__&#x27;, &#x27;__file__&#x27;, &#x27;__loader__&#x27;, &#x27;__name__&#x27;, &#x27;__package__&#x27;, &#x27;__spec__&#x27;, &#x27;a&#x27;, &#x27;sys&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a))  <span class="comment"># 2653299804976</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(sys.modules[<span class="string">&quot;a&quot;</span>]))  <span class="comment"># 2653299804976</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a))  <span class="comment"># &lt;class &#x27;module&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>调用type的结果显示，import机制确实创建了一个新的module对象。而且也确实如我们之前所说，Python对a这个module对象或者模块，不仅将其引入进当前的local名字空间中，而且这个被动态加载的模块也在sys.module中拥有了一席之地，而且它们背后隐藏的是同一个PyModuleObject对象。然后我们再来看看这个module对象：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> a</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>(a))  <span class="comment"># [&#x27;__builtins__&#x27;, &#x27;__cached__&#x27;, &#x27;__doc__&#x27;, &#x27;__file__&#x27;, &#x27;__loader__&#x27;, &#x27;__name__&#x27;, &#x27;__package__&#x27;, &#x27;__spec__&#x27;, &#x27;a&#x27;, &#x27;b&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(a.__dict__.keys())</span><br><span class="line"><span class="comment"># dict_keys([&#x27;__name__&#x27;, &#x27;__doc__&#x27;, &#x27;__package__&#x27;, &#x27;__loader__&#x27;, &#x27;__spec__&#x27;, &#x27;__file__&#x27;, &#x27;__cached__&#x27;, &#x27;__builtins__&#x27;, &#x27;a&#x27;, &#x27;b&#x27;])</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a.__name__)  <span class="comment"># a</span></span><br><span class="line"><span class="built_in">print</span>(a.__file__)  <span class="comment"># D:\satori\a.py</span></span><br></pre></td></tr></table></figure>

<p><strong>这里可以看到，module对象内部实际上是通过一个dict在维护所有的module对象<code>&#123;名字: 属性值&#125;</code>，里面有module的元信息<code>(名字、文件路径)</code>、以及module对象里面的内容。对，说白了，同class一样，module也是一个名字空间。</strong></p>
<p><strong>另外如果此时你查看a.py所在目录的<code>__pycache__</code>目录，你会发现里面有一个a.pyc，说明Python在导入的时候先生成了pyc，然后导入了pyc。并且我们通过dir(a)查看的时候，发现里面有一个<code>__builtins__</code>符号，那么这个<code>__builtins__</code>和我们之前说的那个<code>__builtins__</code>是一样的吗？</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们之前说获取builtins可以通过import builtins的方式导入，但其实也可以通过__builtins__获取</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(__builtins__), <span class="built_in">type</span>(__builtins__))  <span class="comment"># 1745602347792 &lt;class &#x27;module&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a.__dict__[<span class="string">&quot;__builtins__&quot;</span>]), <span class="built_in">type</span>(a.__dict__[<span class="string">&quot;__builtins__&quot;</span>]))  <span class="comment"># 1745602345408 &lt;class &#x27;dict&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>尽管它们都叫<code>__builtins__</code>，但一个是module对象，一个是字典。我们通过<code>__builtins__</code>获取的是一个module对象，里面存放了int、str、globals等内建对象和内建函数等等，我们直接输入int、str、globals和通过<code>__builtins__.int</code>，<code>__builtins__.str</code>，<code>__builtins__.globals</code>的效果是一样的，我们输入<code>__builtins__</code>可以拿到这个内置模块，通过这个内置模块去获取里面的内容，当然也可以直接获取里面的内容，因为这些已经是全局的了。</strong></p>
<p><strong>但是<code>a.__dict__[&quot;__builtins__&quot;]</code>是一个字典，这就说明两个从性质上就是不同的东西，但即便如此，就真的一点关系也没有吗？</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> a</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(__builtins__.__dict__))  <span class="comment"># 2791398177216</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a.__dict__[<span class="string">&quot;__builtins__&quot;</span>]))  <span class="comment"># 2791398177216</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看到还是有一点关系的，和类、类的实例对象一样，每一个module对象也有自己的属性字典<code>__dict__</code>，记录了自身的元信息、里面存放的内容等等。对于<code>a.__dict__[&quot;__builtins__&quot;]</code>来说，拿到的就是<code>__builtins__.__dict__</code>，所以说<code>__builtins__</code>是一个模块，但是这个模块有一个<code>__dict__</code>属性字典，而这个字典是可以通过<code>module对象.__dict__[&quot;__builtins__&quot;]</code>来获取的，因为任何一个模块都可以使用<code>__builtins__</code>里面的内容，并且所有模块对应的<code>__builtins__</code>都是一样的。所以当你直接打印<code>a.__dict__</code>的时候会输出一大堆内容，因为输出的内容里面不仅有当前模块的内容，还有<code>__builtins__.__dict__</code>。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> a</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a.__dict__[<span class="string">&quot;__builtins__&quot;</span>][<span class="string">&quot;list&quot;</span>](<span class="string">&quot;abcd&quot;</span>))  <span class="comment"># [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># a.__dict__[&quot;__builtins__&quot;]就是__builtins__.__dict__这个属性字典</span></span><br><span class="line"><span class="comment"># __builtins__.list就等价于__builtins__.__dict__[&quot;list&quot;]</span></span><br><span class="line"><span class="comment"># 说白了，就是我们直接输入的list</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a.__dict__[<span class="string">&quot;__builtins__&quot;</span>][<span class="string">&quot;list&quot;</span>] <span class="keyword">is</span> <span class="built_in">list</span>)  <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 回顾之前的内容</span></span><br><span class="line"><span class="comment"># 我们说，模块名是在模块的属性字典里面</span></span><br><span class="line"><span class="built_in">print</span>(a.__dict__[<span class="string">&quot;__name__&quot;</span>] == a.__name__ == <span class="string">&quot;a&quot;</span>)  <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># __builtins__里面的__name__就是builtins</span></span><br><span class="line"><span class="built_in">print</span>(__builtins__.__dict__[<span class="string">&quot;__name__&quot;</span>])  <span class="comment"># builtins</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 还记得如何获取当前文件的文件名吗</span></span><br><span class="line"><span class="built_in">print</span>(__name__)   <span class="comment"># __main__</span></span><br><span class="line"><span class="comment"># 咦，可能有人说，这不是从__builtins__里面获取的吗？</span></span><br><span class="line"><span class="comment"># 我们之前说了，__name__已经被设置到local名字空间了</span></span><br><span class="line"><span class="comment"># 所以这个__name__是从local里面拿的，尽管我们没有设置，但是它确确实实在里面</span></span><br><span class="line"><span class="comment"># 而且local里面有的话，就不会再去找__builtins__</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>所以可以把模块的属性字典，看成是local空间、内置空间的组合。</strong></p>
</blockquote>
<h4 id="嵌套import"><a href="#嵌套import" class="headerlink" title="嵌套import"></a>嵌套import</h4><p><strong>我们下面来看一下import的嵌套，所谓import的嵌套就是指，假设我import a，但是在a中又import b，我们来看看这个时候会发生什么有趣的动作。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># a.py</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> a</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">  1           0 LOAD_CONST               0 (0)</span></span><br><span class="line"><span class="string">              2 LOAD_CONST               1 (None)</span></span><br><span class="line"><span class="string">              4 IMPORT_NAME              0 (a)</span></span><br><span class="line"><span class="string">              6 STORE_NAME               0 (a)</span></span><br><span class="line"><span class="string">              8 LOAD_CONST               1 (None)</span></span><br><span class="line"><span class="string">             10 RETURN_VALUE</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>在a.py中导入sys，在另一个模块导入a，打印字节码指令，我们只看到了<code>IMPORT_NAME 0 (a)</code>，似乎并没有看到a模块中的动作。我们说了，使用dis模块查看的字节码是分层级的，只能看到import a这个动作，a里面做了什么是看不到的。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> a</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a.sys <span class="keyword">is</span> sys <span class="keyword">is</span> sys.modules[<span class="string">&quot;sys&quot;</span>] <span class="keyword">is</span> a.__dict__[<span class="string">&quot;sys&quot;</span>] <span class="keyword">is</span> a.sys)  <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<p><strong>首先我们import  a，那么a模块就在当前模块的属性字典里面了，我们通过a这个符号是可以直接拿到其对应的模块的。但是在a中我们又import  sys，那么这个sys模块就已经在a模块对应的属性字典里面了，也就是说，我们这里通过a.sys是可以直接拿到sys模块的。但是，我们第二次导入sys的时候，会怎么样呢？首先我们在a中已经导入了sys，那么sys这个模块就已经在sys.modules里面了。那么当我们再导入sys的时候，就直接从sys.modules里面去找了，因此不会二次加载。为了更直观的验证，我们再举一个例子：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># a.py</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">123</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># b.py</span></span><br><span class="line"><span class="keyword">import</span> a</span><br><span class="line"></span><br><span class="line"><span class="comment"># c.py</span></span><br><span class="line"><span class="keyword">import</span> a</span><br></pre></td></tr></table></figure>

<p><strong>以上是三个文件，每个文件只有一行代码：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> a</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">123</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> b</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">123</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> a</span><br><span class="line"><span class="keyword">import</span> b</span><br><span class="line"><span class="keyword">import</span> c</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">123</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>当导入一个不在sys.modules的模块时，会先从硬盘中加载相应的文件，然后逐行解释执行里面的内容，构建PyModuleObject对象，加入到sys.modules里面。当第二次导入的时候，直接将符号暴露在当前的local空间中，就不会再执行里面的内容了。</strong></p>
<p><strong>所以我们可以把sys.modules看成是一个大仓库，任何导入了的模块都在这里面。如果再导入的话，在sys.modules里面找到了，就直接返回即可，这样可以避免重复加载。</strong></p>
<h4 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h4><p><strong>我们写的多个逻辑或者功能上相关的函数、类可以放在一个模块里面，那么多个模块是不是也可以组成一个包呢？如果说模块是管理class、函数、一些变量的机制，那么包就是管理模块的机制，当然啦，多个小的包又可以聚合成一个较大的包。</strong></p>
<p><strong>因此在Python中，模块是由一个单独的文件来实现的，可以是py文件、或者二进制文件。而对于包来说，则是一个目录，里面容纳了模块对应的文件，这种方式就是把多个模块聚合成一个包的具体实现。</strong></p>
<p><strong>现在我有一个名为test_import的模块，里面有一个a.py：</strong></p>
<p><img src="/2023/04/20/23-%E5%89%96%E6%9E%90Python%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97%E5%AF%BC%E5%85%A5%E6%9C%BA%E5%88%B6%E3%80%81Python%E6%98%AF%E5%A6%82%E4%BD%95%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9D%97%E7%9A%84/1229382-20200906062927709-338402810.png" alt="img"></p>
<p><strong>a.py内容如下</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">123</span></span><br><span class="line">b = <span class="number">456</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&gt;&gt;&gt;&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>现在我们来导入它</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> test_import</span><br><span class="line"><span class="built_in">print</span>(test_import)  <span class="comment"># &lt;module &#x27;test_import&#x27; (namespace)&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>在Python2中，这样是没办法导入的，因为如果一个目录要成为Python中的包，那么里面必须要有一个<code>__init__</code>文件，但是在Python3中没有此要求。而且我们发现print之后，显示的也是一个module对象，因此Python对于模块和包的底层定义其实是很灵活的，并没有那么僵硬。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> test_import</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(test_import.a)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">AttributeError: module &#x27;test_import&#x27; has no attribute &#x27;a&#x27;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>然而此时神奇的地方出现了，我们调用test_import.a的时候，告诉我们没有a这个属性。很奇怪，我们的test_import里面不是有a.py吗？首先python导入一个包，会先执行这个包的<code>__init__</code>文件，只有在<code>__init___</code>文件中导入了，我们才可以通过包名来调用。如果这个包里面没有<code>__init__</code>文件，那么你导入这个包，是什么属性也用不了的。光说可能比较难理解，我们来演示一下。我们先来创建<code>__init__</code>文件，但是里面什么也不写。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> test_import</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(test_import)  <span class="comment"># &lt;module &#x27;test_import&#x27; from &#x27;D:\\satori\\test_import\\__init__.py&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>此时我们又看到了神奇的地方，我们在test_import目录里面创建了<code>__init__</code>文件之后，再打印test_import，得到结果又变了，告诉我们这个包来自于该包里面的<code>__init__</code>文件。所以就像我们之前说的，Python对于包和模块的概念区分的不是很明显，我们把包就当做该包下面的<code>__init__</code>文件即可，这个<code>__init__</code>中定义了什么，那么这个包里面就有什么。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># test_import/__init__.py</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> a</span><br><span class="line">name = <span class="string">&quot;satori&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong><code>from . import a</code>这句话表示导入test_import这个下面的a.py，但是直接像import sys那样import a不行吗？答案是不行的，至于为什么我们后面说。我们在<code>__init__.py</code>中导入了sys模块、a模块，定义了name属性，那么就等于将sys、a、name加入到了test_import这个包的local空间里面去了。因为我们说过，对于Python中的包，那么其等价于里面的<code>__init__</code>文件，这个文件有什么，那么这个包就有什么。既然我们在<code>__init__.py</code>中导入了sys、a模块，定义了name，那么这个文件的属性字典里面、或者也可以说local空间里面就有了<code>&quot;sys&quot;: sys, &quot;a&quot;: a, &quot;name&quot;: &quot;satori&quot;</code>这三个entry，而我们又说了<code>__init__.py</code>里面有什么，那么通过包名就能够调用什么。所以：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> test_import</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(test_import.a)</span><br><span class="line"><span class="built_in">print</span>(test_import.a.a)</span><br><span class="line"><span class="built_in">print</span>(test_import.sys)</span><br><span class="line"><span class="built_in">print</span>(test_import.name)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&gt;&gt;&gt;</span></span><br><span class="line"><span class="string">&lt;module &#x27;test_import.a&#x27; from &#x27;D:\\satori\\test_import\\a.py&#x27;&gt;</span></span><br><span class="line"><span class="string">123</span></span><br><span class="line"><span class="string">&lt;module &#x27;sys&#x27; (built-in)&gt;</span></span><br><span class="line"><span class="string">satori</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 首先在a里面有一个print(&quot;&gt;&gt;&gt;&quot;)</span></span><br><span class="line"><span class="comment"># 而我们说初次导入一个模块，就相当于把这个模块里面的内容拿过来执行一遍；初次导入一个包则是把这个包里面的__init__.py拿过来执行一遍</span></span><br><span class="line"><span class="comment"># 那么在__init__里面导入a的时候，就会打印这个print</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 另外此时如果我再单独导入test_import里面的a模块的话，会怎么样呢？</span></span><br><span class="line"><span class="comment"># 下面这两种导入方式后面会介绍</span></span><br><span class="line"><span class="keyword">import</span> test_import.a</span><br><span class="line"><span class="keyword">from</span> test_import <span class="keyword">import</span> a</span><br><span class="line"><span class="comment"># 我们看到a里面的print没有被打印，证明确实模块、包不管以怎样的方式被导入，只要被导入一次，那么对应的文件只会被加载一遍</span></span><br><span class="line"><span class="comment"># 第二次导入只是将符号加入到了当前的名字空间中</span></span><br></pre></td></tr></table></figure>

<h5 id="相对导入与绝对导入"><a href="#相对导入与绝对导入" class="headerlink" title="相对导入与绝对导入"></a>相对导入与绝对导入</h5><p><strong>我们刚才使用了一个<code>from . import a</code>的方式，这个<code>.</code>表示当前文件所在的目录，这行代码就表示，我要导入a这个模块，不是从别的地方导入，而是从该文件所在的目录里面导入。如果是<code>..</code>就表示该目录的上一层目录，三个<code>.</code>、四个<code>.</code>依次类推。我们知道a模块里面还有一个a这个变量，那如果我想在<code>__init__.py</code>中导入这个变量该怎么办呢？直接<code>from .a import a</code>即可，表示导入当前目录里面的a模块里面的a变量。如果我们导入的时候没有<code>.</code>的话，那么表示绝对导入，Python虚拟机就会按照sys.path定义的路径去找。假设我们在<code>__init__.py</code>当中写的是不是<code>from . import a</code>，而是<code>import a</code>，那么会发生什么后果呢？</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> test_import</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    import a</span></span><br><span class="line"><span class="string">ModuleNotFoundError: No module named &#x27;a&#x27;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>我们发现报错了，告诉我们没有a这个模块，可是我们明明在module包里面定义了呀。还记得之前说的导入一个模块、导入一个包会做哪些事情吗？导入一个模块，会将该模块里面”拿过来”执行一遍，导入包会将该包里面的<code>__init__.py</code>文件”拿过来”执行一遍。注意：我们把”拿过来”三个字加上了引号。</strong></p>
<p><strong>我们在test_import同级目录的py文件中导入了test_import，那么就相当于把里面的__init__拿过来执行一遍<code>(当然只有第一次导入的时候才会这么做)</code>，然后它们具有单独的空间，是被隔离的，调用需要使用符号test_import来调用。但是正如我们之前所说，是”拿过来”执行，所以这个<code>__init__.py</code>里面的内容是”拿过来”，在当前的py文件<code>(在哪里导入的就是哪里)</code>中执行的。所以由于import a这行代码表示绝对导入，就相当于在当前模块里面导入，会从sys.path里面搜索，但是a是在test_import包里面，那么此时还能找到这个a吗？显然是不能的。那<code>from . import a</code>为什么就好使呢？因为这种导入表示相对导入，就表示要在<code>__init__.py</code>所在目录里面找，那么不管在什么地方导入这个包，由于这个<code>__init__.py</code>的位置是不变的，所以<code>from . import a</code>这种相对导入的方式总能找到对应的a。至于标准库、第三方模块、第三方包，因为它是在sys.path里面的，在哪儿都能找得到，所以可以绝对导入，貌似也只能绝对导入。并且我们知道每一个模块都有一个<code>__file__</code>属性<code>(除了内嵌在解释器里面的模块)</code>，当然包也是。如果你在一个模块里面<code>print(__file__)</code>，那么不管你在哪里导入这个模块，打印的永远是这个模块的路径；包的话，则是指向内部的<code>__init__.py</code>文件。</strong></p>
<p><strong>另外关于相对导入，一个很重要的一点，一旦一个模块出现了相对导入，那么这个模块就不能被执行了，它只可以被导入。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> a</span><br><span class="line">name = <span class="string">&quot;satori&quot;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    from . import a</span></span><br><span class="line"><span class="string">ImportError: attempted relative import with no known parent package</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>此时如果我试图执行<code>__init__.py</code>，那么就会给我报出这个错误。另外即便导入一个内部具有”相对导入”的模块，那么此模块和导入的模块也不能在同一个包内，我们要执行的当前模块至少要在导入模块的上一级，否则执行的当前模块也会报出这种错误。为什么会有这种情况，很简单。想想为什么会有相对导入，就是希望这些模块在被其它地方导入的时候能够准确记住要导入的包的位置。那么这些模块肯定要在一个共同的包里面，然后我们在包外面使用。所以我们导入一个具有相对导入的模块时候，那么我们当前模块和要导入的模块绝对不能在同一个包里面。</strong></p>
<h5 id="import的另一种方式"><a href="#import的另一种方式" class="headerlink" title="import的另一种方式"></a>import的另一种方式</h5><p><strong>我们要导入test_import包里面的a模块，除了可以import test_import<code>(_init__.py里面导入了a)</code>，还可以通过<code>import test_import.a</code>的方式，另外如果是这种导入方式，那么module里面可以没有<code>__init__.py</code>文件，因为我们导入test_import包的时候，是通过test_import来获取a，所以必须要有<code>__init__.py</code>文件、并且里面导入a。但是在导入test_import.a的时候，就是找test_import.a，所以此时是可以没有<code>__init__.py</code>文件的。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># test_import/__init__.py</span></span><br><span class="line">__version__ = <span class="string">&quot;1.0&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># test_import/a.py</span></span><br><span class="line">name = <span class="string">&quot;夏色祭&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;xxx&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>此时test_import包里面的<code>__init__.py</code>只定义了一个变量，下面我们来通过test_import.a的形式导入。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> test_import.a</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(test_import.a.name) </span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">xxx</span></span><br><span class="line"><span class="string">夏色祭</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当import test_import.a的时候，会执行里面的print</span></span><br><span class="line"><span class="comment"># 然后可以通过test_import.a获取a.py里面的属性，这很好理解</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 但是，没错，我要说但是了</span></span><br><span class="line"><span class="built_in">print</span>(test_import.__version__)  <span class="comment"># 1.0</span></span><br></pre></td></tr></table></figure>

<p><strong>惊了，我们在导入test_import.a的时候，也把test_import导入进来了，为了更直观的看到现象，我们在<code>__init__.py</code>里面打印一句话。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># test_import/__init__.py</span></span><br><span class="line">__version__ = <span class="string">&quot;1.0&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;我是test_import下面的__init__&quot;</span>)</span><br><span class="line"><span class="keyword">import</span> test_import.a</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">我是test_import下面的__init__</span></span><br><span class="line"><span class="string">xxx</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>所以一个有趣的现象就产生了，我们是导入test_import.a，但是把test_import也导入进来了。而且通过打印的顺序，我们看到是先导入了test_import，然后再导入test_import下面的a。如果我们在<code>__init__.py</code>中也导入了a会怎么样？</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># test_import/__init__.py</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;我是test_import下面的__init__&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> a</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># test_import/a.py</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;我是test_import下面的a&quot;</span>)</span><br><span class="line"><span class="keyword">import</span> test_import.a</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">我是test_import下面的__init__</span></span><br><span class="line"><span class="string">我是test_import下面的a</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 我们看到a.py里面的内容只被打印了一次，说明没有进行二次加载</span></span><br><span class="line"><span class="comment"># 在__init__.py中将a导进来之后，就加入到sys.modules里面了</span></span><br></pre></td></tr></table></figure>

<p><strong>所以通过<code>test_import.a</code>的方式来导入，即使没有<code>__init__.py</code>文件依旧是可以访问的，因为这是我在import的时候指定的。我们可以看一下sys.modules</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> test_import.a</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(sys.modules[<span class="string">&quot;test_import&quot;</span>])</span><br><span class="line"><span class="built_in">print</span>(sys.modules[<span class="string">&quot;test_import.a&quot;</span>])</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">我是test_import下面的__init__</span></span><br><span class="line"><span class="string">我是test_import下面的a</span></span><br><span class="line"><span class="string">&lt;module &#x27;test_import&#x27; from &#x27;D:\\satori\\test_import\\__init__.py&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;module &#x27;test_import.a&#x27; from &#x27;D:\\satori\\test_import\\a.py&#x27;&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>不过问题来了，为什么在导入test_import.a的时候，会将test_import也导入了进来呢？并且还可以直接使用test_import，毕竟这不是我们期望的结果，因为导入test_import.a的话，那么我们只是想使用test_import.a，不打算使用test_import，那么Python为什么要这么做呢？</strong></p>
<blockquote>
<p><strong>事实上，这对Python而言是必须的，根据我们对Python虚拟机的执行原理的了解，Python要想执行test_import.a，那么肯定要先从local空间找到test_import，然后才能找到a，如果不找到test_import的话，那么对a的查找也就无从谈起。可问题是sys.modules里面是<code>test_import.a</code>啊，这是一个整体啊。事实上尽管是一个整体，但并不是说有一个模块，这个模块就叫做test_import.a。准确的说import  test_import.a表示先导入test_import，然后再将test_import下面的a加入到test_import的属性字典里面。我们说当module这个包里面没有<code>__init__.py</code>的时候，那个这个包是无法使用的，因为属性字典里面没有相关属性，但是当我们import test_import.a的时候，Python会先导入test_import这个包，然后自动帮我们把a这个模块加入到module这个包的属性字典里面。</strong></p>
<p><strong>但之所以会有”test_import.a”这个key，显然也是为了解决重复导入的问题。</strong></p>
</blockquote>
<p><strong>假设test_import这个包里面有a和b两个py文件，那么我们执行<code>import test_import.a</code>和<code>import test_import.b</code>会进行什么样的动作应该就了如指掌了吧。执行<code>import test_import.a</code>，那么会先导入test_import，然后把a加到test_import的属性字典里面，执行<code>import test_import.b</code>，还是会先导入包test_import，但是包test_import在上一步已经被导入了，所以此时直接会从sys.modules里面获取，然后再把b加入到test_import的属性字典里面。所以如果<code>__init__.py</code>里面有一个print的话，那么两次导入显然只会print一次，这种现象是由Python对包中的模块的动态加载机制决定的。还是那句话，一个包你就看成是里面的<code>__init__.py</code>文件即可，Python对于包和模块的区分不是特别明显。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># test_import目录下有__init__.py文件</span></span><br><span class="line"><span class="keyword">import</span> test_import</span><br><span class="line"><span class="built_in">print</span>(test_import.__file__)  <span class="comment"># D:\satori\test_import\__init__.py</span></span><br><span class="line"><span class="built_in">print</span>(test_import)  <span class="comment"># &lt;module &#x27;test_import&#x27; from &#x27;D:\\satori\\test_import\\__init__.py&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># test_import目录下没有__init__.py文件</span></span><br><span class="line"><span class="keyword">import</span> test_import</span><br><span class="line"><span class="built_in">print</span>(test_import.__file__)  <span class="comment"># None</span></span><br><span class="line"><span class="built_in">print</span>(test_import)  <span class="comment"># &lt;module &#x27;test_import&#x27; (namespace)&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看到如果包里面有<code>__init__.py</code>文件，那么这个包的<code>__file__</code>属性就是其内部的<code>__init__.py</code>文件，打印这个包，显示的也是其内部的<code>__init__.py</code>模块。如果没有<code>__init__.py</code>文件，那么这个包的<code>__file__</code>就是一个None，打印这个包，显示其是一个名字空间。另外，我们知道任何一个模块<code>(即使里面什么也不写)</code>的属性字典里面都是有<code>__builtins__</code>属性的，因为可以直接使用内置的对象、函数等等。而<code>__init__.py</code>也是属于一个模块，所以它也有<code>__builtins__</code>属性的，由于一个包指向了内部的<code>__init__.py</code>，所以这个包的属性字典也是有<code>__builtins__</code>属性的。但如果这个包没有<code>__init__.py</code>文件，那么这个包是没有<code>__builtins__</code>属性的。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 没有__init__.py文件</span></span><br><span class="line"><span class="keyword">import</span> test_import</span><br><span class="line"><span class="built_in">print</span>(test_import.__dict__.get(<span class="string">&quot;__builtins__&quot;</span>))  <span class="comment"># None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 有__init__.py文件</span></span><br><span class="line"><span class="keyword">import</span> test_import</span><br><span class="line"><span class="built_in">print</span>(test_import.__dict__.get(<span class="string">&quot;__builtins__&quot;</span>)[<span class="string">&quot;int&quot;</span>])  <span class="comment"># &lt;class &#x27;int&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="路径搜索树"><a href="#路径搜索树" class="headerlink" title="路径搜索树"></a>路径搜索树</h5><p><strong>假设我有这样的一个目录结构：</strong></p>
<p><img src="/2023/04/20/23-%E5%89%96%E6%9E%90Python%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97%E5%AF%BC%E5%85%A5%E6%9C%BA%E5%88%B6%E3%80%81Python%E6%98%AF%E5%A6%82%E4%BD%95%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9D%97%E7%9A%84/1229382-20200906062935691-954690708.png" alt="img"></p>
<p><strong>那么Python会将这个结构进行分解，得到一个类似于树状的节点集合：</strong></p>
<p><img src="/2023/04/20/23-%E5%89%96%E6%9E%90Python%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97%E5%AF%BC%E5%85%A5%E6%9C%BA%E5%88%B6%E3%80%81Python%E6%98%AF%E5%A6%82%E4%BD%95%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9D%97%E7%9A%84/1229382-20200906062939957-3975499.png" alt="img"></p>
<p><strong>然后从左到右依次去sys.modules中查找每一个符号所对应的module对象是否已经被加载，如果一个包被加载了，比如说包test_import被加载了，那么在包test_import对应的PyModuleObject中会维护一个元信息<code>__path__</code>，表示这个包的路径。比如我搜索A.a，当加载进来A的时候，那么a只会在<code>A.__path__</code>中进行，而不会在Python的所有搜索路径中执行了。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> test_import</span><br><span class="line"><span class="built_in">print</span>(test_import.__path__)  <span class="comment"># [&#x27;D:\\satori\\test_import&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入sys模块</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">import</span> test_import.sys</span><br><span class="line"><span class="keyword">except</span> ImportError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># No module named &#x27;test_import.sys&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显然这样是错的，因为导入test_import.sys，那么就将搜索范围只限定在test_import的__path__下面了</span></span><br></pre></td></tr></table></figure>

<h4 id="from与import"><a href="#from与import" class="headerlink" title="from与import"></a>from与import</h4><p><strong>在Python的import中，有一种精确控制所加载的对象的方法，通过from和import的结合，可以只将我们期望的module对象、甚至是module对象中的某个符号，动态地加载到内存中。这种机制使得Python虚拟机在当前名字空间中引入的符号可以尽可能地少，从而更好地避免名字空间遭到污染。</strong></p>
<p><strong>按照我们之前所说，导入test_import下面的a模块，我们可以使用<code>import test_import.a</code>的方式，但是此时a是在test_import的名字空间中，不是在我们当前模块的名字空间中。也就是说我们希望能直接通过符号a来调用，而不是test_import.a，此时通过<code>from ... import ...</code>联手就能完美解决。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> test_import <span class="keyword">import</span> a</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">print</span>(sys.modules.get(<span class="string">&quot;test_import&quot;</span>) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>)  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(sys.modules.get(<span class="string">&quot;test_import.a&quot;</span>) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>)  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(sys.modules.get(<span class="string">&quot;a&quot;</span>) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>)  <span class="comment"># False</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看到，确确实实将a这个符号加载到当前的名字空间里面了，但是在sys.modules里面却没有a。还是之前说的，a这个模块是在test_import这个包里面的，你不可能不通过包就直接拿到包里面的模块，因此在sys.modules里面的形式其实还是test_import.a这样形式，只不过在当前模块的名字空间中是a，a被映射到sys.modules[“test_import.a”]，另外我们看到除了test_import.a，test_import也导入进来了，这个原因我们之前也说过了，不再赘述。所以我们发现即便我们是<code>from ... import ...</code>，还是会触发整个包的导入。只不过我们导入谁<code>(假设从a导入b)</code>，就把谁加入到了当前模块的名字空间里面<code>(但是在sys.modules里面是没有b的，而是a.b)</code>，并映射到sys.modules[“a.b”]。</strong></p>
<p><strong>所以我们见识到了，即便是我们通过from test_import import a，还是会导入test_import这个包的，只不过test_import这个包是在sys.modules里面，并没有暴露到local空间中。</strong></p>
<p><strong>此外我们<code>from test_import import a</code>，导入的这个a是一个模块，但是模块a里面还有一个变量a，我们不加from，只通过import的话，那么最深也只能import到一个模块，不可能说直接import模块里面的某个变量、方法什么的。但是<code>from ... import ...</code>的话，却是可以的，比如我们<code>from test_import.a import a</code>，这句就表示我要导入test_import.a模块里面变量a。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> test_import.a <span class="keyword">import</span> a</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">modules = sys.modules</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a&quot;</span> <span class="keyword">in</span> modules)  <span class="comment"># False</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;test_import.a&quot;</span> <span class="keyword">in</span> modules)  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;test_import&quot;</span> <span class="keyword">in</span> modules)  <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<p><strong>我们导入的a是一个变量，并不是模块，所以sys.modules里面不会出现test_import.a.a这样的东西存在，但是这个a毕竟是从test_import.a里面导入的，所以test_import.a是会在sys.modules里面的，同理test_import.a表示从test_import的属性字典里面找a，所以test_import也是会进入sys.modules里面的。</strong></p>
<blockquote>
<p><strong>最后还可以使用from test_import.a import  *，这样的机制把一个模块里面所有的内容全部导入进来，本质和导入一个变量是一致的。但是在Python中有一个特殊的机制，比如我们from  test_import.a import *，如果a里面定义了__all__，那么只会导入__all__里面指定的属性。</strong></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># test_import/a.py</span></span><br><span class="line">a = <span class="number">123</span></span><br><span class="line">b = <span class="number">456</span></span><br><span class="line">c = <span class="number">789</span></span><br><span class="line">__all__ = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>]</span><br></pre></td></tr></table></figure>

<p><strong>我们注意到在<code>__all__</code>里面只指定了a和b，那么后续通过<code>from test_import.a import \*</code>的时候，只会导入a和b，而不会导入c。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> test_import.a <span class="keyword">import</span> *</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a&quot;</span> <span class="keyword">in</span> <span class="built_in">locals</span>() <span class="keyword">and</span> <span class="string">&quot;b&quot;</span> <span class="keyword">in</span> <span class="built_in">locals</span>())  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c&quot;</span> <span class="keyword">in</span> <span class="built_in">locals</span>())  <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> test_import.a <span class="keyword">import</span> c</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c&quot;</span> <span class="keyword">in</span> <span class="built_in">locals</span>())  <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<p><strong>我们注意到：通过<code>from ... import \*</code>导入的时候，是无法导入c的，因为c没有在<code>__all__</code>中。但是即便如此，我们也可以通过单独导入，把c导入进来。只是不推荐这么做，像pycharm这种智能编辑器也会提示：<code>&#39;c&#39; is not declared in __all__</code>。因为既然没有在<code>__all__</code>里面，就证明这个变量是不希望被导入的，但是一般导入了也没关系。</strong></p>
<h4 id="符号重命名"><a href="#符号重命名" class="headerlink" title="符号重命名"></a>符号重命名</h4><p><strong>我们导入的时候一般为了解决符号冲突，往往会起别名，或者说符号重命名。比如包a和包b下面都有一个模块叫做m，如果是<code>from a import m</code>和<code>from b import m</code>的话，那么两者就冲突了，后面的m会把上面的m覆盖掉，不然Python怎么知道要找哪一个m。所以这个时候我们会起别名，比如<code>from a import m as m1</code>、<code>from b import m as m2</code>，但是<code>from a import \*</code>是不支持as的。所以直接Python都是将module对象内部所以符号都暴露给了local名字空间，而符号重命名则是Python可以通过as关键字控制包、模块、变量暴露给local名字空间的方式。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> test_import.a <span class="keyword">as</span> a</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># &lt;module &#x27;test_import.a&#x27; from &#x27;D:\\satori\\test_import\\a.py&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;test_import.a&quot;</span> <span class="keyword">in</span> sys.modules)  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;test_import&quot;</span> <span class="keyword">in</span> sys.modules)  <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;test_import&quot;</span> <span class="keyword">in</span> <span class="built_in">locals</span>())  <span class="comment"># False</span></span><br></pre></td></tr></table></figure>

<p><strong>到结论我相信就应该心里有数了，不管我们有没有as，既然<code>import test_import.a</code>，那么sys.modules里面就一定有test_import.a，和test_import。其实理论上有包test_import就够了，但是我们说a是一个模块，为了避免多次导入所以也要加到sys.modules里面，而且a又是test_import包里面，所以是test_import.a。而我们这里<code>as a</code>，那么a这个符号就暴露在了当前模块的local空间里面，而且这个a就跟之前的test_import.a一样，指向了test_import包下面的a模块，无非是名字不同罢了。当然这不是重点，我们之前通过<code>import test_import.a</code>的时候，会自动把test_import也加入到当前模块的local空间里面，也就是说通过<code>import test_import.a</code>是可以直接使用test_import的，但是当我们加上了as之后，发现test_import包已经不能访问了。尽管都在sys.modules里面，但是对于加了as来说，此时的test_import这个包已经不在local名字空间里面了。一个as关键字，导致了两者的不同，这是什么原因呢？我们后面分解。</strong></p>
<h4 id="符号的销毁与重载"><a href="#符号的销毁与重载" class="headerlink" title="符号的销毁与重载"></a>符号的销毁与重载</h4><p><strong>为了使用一个模块，无论是内置的还是自己写的，都需要import动态加载到内存，使用之后，我们也可能会删除，删除的原因一般是释放内存啊等等。在python中，删除一个对象可以使用del关键字，遇事不决del。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">d = &#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>, <span class="string">&quot;b&quot;</span>: <span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> l[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">del</span> d[<span class="string">&quot;a&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(l)  <span class="comment"># [2, 3]</span></span><br><span class="line"><span class="built_in">print</span>(d)  <span class="comment"># &#123;&#x27;b&#x27;: 2&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;foo&quot;</span> <span class="keyword">in</span> <span class="built_in">dir</span>(A))  <span class="comment"># True</span></span><br><span class="line"><span class="keyword">del</span> A.foo</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;foo&quot;</span> <span class="keyword">in</span> <span class="built_in">dir</span>(A))  <span class="comment"># False</span></span><br></pre></td></tr></table></figure>

<p><strong>不光是列表、字典，好多东西del都能删除，甚至是删除某一个位置的值、或者方法。我们看到类的一个方法居然也能使用del删除，但是对于module对象来说，del能做到吗？显然是可以做到的，或者更准确的说法是<code>符号的销毁</code>和<code>符号关联的对象的销毁</code>是一个概念吗？Python已经向我们隐藏了太多的动作，也采取了太多的缓存策略，当然对于Python的使用者来说是好事情，因为把复杂的特性隐藏起来了，但是当我们想彻底的了解Python的行为时，则必须要把这些隐藏的东西挖掘出来。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> test_import.a <span class="keyword">as</span> a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于模块来说，dir()和locals()、globals()的keys是一致的</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a&quot;</span> <span class="keyword">in</span> <span class="built_in">dir</span>())  <span class="comment"># True</span></span><br><span class="line"><span class="keyword">del</span> a</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a&quot;</span> <span class="keyword">in</span> <span class="built_in">locals</span>())  <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(sys.modules[<span class="string">&quot;test_import.a&quot;</span>]))  <span class="comment"># 1576944838432</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> test_import.a <span class="keyword">as</span> 我不叫a了</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(我不叫a了))  <span class="comment"># 1576944838432</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看到在del之后，a这个符号确实从local空间消失了，或者说dir已经看不到了。但是后面我们发现，消失的仅仅是a这个符号，至于test_import.a指向的PyModuleObject依旧在sys.modules里面岿然不动。然而，尽管它还存在于Python系统中，但是我们的程序再也无法感知到，但它就在那里不离不弃。所以此时Python就成功地向我们隐藏了这一切，我们的程序认为：test_import.a已经不存在了。</strong></p>
<p><strong>不过为什么Python要采用这种看上去类似<code>模块池</code>的缓存机制呢？因为组成一个完整系统的多个py文件可能都要对某个module对象进行import动作。所以要是从sys.modules里面删除了，那么就意味着需要重新从文件里面读取，如果不删除，那么只需要从sys.modules里面暴露给当前的local名字空间即可。所以import实际上并不等同我们所说的动态加载，它的真实含义是希望某个模块被感知，也就是”将这个模块以某个符号的形式引入到某个名字空间”。这些都是同一个模块，如果import等同于动态加载，那么Python对同一个模块执行多次动态加载，并且内存中保存一个模块的多个镜像，这显然是非常愚蠢的。</strong></p>
<p><strong>所以Python引入了全局的module对象集合–sys.modules，这个集合作为<code>模块池</code>，保存了模块的唯一值。当某个模块通过import声明希望感知到某个module对象时，Python将在这个池子里面查找，如果被导入的模块已经存在于池子中，那么就引入一个符号到当前模块的名字空间中，并将其关联到导入的模块，使得被导入的模块可以透过这个符号被当前模块感知到。而如果被导入的模块不在池子里，Python这才执行动态加载的动作。</strong></p>
<p><strong>如果这样的话，难道一个模块在被加载之后，就不能改变了。假如在加载了模块a的时候，如果我们修改了模块a，难道Python程序只能先暂停再重启吗？显然不是这样的，python的动态特性不止于此，它提供了一种重新加载的机制，使用importlib模块，通过importlib.reload(module),可以实现重新加载并且这个函数是有返回值的，返回加载之后的模块。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.path.append(<span class="string">r&quot;D:\satori&quot;</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> test_import <span class="keyword">import</span> a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.name  <span class="comment"># 不存在name属性</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AttributeError: module <span class="string">&#x27;test_import.a&#x27;</span> has no attribute <span class="string">&#x27;name&#x27;</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> importlib</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = importlib.reload(a)  <span class="comment"># 增加一个赋值语句 name = &quot;夏色祭&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.name</span><br><span class="line"><span class="string">&#x27;夏色祭&#x27;</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = importlib.reload(a)  <span class="comment"># 将 name = &quot;夏色祭&quot; 语句删除</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.name</span><br><span class="line"><span class="string">&#x27;夏色祭&#x27;</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>首先我们的a模块里面啥也没有，但是我们在a.py里面增加了name变量，然后重新加载模块，所以a.name正确打印。然后我们在a.py再删除name属性，然后重新加载，但是我们看到name变量还在里面，还可以被调用。</strong></p>
<p><strong>那么根据这个现象我们是不是可以大胆猜测，python在reload一个模块的时候，只是将模块里面新的符号加载进来，而删除的则不管了，那么这个猜测到底正不正确呢，别急我们下面就来揭晓，并通过源码来剖析import的实现机制。</strong></p>
<h3 id="import机制的实现"><a href="#import机制的实现" class="headerlink" title="import机制的实现"></a>import机制的实现</h3><p><strong>从前面的黑盒探测我们已经对import机制有了一个非常清晰的认识，python的import机制基本上可以切分为三个不同的功能。</strong></p>
<ul>
<li><code>python运行时的全局模块池的维护和搜索</code></li>
<li><code>解析与搜索模块路径的树状结构</code></li>
<li><code>对不同文件格式的模块的动态加载机制</code></li>
</ul>
<p><strong>尽管import的表现形式千变万化，但是都可以归结为：<code>import x.y.z</code>的形式。因为<code>import sys</code>也可以看成是<code>x.y.z</code>的一种特殊形式。而诸如from、as与import的结合，实际上同样会进行<code>import x.y.z</code>的动作，只是最后在当前名字空间中引入符号时各有不同。所以我们就以<code>import x.y.z</code>的形式来进行分析。</strong></p>
<p><strong>我们说导入模块，是调用<code>__import__</code>，那么我们就来看看这个函数长什么样子。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">builtin___import__</span><span class="params">(PyObject *self, PyObject *args, PyObject *kwds)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> *kwlist[] = &#123;<span class="string">&quot;name&quot;</span>, <span class="string">&quot;globals&quot;</span>, <span class="string">&quot;locals&quot;</span>, <span class="string">&quot;fromlist&quot;</span>,</span><br><span class="line">                             <span class="string">&quot;level&quot;</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">//初始化globals、fromlist都为NULL</span></span><br><span class="line">    PyObject *name, *globals = <span class="literal">NULL</span>, *locals = <span class="literal">NULL</span>, *fromlist = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> level = <span class="number">0</span>;<span class="comment">//表示默认绝对导入</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">//从PyTupleObject中解析出需要的信息</span></span><br><span class="line">    <span class="keyword">if</span> (!PyArg_ParseTupleAndKeywords(args, kwds, <span class="string">&quot;U|OOOi:__import__&quot;</span>,</span><br><span class="line">                    kwlist, &amp;name, &amp;globals, &amp;locals, &amp;fromlist, &amp;level))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//导入模块</span></span><br><span class="line">    <span class="keyword">return</span> PyImport_ImportModuleLevelObject(name, globals, locals,</span><br><span class="line">                                            fromlist, level);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>另外，PyArg_ParseTupleAndKeywords这个函数在python中是一个被广泛使用的函数，原型如下：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Python/getargs.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">PyArg_ParseTupleAndKeywords</span><span class="params">(PyObject *, PyObject *,</span></span><br><span class="line"><span class="params">                                <span class="type">const</span> <span class="type">char</span> *, <span class="type">char</span> **, ...)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>这个函数的目的是将args和kwds中所包含的所有对象按format中指定的格式解析成各种目标对象，可以是Python中的对象<code>(PyListObject、PyLongObject等等)</code>，也可以是C的原生对象。</strong></p>
<p><strong>我们知道这个args实际上是一个PyTupleObject对象，包含了<code>__import__</code>函数运行所需要的参数和信息，它是Python虚拟机在执行IMPORT_NAME的时候打包而产生的，然而在这里，Python虚拟机进行了一个逆动作，将打包后的这个PyTupleObject拆开，重新获得当初的参数。Python在自身的实现中大量的使用了这样打包、拆包的策略，使得可变数量的对象能够很容易地在函数之间传递。</strong></p>
<p><strong>在解析参数的过程中，指定解析格式的format中可用的格式字符有很多，这里只看一下<code>__import__</code>用到的格式字符。其中s代表目标对象是一个char *，通常用来将元组中的PyUnicodeObject对象解析成char *，i则用来将元组中的PyLongObject解析成int，而O则代表解析的目标对象依然是一个Python中的合法对象，通常这表示 *PyArg_ParseTupleAndKeywords* 不进行任何的解析和转换，因为在PyTupleObject对象中存放的肯定是一个python的合法对象。至于<code>|</code>和<code>:</code>，它们不是非格式字符，而是指示字符，<code>|</code>指示其后所带的格式字符是可选的。也就是说，如果args中只有一个对象，那么<code>__import__</code>对 *PyArg_ParseTupleAndKeywords* 的调用也不会失败。其中，args中的那个对象会按照<code>s</code>的指示被解析为char *，而剩下的globals、locals、fromlist则会按照<code>O</code>的指示被初始化为Py_None，level是0。而<code>:</code>则指示”格式字符”到此结束了，其后所带字符串用于在解析过程中出错时，定位错误的位置所使用的。</strong></p>
<p><strong>在完成了对参数的拆包动作之后，然后进入了 *PyImport_ImportModuleLevelObject* ，这个我们在import_name中已经看到了，而且它也是先获取<code>__builtin__</code>里面的<code>__import__</code>函数指针。</strong></p>
<p><strong>另外每一个包和模块都有一个<code>__name__</code>和<code>__path__</code>属性</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> numpy.core</span><br><span class="line"><span class="keyword">import</span> six</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(np.__name__, np.__path__)  <span class="comment"># numpy [&#x27;C:\\python38\\lib\\site-packages\\numpy&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(np.core.__name__, np.core.__path__)  <span class="comment"># numpy.core [&#x27;C:\\python38\\lib\\site-packages\\numpy\\core&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(six.__name__, six.__path__)  <span class="comment"># six []</span></span><br></pre></td></tr></table></figure>

<p><strong><code>__name__</code>就是模块或者包名，如果包下面的包或者模块，那么就是<code>包名.包名</code>或者<code>包名.模块名</code>，至于<code>__path__</code>则是包所在的路径。但是这个和<code>__file__</code>又是不一样的，如果是<code>__file__</code>则是指向内部的<code>__init__.py</code>文件，没有则为None。但是对于模块来说，则没有<code>__path__</code>。</strong></p>
<p><strong>精力有限，具体的不再深入。我们下面从python的角度来理解一下吧</strong></p>
<h3 id="Python中的import操作"><a href="#Python中的import操作" class="headerlink" title="Python中的import操作"></a>Python中的import操作</h3><h4 id="import-模块"><a href="#import-模块" class="headerlink" title="import 模块"></a>import 模块</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys </span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">  1           0 LOAD_CONST               0 (0)</span></span><br><span class="line"><span class="string">              2 LOAD_CONST               1 (None)</span></span><br><span class="line"><span class="string">              4 IMPORT_NAME              0 (sys)</span></span><br><span class="line"><span class="string">              6 STORE_NAME               0 (sys)</span></span><br><span class="line"><span class="string">              8 LOAD_CONST               1 (None)</span></span><br><span class="line"><span class="string">             10 RETURN_VALUE</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>这是我们一开始考察的例子，现在我们已经很清楚地了解了<code>IMPORT_NAME</code>的行为，在<code>IMPORT_NAME</code>指令的最后，python虚拟机会将<code>PyModuleObject</code>对象压入到运行时栈内，随后会将<code>(sys, PyModuleObject)</code>存放到当前的local名字空间中。</strong></p>
<h4 id="import-包"><a href="#import-包" class="headerlink" title="import 包"></a>import 包</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sklearn.linear_model.ridge</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">  1           0 LOAD_CONST               0 (0)</span></span><br><span class="line"><span class="string">              2 LOAD_CONST               1 (None)</span></span><br><span class="line"><span class="string">              4 IMPORT_NAME              0 (sklearn.linear_model.ridge)</span></span><br><span class="line"><span class="string">              6 STORE_NAME               1 (sklearn)</span></span><br><span class="line"><span class="string">              8 LOAD_CONST               1 (None)</span></span><br><span class="line"><span class="string">             10 RETURN_VALUE</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>这是我们一开始考察的例子，现在我们已经很清楚地了解了<code>IMPORT_NAME</code>的行为，在<code>IMPORT_NAME</code>指令的最后，python虚拟机会将<code>PyModuleObject</code>对象压入到运行时栈内，随后会将<code>(sys, PyModuleObject)</code>存放到当前的local名字空间中。</strong></p>
<p><strong>如果涉及的是对包的import动作，那么IMPORT_NAME的指令参数则是关于包的完整路径信息，IMPORT_NAME指令的内部将解析这个路径，并为sklearn、sklearn.linear_model，sklearn.linear_model.ridge都创建一个PyModuleObject对象，这三者都存在于sys.modules里面。但是我们看到STORE_NAME是sklearn，表示只有sklearn对应的PyModuleObject放在了当前模块的local空间里面，可为什么是sklearn呢？难道不应该是sklearn.linear_model.ridge吗？其实经过我们之前的分析这一点已经不再是问题了，因为<code>import sklearn.linear_model.ridge</code>并不是说导入一个模块或包叫做sklearn.linear_model.ridge，而是先导入sklearn，然后把linear_model放在sklearn的属性字典里面，把ridge放在linear_model的属性字典里面。同理sklearn.linear_model.ridge代表的是先从local空间里面找到sklearn，再从sklearn的属性字典中找到linear_model，然后在linear_model的属性字典里面找到ridge。而我们说，linear_model和ridge已经在对应的包的属性字典里面的了，我们通过sklearn一级一级往下找是可以找到的，因此只需要把skearn返回即可，或者说返回sklearn.linear_model.ridge本身就是不合理的，因为这表示导入一个名字就叫做sklearn.linear_model.ridge的模块或者包，但显然不存在，即便我们创建了，但是由于python的语法解析规范依旧不会得到想要的结果。不然的话，假设<code>import test_import.a</code>，那Python是导入名为<code>test_import.a</code>的模块或包呢？还是导入test_import下的a呢？</strong></p>
<p><strong>也正如我们之前分析的<code>test_import.a</code>，我们<code>import test_import.a</code>的时候，会把test_import加载进来，然后把a加到test_import的属性字典里面，然后只需要把test_import返回即可，因为我们通过test_import是可以找到a，而且也不存在我们期望的<code>test_import.a</code>，因为这个<code>test_import.a</code>代表的含义是<code>从test_import的属性字典里面获取a</code>，所以<code>import test_import.a</code>是必须要返回test_import的，而且只返回了test_import。至于sys.modules<code>(一个字典)</code>里面是存在字符串名为<code>test_import.a</code>的key的，这是为了避免重复加载所采取的策略，但它依旧表示从test_import里面获取a。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas.core</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(pandas.DataFrame(&#123;<span class="string">&quot;a&quot;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&#125;))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">   a</span></span><br><span class="line"><span class="string">0  1</span></span><br><span class="line"><span class="string">1  2</span></span><br><span class="line"><span class="string">2  3</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 导入pandas.core会先执行pandas的__init__文件</span></span><br><span class="line"><span class="comment"># 所以通过pandas.DataFrame是可以调用的</span></span><br></pre></td></tr></table></figure>

<h4 id="from-amp-import"><a href="#from-amp-import" class="headerlink" title="from &amp; import"></a>from &amp; import</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> ridge</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">  1           0 LOAD_CONST               0 (0)</span></span><br><span class="line"><span class="string">              2 LOAD_CONST               1 ((&#x27;ridge&#x27;,))</span></span><br><span class="line"><span class="string">              4 IMPORT_NAME              0 (sklearn.linear_model)</span></span><br><span class="line"><span class="string">              6 IMPORT_FROM              1 (ridge)</span></span><br><span class="line"><span class="string">              8 STORE_NAME               1 (ridge)</span></span><br><span class="line"><span class="string">             10 POP_TOP</span></span><br><span class="line"><span class="string">             12 LOAD_CONST               2 (None)</span></span><br><span class="line"><span class="string">             14 RETURN_VALUE</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>注意此时的<code>LOAD_CONST 1</code>不再是None了，而是一个元组。此时Python是将ridge放到了当前模块的local空间中，并且sklearn、sklearn.linear_model都被导入了，并且存在于sys.modules里面，但是sklearn却并不在当前local空间中，尽管这个对象被创建了，但是它被Python隐藏了。IMPORT_NAME是sklearn.linear_model，也表示导入sklearn，然后把sklearn下面的linear_model加入到sklearn的属性字典里面。其实sklearn没在local空间里面，还可以这样理解。只有import的时候，那么我们必须从头开始一级一级向下调用，所以顶层的包必须加入到local空间里面，但是<code>from sklearn.linear_model import ridge</code>是把ridge导出，此时ridge已经指向了<code>sklearn</code>下面的<code>linear_model</code>下面的<code>ridge</code>，那么此时就不需要sklearn了，或者说sklearn就没必要暴露在local空间里面了。并且sys.modules里面也不存在<code>ridge</code>这个key，存在的是<code>sklearn.linear_model.ridge</code>，暴露给当前模块的local空间里面的符号是<code>ridge</code></strong></p>
<h4 id="import-amp-as"><a href="#import-amp-as" class="headerlink" title="import &amp; as"></a>import &amp; as</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sklearn.linear_model.ridge <span class="keyword">as</span> xxx</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">  1           0 LOAD_CONST               0 (0)</span></span><br><span class="line"><span class="string">              2 LOAD_CONST               1 (None)</span></span><br><span class="line"><span class="string">              4 IMPORT_NAME              0 (sklearn.linear_model.ridge)</span></span><br><span class="line"><span class="string">              6 IMPORT_FROM              1 (linear_model)</span></span><br><span class="line"><span class="string">              8 ROT_TWO</span></span><br><span class="line"><span class="string">             10 POP_TOP</span></span><br><span class="line"><span class="string">             12 IMPORT_FROM              2 (ridge)</span></span><br><span class="line"><span class="string">             14 STORE_NAME               3 (xxx)</span></span><br><span class="line"><span class="string">             16 POP_TOP</span></span><br><span class="line"><span class="string">             18 LOAD_CONST               1 (None)</span></span><br><span class="line"><span class="string">             20 RETURN_VALUE</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>这个和带有from的import类似，<code>sklearn</code>，<code>sklearn.linear_model</code>，<code>sklearn.linear_model.ridge</code>都在sys.modules里面，但是我们加上了as xxx，那么这个xxx就直接指向了<code>sklearn</code>下面的<code>linear_model</code>下面的<code>ridge</code>，就不需要sklearn了。这个和上面的from &amp; import类似，只有xxx暴露在了当前模块的local空间里面，sklearn虽然在sys.modules里面，但是在当前模块就无法访问了。</strong></p>
<h4 id="from-amp-import-amp-as"><a href="#from-amp-import-amp-as" class="headerlink" title="from &amp; import &amp; as"></a>from &amp; import &amp; as</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> ridge <span class="keyword">as</span> xxx</span><br></pre></td></tr></table></figure>

<p><strong>这个我想连字节码都不需要贴了，和之前from &amp; import一样，只是最后暴露给当前模块的local空间的ridge变成了我们自己指定的xxx。</strong></p>
<h3 id="与module对象有关的名字空间问题"><a href="#与module对象有关的名字空间问题" class="headerlink" title="与module对象有关的名字空间问题"></a>与module对象有关的名字空间问题</h3><p><strong>同函数、类一样，每个PyModuleObject也是有自己的名字空间的。一个模块不能直接访问另一个模块的内容，尽管模块内部的作用域比较复杂，比如：遵循LEGB规则，但是模块与模块之间的划分则是很明显的。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># test1.py</span></span><br><span class="line">name = <span class="string">&quot;夏色祭&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_name</span>():</span><br><span class="line">    <span class="keyword">return</span> name</span><br><span class="line"><span class="comment"># test2.py</span></span><br><span class="line"><span class="keyword">from</span> test1 <span class="keyword">import</span> name, print_name</span><br><span class="line"></span><br><span class="line">name = <span class="string">&quot;神乐mea&quot;</span></span><br><span class="line"><span class="built_in">print</span>(print_name())  <span class="comment"># 夏色祭</span></span><br></pre></td></tr></table></figure>

<p><strong>执行test2.py之后，发现打印的依旧是”夏色祭”。我们说Python是根据LEGB规则，而print_name里面没有name，那么去外层找，test2.py里面的name是”神乐mea”，但是找到的依旧是test1.py里面的”夏色祭”。为什么？</strong></p>
<p><strong>还是那句话，模块与模块之间的作用域划分的非常明显，print_name是test1.py里面的函数，所以在返回name的时候，只会从test1.py中搜索，无论如何都是不会跳过test1.py、跑到test2.py里面的。</strong></p>
<p><strong>再来看个栗子：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># test1.py</span></span><br><span class="line">name = <span class="string">&quot;夏色祭&quot;</span></span><br><span class="line">nicknames = [<span class="string">&quot;夏哥&quot;</span>, <span class="string">&quot;祭妹&quot;</span>]</span><br><span class="line"><span class="comment"># test2.py</span></span><br><span class="line"><span class="keyword">import</span> test1</span><br><span class="line">test1.name = <span class="string">&quot;❤夏色祭❤&quot;</span></span><br><span class="line">test1.nicknames = [<span class="string">&quot;祭妹&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> test1 <span class="keyword">import</span> name, nicknames</span><br><span class="line"><span class="built_in">print</span>(name)  <span class="comment"># ❤夏色祭❤</span></span><br><span class="line"><span class="built_in">print</span>(nicknames)  <span class="comment"># [&#x27;祭妹&#x27;]</span></span><br></pre></td></tr></table></figure>

<p><strong>很简单，直接把test1里面的变量修改了。因为这种方式，相当于直接修改test1内部的属性字典。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># test1.py</span></span><br><span class="line">name = <span class="string">&quot;夏色祭&quot;</span></span><br><span class="line">nicknames = [<span class="string">&quot;夏哥&quot;</span>, <span class="string">&quot;祭妹&quot;</span>]</span><br><span class="line"><span class="comment"># test2.py</span></span><br><span class="line"><span class="keyword">from</span> test1 <span class="keyword">import</span> name, nicknames</span><br><span class="line">name = <span class="string">&quot;神乐mea&quot;</span></span><br><span class="line">nicknames.remove(<span class="string">&quot;夏哥&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> test1 <span class="keyword">import</span> name, nicknames</span><br><span class="line"><span class="built_in">print</span>(name)  <span class="comment"># 夏色祭</span></span><br><span class="line"><span class="built_in">print</span>(nicknames)  <span class="comment"># [&quot;祭妹&quot;]</span></span><br></pre></td></tr></table></figure>

<p><strong>如果是<code>from test1 import name, nicknames</code>，那么相当于在当前的local空间中创建一个变量name和nicknames指向对应的对象。name &#x3D; “神乐mea”相当于重新赋值了，而nicknames.remove则是在本地进行修改。</strong></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><strong>总的来说，Python中module对象的导入还是很简单的，所以我们也没有涉及太多关于源码的知识。</strong></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Lin Li</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/04/20/23-%E5%89%96%E6%9E%90Python%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97%E5%AF%BC%E5%85%A5%E6%9C%BA%E5%88%B6%E3%80%81Python%E6%98%AF%E5%A6%82%E4%BD%95%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9D%97%E7%9A%84/">http://example.com/2023/04/20/23-%E5%89%96%E6%9E%90Python%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97%E5%AF%BC%E5%85%A5%E6%9C%BA%E5%88%B6%E3%80%81Python%E6%98%AF%E5%A6%82%E4%BD%95%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9D%97%E7%9A%84/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">LinLi's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/CPython/">CPython</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/04/20/24-Python%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E7%8E%AF%E5%A2%83%E5%88%9D%E5%A7%8B%E5%8C%96/" title="24-Python运行时的环境初始化"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">24-Python运行时的环境初始化</div></div></a></div><div class="next-post pull-right"><a href="/2023/04/18/TYPET5-SEQ2SEQ-TYPE-INFERENCEUSING-STATIC-ANALYSIS/" title="TYPET5 SEQ2SEQ TYPE INFERENCEUSING STATIC ANALYSIS"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">TYPET5 SEQ2SEQ TYPE INFERENCEUSING STATIC ANALYSIS</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/03/29/01-%E7%BC%96%E8%AF%91Cpython/" title="01-编译Cpython"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">01-编译Cpython</div></div></a></div><div><a href="/2023/03/29/02-%E4%B8%80%E5%88%87%E5%AF%B9%E8%B1%A1%E7%9A%86PyObject/" title="02-一切对象皆PyObject"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">02-一切对象皆PyObject</div></div></a></div><div><a href="/2023/03/29/04-%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/" title="04-浮点数的底层实现"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">04-浮点数的底层实现</div></div></a></div><div><a href="/2023/03/29/06-Bytes%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BA%95%E5%B1%82%E6%93%8D%E4%BD%9C/" title="06-Bytes对象的底层操作"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">06-Bytes对象的底层操作</div></div></a></div><div><a href="/2023/03/29/03-Python%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E5%99%A8%E5%92%8C%E5%BA%95%E5%B1%82%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86/" title="03-Python引用计数器和底层对象管理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">03-Python引用计数器和底层对象管理</div></div></a></div><div><a href="/2023/03/29/05-Python%E6%95%B4%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/" title="05-Python整数的底层实现"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">05-Python整数的底层实现</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Lin Li</div><div class="author-info__description">今日事，今日毕</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">87</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#23-%E5%89%96%E6%9E%90Python%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97%E5%AF%BC%E5%85%A5%E6%9C%BA%E5%88%B6%E3%80%81Python%E6%98%AF%E5%A6%82%E4%BD%95%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9D%97%E7%9A%84"><span class="toc-number">1.</span> <span class="toc-text">23-剖析Python中的模块导入机制、Python是如何加载模块的</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A5%94%E5%AD%90"><span class="toc-number">1.1.</span> <span class="toc-text">楔子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#import%E5%89%8D%E5%A5%8F%E6%9B%B2"><span class="toc-number">1.2.</span> <span class="toc-text">import前奏曲</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#import%E6%9C%BA%E5%88%B6%E7%9A%84%E9%BB%91%E7%9B%92%E6%8E%A2%E6%B5%8B"><span class="toc-number">1.3.</span> <span class="toc-text">import机制的黑盒探测</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E5%87%86import"><span class="toc-number">1.3.1.</span> <span class="toc-text">标准import</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Python%E5%86%85%E5%BB%BAmodule"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">Python内建module</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89module"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">用户自定义module</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97import"><span class="toc-number">1.3.2.</span> <span class="toc-text">嵌套import</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5%E5%8C%85"><span class="toc-number">1.3.3.</span> <span class="toc-text">导入包</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%B8%E5%AF%B9%E5%AF%BC%E5%85%A5%E4%B8%8E%E7%BB%9D%E5%AF%B9%E5%AF%BC%E5%85%A5"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">相对导入与绝对导入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#import%E7%9A%84%E5%8F%A6%E4%B8%80%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">import的另一种方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">1.3.3.3.</span> <span class="toc-text">路径搜索树</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#from%E4%B8%8Eimport"><span class="toc-number">1.3.4.</span> <span class="toc-text">from与import</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7%E9%87%8D%E5%91%BD%E5%90%8D"><span class="toc-number">1.3.5.</span> <span class="toc-text">符号重命名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7%E7%9A%84%E9%94%80%E6%AF%81%E4%B8%8E%E9%87%8D%E8%BD%BD"><span class="toc-number">1.3.6.</span> <span class="toc-text">符号的销毁与重载</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#import%E6%9C%BA%E5%88%B6%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.4.</span> <span class="toc-text">import机制的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Python%E4%B8%AD%E7%9A%84import%E6%93%8D%E4%BD%9C"><span class="toc-number">1.5.</span> <span class="toc-text">Python中的import操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#import-%E6%A8%A1%E5%9D%97"><span class="toc-number">1.5.1.</span> <span class="toc-text">import 模块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#import-%E5%8C%85"><span class="toc-number">1.5.2.</span> <span class="toc-text">import 包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#from-amp-import"><span class="toc-number">1.5.3.</span> <span class="toc-text">from &amp; import</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#import-amp-as"><span class="toc-number">1.5.4.</span> <span class="toc-text">import &amp; as</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#from-amp-import-amp-as"><span class="toc-number">1.5.5.</span> <span class="toc-text">from &amp; import &amp; as</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8Emodule%E5%AF%B9%E8%B1%A1%E6%9C%89%E5%85%B3%E7%9A%84%E5%90%8D%E5%AD%97%E7%A9%BA%E9%97%B4%E9%97%AE%E9%A2%98"><span class="toc-number">1.6.</span> <span class="toc-text">与module对象有关的名字空间问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">1.7.</span> <span class="toc-text">小结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/06/21/Fuzz4All-Universal-Fuzzing-with-Large-Language-Models/" title="Fuzz4All Universal Fuzzing with Large Language Models">Fuzz4All Universal Fuzzing with Large Language Models</a><time datetime="2024-06-21T06:10:36.000Z" title="发表于 2024-06-21 14:10:36">2024-06-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/06/18/Detecting-Logic-Bugs-in-Database-Engines-via-Equivalent-Expression-Transformation/" title="Detecting Logic Bugs in Database Engines via Equivalent Expression Transformation">Detecting Logic Bugs in Database Engines via Equivalent Expression Transformation</a><time datetime="2024-06-18T07:48:17.000Z" title="发表于 2024-06-18 15:48:17">2024-06-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/24/Mozi-Discovering-DBMS-Bugs-via-Configuration-Based-Equivalent-Transformation/" title="Mozi: Discovering DBMS Bugs via Configuration-Based Equivalent Transformation">Mozi: Discovering DBMS Bugs via Configuration-Based Equivalent Transformation</a><time datetime="2024-05-24T09:07:56.000Z" title="发表于 2024-05-24 17:07:56">2024-05-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/24/Testing-Graph-Database-Systems-via-Equivalent-Query-Rewriting/" title="Testing Graph Database Systems via Equivalent Query Rewriting">Testing Graph Database Systems via Equivalent Query Rewriting</a><time datetime="2024-05-24T02:53:06.000Z" title="发表于 2024-05-24 10:53:06">2024-05-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/23/Towards-Generic-Database-Management-System-Fuzzing/" title="Towards Generic Database Management System Fuzzing">Towards Generic Database Management System Fuzzing</a><time datetime="2024-05-23T09:51:00.000Z" title="发表于 2024-05-23 17:51:00">2024-05-23</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Lin Li</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>