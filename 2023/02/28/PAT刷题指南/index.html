<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>PAT甲级刷题指南 | LinLi's Blog</title><meta name="author" content="Lin Li"><meta name="copyright" content="Lin Li"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="PAT甲级刷题指南《算法笔记》C++标准模板库(STL)介绍vector定义：变长数组 初始化：1234561、vector&lt;int&gt; v(size,0);  &#x2F;&#x2F;初始化为02、vector&lt;int&gt; v;  v.resize(n,0);  &#x2F;&#x2F;resize一个大小为n，初值为0的可变数组3、vector&lt;type&gt; v;   &#x2F;&#x2F;不初始化,type可以是一个结">
<meta property="og:type" content="article">
<meta property="og:title" content="PAT甲级刷题指南">
<meta property="og:url" content="http://example.com/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/index.html">
<meta property="og:site_name" content="LinLi&#39;s Blog">
<meta property="og:description" content="PAT甲级刷题指南《算法笔记》C++标准模板库(STL)介绍vector定义：变长数组 初始化：1234561、vector&lt;int&gt; v(size,0);  &#x2F;&#x2F;初始化为02、vector&lt;int&gt; v;  v.resize(n,0);  &#x2F;&#x2F;resize一个大小为n，初值为0的可变数组3、vector&lt;type&gt; v;   &#x2F;&#x2F;不初始化,type可以是一个结">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2023-02-28T13:46:14.000Z">
<meta property="article:modified_time" content="2023-02-28T13:56:22.971Z">
<meta property="article:author" content="Lin Li">
<meta property="article:tag" content="算法系列">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'PAT甲级刷题指南',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-02-28 21:56:22'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">119</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="LinLi's Blog"><span class="site-name">LinLi's Blog</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">PAT甲级刷题指南</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-02-28T13:46:14.000Z" title="发表于 2023-02-28 21:46:14">2023-02-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-02-28T13:56:22.971Z" title="更新于 2023-02-28 21:56:22">2023-02-28</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="PAT甲级刷题指南"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="PAT甲级刷题指南"><a href="#PAT甲级刷题指南" class="headerlink" title="PAT甲级刷题指南"></a>PAT甲级刷题指南</h1><h2 id="《算法笔记》C-标准模板库-STL-介绍"><a href="#《算法笔记》C-标准模板库-STL-介绍" class="headerlink" title="《算法笔记》C++标准模板库(STL)介绍"></a>《算法笔记》C++标准模板库(STL)介绍</h2><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><h5 id="定义："><a href="#定义：" class="headerlink" title="定义："></a><strong>定义</strong>：</h5><p>变长数组</p>
<h5 id="初始化："><a href="#初始化：" class="headerlink" title="初始化："></a><strong>初始化</strong>：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1、vector&lt;int&gt; v(size,0);  //初始化为0</span><br><span class="line">2、vector&lt;int&gt; v;  v.resize(n,0);  //resize一个大小为n，初值为0的可变数组</span><br><span class="line">3、vector&lt;type&gt; v;   //不初始化,type可以是一个结构体</span><br><span class="line">4、vector&lt;int&gt; ilist2(v);  vector&lt;int&gt; ilist2  = v;   //两种方式等价，都是深拷贝</span><br><span class="line">5、vector&lt;int&gt; ilist = &#123;1,2,3.0,4,5,6,7&#125;;   //和数组初始化方法一样</span><br><span class="line">6、vector&lt;int&gt; ilist3(ilist.begin()+2,ilist.end()-1);   //迭代器初始化</span><br></pre></td></tr></table></figure>

<h5 id="访问："><a href="#访问：" class="headerlink" title="访问："></a><strong>访问</strong>：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1、随机访问数组下标访问 v[i]</span><br><span class="line">2、迭代器访问数组</span><br><span class="line">    vector&lt;int&gt;::iterator iter;</span><br><span class="line">    for(iter = vi.begin();iter != vi.end();iter++)&#123;</span><br><span class="line">        cout&lt;&lt;*iter&lt;&lt;&quot; &quot;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="常用函数："><a href="#常用函数：" class="headerlink" title="常用函数："></a><strong>常用函数</strong>：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">1、插入push_back  v.push_back(i);</span><br><span class="line">2、删除pop_back   v.pop_back();  //删除最后一个元素，回溯的时候常用</span><br><span class="line">3、大小size    v.size();  //获取数组大小</span><br><span class="line">4、清空clear   v.clear(); //清空数组</span><br><span class="line">5、插入insert  //尽量不要频繁使用这个函数，会引起大量数据移动，降低程序效率</span><br><span class="line">    v.insert(v.begin(),8);//在最前面插入新元素</span><br><span class="line">    v.insert(v.begin()+3,1);//在迭代器中下标为3的元素前插入新元素</span><br><span class="line">    v.insert(v.end(),3);//在向量末尾追加新元素</span><br><span class="line">    v.insert(v.end(),3,0);//在尾部插入3个0</span><br><span class="line">6、删除erase  //erase函数有两种函数原型，一种是给定要删除的位置，另一种是给定删除的区域。</span><br><span class="line">	有两种函数原型，c.erase (p),c.erase(b,e);第一个删除迭代器p所指向的元素，第二个删除迭代器b,e所标记的范围内的元素，c为容器对象，返回值都是一个迭代器，该迭代器指向被删除元素后面的元素（这个是重点）</span><br><span class="line">	应用一：删除连续数字</span><br><span class="line">	//但是这种代码也是存在缺陷的，首先是我们无法连续删除数字3，其次是迭代器在指向vec.end()的时候，还会进行一次++，这就发生了数组越界，所以我们一概这样修改：</span><br><span class="line">	for(auto iter=vec.begin();iter!=vec.end(); iter++)  </span><br><span class="line">	&#123;</span><br><span class="line">      if(*iter == 3)</span><br><span class="line">            iter = veci.erase(iter);</span><br><span class="line">	&#125;</span><br><span class="line">	//可以删除连续的数字3</span><br><span class="line">	for(auto iter=vec.begin();iter!=vec.end(); )</span><br><span class="line">	&#123;</span><br><span class="line">     if( *iter == 3)</span><br><span class="line">          iter = veci.erase(iter);//当删除时erase函数自动指向下一个位置，就不需要进行++</span><br><span class="line">      else</span><br><span class="line">            iter ++ ;    //当没有进行删除的时候，迭代器++</span><br><span class="line">	&#125;</span><br><span class="line">	//另一种解决无法删除连续的数字的方法</span><br><span class="line">	我们先介绍一下remove函数:</span><br><span class="line">    remove是个stl的通用算法std::remove(first,last,val)移除[first, last)范围内等于val的元素在vector里面用就类似于 iter=std::remove(vec.begin(), vec.end(), val)但这个函数只是把val移到vec的末尾，并不真正删除,真正删除还是要调用一次erase函数</span><br><span class="line">    veci.erase(remove(vec.begin(),vec.end(),3),vec.end());</span><br><span class="line">    </span><br><span class="line">    应用二：删除重复数字，顺序不发生变化</span><br><span class="line">    如果不要求顺序的话，我们可以直接调用unique函数进行操作，这里介绍一下unique函数：从头到尾，判断当前元素是否等于上一个元素，将不重复的元素移到前面来(赋值操作)，而不是将重复的元素移动到后面去。</span><br><span class="line">    vec.erase(unique(vec.begin(),vec.end()),vec.end())  //将重复的区域删除，顺序会改变</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="常见错误："><a href="#常见错误：" class="headerlink" title="常见错误："></a><strong>常见错误</strong>：</h5><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210814163126705.png" alt="image-20210814163126705"></p>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><h5 id="定义：-1"><a href="#定义：-1" class="headerlink" title="定义："></a><strong>定义</strong>：</h5><p>是一个内部自动有序且不含重复元素的容器</p>
<p>unordered_set 无序 其余和set的用法一样，效率更高</p>
<h5 id="初始化：-1"><a href="#初始化：-1" class="headerlink" title="初始化："></a>初始化：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set&lt;T&gt; s;</span><br><span class="line">set&lt;T&gt; s(b, e);</span><br><span class="line">比如：</span><br><span class="line">int arr[]=&#123;1,2,3,4,3,2,1&#125;;</span><br><span class="line">set&lt;int&gt; iset(arr,arr+sizeof(arr)/sizeof(*arr));</span><br></pre></td></tr></table></figure>

<h5 id="访问：-1"><a href="#访问：-1" class="headerlink" title="访问："></a><strong>访问</strong>：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1、迭代器访问</span><br><span class="line">set&lt;int&gt; st;</span><br><span class="line">set&lt;int&gt;::iterator it</span><br><span class="line">for(it = st.begin();it != st.end();it++)&#123;</span><br><span class="line">	printf(&quot;%d &quot;,*it);</span><br><span class="line">&#125; </span><br><span class="line">2、随机访问   在set中查找2，返回其迭代器</span><br><span class="line">set&lt;int&gt;::iterator it = st.find(2); </span><br><span class="line">printf(&quot;%d &quot;,*it);</span><br></pre></td></tr></table></figure>

<h5 id="常用函数：-1"><a href="#常用函数：-1" class="headerlink" title="常用函数："></a>常用函数：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">	set&lt;int&gt; st;</span><br><span class="line">1、插入 insert()</span><br><span class="line">	st.insert(3);</span><br><span class="line">2、查找 find()</span><br><span class="line">	set&lt;int&gt;::iterator it = st.find(2); </span><br><span class="line">	if(st.find(2)==st.end()) printf(&quot;没找到&quot;);</span><br><span class="line">3、删除  erase()</span><br><span class="line">st.erase(it) it为需要删除元素的迭代器，复杂度O(1)</span><br><span class="line">st.erase(value) value为要删除元素的值，复杂度O(logN)</span><br><span class="line">	st.erase(st.find(2));</span><br><span class="line">	st.erase(2)，效果一致，两种用法</span><br><span class="line">4、获取元素个数 size()</span><br><span class="line">	cout&lt;&lt;&lt;&lt;st.size()&lt;&lt;endl;</span><br><span class="line">5、清空 clear()</span><br><span class="line">	st.clear(); </span><br><span class="line">6、判空 empty()</span><br><span class="line">	st.empty()</span><br></pre></td></tr></table></figure>





<h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><h5 id="定义：-2"><a href="#定义：-2" class="headerlink" title="定义："></a>定义：</h5><p>字符串</p>
<h5 id="初始化：-2"><a href="#初始化：-2" class="headerlink" title="初始化："></a>初始化：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、string s1;  s1为空字符串</span><br><span class="line">2、string s2(&quot;ABC&quot;);  用字符串字面值初始化s2</span><br><span class="line">3、string s3(s2);  用s3初始化为s2的一个副本</span><br><span class="line">4、string s4(n,&#x27;c&#x27;);  将s4初始化为字符&#x27;c&#x27;的n个副本</span><br></pre></td></tr></table></figure>

<h5 id="访问：-2"><a href="#访问：-2" class="headerlink" title="访问："></a>访问：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1、通过下标访问</span><br><span class="line">    string str = &quot;abcd&quot;;</span><br><span class="line">    for(int i=0;i &lt; str.length();i++)&#123;</span><br><span class="line">        printf(&quot;%c&quot;,str[i]);</span><br><span class="line">    &#125; </span><br><span class="line">2、通过迭代器访问</span><br><span class="line">    cout&lt;&lt;&quot;通过迭代器访问如下：&quot;&lt;&lt;endl;</span><br><span class="line"> for(string::iterator;it=str.begin();it!=str.end();it++)&#123;</span><br><span class="line">        printf(&quot;%c&quot;,*it);</span><br><span class="line">    &#125; </span><br></pre></td></tr></table></figure>

<h5 id="常用函数：-2"><a href="#常用函数：-2" class="headerlink" title="常用函数："></a>常用函数：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">1、判空 s.empty()</span><br><span class="line">2、统计字符个数  s.size()  /   s.length()</span><br><span class="line">3、拼接字符串 += </span><br><span class="line">	str3 = str1+str2;  //拼接后再赋值</span><br><span class="line">	str1 += str2;  //直接接在后面，效率更高</span><br><span class="line">4、字符串比较大小 == != &gt;=等等</span><br><span class="line">5、插入 insert()</span><br><span class="line"> insert(pos,string) 在pos位置插入string</span><br><span class="line"> insert(it,it2,it3) 在it位置插入 [it2,it3)的串，it2,it3为待插字符串的首尾迭代器</span><br><span class="line"> </span><br><span class="line"> 	str1 = &quot;abcxyz&quot;;</span><br><span class="line"> 	str2 = &quot;opq&quot;;     //insert(pos,string)</span><br><span class="line">	str1.insert(3,str2);</span><br><span class="line">	cout&lt;&lt;&quot;abcxyz字符串第三个位置插入opq字符串后变为：&quot;&lt;&lt;str1&lt;&lt;endl;</span><br><span class="line">	str1.insert(str1.begin()+3,str2.begin(),str2.end());     //insert(it,it2,it3)</span><br><span class="line">	cout&lt;&lt;&quot;abcopqxyz字符串第三个位置插入opq字符串后变为：&quot;&lt;&lt;str1&lt;&lt;endl; </span><br><span class="line"></span><br><span class="line">6、删除单个元素、区间元素 erase()</span><br><span class="line"> 删除单个元素 str.erase(it)  it为删除元素的迭代器</span><br><span class="line"> 删除一个区间内的所有元素 str.erase(first,last) [first,last)</span><br><span class="line"> str.erase(pos,length) pos为开始位置，length为长度</span><br><span class="line"> </span><br><span class="line"> 	str1 = &quot;abcopqopqxyz&quot;;</span><br><span class="line"> 	str1.erase(str1.begin()+3);//str.erase(it)删除4号位o </span><br><span class="line">	cout&lt;&lt;&quot;abcopqopqxyz字符串删除第四个位置o字符串后变为：&quot;&lt;&lt;str1&lt;&lt;endl;</span><br><span class="line">	str1.erase(str1.begin()+3,str1.end()-3);//str.erase(first,last)</span><br><span class="line">	cout&lt;&lt;&quot;abcpqopqxyz字符串删除第4~8位置字符后变为：&quot;&lt;&lt;str1&lt;&lt;endl;</span><br><span class="line">	str1.erase(3,3);//str.erase(ipos,length)</span><br><span class="line">	cout&lt;&lt;&quot;abcxyz字符串删除从第4位置开始的3个字符后变为：&quot;&lt;&lt;str1&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">7、清空 clear()</span><br><span class="line">	str1.clear();</span><br><span class="line">8、子串 substr()</span><br><span class="line"> substr(pos,len) 返回从pos号开始，长度为len子串</span><br><span class="line"> 	str1 = &quot;abcxyz&quot;;</span><br><span class="line">	cout&lt;&lt;&quot;abcxyz字符串从下标2开始长度为3的子串为：&quot;&lt;&lt;str1.substr(2,3)&lt;&lt;endl;</span><br><span class="line">9、查找 find()</span><br><span class="line"> str.find(str2) 当str2是str的子串时，返回其在str中第一次出现的位置，如果str2不是str的子串，返回string::npos（常数）</span><br><span class="line"> str.find(str2,pos) 从str的pos号位置开始匹配str2，返回指相同</span><br><span class="line"> 	str1 = &quot;abcxyz&quot;,str2=&quot;xyz&quot;;</span><br><span class="line">	cout&lt;&lt;&quot;xyz子串在abcxyz中第一次出现的位置为：&quot;&lt;&lt;str1.find(str2)&lt;&lt;endl;  </span><br><span class="line">	</span><br><span class="line">	position = s.find(&quot;jk&quot;);</span><br><span class="line">	if (position != s.npos) printf(&quot;position is : %d\n&quot; ,position);  //查找成功</span><br><span class="line">	else printf(&quot;Not found the flag\n&quot;);  //查找失败</span><br><span class="line"> 10、替换 replace()</span><br><span class="line">  str.replace(pos,len,str2) 把str从pos号开始，长度为len的子串替换为str2</span><br><span class="line">  str.replace(it1,it2,str) 把str的迭代器[it1,it2)返回的子串替换为str2</span><br><span class="line">  	str1 = &quot;Maybe you will turn around.&quot;;</span><br><span class="line">	str2 = &quot;will not&quot;;str3 = &quot;surely&quot;;</span><br><span class="line">	cout&lt;&lt;&quot;Maybe you will turn around.字符串从第10位开始的4位替换为str2后为：&quot;;</span><br><span class="line">	cout&lt;&lt;str1.replace(10,4,str2)&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;&quot;Maybe you will not turn around.字符串从起始位开始的5位替换为str3后为：&quot;;</span><br><span class="line">	cout&lt;&lt;str1.replace(str1.begin(),str1.begin()+5,str3)&lt;&lt;endl;</span><br></pre></td></tr></table></figure>



<h5 id="string和char-的转换"><a href="#string和char-的转换" class="headerlink" title="string和char[]的转换"></a>string和char[]的转换</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、string转char*</span><br><span class="line">printf(&quot;%s&quot;,str.c_str());</span><br><span class="line">2、char* 转string</span><br><span class="line">	char* p = &quot;abc&quot;;</span><br><span class="line">    string s = p;</span><br></pre></td></tr></table></figure>

<h5 id="string和int等类型的转换"><a href="#string和int等类型的转换" class="headerlink" title="string和int等类型的转换"></a>string和int等类型的转换</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">转string:</span><br><span class="line">string to_string (int val);</span><br><span class="line">string to_string (long val);</span><br><span class="line">string to_string (long long val);</span><br><span class="line">string to_string (unsigned val);</span><br><span class="line">string to_string (unsigned long val);</span><br><span class="line">string to_string (unsigned long long val);</span><br><span class="line">string to_string (float val);</span><br><span class="line">string to_string (double val);</span><br><span class="line">string to_string (long double val);</span><br><span class="line">转Int</span><br><span class="line">stoi(str1);  //int</span><br><span class="line">stof(str1);  //float</span><br><span class="line">stoll(str1);  //long long </span><br></pre></td></tr></table></figure>

<h4 id="大小写转换"><a href="#大小写转换" class="headerlink" title="大小写转换"></a>大小写转换</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string strA = &quot;yasaken@126.com&quot;;</span><br><span class="line">    string strB = &quot;LURY@LENOVO.com&quot;;</span><br><span class="line">    printf(&quot;Before transform:\n&quot;);</span><br><span class="line">    printf(&quot;strA:%s \n&quot;, strA.c_str());</span><br><span class="line">    printf(&quot;strB:%s \n\n&quot;, strB.c_str());</span><br><span class="line"> </span><br><span class="line">    transform(strA.begin(), strA.end(), strA.begin(), ::toupper);</span><br><span class="line">    transform(strB.begin(), strB.end(), strB.begin(), ::toupper);</span><br><span class="line">    printf(&quot;After transform to toupper:\n&quot;);</span><br><span class="line">    printf(&quot;strA:%s \n&quot;, strA.c_str());</span><br><span class="line">    printf(&quot;strB:%s \n\n&quot;, strB.c_str());</span><br><span class="line"> </span><br><span class="line">    transform(strA.begin(), strA.end(), strA.begin(), ::tolower);</span><br><span class="line">    transform(strB.begin(), strB.end(), strB.begin(), ::tolower);</span><br><span class="line">    printf(&quot;After transform to lower:\n&quot;);</span><br><span class="line">    printf(&quot;strA:%s \n&quot;, strA.c_str());</span><br><span class="line">    printf(&quot;strB:%s \n\n&quot;, strB.c_str());</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><h5 id="定义：-3"><a href="#定义：-3" class="headerlink" title="定义："></a>定义：</h5><p>map即映射，是常用的STL容器，它可以将任何基本类型（包括STL容器）映射到任何基本类型（包括STL容器）。</p>
<p>uordered_map无序容器，效率更高</p>
<h5 id="初始化：-3"><a href="#初始化：-3" class="headerlink" title="初始化："></a>初始化：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1、直接赋值</span><br><span class="line">map&lt;string, int&gt; m1;</span><br><span class="line">m1[string(&quot;abc&quot;)] ++;</span><br><span class="line">//如果“abc&quot;已经存在，会在原来的基础上++，如果不存在，则会创建一个hash_key</span><br><span class="line"></span><br><span class="line">2、用insert添加</span><br><span class="line">map&lt;string, int&gt; m2;</span><br><span class="line">m2.insert(&#123; string(&quot;abc&quot;), 1 &#125;);</span><br><span class="line">m2.insert(make_pair(string(&quot;defg&quot;), 2));</span><br><span class="line">m2.insert(pair&lt;string, int&gt;(string(&quot;hijk&quot;), 3));</span><br></pre></td></tr></table></figure>

<h5 id="访问：-3"><a href="#访问：-3" class="headerlink" title="访问："></a>访问：</h5><p>map会以键从小到大的顺序自动排序，unordered_map则不会排序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1、通过key访问value</span><br><span class="line">	map&lt;char,int&gt; mp;</span><br><span class="line">	//通过下标访问 </span><br><span class="line">	mp[&#x27;c&#x27;] = 20;</span><br><span class="line">	mp[&#x27;c&#x27;] = 30;//20被覆盖</span><br><span class="line">	printf(&quot;%d\n&quot;,mp[&#x27;c&#x27;]);//输出30</span><br><span class="line">2、通过迭代器访问</span><br><span class="line">	for(map&lt;char,int&gt;::iterator it = mp.begin();it != mp.end();it++)&#123;</span><br><span class="line">		//it-&gt;first是当前映射的键；it-&gt;second是当前映射的值 </span><br><span class="line">		printf(&quot;%c %d\n&quot;,it-&gt;first,it-&gt;second);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h5 id="常用函数：-3"><a href="#常用函数：-3" class="headerlink" title="常用函数："></a>常用函数：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1、查找  find()</span><br><span class="line">     if(M.find(exponent)!=M.end())&#123;</span><br><span class="line">     	printf(&quot;%d&quot;,M[exponent]);</span><br><span class="line">     &#125;else&#123;</span><br><span class="line">     	printf(&quot;没找到&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">	map&lt;char,int&gt;::iterator it = mp.find(&#x27;b&#x27;);</span><br><span class="line">	printf(&quot;%c %d\n&quot;,it-&gt;first,it-&gt;second);</span><br><span class="line">2、删除 erase</span><br><span class="line"> mp.erase(key);  key为想要删除的键</span><br><span class="line"> mp.erase(first,last); 删除一个区间内的元素，first,last为迭代器</span><br><span class="line"> 	it = mp.find(&#x27;m&#x27;);</span><br><span class="line">	mp.erase(it);//删除b 2</span><br><span class="line">	mp.erase(&#x27;r&#x27;);//删除b 2</span><br><span class="line">3、获取大小 size()</span><br><span class="line">	cout&lt;&lt;&quot;此时map的长度为：&quot;&lt;&lt;mp.size();</span><br><span class="line">4、清空 clear()</span><br><span class="line">	mp.clear();</span><br></pre></td></tr></table></figure>

<h5 id="multimap"><a href="#multimap" class="headerlink" title="multimap:"></a>multimap:</h5><p>multimap 和 map 很相似，但是 multimap 允许重复的元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">multimap&lt;int, string&gt; multi_map;		// 可实现多重映射</span><br><span class="line"></span><br><span class="line">multimap.insert(&#123; 520, &quot;huameng&quot; &#125;);</span><br><span class="line">multimap.insert(&#123; 520, &quot;huameng1&quot; &#125;);</span><br><span class="line">multimap.insert(&#123; 520, &quot;huameng2&quot; &#125;);</span><br><span class="line">for (auto&amp; i: multi_map)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; i.first &lt;&lt; &quot;  &quot; &lt;&lt; i.second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">520  huameng</span><br><span class="line">520  huameng1</span><br><span class="line">520  huameng2</span><br></pre></td></tr></table></figure>



<h3 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h3><h5 id="定义：-4"><a href="#定义：-4" class="headerlink" title="定义："></a>定义：</h5><p>Queue翻译为队列，理解为一个先进先出的容器</p>
<h5 id="queue初始化："><a href="#queue初始化：" class="headerlink" title="queue初始化："></a>queue初始化：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;int&gt; first;                 // empty queue</span><br></pre></td></tr></table></figure>

<h5 id="访问：-4"><a href="#访问：-4" class="headerlink" title="访问："></a>访问：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">访问队首元素：如q.front()</span><br><span class="line">访问队尾元素，如q.back();</span><br><span class="line">printf(&quot;%d %d\n&quot;,q.front(),q.back());</span><br></pre></td></tr></table></figure>

<h5 id="常用函数：-4"><a href="#常用函数：-4" class="headerlink" title="常用函数："></a>常用函数：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">size()-容器大小</span><br><span class="line">empty()-容器判空</span><br><span class="line">push()尾部增加元素</span><br><span class="line">pop()删除尾部元素</span><br></pre></td></tr></table></figure>

<h5 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue:"></a>priority_queue:</h5><p>在&lt; queue&gt;头文件中，还定义了一个非常有用的模版类priority_queue(优先队列），优先队列与队列的差别在于优先队列不是按照入队的顺序出队，而是按照队列中元素的优先权顺序出队（默认为大者优先，也可以通过指定算子来指定自己的优先顺序）。</p>
<p>priority_queue模版类有三个模版参数，元素类型，容器类型，比较算子。其中后两个都可以省略，默认容器为vector，默认算子为less，即小的往前排，大的往后排（出队时序列尾的元素出队）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">定义priority_queue对象</span><br><span class="line">priority_queue&lt;int &gt;q1;</span><br><span class="line">priority_queue&lt;pair&lt;int,int&gt; &gt;q2;</span><br><span class="line">priority_queue&lt;int,vector&lt;int&gt;，greater&lt;int&gt; &gt;q3;//定义小的先出队</span><br><span class="line">//其中第二个参数( vector )，是来承载底层数据结构堆的容器，第三个参数( less )，则是一个比较类，</span><br><span class="line">//less 表示数字大的优先级高，而 greater 表示数字小的优先级高</span><br></pre></td></tr></table></figure>

<p>priority_queue的基本操作均与queue相同，<strong>优先队列没有back（）操作</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">q.size();//返回q里元素个数</span><br><span class="line">q.empty();//返回q是否为空，空则返回1，否则返回0</span><br><span class="line">q.push(k);//在q的末尾插入k</span><br><span class="line">q.pop();//删掉q的第一个元素</span><br><span class="line">q.top();//返回q的第一个元素</span><br></pre></td></tr></table></figure>

<p>操作示例1</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	priority_queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">	<span class="comment">//---1---push()</span></span><br><span class="line">	q.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">	q.<span class="built_in">push</span>(<span class="number">4</span>);</span><br><span class="line">	q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="comment">//---2---top()</span></span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;优先队列341的队首为：&quot;</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,q.<span class="built_in">top</span>());  <span class="comment">//4</span></span><br><span class="line">	<span class="comment">//---3---pop()</span></span><br><span class="line">	q.<span class="built_in">pop</span>();</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;弹出队首元素后优先队列的队首为：&quot;</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,q.<span class="built_in">top</span>());   <span class="comment">//3</span></span><br><span class="line">	<span class="comment">//---4---empty()</span></span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;此时队列为空吗？&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">if</span>(q.<span class="built_in">empty</span>() == <span class="literal">true</span>)<span class="built_in">printf</span>(<span class="string">&quot;Empty\n&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span>	<span class="built_in">printf</span>(<span class="string">&quot;Not Empty\n&quot;</span>);</span><br><span class="line">	<span class="comment">//---5---size()</span></span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;此时队列大小为：&quot;</span>&lt;&lt;q.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优先级操作示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//优先级队列优先级设置 </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//---1---基本数据类型：设置优先级队列总是把最小的元素放在队首 </span></span><br><span class="line">	<span class="comment">// priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q; //小顶堆</span></span><br><span class="line">    <span class="comment">//注意&lt;int&gt; &gt;之间的空格 </span></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,less&lt;<span class="type">int</span>&gt; &gt; q; <span class="comment">//大顶堆</span></span><br><span class="line">	q.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">	q.<span class="built_in">push</span>(<span class="number">4</span>);</span><br><span class="line">	q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,q.<span class="built_in">top</span>());</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结构体优先级的设置：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//结构体优先级设置 </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">fruit</span>&#123;</span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">int</span> price;</span><br><span class="line">	<span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt; (fruit f1,fruit f2)&#123;</span><br><span class="line">		<span class="keyword">return</span> f1.price &lt; f2.price;  <span class="comment">//价格大的优先</span></span><br><span class="line">        <span class="comment">//return f1.price &gt; f2.price; //价格小的优先</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;f1,f2,f3; </span><br><span class="line"><span class="comment">//需要重载小于号，只能重载小于号</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	priority_queue&lt;fruit&gt; q;  <span class="comment">//价格大的优先</span></span><br><span class="line">    <span class="comment">//这边就不能再加greater或less了</span></span><br><span class="line">	f1.name = <span class="string">&quot;桃子&quot;</span>;</span><br><span class="line">	f1.price = <span class="number">3</span>;</span><br><span class="line">	f2.name = <span class="string">&quot;梨子&quot;</span>;</span><br><span class="line">	f2.price = <span class="number">4</span>;</span><br><span class="line">	f3.name = <span class="string">&quot;苹果&quot;</span>;</span><br><span class="line">	f3.price = <span class="number">1</span>;</span><br><span class="line">	q.<span class="built_in">push</span>(f1);</span><br><span class="line">	q.<span class="built_in">push</span>(f2);</span><br><span class="line">	q.<span class="built_in">push</span>(f3); </span><br><span class="line">	cout&lt;&lt;q.<span class="built_in">top</span>().name&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;q.<span class="built_in">top</span>().price&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以类似Cmp写在外面</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//结构体优先级设置 </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">fruit</span>&#123;</span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">int</span> price;</span><br><span class="line">	<span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt; (fruit f1,fruit f2)&#123;</span><br><span class="line">		<span class="keyword">return</span> f1.price &lt; f2.price;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;f1,f2,f3; </span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span>&#123;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">(fruit f1,fruit f2)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> f1.price &gt; f2.price;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//重载优先级结构体进行排序 </span></span><br><span class="line">	priority_queue&lt;fruit&gt; q;</span><br><span class="line">	f1.name = <span class="string">&quot;桃子&quot;</span>;</span><br><span class="line">	f1.price = <span class="number">3</span>;</span><br><span class="line">	f2.name = <span class="string">&quot;梨子&quot;</span>;</span><br><span class="line">	f2.price = <span class="number">4</span>;</span><br><span class="line">	f3.name = <span class="string">&quot;苹果&quot;</span>;</span><br><span class="line">	f3.price = <span class="number">1</span>;</span><br><span class="line">	q.<span class="built_in">push</span>(f1);</span><br><span class="line">	q.<span class="built_in">push</span>(f2);</span><br><span class="line">	q.<span class="built_in">push</span>(f3); </span><br><span class="line">	cout&lt;&lt;q.<span class="built_in">top</span>().name&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;q.<span class="built_in">top</span>().price&lt;&lt;endl;</span><br><span class="line">	<span class="comment">//梨子 4</span></span><br><span class="line">    <span class="comment">//用cmp函数优先级排序 </span></span><br><span class="line">	priority_queue&lt;fruit,vector&lt;fruit&gt;,cmp&gt; qq;</span><br><span class="line">	f1.name = <span class="string">&quot;桃子&quot;</span>;</span><br><span class="line">	f1.price = <span class="number">3</span>;</span><br><span class="line">	f2.name = <span class="string">&quot;梨子&quot;</span>;</span><br><span class="line">	f2.price = <span class="number">4</span>;</span><br><span class="line">	f3.name = <span class="string">&quot;苹果&quot;</span>;</span><br><span class="line">	f3.price = <span class="number">1</span>;</span><br><span class="line">	qq.<span class="built_in">push</span>(f1);</span><br><span class="line">	qq.<span class="built_in">push</span>(f2);</span><br><span class="line">	qq.<span class="built_in">push</span>(f3); </span><br><span class="line">	cout&lt;&lt;qq.<span class="built_in">top</span>().name&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;qq.<span class="built_in">top</span>().price&lt;&lt;endl;</span><br><span class="line">	<span class="comment">//苹果 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h3><h5 id="定义：-5"><a href="#定义：-5" class="headerlink" title="定义："></a>定义：</h5><p>stack即栈，是一种先进后出的容器，区别于queue；</p>
<h5 id="初始化：-4"><a href="#初始化：-4" class="headerlink" title="初始化："></a>初始化：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;int&gt; stk;</span><br></pre></td></tr></table></figure>

<h5 id="访问：-5"><a href="#访问：-5" class="headerlink" title="访问："></a>访问：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">访问栈顶元素 stk.top()</span><br></pre></td></tr></table></figure>

<h5 id="常用函数：-5"><a href="#常用函数：-5" class="headerlink" title="常用函数："></a>常用函数：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">push() 压栈</span><br><span class="line">top() 取栈顶元素</span><br><span class="line">pop() 出栈</span><br><span class="line">empty() 判空</span><br><span class="line">size() 获取大小</span><br><span class="line">//---1、2、3---push()、top()、pop() </span><br><span class="line">for(int i = 1;i &lt;= 5;i++)&#123;</span><br><span class="line">	st.push(i);//将i压入栈 </span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;&quot;入栈12345的栈顶为：&quot;;</span><br><span class="line">cout&lt;&lt;st.top()&lt;&lt;endl;</span><br><span class="line">for(int i = 1;i &lt;= 3;i++)&#123;</span><br><span class="line">	st.pop();</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;&quot;出栈3个元素后栈顶为：&quot;;</span><br><span class="line">printf(&quot;%d\n&quot;,st.top());</span><br><span class="line">//---4---empty()</span><br><span class="line">cout&lt;&lt;&quot;此时栈为空吗？&quot;&lt;&lt;endl;</span><br><span class="line">if(st.empty() == true)  printf(&quot;Empty\n&quot;);</span><br><span class="line">else printf(&quot;Not Empty\n&quot;);</span><br><span class="line">//---5---size()</span><br><span class="line">cout&lt;&lt;&quot;此时队列大小为：&quot;&lt;&lt;st.size()&lt;&lt;endl;</span><br></pre></td></tr></table></figure>



<h3 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h3><h5 id="定义：-6"><a href="#定义：-6" class="headerlink" title="定义："></a>定义：</h5><p>Pair可以看作一个内部有两个元素的结构体，且这两个元素的类型可以指定</p>
<h5 id="初始化：-5"><a href="#初始化：-5" class="headerlink" title="初始化："></a>初始化：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;int, double&gt; p1;  //使用默认构造函数</span><br><span class="line">pair&lt;int, double&gt; p2(1, 2.4);  //用给定值初始化</span><br><span class="line">pair&lt;int, double&gt; p3(p2);  //拷贝构造函数</span><br></pre></td></tr></table></figure>

<h5 id="访问：-6"><a href="#访问：-6" class="headerlink" title="访问："></a>访问：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;int, double&gt; p1;  //使用默认构造函数</span><br><span class="line">p1.first = 1;</span><br><span class="line">p1.second = 2.5;</span><br><span class="line">cout &lt;&lt; p1.first &lt;&lt; &#x27; &#x27; &lt;&lt; p1.second &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<h5 id="常用函数：-6"><a href="#常用函数：-6" class="headerlink" title="常用函数："></a>常用函数：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1、比较操作数 &lt;.&gt;,&lt;=,==</span><br><span class="line">//比较规则是先比较first，再比较second</span><br><span class="line">int main()&#123;</span><br><span class="line">	pair&lt;int,int&gt; p1(5,10);</span><br><span class="line">	pair&lt;int,int&gt; p2(5,15);</span><br><span class="line">	pair&lt;int,int&gt; p3(10,5);</span><br><span class="line">	if(p1 &lt; p3)	printf(&quot;p1 &lt; p3\n&quot;);</span><br><span class="line">	if(p1 &lt;= p3)	printf(&quot;p1 &lt;= p3\n&quot;);</span><br><span class="line">	if(p1 &lt; p2)	printf(&quot;p1 &lt; p2\n&quot;);</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">2、make_pair 赋值</span><br><span class="line">pair &lt;string,double&gt; product1 (&quot;tomatoes&quot;,3.25);</span><br><span class="line">pair &lt;string,double&gt; product2;</span><br><span class="line">pair &lt;string,double&gt; product3;</span><br><span class="line"> </span><br><span class="line">product2.first =&quot;lightbulbs&quot;; // type of first is string</span><br><span class="line">product2.second =0.99; // type of second is double</span><br><span class="line"> </span><br><span class="line">product3 = make_pair (&quot;shoes&quot;,20.0);</span><br></pre></td></tr></table></figure>

<h5 id="常用于作为map的键值对进行插入："><a href="#常用于作为map的键值对进行插入：" class="headerlink" title="常用于作为map的键值对进行插入："></a>常用于作为map的键值对进行插入：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string,int&gt; mp;</span><br><span class="line">//pair作为map键值对进行插入 </span><br><span class="line">mp.insert(make_pair(&quot;heihei&quot;,5));</span><br><span class="line">mp.insert(pair&lt;string,int&gt;(&quot;haha&quot;,10));</span><br></pre></td></tr></table></figure>



<h3 id="algorithm常用函数"><a href="#algorithm常用函数" class="headerlink" title="algorithm常用函数"></a>algorithm常用函数</h3><h5 id="max-、min-、abs"><a href="#max-、min-、abs" class="headerlink" title="max()、min()、abs()"></a>max()、min()、abs()</h5><p>最大值、最小值、绝对值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int x=1,y=-2;</span><br><span class="line">printf(&quot;%d %d\n&quot;,max(x,y),min(x,y));</span><br><span class="line">printf(&quot;%d %d\n&quot;,abs(x),abs(y));</span><br></pre></td></tr></table></figure>

<h5 id="swap"><a href="#swap" class="headerlink" title="swap"></a>swap</h5><p>交换两个元素的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int x=1,y=2;</span><br><span class="line">swap(x,y);</span><br><span class="line">printf(&quot;%d %d\n&quot;,x,y);</span><br></pre></td></tr></table></figure>

<h5 id="reverse"><a href="#reverse" class="headerlink" title="reverse()"></a>reverse()</h5><p>1.会将区间内的元素全部逆序。常用于数组，字符串，容器等，其本身的函数参数也不复杂。<br>2.容器类型的要用begin()和end()来指定反转的区域，数组类型的直接用int类型即可。<br>3.reverse函数用于反转在[first,last)范围内的顺序（包括first指向的元素，不包括last指向的元素），reverse函数没有返回值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; v = &#123;5,4,3,2,1&#125;;</span><br><span class="line">reverse(v.begin(),v.end());//v的值为1,2,3,4,5</span><br><span class="line">string str=&quot;www.mathor.top&quot;;</span><br><span class="line">reverse(str.begin(),str.end());//str结果为pot.rohtam.wwww</span><br></pre></td></tr></table></figure>

<h5 id="fill"><a href="#fill" class="headerlink" title="fill()"></a>fill()</h5><p>1.按照单元赋值，将一个区间的元素都赋同一个值<br> 2.fill(arr, arr + n, 要填入的内容);<br> fill(vector.begin(), vector.end(), val);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int arr[10];</span><br><span class="line">fill(arr, arr + 10, 2);</span><br><span class="line">vector&lt;int&gt;  v&#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;;</span><br><span class="line">fill(v.begin(), v.end(), -1);</span><br><span class="line">vector&lt;int&gt; myvector (8);// myvector: 0 0 0 0 0 0 0 0</span><br><span class="line">fill (myvector.begin(),myvector.begin()+4,5);</span><br><span class="line">// myvector: 5 5 5 5 0 0 0 0</span><br><span class="line">fill (myvector.begin()+3,myvector.end()-2,8);</span><br><span class="line">// myvector: 5 5 5 8 8 8 0 0</span><br></pre></td></tr></table></figure>

<h5 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h5><p>1.Sort函数有三个参数：<br>（1）第一个是要排序的数组的起始地址。<br>（2）第二个是结束的地址（最后一位要排序的地址的下一地址）<br>（3）第三个参数是排序的方法，可以是从大到小也可是从小到大，还可以不写第三个参数，此时默认的排序方法是从小到大排序。<br>2.Sort函数使用模板:Sort(start,end,排序方法)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">1、数组排序</span><br><span class="line">int IntValue[5] = &#123;1,4,3,8,5&#125;;</span><br><span class="line">sort(IntValue,IntValue+5);</span><br><span class="line">for(int i=0;i&lt;5;i++)&#123;</span><br><span class="line">	cout&lt;&lt;IntValue[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">2、vector排序</span><br><span class="line">vector&lt;int&gt; v = &#123;2,6,4,9,6,0,3&#125;;</span><br><span class="line">sort(v.begin(),v.end());</span><br><span class="line">vector&lt;int&gt;::iterator  start;</span><br><span class="line">for(start = v.begin();start!=v.end();start++)&#123;</span><br><span class="line">	cout&lt;&lt;(*start)&lt;&lt;&quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">3、自定义排序</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">/*</span><br><span class="line">linli1 20</span><br><span class="line">linli2 24</span><br><span class="line">linli6 8</span><br><span class="line">linli3 8</span><br><span class="line"> * */</span><br><span class="line">typedef struct stu&#123;</span><br><span class="line">    string name;</span><br><span class="line">    int age;</span><br><span class="line">&#125;stu;</span><br><span class="line">bool cmp(stu u,stu g)&#123;  //&lt;表示升序排序</span><br><span class="line">    if(u.age==g.age)&#123;</span><br><span class="line">        return u.name&lt;g.name;</span><br><span class="line">    &#125;</span><br><span class="line">    return u.age&lt;g.age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    vector&lt;stu&gt; v;</span><br><span class="line">    for(int i=0;i&lt;4;i++)&#123;</span><br><span class="line">        stu c ;</span><br><span class="line">        cin&gt;&gt;c.name&gt;&gt;c.age;</span><br><span class="line">        v.push_back(c);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(v.begin(),v.end(),cmp);</span><br><span class="line">    vector&lt;stu&gt;::iterator  start;</span><br><span class="line">    for(start = v.begin();start!=v.end();start++)&#123;</span><br><span class="line">        cout&lt;&lt;(*start).name&lt;&lt;&quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="lower-bound-和upper-bound"><a href="#lower-bound-和upper-bound" class="headerlink" title="lower_bound()和upper_bound()"></a>lower_bound()和upper_bound()</h5><p><strong>lower_bound：</strong></p>
<p>功能：查找<strong>非递减序列[first,last)</strong> 内第一个大于或等于某个元素的位置。</p>
<p>返回值：如果找到返回找到元素的地址否则返回last的地址。（这样不注意的话会越界，小心）</p>
<p>用法：int t&#x3D;lower_bound(a+l,a+r,key)-a；(a是数组)。</p>
<p><strong>upper_bound:</strong></p>
<p>功能：查找<strong>非递减序列[first,last)</strong> 内第一个大于某个元素的位置。</p>
<p>返回值：如果找到返回找到元素的地址否则返回last的地址。（同样这样不注意的话会越界，小心）</p>
<p>用法：int t&#x3D;upper_bound(a+l,a+r,key)-a；(a是数组)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int board[5] = &#123;1,2,3,4,5&#125;;</span><br><span class="line">int t1 = lower_bound(board,board+5,3)-board; //2</span><br><span class="line">int t2 = upper_bound(board,board+5,3)-board; //3</span><br></pre></td></tr></table></figure>



<h2 id="PAT真题模拟"><a href="#PAT真题模拟" class="headerlink" title="PAT真题模拟"></a>PAT真题模拟</h2><h3 id="PAT-1001"><a href="#PAT-1001" class="headerlink" title="PAT 1001"></a>PAT 1001</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210330182108486.png" alt="image-20210330182108486"></p>
<p>我的做法，难点在于如何3位3位加一个逗号，我用栈来存储。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="type">int</span> c = a + b;</span><br><span class="line">    <span class="type">int</span> cishu;</span><br><span class="line">    string s = <span class="built_in">to_string</span>(c);</span><br><span class="line">    stack&lt;<span class="type">char</span>&gt; st;</span><br><span class="line">    <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = s.<span class="built_in">length</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        st.<span class="built_in">push</span>(s[i]);</span><br><span class="line">        flag++;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">3</span> &amp;&amp; i != <span class="number">0</span> &amp;&amp; s[i - <span class="number">1</span>] != <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            st.<span class="built_in">push</span>(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!st.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; st.<span class="built_in">top</span>();</span><br><span class="line">        st.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for(int i=0;i&lt;s.length();i++)&#123;</span></span><br><span class="line">    <span class="comment">// 	cout&lt;&lt;s[i];</span></span><br><span class="line">    <span class="comment">// 	if(s[i]!=&#x27;-&#x27;&amp;&amp;(i!=s.length()-1)&amp;&amp;(s.length()-i-1)%3==0) cout&lt;&lt;&quot;,&quot;;//后面剩下3n个数时 要加&#x27;,&#x27;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大神的做法见注释，好像比较难想到。</p>
<h3 id="PAT-1002"><a href="#PAT-1002" class="headerlink" title="PAT 1002"></a>PAT 1002</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210330183857126.png" alt="image-20210330183857126"></p>
<p>多项式加法，通过第一个测试点不是很难。</p>
<p>注意点： <strong>系数为0时不进行输出。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    map&lt;<span class="type">int</span>,<span class="type">double</span>&gt; M;</span><br><span class="line">    <span class="type">int</span> n,m;   cin&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> a; <span class="type">double</span> b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        M[a] = b;</span><br><span class="line">    &#125;</span><br><span class="line">    cin&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="keyword">if</span>(M.<span class="built_in">find</span>(a)!=M.<span class="built_in">end</span>()) M[a] += b;</span><br><span class="line">        <span class="keyword">else</span> M[a] = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    map&lt;<span class="type">int</span>,<span class="type">double</span>&gt;::reverse_iterator iter;</span><br><span class="line">    <span class="type">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(iter = M.<span class="built_in">rbegin</span>();iter!=M.<span class="built_in">rend</span>();iter++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(iter-&gt;second!=<span class="number">0</span>) size++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;size;</span><br><span class="line">    <span class="keyword">for</span>(iter = M.<span class="built_in">rbegin</span>();iter!=M.<span class="built_in">rend</span>();iter++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(iter-&gt;second!=<span class="number">0</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;iter-&gt;first&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%.1lf&quot;</span>,iter-&gt;second);  <span class="comment">//保留一位小数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210330190215218.png" alt="image-20210330190215218"></p>
<p>具体还有两个未通过也不知道是怎么回事</p>
<p>map的倒叙遍历需要掌握</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(iter = M.<span class="built_in">rbegin</span>();iter!=M.<span class="built_in">rend</span>();iter++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(iter-&gt;second!=<span class="number">0</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;iter-&gt;first&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%.1lf&quot;</span>,iter-&gt;second);  <span class="comment">//保留一位小数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="PAT-1003-dijstra"><a href="#PAT-1003-dijstra" class="headerlink" title="PAT 1003 (dijstra)"></a>PAT 1003 (dijstra)</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210401155146524.png" alt="image-20210401155146524"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210401155200043.png" alt="image-20210401155200043"></p>
<p> 题目翻译：</p>
<p>你是一个救援队长，你要救援有危险的城市，你需要尽可能快的到达有危险的城市，并且带尽可能多的人。</p>
<p>输入：</p>
<p>第1行：4个正整数： 城市数量N、 路数量M、你在的城市、你要救援的城市。</p>
<p>第2行：N个整数，第i个数表示第i个城市的救援队数量。</p>
<p>然后M行：每一行表示一条路，三个数字分别是起点、终点、距离。</p>
<p>保证至少有一条路让你去你要救援的城市。</p>
<p>输出：</p>
<p>最短路径条数  可带的最多人数  (我输出理解成了最短路径长度…)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> *dist;   <span class="comment">//保存最短路径</span></span><br><span class="line"><span class="type">int</span> *visited;  <span class="comment">//s集合，表示已经访问过</span></span><br><span class="line"><span class="type">int</span> *rescue;    <span class="comment">//救援队</span></span><br><span class="line"><span class="type">int</span> **e;      <span class="comment">//邻接矩阵</span></span><br><span class="line"><span class="type">int</span> *pre;     <span class="comment">//pre记录路径</span></span><br><span class="line"><span class="type">int</span> *rm;      <span class="comment">//能够到达i点的最多人数</span></span><br><span class="line"><span class="type">int</span> *num_of_shortest;  <span class="comment">//能够到达i点的最短路径条数</span></span><br><span class="line"><span class="type">int</span> N,M,C1,C2;</span><br><span class="line"><span class="type">int</span> maxrescue = <span class="number">0</span>;  <span class="comment">//最大救援队数量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dist = <span class="keyword">new</span> <span class="type">int</span>[N];</span><br><span class="line">    visited = <span class="keyword">new</span> <span class="type">int</span>[N];</span><br><span class="line">    <span class="built_in">memset</span>(visited,<span class="number">0</span>,<span class="built_in">sizeof</span>(visited));</span><br><span class="line">    rescue = <span class="keyword">new</span> <span class="type">int</span>[N];</span><br><span class="line">    pre = <span class="keyword">new</span> <span class="type">int</span>[N];</span><br><span class="line">    <span class="built_in">memset</span>(pre,<span class="number">-1</span>,<span class="built_in">sizeof</span>(pre));</span><br><span class="line">    rm = <span class="keyword">new</span> <span class="type">int</span>[N];</span><br><span class="line">    <span class="built_in">memset</span>(rm,<span class="number">0</span>,<span class="built_in">sizeof</span>(rm));</span><br><span class="line">    num_of_shortest = <span class="keyword">new</span> <span class="type">int</span>[N];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;  <span class="comment">//初始化城市救援队数量</span></span><br><span class="line">        cin&gt;&gt;rescue[i];</span><br><span class="line">    &#125;</span><br><span class="line">    e = <span class="keyword">new</span> <span class="type">int</span>*[N];     <span class="comment">//初始化邻接矩阵</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        e[i] = <span class="keyword">new</span> <span class="type">int</span>[N];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;N;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==j) e[i][j]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> e[i][j]=<span class="number">9999</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        <span class="type">int</span> c1,c2,length;  </span><br><span class="line">        cin&gt;&gt;c1&gt;&gt;c2&gt;&gt;length;</span><br><span class="line">        e[c1][c2] = length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for(int i=0;i&lt;N;i++)</span></span><br><span class="line">    <span class="comment">//     for(int j=0;j&lt;N;j++)</span></span><br><span class="line">    <span class="comment">//         cout&lt;&lt;&quot;e[&quot;&lt;&lt;i&lt;&lt;&quot;][&quot;&lt;&lt;j&lt;&lt;&quot;]&quot;&lt;&lt;e[i][j]&lt;&lt;endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    visited[C1] = <span class="number">1</span>;</span><br><span class="line">    num_of_shortest[C1] = <span class="number">1</span>;</span><br><span class="line">    rm[C1] = rescue[C1];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        dist[i] = e[C1][i];</span><br><span class="line">        <span class="keyword">if</span>(dist[i]&lt;<span class="number">9999</span>)&#123;   <span class="comment">//能够到达</span></span><br><span class="line">            pre[i]=C1;</span><br><span class="line">            rm[i] = rescue[C1]+rescue[i];</span><br><span class="line">            num_of_shortest[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cout&lt;&lt;e[C1][4]&lt;&lt;&quot; &quot;&lt;&lt;endl;</span></span><br><span class="line">    <span class="comment">// for(int i=0;i&lt;N;i++)&#123;</span></span><br><span class="line">    <span class="comment">//     cout&lt;&lt;i&lt;&lt;&quot; :&quot;&lt;&lt;dist[i]&lt;&lt;endl;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="type">int</span> min = <span class="number">99999</span>,u=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;   <span class="comment">//选出下一次要加入s集合的顶点</span></span><br><span class="line">            <span class="keyword">if</span>(!visited[i] &amp;&amp; dist[i]&lt;min)&#123;</span><br><span class="line">                min = dist[i];</span><br><span class="line">                u = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">if</span>(u==<span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        visited[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;    <span class="comment">//更新dist数组</span></span><br><span class="line">            <span class="keyword">if</span>(!visited[i] &amp;&amp; dist[u]+e[u][i]&lt;dist[i])&#123;</span><br><span class="line">                dist[i] = dist[u] + e[u][i];</span><br><span class="line">                pre[i]=u;</span><br><span class="line">                rm[i] = rm[u]+rescue[i];</span><br><span class="line">                num_of_shortest[i] = num_of_shortest[u];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!visited[i] &amp;&amp; dist[u]+e[u][i]==dist[i])&#123;</span><br><span class="line">                <span class="keyword">if</span>(rm[u]+rescue[i]&gt;rm[i])&#123;</span><br><span class="line">                    pre[i]=u;</span><br><span class="line">                    rm[i] = rm[u]+rescue[i];</span><br><span class="line">                &#125;</span><br><span class="line">                num_of_shortest[i] += num_of_shortest[u];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;N&gt;&gt;M&gt;&gt;C1&gt;&gt;C2;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">dijstra</span>();</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;num_of_shortest[C2]&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;rm[C2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210401160800655.png" alt="image-20210401160800655"></p>
<p>dijstra的套路算法，关键是需要增加几个判别的数组，一个是有多少条最短路径num_of_shortest，另一个是当前可以到达的最多救援队数量rm。</p>
<h3 id="PAT-1004（按层统计树的叶子节点）"><a href="#PAT-1004（按层统计树的叶子节点）" class="headerlink" title="PAT 1004（按层统计树的叶子节点）"></a>PAT 1004（按层统计树的叶子节点）</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210405155805312.png" alt="image-20210405155805312"></p>
<p>题意：按照每一层统计树的叶子节点个数</p>
<p>第一行输入 N&#x3D;2 树的节点       M&#x3D;1 非叶子节点个数</p>
<p>下面M行表示非叶子节点所跟的孩子  01 1 02    01表示 01号节点 ，1表示有一个孩子，02表示01的孩子的ID。</p>
<p><strong>题解</strong>：</p>
<p>第一步当然是想数据结构，用什么数据结构来存储这棵树呢？由于树的度不确定，我们很难使用二叉树的链式结构来存储，最初想到的是使用孩子兄弟链表进行存储，但最后发现构造这一棵树并不是太容易，而且我们只是需要统计每一层的非叶子节点数而已。我们不如直接使用结构体数组来存储这棵树，结构体包括ID，节点的孩子vector<int> child ，layer层数，这样我们统计每个节点是否是叶子节点的时候就可以使用child.size()来判断。</int></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Tree_Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> ID;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; child;</span><br><span class="line">    <span class="type">int</span> layer;   <span class="comment">//层数</span></span><br><span class="line">&#125;Tree_Node,*pTree_Node;</span><br></pre></td></tr></table></figure>

<p>其次就是有几个注意点：在分配内存空间的时候需要注意 如果是new，在堆上分配，内存的数据可以是任意的，意味着我们需要额外的初始化。如果使用Tseq[N+1]这种在栈上分配内存的状况，就可以不用初始化，这也导致我几个测试点过不了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Tseq = new Tree_Node[N+1];</span></span><br><span class="line">Tree_Node Tseq[N+<span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<p>还有一个坑点是，我们统计每一个节点的层数是，利用双亲节点的层数+1，这样有一个问题，要是先输入孩子节点，再输入双亲节点统计就有问题。<img src="../../../../AppData/Roaming/Typora/typora-user-images/image-20210405160649369.png" alt="image-20210405160649369" style="zoom:50%;"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tseq[childnum].layer = Tseq[id].layer+<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>所以需要对输入的结点ID的大小进行排序，确保上层的节点先被统计进来。这样做法虽然有点蠢，但最后得了27分。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Tree_Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> ID;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; child;</span><br><span class="line">    <span class="type">int</span> layer;   <span class="comment">//层数</span></span><br><span class="line">&#125;Tree_Node,*pTree_Node;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">next_input</span>&#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; numvec;</span><br><span class="line">&#125;next_input;</span><br><span class="line">vector&lt;next_input&gt; input_vector;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(next_input a,next_input b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.id&lt;b.id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N,M;   cin&gt;&gt;N&gt;&gt;M;    <span class="comment">//N节点数  M非叶子节点数  </span></span><br><span class="line">    <span class="keyword">if</span>(N==<span class="number">1</span>) &#123;cout&lt;&lt;<span class="string">&#x27;0&#x27;</span>; <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="comment">// Tree_Node* Tseq; </span></span><br><span class="line">    <span class="type">int</span> maxlayer;  <span class="comment">//统计最大层数</span></span><br><span class="line">    <span class="comment">// Tseq = new Tree_Node[N+1];</span></span><br><span class="line">    Tree_Node Tseq[N+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">        Tseq[i].ID = i;  <span class="comment">//分配序号</span></span><br><span class="line">    Tseq[<span class="number">1</span>].layer = <span class="number">1</span>;  <span class="comment">//01节点为根节点，层数为1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;  <span class="comment">//把输入变成一个vector，然后再排序，以免计算层数时出错</span></span><br><span class="line">        next_input input;</span><br><span class="line">        <span class="type">int</span> id,num,child;  </span><br><span class="line">        cin&gt;&gt;id&gt;&gt;num;</span><br><span class="line">        input.id = id;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;num;j++)&#123;</span><br><span class="line">            cin&gt;&gt;child;  input.numvec.<span class="built_in">push_back</span>(child);</span><br><span class="line">        &#125;</span><br><span class="line">        input_vector.<span class="built_in">push_back</span>(input);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(input_vector.<span class="built_in">begin</span>(),input_vector.<span class="built_in">end</span>(),cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;  <span class="comment">//统计节点的层数和孩子</span></span><br><span class="line">        <span class="type">int</span> id,num,childnum;</span><br><span class="line">        id = input_vector[i].id;</span><br><span class="line">        num = input_vector[i].numvec.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;num;j++)&#123;</span><br><span class="line">            childnum = input_vector[i].numvec[j];</span><br><span class="line">            Tseq[id].child.<span class="built_in">push_back</span>(childnum);</span><br><span class="line">            Tseq[childnum].layer = Tseq[id].layer+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//统计最大层数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        maxlayer = <span class="built_in">max</span>(maxlayer,Tseq[i].layer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; Map;  <span class="comment">//第i层有几个叶子节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=maxlayer;i++)&#123;</span><br><span class="line">        Map[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(Tseq[i].child.<span class="built_in">size</span>()==<span class="number">0</span>)&#123;   <span class="comment">//是叶子节点</span></span><br><span class="line">            Map[Tseq[i].layer]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出</span></span><br><span class="line">    map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; ::iterator iter;</span><br><span class="line">    cout&lt;&lt;Map.<span class="built_in">begin</span>()-&gt;second;</span><br><span class="line">    iter = Map.<span class="built_in">begin</span>(); iter++;</span><br><span class="line">    <span class="keyword">for</span>(;iter!=Map.<span class="built_in">end</span>();iter++)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;iter-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210405160805791.png" alt="image-20210405160805791"></p>
<p>最后一个测试点有点懵</p>
<p>如果考虑到只有一个节点的情况，if(N&#x3D;&#x3D;1){ cout&lt;&lt;”1”&lt;&lt;endl;return 0;} 这句话会根据出现在不同的位置而产生不同的结果。</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210405161716830.png" alt="image-20210405161716830"></p>
<h3 id="PAT-1005"><a href="#PAT-1005" class="headerlink" title="PAT 1005"></a>PAT 1005</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210404205053583.png" alt="image-20210404205053583"></p>
<p>计算一个数的个位数字之和，英文输出。比较简单，十分钟搞定。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string Map[] = &#123;<span class="string">&quot;zero&quot;</span>,<span class="string">&quot;one&quot;</span>,<span class="string">&quot;two&quot;</span>,<span class="string">&quot;three&quot;</span>,<span class="string">&quot;four&quot;</span>,<span class="string">&quot;five&quot;</span>,<span class="string">&quot;six&quot;</span>,<span class="string">&quot;seven&quot;</span>,<span class="string">&quot;eight&quot;</span>,<span class="string">&quot;nine&quot;</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    string s=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:s)&#123;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;i&lt;&lt;&quot; &quot;;</span></span><br><span class="line">        count += (i-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    string ss = <span class="built_in">to_string</span>(count);</span><br><span class="line">    <span class="comment">// cout&lt;&lt;ss;</span></span><br><span class="line">    cout&lt;&lt;Map[ss[<span class="number">0</span>]-<span class="string">&#x27;0&#x27;</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;ss.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;Map[ss[i]-<span class="string">&#x27;0&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="PAT-1006"><a href="#PAT-1006" class="headerlink" title="PAT 1006"></a>PAT 1006</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210404211724478.png" alt="image-20210404211724478"></p>
<p>水题，比较来上班最早的和来上班最晚的，直接写一个结构体比较就好了，二十分钟能搞定。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">person</span>&#123;</span><br><span class="line">    string id;</span><br><span class="line">    string early;</span><br><span class="line">    string later;</span><br><span class="line">&#125;person;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sp</span><span class="params">(string a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(a.<span class="built_in">substr</span>(<span class="number">0</span>,<span class="number">2</span>)));</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(a.<span class="built_in">substr</span>(<span class="number">3</span>,<span class="number">2</span>)));</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(a.<span class="built_in">substr</span>(<span class="number">6</span>,<span class="number">2</span>)));</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmpearly</span><span class="params">(person early,person later)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = <span class="built_in">sp</span>(early.early);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; b = <span class="built_in">sp</span>(later.early);</span><br><span class="line">    <span class="keyword">if</span>(a[<span class="number">0</span>]==b[<span class="number">0</span>] &amp;&amp; a[<span class="number">1</span>]==b[<span class="number">1</span>])&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">2</span>]&lt;b[<span class="number">2</span>];</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a[<span class="number">0</span>]==b[<span class="number">0</span>])&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">1</span>]&lt;b[<span class="number">1</span>];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>]&lt;b[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmplater</span><span class="params">(person early,person later)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = <span class="built_in">sp</span>(early.later);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; b = <span class="built_in">sp</span>(later.later);</span><br><span class="line">    <span class="keyword">if</span>(a[<span class="number">0</span>]==b[<span class="number">0</span>] &amp;&amp; a[<span class="number">1</span>]==b[<span class="number">1</span>])&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">2</span>]&gt;b[<span class="number">2</span>];</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a[<span class="number">0</span>]==b[<span class="number">0</span>])&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">1</span>]&gt;b[<span class="number">1</span>];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>]&gt;b[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;person&gt;  vec_person;</span><br><span class="line">    <span class="type">int</span> n; cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        person p;</span><br><span class="line">        cin&gt;&gt;p.id&gt;&gt;p.early&gt;&gt;p.later;</span><br><span class="line">        vec_person.<span class="built_in">push_back</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(vec_person.<span class="built_in">begin</span>(),vec_person.<span class="built_in">end</span>(),cmpearly);</span><br><span class="line">    cout&lt;&lt;vec_person[<span class="number">0</span>].id&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">sort</span>(vec_person.<span class="built_in">begin</span>(),vec_person.<span class="built_in">end</span>(),cmplater);</span><br><span class="line">    cout&lt;&lt;vec_person[<span class="number">0</span>].id;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="PAT-1007（动态规划）"><a href="#PAT-1007（动态规划）" class="headerlink" title="PAT 1007（动态规划）"></a>PAT 1007（动态规划）</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210404222558427.png" alt="image-20210404222558427"></p>
<p>leetcode经典题，最大连续子序列和，一想就知道使用动态规划。</p>
<p>坑点1： output the one with the smallest indices i and j (as shown by the sample case). 这句话的意思是输出开始的数，而不是下标，整了一小时。</p>
<p>坑点2： If all the K numbers are negative, then its maximum sum is defined to be 0, and you  are supposed to output the first and the last numbers of the whole  sequence.  这句话记得看就好</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; seq;</span><br><span class="line">    <span class="type">int</span> n; cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a; cin&gt;&gt;a; seq.<span class="built_in">push_back</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> dp[seq.<span class="built_in">size</span>()];</span><br><span class="line">    <span class="type">int</span> pre[seq.<span class="built_in">size</span>()];</span><br><span class="line">    dp[<span class="number">0</span>] = seq[<span class="number">0</span>];  pre[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> maxsub = dp[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> maxi=<span class="number">0</span>,maxj=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;seq.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[i<span class="number">-1</span>]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            dp[i] = dp[i<span class="number">-1</span>]+seq[i];</span><br><span class="line">            pre[i] = pre[i<span class="number">-1</span>];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            dp[i] = seq[i];</span><br><span class="line">            pre[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[i]&gt;maxsub)&#123;</span><br><span class="line">            maxsub = dp[i];  maxi = pre[i]; maxj = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(maxsub&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&#x27;0&#x27;</span>&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;seq[<span class="number">0</span>]&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;seq[seq.<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;maxsub&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;seq[maxi]&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;seq[maxj];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我这儿的dp定义的略有不同，不过无伤大雅，dp[i]是指以i结尾的最大连续子序列和。</p>
<h3 id="PAT-1008"><a href="#PAT-1008" class="headerlink" title="PAT 1008"></a>PAT 1008</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210404223852830.png" alt="image-20210404223852830"></p>
<p>水题。电梯上升一层6s，下降一层4s，每层有需要停留5s，求电梯所需要时间。十分钟解决。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a; cin&gt;&gt;a; v.<span class="built_in">push_back</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> temp = <span class="number">0</span>;  <span class="comment">//代表现在电梯到哪一层了</span></span><br><span class="line">    <span class="type">int</span> total_time = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;v.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>((v[i]-temp)&gt;=<span class="number">0</span>)&#123;  <span class="comment">//上升</span></span><br><span class="line">            total_time += (v[i]-temp)*<span class="number">6</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  <span class="comment">//下降</span></span><br><span class="line">            total_time += (temp-v[i])*<span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = v[i];</span><br><span class="line">        total_time += <span class="number">5</span>; <span class="comment">//停留</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;total_time;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="PAT-1009"><a href="#PAT-1009" class="headerlink" title="PAT 1009"></a>PAT 1009</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210409154552498.png" alt="image-20210409154552498"></p>
<p>和pat1002类似，这里做的是乘法A * B,可以采用暴力法二重循环。</p>
<p>注意的是如果系数等于0则不输出。</p>
<p>不能使用cout&lt;&lt;M.size();  来统计输出的个数，因为会把系数为0的统计进去。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">map&lt;<span class="type">int</span>,<span class="type">double</span>&gt; M;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n; cin&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> a[n]; <span class="type">double</span> b[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i]&gt;&gt;b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> k; cin&gt;&gt;k;</span><br><span class="line">    <span class="type">int</span> ai; <span class="type">double</span> bi;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">        cin&gt;&gt;ai&gt;&gt;bi;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="type">int</span> exponent = ai+a[j];</span><br><span class="line">            <span class="type">double</span> coefficient = bi*b[j];</span><br><span class="line">            <span class="keyword">if</span>(M.<span class="built_in">find</span>(exponent)!=M.<span class="built_in">end</span>())&#123;</span><br><span class="line">                M[exponent] += coefficient;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                M[exponent] = coefficient;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cout&lt;&lt;M.size();</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    map&lt;<span class="type">int</span>,<span class="type">double</span>&gt;::reverse_iterator iter;</span><br><span class="line">    <span class="keyword">for</span>(iter = M.<span class="built_in">rbegin</span>();iter!=M.<span class="built_in">rend</span>();iter++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(iter-&gt;second!=<span class="number">0</span>) count++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;count;</span><br><span class="line">    <span class="keyword">for</span>(iter = M.<span class="built_in">rbegin</span>();iter!=M.<span class="built_in">rend</span>();iter++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(iter-&gt;second!=<span class="number">0</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;iter-&gt;first&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%.1lf&quot;</span>,iter-&gt;second);  <span class="comment">//保留一位小数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="PAT-1010（数学题）"><a href="#PAT-1010（数学题）" class="headerlink" title="PAT 1010（数学题）"></a>PAT 1010（数学题）</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210410202035024.png" alt="image-20210410202035024"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210410202048687.png" alt="image-20210410202048687"></p>
<p>题目大意：N1 N2 tag radix</p>
<p>N1 N2 为两个数，基数未定，范围从[0-9] [a-z]，radix表示一个数的基数（tag&#x3D;1，则表示N1 的基数，tag&#x3D;2则表示N2的基数）我们要求另一个数的基数，使得N1&#x3D;N2。若不存在则输出”Impossible”。</p>
<p>最初的想法是把一个数的十进制算出来，另一个数从2 一直往上遍历，遍历到什么时候是个头呢，无从知晓。看了答案之后方才明白。</p>
<p><strong>进制范围的确定</strong>   （关键步骤+二分查找）</p>
<p>进制的最小取值为：各个位数最大值+1 如123的最小进制一定大于3， abc的最小进制一定大于12  （这个比较好理解）</p>
<p>现在来讨论进制的上限（max_radix）  (这个不好理解)<br>　　那么现在在题目中，给出了两个数，一个数记为a是已知进制的，另一个记为b未知，假设a&#x3D;675,为10进制，b&#x3D;1，未知进制<br>　　很显然，b的最低进制min_radix是2<br>　　那么b的最高进制max_radix 是多少呢<br>　　我们的目的是让a&#x3D;b，b不可过小也不可过大<br>　　<br>　　假设 max_radix&#x3D;1000<br>　　很显然b &#x3D; 1(1000) &#x3D; 1000 &gt; a &#x3D; 675<br>　　所以，发现了吗<br>　　想让a&#x3D;b，b的最大进制就是a的值,即675<br>　　因为我举的例子比较特殊，如果b不为1，那么就很难直接得到b的精确的最高进制max_radix<br>　　但是 ，可以肯定的是，当b为1 的时候，max_radix是最大的（因为此时b最小）<br>　　因此，我们虽然不知道b&#x3D;10,20,80,13671…时，对应的max_radix是多少，但是，他们一定比b&#x3D;1对应的max_radix小<br>　　那么我们就可以用最大的max_radix作为进制的上限，在min_radix 到max_radix中二分查找<br>　　同时需要注意，max_radix&gt;&#x3D;min_radix<br>　　故有 max_radix &#x3D; max(a,min_radix);</p>
<p><strong>坑点</strong>：</p>
<p>计算过程中会出现数据溢出。<br> 举个极端例子：<br> 一亿进制的zzzzzzzzzz转化为十进制。 即使用long long也无法保存。<br> 那么应该怎么判断呢？ 可以判断计算结束后的值是否小于0，因为溢出后的值一定小于0</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210410202935463.png" alt="image-20210410202935463"></p>
<p>这一句显得至关重要，有6个测试点来自这。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">transfer_to_ten</span><span class="params">(string a,<span class="type">int</span> radix)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll total=<span class="number">0</span>;</span><br><span class="line">    ll basement = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=a.<span class="built_in">length</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;=<span class="string">&#x27;9&#x27;</span>) total += (a[i]-<span class="string">&#x27;0&#x27;</span>)*basement;</span><br><span class="line">        <span class="keyword">else</span> total += (a[i]-<span class="string">&#x27;a&#x27;</span>+<span class="number">10</span>)*basement;</span><br><span class="line">        basement *= radix;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_min_base</span><span class="params">(string a)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> min_base = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">        <span class="comment">// if(a[i]&lt;=&#x27;9&#x27;) min_base = max(min_base,a[i]-&#x27;0&#x27;+1);</span></span><br><span class="line">        <span class="comment">// else min_base = max(min_base,a[i]-&#x27;a&#x27;+11);</span></span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;=<span class="string">&#x27;9&#x27;</span>) min_base = min_base&gt;(a[i]-<span class="string">&#x27;0&#x27;</span>+<span class="number">1</span>) ? min_base : (a[i]-<span class="string">&#x27;0&#x27;</span>+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> min_base = min_base&gt;(a[i]-<span class="string">&#x27;a&#x27;</span>+<span class="number">11</span>) ? min_base : (a[i]-<span class="string">&#x27;a&#x27;</span>+<span class="number">11</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min_base;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">search_base</span><span class="params">(string a,<span class="type">int</span> min_base,<span class="type">int</span> max_base,<span class="type">long</span> <span class="type">long</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(min_base&lt;<span class="number">2</span>) min_base = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(min_base&gt;max_base) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ll mid_base = min_base + (max_base-min_base)/<span class="number">2</span>;</span><br><span class="line">    ll temp = <span class="built_in">transfer_to_ten</span>(a,mid_base);</span><br><span class="line">    <span class="keyword">if</span>(temp==target) <span class="keyword">return</span> mid_base;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(temp&gt;target || temp&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">search_base</span>(a,min_base,mid_base<span class="number">-1</span>,target);  <span class="comment">//关键 temp可能会溢出</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">search_base</span>(a,mid_base+<span class="number">1</span>,max_base,target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a,b;</span><br><span class="line">    string cc;</span><br><span class="line">    ll tag,radix;</span><br><span class="line">    ll target;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b&gt;&gt;tag&gt;&gt;radix;</span><br><span class="line">    <span class="keyword">if</span>(tag==<span class="number">1</span>)&#123;</span><br><span class="line">        target = <span class="built_in">transfer_to_ten</span>(a,radix);</span><br><span class="line">        <span class="comment">// cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;radix;</span></span><br><span class="line">        <span class="comment">// cout&lt;&lt;&quot;target: &quot;&lt;&lt;target&lt;&lt;endl;</span></span><br><span class="line">        cc = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(tag==<span class="number">2</span>)&#123;</span><br><span class="line">        target = <span class="built_in">transfer_to_ten</span>(b,radix);</span><br><span class="line">        cc = a;</span><br><span class="line">    &#125;</span><br><span class="line">    ll min_base = <span class="built_in">find_min_base</span>(cc);</span><br><span class="line">    <span class="comment">// cout&lt;&lt;&quot;min_base: &quot;&lt;&lt;min_base&lt;&lt;endl;</span></span><br><span class="line">    ll max_base = target&gt;min_base ? target : min_base;</span><br><span class="line">    <span class="comment">// cout&lt;&lt;&quot;max_base: &quot;&lt;&lt;max_base&lt;&lt;endl;</span></span><br><span class="line">    ll mid_base = <span class="built_in">search_base</span>(cc,min_base,max_base,target);</span><br><span class="line">    <span class="keyword">if</span>(mid_base) cout&lt;&lt;mid_base;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;Impossible&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210410203111819.png" alt="image-20210410203111819"></p>
<p>第10个测试点据说是：10测试点是输入为0<br> 当其中一个输入为0时，base若等于最大数字加1则为1，但我们知道进制的最小值为2，故在搜索前需要进行检查。（不太清楚）</p>
<h3 id="PAT-1011"><a href="#PAT-1011" class="headerlink" title="PAT 1011"></a>PAT 1011</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210422153118330.png" alt="image-20210422153118330"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210422153134396.png" alt="image-20210422153134396"></p>
<p>给定三场比赛和每一场的结果的赔率，问怎么下注使利润最大。每一场都选最大的。无脑题，关键在于读懂题目。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ca</span>&#123;</span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="type">double</span> pro;</span><br><span class="line">&#125;ca;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(ca a,ca b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.pro&gt;b.pro;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> a[<span class="number">3</span>]=&#123;<span class="string">&#x27;W&#x27;</span>,<span class="string">&#x27;T&#x27;</span>,<span class="string">&#x27;L&#x27;</span>&#125;;</span><br><span class="line"><span class="type">double</span> res = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;vector&lt;ca&gt;&gt; <span class="built_in">v</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)&#123;</span><br><span class="line">            ca d; </span><br><span class="line">            cin&gt;&gt;d.pro;</span><br><span class="line">            d.a = a[j];</span><br><span class="line">            v[i].<span class="built_in">push_back</span>(d);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(v[i].<span class="built_in">begin</span>(),v[i].<span class="built_in">end</span>(),cmp);</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">        res *= v[i][<span class="number">0</span>].pro;</span><br><span class="line">        cout&lt;&lt;v[i][<span class="number">0</span>].a&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    res = (res*<span class="number">0.65</span><span class="number">-1</span>)*<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2f&quot;</span>,res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="PAT-1012"><a href="#PAT-1012" class="headerlink" title="PAT 1012"></a>PAT 1012</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210422163238958.png" alt="image-20210422163238958"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210422163249988.png" alt="image-20210422163249988"></p>
<p>这一题竟然解决了一个小时。</p>
<p>题目大意：输入学生 以及三门课的成绩，然后每输入一个学生的id就打印最高的排名和对应排名的分类。排名分成三门课的单独排名和平均分的排名。排名也有优先级，A&gt;C&gt;M&gt;E。还算模拟题吧。</p>
<p>我的思路是建立一个学生表Map[string , stu]；stu包含学生的信息，包括成绩，排名等等。在第一波输入的时候，我们可以将成绩信息，填入学生表，同时将每科的成绩分门别列进行排序，第二轮遍历学生表Map时我们按照成绩查找对应的排名，本来想用二分查找，（但也必须是改进的二分查找，查找目标&#x3D;&#x3D;target的最小边界）。然后printinfo函数输出每个学生的信息。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">stu</span>&#123;</span><br><span class="line">    string ID;</span><br><span class="line">    <span class="type">int</span> C,M,E,A;  <span class="comment">//成绩</span></span><br><span class="line">    <span class="type">int</span> rC,rM,rE,rA;  <span class="comment">//排名</span></span><br><span class="line">&#125;stu;</span><br><span class="line">map&lt;string,stu&gt; Map;  <span class="comment">//学生表</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; CC;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; MM;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; EE;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; AA;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// int binary_search(vector&lt;int&gt; A,int target,int l,int r)&#123;</span></span><br><span class="line"><span class="comment">//     if(l&gt;r) return -2;</span></span><br><span class="line"><span class="comment">//     int mid = (l+r)/2;</span></span><br><span class="line"><span class="comment">//     if(A[mid]==target) return mid+1;</span></span><br><span class="line"><span class="comment">//     if(A[mid]&gt;target) return binary_search(A,target,mid+1,r);</span></span><br><span class="line"><span class="comment">//     else return binary_search(A,target,l,mid-1);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt; A,<span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;A.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(A[i]==target) <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printstu</span><span class="params">(stu S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.rA&lt;=<span class="built_in">min</span>(S.rC,<span class="built_in">min</span>(S.rE,S.rM)))&#123;</span><br><span class="line">        cout&lt;&lt;S.rA&lt;&lt;<span class="string">&quot; A&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(S.rC&lt;=<span class="built_in">min</span>(S.rA,<span class="built_in">min</span>(S.rE,S.rM)))&#123;</span><br><span class="line">        cout&lt;&lt;S.rC&lt;&lt;<span class="string">&quot; C&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(S.rM&lt;=<span class="built_in">min</span>(S.rC,<span class="built_in">min</span>(S.rE,S.rA)))&#123;</span><br><span class="line">        cout&lt;&lt;S.rM&lt;&lt;<span class="string">&quot; M&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(S.rE&lt;=<span class="built_in">min</span>(S.rC,<span class="built_in">min</span>(S.rA,S.rM)))&#123;</span><br><span class="line">        cout&lt;&lt;S.rE&lt;&lt;<span class="string">&quot; E&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N,M; cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        string a; <span class="type">int</span> b,c,d;  cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;</span><br><span class="line">        CC.<span class="built_in">push_back</span>(b);   MM.<span class="built_in">push_back</span>(c);  </span><br><span class="line">        EE.<span class="built_in">push_back</span>(d); </span><br><span class="line">        <span class="type">int</span> aver = (<span class="type">int</span>)((<span class="type">double</span>)(b+c+d)/<span class="number">3.0</span>+<span class="number">0.5</span>);</span><br><span class="line">        AA.<span class="built_in">push_back</span>(aver);</span><br><span class="line">        stu temp; </span><br><span class="line">        temp.ID = a; temp.C=b; temp.M=c; temp.E=d; temp.A=aver;</span><br><span class="line">        Map[a] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(CC.<span class="built_in">begin</span>(),CC.<span class="built_in">end</span>(),cmp);</span><br><span class="line">    <span class="built_in">sort</span>(EE.<span class="built_in">begin</span>(),EE.<span class="built_in">end</span>(),cmp);</span><br><span class="line">    <span class="built_in">sort</span>(MM.<span class="built_in">begin</span>(),MM.<span class="built_in">end</span>(),cmp);</span><br><span class="line">    <span class="built_in">sort</span>(AA.<span class="built_in">begin</span>(),AA.<span class="built_in">end</span>(),cmp);</span><br><span class="line">    map&lt;string,stu&gt; :: iterator iter;</span><br><span class="line">    <span class="keyword">for</span>(iter=Map.<span class="built_in">begin</span>();iter!=Map.<span class="built_in">end</span>();iter++)&#123;</span><br><span class="line">        <span class="comment">// int a = binary_search(AA,iter-&gt;second.A,0,AA.size()-1);</span></span><br><span class="line">        <span class="comment">// iter-&gt;second.rA = binary_search(AA,iter-&gt;second.A,0,AA.size()-1);</span></span><br><span class="line">        <span class="comment">// iter-&gt;second.rC = binary_search(CC,iter-&gt;second.C,0,CC.size()-1);</span></span><br><span class="line">        <span class="comment">// iter-&gt;second.rE = binary_search(EE,iter-&gt;second.E,0,EE.size()-1);</span></span><br><span class="line">        <span class="comment">// iter-&gt;second.rM = binary_search(MM,iter-&gt;second.M,0,MM.size()-1);</span></span><br><span class="line">        iter-&gt;second.rA = <span class="built_in">search</span>(AA,iter-&gt;second.A);</span><br><span class="line">        iter-&gt;second.rC = <span class="built_in">search</span>(CC,iter-&gt;second.C);</span><br><span class="line">        iter-&gt;second.rE = <span class="built_in">search</span>(EE,iter-&gt;second.E);</span><br><span class="line">        iter-&gt;second.rM = <span class="built_in">search</span>(MM,iter-&gt;second.M);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        string s;  cin&gt;&gt;s;</span><br><span class="line">        <span class="keyword">if</span>(Map.<span class="built_in">find</span>(s)!=Map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="built_in">printstu</span>(Map[s]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;N/A&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i!=M<span class="number">-1</span>) cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210422163816564.png" alt="image-20210422163816564"></p>
<h3 id="PAT-1013（连通分量）"><a href="#PAT-1013（连通分量）" class="headerlink" title="PAT 1013（连通分量）"></a>PAT 1013（连通分量）</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210422172221670.png" alt="image-20210422172221670"></p>
<p>题意：给出城市个数为N，连接城市间的道路的条数为M，以及询问次数为K</p>
<p>然后输入这M条道路连接的两个端点城市的编号Ａ和Ｂ</p>
<p>然后是K次询问，每次询问的方法是：给出一个编号为Q城市，然后将这个城市和与其相连的道路从网络中删除，要求让你求出添加多少条道路，才能使得被删除了编号为Q的城市的网络仍然联通</p>
<p>转化成求连通分量个数。即图的遍历，我这里使用广度优先搜索遍历图，求连通分量k。</p>
<p>bfs(int node)；除去node结点的连通分量，从1..N遍历结点，设置一个visited数组表示该结点是否访问过。如果访问过则记作1.k++，然后是用一个栈广度优先搜索该连通分量中可以到达的结点。</p>
<p>最后需要增加的路径&#x3D;连通分量个数-1</p>
<p>注意：每一次考虑新的结点的时候visited必须复位。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> *visited;  <span class="comment">//1..N 0不用</span></span><br><span class="line"><span class="type">int</span> N,M,K;</span><br><span class="line"><span class="type">int</span> k;  <span class="comment">//连通分量个数</span></span><br><span class="line"><span class="type">int</span> **Graph;   <span class="comment">//Graph  1..N</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> node)</span></span>&#123;   <span class="comment">//不考虑node结点,求连通分量个数k</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==node) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(visited[i]) <span class="keyword">continue</span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; S;</span><br><span class="line">        visited[i]=<span class="number">1</span>;</span><br><span class="line">        k++;</span><br><span class="line">        S.<span class="built_in">push</span>(i);</span><br><span class="line">        <span class="keyword">while</span>(!S.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> top = S.<span class="built_in">top</span>(); S.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=N;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j==node) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(Graph[top][j] &amp;&amp; !visited[j]) &#123;</span><br><span class="line">                    visited[j]=<span class="number">1</span>;</span><br><span class="line">                    S.<span class="built_in">push</span>(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;N&gt;&gt;M&gt;&gt;K;</span><br><span class="line">    <span class="comment">//visited数组初始化，表示没有访问过</span></span><br><span class="line">    visited = <span class="keyword">new</span> <span class="type">int</span>[N+<span class="number">1</span>];  </span><br><span class="line">    <span class="built_in">memset</span>(visited,<span class="number">0</span>,<span class="built_in">sizeof</span>(visited));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Graph初始化</span></span><br><span class="line">    Graph = <span class="keyword">new</span> <span class="type">int</span>*[N+<span class="number">1</span>];  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        Graph[i] = <span class="keyword">new</span> <span class="type">int</span>[N+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(Graph[i],<span class="number">0</span>,<span class="built_in">sizeof</span>(Graph[i]));  <span class="comment">//Graph[i][u] = 0代表i,u之间没有路径</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;  </span><br><span class="line">        <span class="type">int</span> a,b; cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        Graph[a][b] = <span class="number">1</span>;</span><br><span class="line">        Graph[b][a] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;K;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a; cin&gt;&gt;a;</span><br><span class="line">        k = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// memset(visited,0,sizeof(visited));</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++) visited[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">bfs</span>(a);</span><br><span class="line">        cout&lt;&lt;k<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(i!=K<span class="number">-1</span>) cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">7 5 7</span></span><br><span class="line"><span class="comment">1 2</span></span><br><span class="line"><span class="comment">1 3</span></span><br><span class="line"><span class="comment">1 4</span></span><br><span class="line"><span class="comment">2 5</span></span><br><span class="line"><span class="comment">6 7</span></span><br><span class="line"><span class="comment">2 1 3 4 5 6 7</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210422172806405.png" alt="image-20210422172806405"></p>
<h3 id="PAT-1014-队列模拟"><a href="#PAT-1014-队列模拟" class="headerlink" title="PAT 1014 (队列模拟)"></a>PAT 1014 (队列模拟)</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210422174327230.png" alt="image-20210422174327230"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210422174337754.png" alt="image-20210422174337754"></p>
<p><strong>题目大意</strong>：银行有N个窗口，每个窗口划分成两部分，黄线内的和黄线外的</p>
<p>顾客排队有以下几个要求：</p>
<p>1、每个窗口黄线内可以站M个人，第（MN+1)个人得排在黄线外</p>
<p>2、每个顾客选择最短的队伍，（队伍长度相同选择序号小的）</p>
<p>3、顾客i将花费 Ti 的时间处理问题</p>
<p>3、每个窗口的第一位顾客将于8:00被服务</p>
<p>给定每个顾客的处理问题的时间，求每位顾客解决问题的时间点。</p>
<p>输入：第一行 N(窗口）、M（黄线内的人数）、K（顾客人数）、Q（要求的顾客完成时间）  五点之前下班</p>
<p><strong>思路</strong>：用一个vector表示一个窗口，窗口里是一个queue<int>表示窗口队列，首先初始化窗口，之后模拟每一次完成（查找所有窗口剩余时间最少的出队，如果还有人在黄线外等候则加入该窗口的队列，然后更新每个窗口front元素的剩余时间）。持续下去直到所有窗口都为空。 用一个变量nowtime记录当前时间，也即每个顾客的完成时间。</int></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> N,M,K,Q;  <span class="comment">//N 窗口  M 黄线内人数  K 顾客人数  Q 询问时间</span></span><br><span class="line"><span class="type">int</span> Time[<span class="number">1001</span>];   <span class="comment">//表示第i位顾客还剩多少时间完成</span></span><br><span class="line"><span class="type">int</span> process[<span class="number">1001</span>];   <span class="comment">//最多有1001个顾客，time表示第i个顾客的完成时间，单位分钟</span></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; Custom;  <span class="comment">//顾客队列,按照编号进行</span></span><br><span class="line">vector&lt;queue&lt;<span class="type">int</span>&gt;&gt; Window; <span class="comment">//窗口vector，每个窗口维护一个队列，队列长度不超过M</span></span><br><span class="line"><span class="type">int</span> nowtime = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断所有窗口是否还有人在排队</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isemptyWindow</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;Window.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!Window[i].<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找最早出队的窗口号</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mintime</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> min_time = <span class="number">9999</span>; </span><br><span class="line">    <span class="type">int</span> min_i = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;Window.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!Window[i].<span class="built_in">empty</span>() &amp;&amp; Time[Window[i].<span class="built_in">front</span>()]&lt;min_time)&#123;</span><br><span class="line">            min_time = Time[Window[i].<span class="built_in">front</span>()];</span><br><span class="line">            min_i = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min_i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//更新每个窗口的出队时间</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> subtime,<span class="type">int</span> t)</span></span>&#123;  <span class="comment">//subtime减去的时间，t除外</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;Window.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i!=t &amp;&amp; !Window[i].<span class="built_in">empty</span>())&#123;</span><br><span class="line">            Time[Window[i].<span class="built_in">front</span>()] -= subtime;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">time_to_clock</span><span class="params">(<span class="type">int</span> time)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> hour = time/<span class="number">60</span>+<span class="number">8</span>;</span><br><span class="line">    <span class="type">int</span> minn = time%<span class="number">60</span>;</span><br><span class="line">    <span class="keyword">if</span>(hour&gt;<span class="number">17</span> || (hour==<span class="number">17</span>&amp;&amp;minn&gt;<span class="number">0</span>)) cout&lt;&lt;<span class="string">&quot;Sorry&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%02d:%02d&quot;</span>,hour,minn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="type">int</span> pCustom = <span class="number">1</span>;  <span class="comment">//顾客指针，在pCustom之前的都已经安排到Windows黄线内去了</span></span><br><span class="line">    cin&gt;&gt;N&gt;&gt;M&gt;&gt;K&gt;&gt;Q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=K;i++)&#123;</span><br><span class="line">        cin&gt;&gt;Time[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;    <span class="comment">//初始化窗口</span></span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;  Window.<span class="built_in">push_back</span>(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化窗口队列</span></span><br><span class="line">    <span class="keyword">while</span>(pCustom&lt;=N*M &amp;&amp; pCustom&lt;=K)&#123;</span><br><span class="line">        Window[(pCustom+<span class="number">1</span>)%M].<span class="built_in">push</span>(pCustom);  <span class="comment">//按照顺序每个窗口依次安排人</span></span><br><span class="line">        pCustom++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isemptyWindow</span>())&#123;</span><br><span class="line">        <span class="type">int</span> min_i = <span class="built_in">mintime</span>();  <span class="comment">//最早出队的窗口号</span></span><br><span class="line">        <span class="type">int</span> subtime = Time[Window[min_i].<span class="built_in">front</span>()];  <span class="comment">//需要更新的时间</span></span><br><span class="line">        nowtime += subtime;   <span class="comment">//更新当前时间</span></span><br><span class="line">        process[Window[min_i].<span class="built_in">front</span>()] = nowtime;   <span class="comment">//记录该顾客已经完成</span></span><br><span class="line">        Window[min_i].<span class="built_in">pop</span>();  <span class="comment">//当前窗口出队</span></span><br><span class="line">        <span class="keyword">if</span>(pCustom&lt;=K)&#123;</span><br><span class="line">            Window[min_i].<span class="built_in">push</span>(pCustom);   <span class="comment">//加入新元素</span></span><br><span class="line">            pCustom++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">update</span>(subtime,min_i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;Q;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a; cin&gt;&gt;a;</span><br><span class="line">        <span class="built_in">time_to_clock</span>(process[a]);</span><br><span class="line">        <span class="keyword">if</span>(i!=Q<span class="number">-1</span>) cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210422193023153.png" alt="image-20210422193023153"></p>
<p>看答案发现五点前还没处理完的不可能赶人家走吧，所以修改了一下代码</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210422193841669.png" alt="image-20210422193841669"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210422193858472.png" alt="image-20210422193858472"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210422193918612.png" alt="image-20210422193918612"></p>
<p>参考了网上的AC代码，还是没看出来自己为什么错</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> win_num, win_len, n, k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;win_num, &amp;win_len, &amp;n, &amp;k);</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">times</span>(win_num); <span class="comment">//times按顺序记录每个窗口中排队的人的结束时间，用以标示下一个进入的人的开始时间</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">data</span><span class="params">(n)</span>, <span class="title">start_time</span><span class="params">(n)</span></span>; <span class="comment">//data记录每个用户的耗时，start_time记录每个用户的开始时间</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;data[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n&amp;&amp;i&lt;win_num*win_len; i++)&#123;  <span class="comment">//先把黄线内的人排队排好</span></span><br><span class="line">        <span class="type">int</span> t = i%win_num; <span class="comment">//第t个窗口</span></span><br><span class="line">        start_time[i] = i&lt;win_num?<span class="number">0</span>:times[t][i/win_num<span class="number">-1</span>]; <span class="comment">//第一排的开始时间是0，之后的开始时间是前一排的结束时间，从times中获取</span></span><br><span class="line">        times[t].<span class="built_in">push_back</span>(start_time[i]+data[i]); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=win_num*win_len; i&lt;n; i++)&#123;  <span class="comment">//黄线外的人进入队伍</span></span><br><span class="line">        <span class="type">int</span> mint=<span class="number">540</span>, w=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;win_num; j++)&#123;  <span class="comment">//选择队伍，按队伍中size()-win_len个人的最早开始时间选择</span></span><br><span class="line">            <span class="type">int</span> st = times[j][times[j].<span class="built_in">size</span>()-win_len];</span><br><span class="line">            <span class="keyword">if</span>(st&lt;mint)&#123;</span><br><span class="line">                mint = st;</span><br><span class="line">                w = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(w==<span class="number">-1</span>) start_time[i] = <span class="number">540</span>; <span class="comment">//没窗口选，全都已经超时，按540计</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            start_time[i] = times[w][times[w].<span class="built_in">size</span>()<span class="number">-1</span>]; <span class="comment">//计算开始时间</span></span><br><span class="line">            times[w].<span class="built_in">push_back</span>(start_time[i]+data[i]); <span class="comment">//排队进入</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;k; i++)&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">        x--;</span><br><span class="line">        <span class="keyword">if</span>(start_time[x]&gt;=<span class="number">540</span>) <span class="built_in">printf</span>(<span class="string">&quot;Sorry\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%02d:%02d\n&quot;</span>, (start_time[x]+data[x])/<span class="number">60</span>+<span class="number">8</span>, (start_time[x]+data[x])%<span class="number">60</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="PAT-1015"><a href="#PAT-1015" class="headerlink" title="PAT 1015"></a>PAT 1015</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210426090709927.png" alt="image-20210426090709927"></p>
<p>最初这题题目没看懂</p>
<p>题目大意：给出一个素数，判断在d进制下反转后在十进制下是否是素数，如果是，则输出”Yes”，否，则输出”No”。</p>
<p>Sample input:</p>
<p>73 在十进制下反转 37</p>
<p>23(10111) 在2进制下反转(11101) 29 是质数</p>
<p>23在10进制下反转32不是质数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> z[<span class="number">101</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPrime</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;<span class="comment">//判断n是否是素数</span></span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> sqr = (<span class="type">int</span>) <span class="built_in">sqrt</span>(<span class="number">1.0</span> * n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= sqr; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Check</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> zNum = <span class="number">0</span>;<span class="comment">//长度</span></span><br><span class="line">    <span class="keyword">do</span>&#123;<span class="comment">//转换为p进制</span></span><br><span class="line">        z[zNum++] = n % d;</span><br><span class="line">        n /=d;</span><br><span class="line">    &#125;<span class="keyword">while</span>(n != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; zNum; ++i) &#123;<span class="comment">//逆序转为10进制</span></span><br><span class="line">        n = n * d + z[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isPrime</span>(n) == <span class="literal">true</span>)&#123;<span class="comment">//是素数</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, d;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n) != EOF)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;<span class="comment">//是负数，则退出循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;d);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isPrime</span>(n) == <span class="literal">false</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">Check</span>(n, d);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="PAT-1016"><a href="#PAT-1016" class="headerlink" title="PAT 1016"></a>PAT 1016</h3><p>题目大意： 打长途电话每分钟要花一定的费用，这取决于一天中打电话的时间。当客户开始连接长途电话时，时间会被记录下来，客户挂断电话的时间也会被记录下来。每个日历月，每一分钟都会向客户发送一张账单（按一天中的时间确定的费率）。你的工作是准备每个月的账单，给你一套电话记录。</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210429204459301.png" alt="image-20210429204459301"></p>
<h3 id="PAT-1039"><a href="#PAT-1039" class="headerlink" title="PAT 1039"></a>PAT 1039</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210420182936179.png" alt="image-20210420182936179"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210420182949322.png" alt="image-20210420182949322"></p>
<p>题目大意：有一个表保存了学生的选课信息，根据学生姓名来查询信息，输出该名学生选课情况。</p>
<p>样例解释，有11个学生，共5门课，接下来10行表示每门课的选课情况，例如2,3行，第4门课（4是课程号），7个人选，选课名单BOB5…</p>
<p>最后一行按顺序输出学生的名单。结果输出每个学生的名字，选课门数和课程号。</p>
<p>思路比较清楚，我定义的数据结构还算比较复杂</p>
<p>Query_List 代表学生的选课列表（索引就代表学号），Course_List代表课程的学生列表。</p>
<p>我们先把数据读入课程列表中，再用一个Map将学生的名字和学号一一对应。然后遍历Course_List，查到Course_List的学生选的哪门课就往Query_List中添加。最后将Query_List中的list排序，输出。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Query_List</span>&#123;</span><br><span class="line">    string name=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; list;</span><br><span class="line">&#125;Query_List;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Course_List</span>&#123;</span><br><span class="line">    <span class="type">int</span> cno;</span><br><span class="line">    vector&lt;string&gt; name;</span><br><span class="line">&#125;Course_List;</span><br></pre></td></tr></table></figure>

<p>坑点：最后一个测试数据比较大，据说要用scanf和printf，或者用char</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Query_List</span>&#123;</span><br><span class="line">    string name=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; list;</span><br><span class="line">&#125;Query_List;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Course_List</span>&#123;</span><br><span class="line">    <span class="type">int</span> cno;</span><br><span class="line">    vector&lt;string&gt; name;</span><br><span class="line">&#125;Course_List;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N,K;</span><br><span class="line">    cin&gt;&gt;N&gt;&gt;K;</span><br><span class="line">    vector&lt;Course_List&gt; CList;</span><br><span class="line">    vector&lt;Query_List&gt; QList;</span><br><span class="line">    map&lt;string,<span class="type">int</span>&gt; M;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=K;i++)&#123;</span><br><span class="line">        <span class="type">int</span> i1,i2;  </span><br><span class="line">        string i3;  </span><br><span class="line">        cin&gt;&gt;i1&gt;&gt;i2;</span><br><span class="line">        Course_List C; </span><br><span class="line">        C.cno = i1;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;i2;i++)&#123;</span><br><span class="line">            cin&gt;&gt;i3;  </span><br><span class="line">            C.name.<span class="built_in">push_back</span>(i3);</span><br><span class="line">        &#125;</span><br><span class="line">        CList.<span class="built_in">push_back</span>(C);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        string name;  cin&gt;&gt;name;</span><br><span class="line">        M[name] = i;</span><br><span class="line">        Query_List Q;  Q.name = name;</span><br><span class="line">        QList.<span class="built_in">push_back</span>(Q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;CList.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;CList[i].name.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">            <span class="comment">//M[CList[i].name[j]].list.push_back(CList[i].cno);</span></span><br><span class="line">            QList[M[CList[i].name[j]]].list.<span class="built_in">push_back</span>(CList[i].cno);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;QList.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="built_in">sort</span>(QList[i].list.<span class="built_in">begin</span>(),QList[i].list.<span class="built_in">end</span>());</span><br><span class="line">        cout&lt;&lt;QList[i].name&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;QList[i].list.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;QList[i].list.<span class="built_in">size</span>();k++)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;QList[i].list[k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i!=QList.<span class="built_in">size</span>()<span class="number">-1</span>)</span><br><span class="line">            cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210420183645306.png" alt="image-20210420183645306"></p>
<h3 id="PAT-1040（dp"><a href="#PAT-1040（dp" class="headerlink" title="PAT 1040（dp)"></a>PAT 1040（dp)</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210420235614633.png" alt="image-20210420235614633"></p>
<p>题目大意：查询长度最长的对称串</p>
<p>动态规划，dp[i] [j] 表示从 i 开始到 j 结束的对称串。（ i&lt;&#x3D;j ） </p>
<p>dp[i] [i] &#x3D; 1;</p>
<p>dp [i] [i+1] &#x3D; (s[i] &#x3D;&#x3D; s[i+1])</p>
<p>dp[i] [i+k] &#x3D; (s[i] &#x3D;&#x3D; s[i+k] &amp;&amp; dp[i+1] [i+k-1] )</p>
<p>i，j的状态取决于 i+1,j-1是不是对称串</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="built_in">getline</span>(cin,s);</span><br><span class="line">    <span class="type">int</span> length = s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">bool</span> dp[length][length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;i++) <span class="built_in">memset</span>(dp[i],<span class="literal">false</span>,<span class="built_in">sizeof</span>(dp[i]));</span><br><span class="line">    <span class="type">int</span> maxlength = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//Initialize</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;i++) dp[i][i]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==s[i+<span class="number">1</span>]) &#123;dp[i][i+<span class="number">1</span>]=<span class="literal">true</span>; maxlength=<span class="number">2</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">2</span>;k&lt;length;k++)&#123;  <span class="comment">//步长</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length &amp;&amp; i+k&lt;length ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==s[i+k] &amp;&amp; dp[i+<span class="number">1</span>][i+k<span class="number">-1</span>]==<span class="literal">true</span>)&#123; </span><br><span class="line">                dp[i][i+k]=<span class="literal">true</span>;</span><br><span class="line">                maxlength=k+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;maxlength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="PAT-1041"><a href="#PAT-1041" class="headerlink" title="PAT 1041"></a>PAT 1041</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210420233542571.png" alt="image-20210420233542571"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210420233553640.png" alt="image-20210420233553640"></p>
<p>题目大意，找到最近的一个不重复的数，如果找不到输出none。</p>
<p>直接一个map存放出现的次数，之后再从前往后遍历。无脑题。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A;</span><br><span class="line">    <span class="type">int</span> N; cin&gt;&gt;N;</span><br><span class="line">    <span class="type">bool</span> unique = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> unicode;</span><br><span class="line">    <span class="type">int</span> Map[<span class="number">50000</span>];</span><br><span class="line">    <span class="built_in">memset</span>(Map,<span class="number">0</span>,<span class="built_in">sizeof</span>(Map));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a ;cin&gt;&gt;a;</span><br><span class="line">        A.<span class="built_in">push_back</span>(a);</span><br><span class="line">        Map[a]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="keyword">while</span>(!unique &amp;&amp; j&lt;A.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">if</span>(Map[A[j]]==<span class="number">1</span>)&#123;</span><br><span class="line">            unique = <span class="literal">true</span>;</span><br><span class="line">            unicode = A[j];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(unique) cout&lt;&lt;unicode;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;None&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="PAT-1081"><a href="#PAT-1081" class="headerlink" title="PAT 1081"></a>PAT 1081</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210423091333960.png" alt="image-20210423091333960"></p>
<p>简单题，模拟分数乘法操作。</p>
<p>注意点：题目准确说明数的范围是Long ing型，第四个测试点出现浮点错误，需要判断一下分母为0的情况。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">gcd</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a, <span class="type">long</span> <span class="type">long</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b == <span class="number">0</span> ? a:<span class="built_in">gcd</span>(b, a%b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N; cin&gt;&gt;N;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> fenzi[N]; <span class="type">long</span> <span class="type">long</span> fenmu[N];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld/%lld&quot;</span>,&amp;fenzi[i],&amp;fenmu[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> denominator = <span class="number">1</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> numerator = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++) denominator *= fenmu[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++) numerator += denominator/fenmu[i]*fenzi[i];</span><br><span class="line">    <span class="keyword">if</span>(denominator==<span class="number">0</span>)&#123;  <span class="comment">//这里一定要判断一下，第四个测试点可能会出现浮点错误</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> interger = numerator/denominator;</span><br><span class="line">    <span class="keyword">if</span>(interger) cout&lt;&lt;interger;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> re_numerator = numerator - interger*denominator;</span><br><span class="line">    <span class="keyword">if</span>(re_numerator)&#123;</span><br><span class="line">        <span class="keyword">if</span>(interger) cout&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> g = <span class="built_in">gcd</span>(re_numerator,denominator);</span><br><span class="line">        re_numerator /= g;    denominator/= g;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld/%lld&quot;</span>,re_numerator,denominator);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2021-7-10"><a href="#2021-7-10" class="headerlink" title="2021.7.10"></a>2021.7.10</h2><h3 id="PAT-1152"><a href="#PAT-1152" class="headerlink" title="PAT 1152"></a>PAT 1152</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210710153004327.png" alt="image-20210710153004327"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210710153023441.png" alt="image-20210710153023441"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210710153032898.png" alt="image-20210710153032898"></p>
<p>题目大意：给定一个N位的数，寻找第一次出现的m位素数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">issushu</span><span class="params">(LL t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(LL s = <span class="number">2</span>; s&lt;<span class="built_in">sqrt</span>(t) ;s++ )&#123;</span><br><span class="line">        <span class="keyword">if</span>(t%s==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m,n;</span><br><span class="line">    string s=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    cin&gt;&gt;m&gt;&gt;n;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i+n&lt;=m;i++)&#123;</span><br><span class="line">        res = s.<span class="built_in">substr</span>(i,n);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">issushu</span>(<span class="built_in">stoi</span>(res)))&#123;</span><br><span class="line">            cout&lt;&lt;res;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag==<span class="literal">false</span>) cout&lt;&lt;<span class="string">&quot;404&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210710153216499.png" alt="image-20210710153216499"></p>
<h3 id="PAT-1153"><a href="#PAT-1153" class="headerlink" title="PAT 1153"></a>PAT 1153</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210710210514325.png" alt="image-20210710210514325"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210710210537819.png" alt="image-20210710210537819"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210710210558121.png" alt="image-20210710210558121"></p>
<p>题目大意：给出一组学生的准考证号和成绩，准考证号包含了等级(乙甲顶)，考场号，日期，和个人编号信息，并有三种查询方式<br>查询一：给出考试等级，找出该等级的考生，按照成绩降序，准考证升序排序<br>查询二：给出考场号，统计该考场的考生数量和总得分<br>查询三：给出考试日期，查询改日期下所有考场的考试人数，按照人数降序，考场号升序排序<br><strong>修改前的代码</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">patinfo</span>&#123;</span><br><span class="line">    <span class="type">char</span> type;</span><br><span class="line">    string total;</span><br><span class="line">    string site;</span><br><span class="line">    string testdate;</span><br><span class="line">    string testee_num;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">&#125;patinfo;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp1</span><span class="params">(patinfo A,patinfo B)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(A.score==B.score)&#123;</span><br><span class="line">        <span class="keyword">return</span> A.total&lt;B.total;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> A.score&gt;B.score;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">flag_2</span><span class="params">(pair&lt;string,<span class="type">int</span>&gt; o1,pair&lt;string,<span class="type">int</span>&gt; o2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> o1.second&gt;o2.second;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;patinfo&gt; PatList;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;a.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="type">int</span> N,M;   <span class="comment">//N个数，M个问题</span></span><br><span class="line">    cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        string aa;  cin&gt;&gt;aa;</span><br><span class="line">        <span class="type">int</span> score; cin&gt;&gt;score;</span><br><span class="line">        patinfo patexample;</span><br><span class="line">        patexample.total = aa;</span><br><span class="line">        patexample.type = aa[<span class="number">0</span>];</span><br><span class="line">        patexample.site = aa.<span class="built_in">substr</span>(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">        patexample.testdate = aa.<span class="built_in">substr</span>(<span class="number">4</span>,<span class="number">6</span>);</span><br><span class="line">        patexample.testee_num = aa.<span class="built_in">substr</span>(<span class="number">10</span>,<span class="number">3</span>);</span><br><span class="line">        patexample.score = score;</span><br><span class="line">        PatList.<span class="built_in">push_back</span>(patexample);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        <span class="type">int</span> query;  cin&gt;&gt;query;</span><br><span class="line">        <span class="keyword">if</span>(query==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">char</span> T;  cin&gt;&gt;T;</span><br><span class="line">            vector&lt;patinfo&gt; p1;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;PatList.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(PatList[j].type==T)&#123;</span><br><span class="line">                    p1.<span class="built_in">push_back</span>(PatList[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">sort</span>(p1.<span class="built_in">begin</span>(),p1.<span class="built_in">end</span>(),cmp1);</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Case &quot;</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">&quot;: 1 &quot;</span>&lt;&lt;T&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">if</span>(p1.<span class="built_in">size</span>()==<span class="number">0</span>) cout&lt;&lt;<span class="string">&quot;NA&quot;</span>;   <span class="comment">//不符合情况</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;p1.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                cout&lt;&lt;p1[j].total&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;p1[j].score;</span><br><span class="line">                <span class="keyword">if</span>(j&lt;p1.<span class="built_in">size</span>()<span class="number">-1</span>) cout&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(query==<span class="number">2</span>)&#123;</span><br><span class="line">            string aa;  cin&gt;&gt;aa;</span><br><span class="line">            <span class="type">int</span> number = <span class="number">0</span>; <span class="type">int</span> total = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;PatList.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(PatList[j].site==aa)&#123;</span><br><span class="line">                    number++; total+=PatList[j].score;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Case &quot;</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">&quot;: 2 &quot;</span>&lt;&lt;aa&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">if</span>(number==<span class="number">0</span>) cout&lt;&lt;<span class="string">&quot;NA&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                cout&lt;&lt;number&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;total;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(query==<span class="number">3</span>)&#123;</span><br><span class="line">            string aa; cin&gt;&gt;aa;</span><br><span class="line">            unordered_map&lt;string,<span class="type">int</span>&gt; M;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;PatList.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(PatList[j].testdate==aa)&#123;</span><br><span class="line">                    string cc = PatList[j].site;</span><br><span class="line">                    <span class="keyword">if</span>(M.<span class="built_in">find</span>(cc)==M.<span class="built_in">end</span>())&#123;</span><br><span class="line">                        M[cc] = <span class="number">1</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        M[cc] += <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            vector&lt;pair&lt;string,<span class="type">int</span>&gt;&gt; <span class="built_in">dic1</span>(M.<span class="built_in">begin</span>(),M.<span class="built_in">end</span>());</span><br><span class="line">            <span class="built_in">sort</span>(dic1.<span class="built_in">begin</span>(),dic1.<span class="built_in">end</span>(),flag_2);</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Case &quot;</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">&quot;: 3 &quot;</span>&lt;&lt;aa&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">if</span>(dic1.<span class="built_in">size</span>()==<span class="number">0</span>) cout&lt;&lt;<span class="string">&quot;NA&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;dic1.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                cout&lt;&lt;dic1[j].first&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;dic1[j].second;</span><br><span class="line">                <span class="keyword">if</span>(j&lt;dic1.<span class="built_in">size</span>()<span class="number">-1</span>) cout&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//换行</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;N<span class="number">-1</span>) cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210710211717494.png" alt="image-20210710211717494"></p>
<p>改后发现格式不需要那么复杂</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">patinfo</span>&#123;</span><br><span class="line">    <span class="type">char</span> type;</span><br><span class="line">    string total;</span><br><span class="line">    string site;</span><br><span class="line">    string testdate;</span><br><span class="line">    string testee_num;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">&#125;patinfo;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp1</span><span class="params">(patinfo A,patinfo B)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(A.score==B.score)&#123;</span><br><span class="line">        <span class="keyword">return</span> A.total&lt;B.total;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> A.score&gt;B.score;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">flag_2</span><span class="params">(pair&lt;string,<span class="type">int</span>&gt; o1,pair&lt;string,<span class="type">int</span>&gt; o2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(o1.second==o2.second)&#123;</span><br><span class="line">        <span class="keyword">return</span> o1.first&lt;o2.first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o1.second&gt;o2.second;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;patinfo&gt; PatList;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;a.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="type">int</span> N,M;   <span class="comment">//N个数，M个问题</span></span><br><span class="line">    cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        string aa;  cin&gt;&gt;aa;</span><br><span class="line">        <span class="type">int</span> score; cin&gt;&gt;score;</span><br><span class="line">        patinfo patexample;</span><br><span class="line">        patexample.total = aa;</span><br><span class="line">        patexample.type = aa[<span class="number">0</span>];</span><br><span class="line">        patexample.site = aa.<span class="built_in">substr</span>(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">        patexample.testdate = aa.<span class="built_in">substr</span>(<span class="number">4</span>,<span class="number">6</span>);</span><br><span class="line">        patexample.testee_num = aa.<span class="built_in">substr</span>(<span class="number">10</span>,<span class="number">3</span>);</span><br><span class="line">        patexample.score = score;</span><br><span class="line">        PatList.<span class="built_in">push_back</span>(patexample);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        <span class="type">int</span> query;  cin&gt;&gt;query;</span><br><span class="line">        <span class="keyword">if</span>(query==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">char</span> T;  cin&gt;&gt;T;</span><br><span class="line">            vector&lt;patinfo&gt; p1;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;PatList.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(PatList[j].type==T)&#123;</span><br><span class="line">                    p1.<span class="built_in">push_back</span>(PatList[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">sort</span>(p1.<span class="built_in">begin</span>(),p1.<span class="built_in">end</span>(),cmp1);</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Case &quot;</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">&quot;: 1 &quot;</span>&lt;&lt;T&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">if</span>(p1.<span class="built_in">size</span>()==<span class="number">0</span>) cout&lt;&lt;<span class="string">&quot;NA&quot;</span>&lt;&lt;endl;   <span class="comment">//不符合情况</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;p1.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                cout&lt;&lt;p1[j].total&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;p1[j].score&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(query==<span class="number">2</span>)&#123;</span><br><span class="line">            string aa;  cin&gt;&gt;aa;</span><br><span class="line">            <span class="type">int</span> number = <span class="number">0</span>; <span class="type">int</span> total = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;PatList.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(PatList[j].site==aa)&#123;</span><br><span class="line">                    number++; </span><br><span class="line">                    total+=PatList[j].score;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Case &quot;</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">&quot;: 2 &quot;</span>&lt;&lt;aa&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">if</span>(number==<span class="number">0</span>) cout&lt;&lt;<span class="string">&quot;NA&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                cout&lt;&lt;number&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;total&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(query==<span class="number">3</span>)&#123;</span><br><span class="line">            string aa; cin&gt;&gt;aa;</span><br><span class="line">            unordered_map&lt;string,<span class="type">int</span>&gt; M;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;PatList.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(PatList[j].testdate==aa)&#123;</span><br><span class="line">                    string cc = PatList[j].site;</span><br><span class="line">                    M[cc] += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            vector&lt;pair&lt;string,<span class="type">int</span>&gt;&gt; dic1;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> it : M) dic1.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(it.first, it.second));</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Case &quot;</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">&quot;: 3 &quot;</span>&lt;&lt;aa&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">if</span>(dic1.<span class="built_in">size</span>()==<span class="number">0</span>) cout&lt;&lt;<span class="string">&quot;NA&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="built_in">sort</span>(dic1.<span class="built_in">begin</span>(),dic1.<span class="built_in">end</span>(),flag_2);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;dic1.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                cout&lt;&lt;dic1[j].first&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;dic1[j].second&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后一格多一个换行也没关系</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210710220609566.png" alt="image-20210710220609566"></p>
<p><strong>修改后的AC代码</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">testees</span>&#123;</span><br><span class="line">    string id;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">&#125;testees;</span><br><span class="line">vector&lt;testees&gt; t;</span><br><span class="line"><span class="type">int</span> N,M,type;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(testees a,testees b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.score==b.score) <span class="keyword">return</span> a.id&lt;b.id;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a.score&gt;b.score;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp1</span><span class="params">(pair&lt;string,<span class="type">int</span>&gt; a,pair&lt;string,<span class="type">int</span>&gt; b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.second==b.second) <span class="keyword">return</span> a.first&lt;b.first;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a.second&gt;b.second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deal</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">    unordered_map&lt;string,<span class="type">int</span>&gt; mp;</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(type==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">sort</span>(t.<span class="built_in">begin</span>(),t.<span class="built_in">end</span>(),cmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s==t[i].id.<span class="built_in">substr</span>(<span class="number">0</span>,<span class="number">1</span>))&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s %d\n&quot;</span>,t[i].id.<span class="built_in">c_str</span>(),t[i].score);</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(type==<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>,count = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s==t[i].id.<span class="built_in">substr</span>(<span class="number">1</span>,<span class="number">3</span>))&#123;</span><br><span class="line">                sum += t[i].score;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag) <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,count,sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(type==<span class="number">3</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s==t[i].id.<span class="built_in">substr</span>(<span class="number">4</span>,<span class="number">6</span>))&#123;</span><br><span class="line">                mp[t[i].id.<span class="built_in">substr</span>(<span class="number">1</span>,<span class="number">3</span>)]++;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;pair&lt;string,<span class="type">int</span>&gt;&gt; <span class="built_in">vec_mp</span>(mp.<span class="built_in">begin</span>(),mp.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(vec_mp.<span class="built_in">begin</span>(),vec_mp.<span class="built_in">end</span>(),cmp1);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;vec_mp.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s %d\n&quot;</span>,vec_mp[i].first.<span class="built_in">c_str</span>(),vec_mp[i].second);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!flag) <span class="built_in">printf</span>(<span class="string">&quot;NA\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        testees ta;</span><br><span class="line">        cin&gt;&gt;ta.id&gt;&gt;ta.score;</span><br><span class="line">        t.<span class="built_in">push_back</span>(ta);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=M;i++)&#123;</span><br><span class="line">        cin&gt;&gt;type&gt;&gt;s;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case %d: %d %s\n&quot;</span>,i,type,s.<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="built_in">deal</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210710215520857.png" alt="image-20210710215520857"></p>
<h3 id="PAT-1154"><a href="#PAT-1154" class="headerlink" title="PAT 1154"></a>PAT 1154</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210710222438518.png" alt="image-20210710222438518"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210710222450152.png" alt="image-20210710222450152"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210710222458698.png" alt="image-20210710222458698"></p>
<p>题目大意：</p>
<p>相邻的两边不能同色，不用邻接矩阵，直接用边进行判断即可</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> V,E;</span><br><span class="line">    cin&gt;&gt;V&gt;&gt;E;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Graph</span><span class="params">(V,<span class="number">0</span>)</span></span>;</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; Edge;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;E;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a,b; cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        Edge.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(a,b));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> query; cin&gt;&gt;query;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;query;i++)&#123;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; M;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;V;i++)&#123;</span><br><span class="line">            <span class="type">int</span> a;  cin&gt;&gt;a;</span><br><span class="line">            Graph[i] = a;</span><br><span class="line">            M[a]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;E;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Graph[Edge[i].first] == Graph[Edge[i].second])&#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag==<span class="literal">false</span>) cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;M.<span class="built_in">size</span>()&lt;&lt;<span class="string">&quot;-coloring&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210710222553175.png" alt="image-20210710222553175"></p>
<h3 id="PAT-1155（回溯）"><a href="#PAT-1155（回溯）" class="headerlink" title="PAT 1155（回溯）"></a>PAT 1155（回溯）</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210710230530365.png" alt="image-20210710230530365"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210710230546043.png" alt="image-20210710230546043"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210710230612772.png" alt="image-20210710230612772"></p>
<p>题目大意：给定一个二叉树，判断是不是大顶堆或小顶堆，并且输出路径，从右到左输出，可以利用回溯法解决。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> MAX_OR_MIN;</span><br><span class="line"><span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="type">int</span> N;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; V;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrace</span><span class="params">(<span class="type">int</span> node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">2</span>*node&gt;N)&#123;   <span class="comment">//到头了，输出路径</span></span><br><span class="line">        res.<span class="built_in">push_back</span>(path);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">2</span>*node&lt;=N)&#123;</span><br><span class="line">        <span class="keyword">if</span>(MAX_OR_MIN==<span class="number">1</span>)&#123;   <span class="comment">//大顶堆</span></span><br><span class="line">            <span class="keyword">if</span>(V[<span class="number">2</span>*node]&gt;V[node])&#123;   <span class="comment">//不是大顶堆</span></span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(V[<span class="number">2</span>*node]&lt;V[node])&#123;   <span class="comment">//不是小顶堆</span></span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        path.<span class="built_in">push_back</span>(V[<span class="number">2</span>*node]);</span><br><span class="line">        <span class="built_in">backtrace</span>(<span class="number">2</span>*node);</span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">2</span>*node+<span class="number">1</span>&lt;=N)&#123;</span><br><span class="line">        <span class="keyword">if</span>(MAX_OR_MIN==<span class="number">1</span>)&#123;   <span class="comment">//大顶堆</span></span><br><span class="line">            <span class="keyword">if</span>(V[<span class="number">2</span>*node+<span class="number">1</span>]&gt;V[node])&#123;   <span class="comment">//不是大顶堆</span></span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(V[<span class="number">2</span>*node+<span class="number">1</span>]&lt;V[node])&#123;   <span class="comment">//不是小顶堆</span></span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        path.<span class="built_in">push_back</span>(V[<span class="number">2</span>*node+<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">backtrace</span>(<span class="number">2</span>*node+<span class="number">1</span>);</span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;N;</span><br><span class="line">    V.<span class="built_in">resize</span>(N+<span class="number">1</span>);  <span class="comment">//下标从1开始</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        cin&gt;&gt;V[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=N;i++)&#123;  <span class="comment">//确定大顶堆or小顶堆</span></span><br><span class="line">        <span class="keyword">if</span>(V[<span class="number">1</span>]&gt;V[i])&#123;</span><br><span class="line">            MAX_OR_MIN = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(V[<span class="number">1</span>]&lt;V[i])&#123;</span><br><span class="line">            MAX_OR_MIN = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    path.<span class="built_in">push_back</span>(V[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">backtrace</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=res.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;res[i].<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j==res[i].<span class="built_in">size</span>()<span class="number">-1</span>) cout&lt;&lt;res[i][j];</span><br><span class="line">            <span class="keyword">else</span> cout&lt;&lt;res[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">        <span class="keyword">if</span>(MAX_OR_MIN) cout&lt;&lt;<span class="string">&quot;Max Heap&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;Min Heap&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Not Heap&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210710230634645.png" alt="image-20210710230634645"></p>
<h2 id="2021-7-17"><a href="#2021-7-17" class="headerlink" title="2021.7.17"></a>2021.7.17</h2><h3 id="PAT-1148"><a href="#PAT-1148" class="headerlink" title="PAT 1148"></a>PAT 1148</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210717174748111.png" alt="image-20210717174748111"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210717174800947.png" alt="image-20210717174800947"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210717174812459.png" alt="image-20210717174812459"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210717174821796.png" alt="image-20210717174821796"></p>
<p>题目大意：狼人杀，给出N个人，其中只有两个是狼人，找出狼人，其中所有人中有两个人说谎，说谎的人里包含一个狼人。</p>
<p>本来是想通过假设说谎的人数 i,j  来找到狼人，后来发现通过假定狼人i,j来验证是否成立来得更加方便。整了一个半小时了都。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N; cin&gt;&gt;N;</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Data</span><span class="params">(N+<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        cin&gt;&gt;Data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="type">bool</span> istrue = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;N;i++)&#123;   <span class="comment">//i,j是werewolf,其他是human</span></span><br><span class="line">        <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;=N;j++)&#123;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">output</span><span class="params">(N+<span class="number">1</span>,<span class="number">-1</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=N;k++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(k==i || k==j) output[k] = <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">else</span> output[k] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//开始验证</span></span><br><span class="line">            <span class="type">int</span> fa = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> wefa = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=N;k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(Data[k] * output[<span class="built_in">abs</span>(Data[k])]&lt;<span class="number">0</span> ) &#123;</span><br><span class="line">                     fa++;</span><br><span class="line">                     <span class="keyword">if</span>(k==i || k==j) wefa++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(fa==<span class="number">2</span> &amp;&amp; wefa==<span class="number">1</span>)&#123;</span><br><span class="line">                cout&lt;&lt;i&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;j;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;No Solution&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210717175023186.png" alt="image-20210717175023186"></p>
<h3 id="PAT-1149"><a href="#PAT-1149" class="headerlink" title="PAT 1149"></a>PAT 1149</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210717193857126.png" alt="image-20210717193857126"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210717193908755.png" alt="image-20210717193908755"></p>
<p>题目大意：集装箱运输货物时，我们必须特别小心，不能把不相容的货物装在一只箱子里。比如氧化剂绝对不能跟易燃液体同箱，否则很容易造成爆炸。给定一张不相容物品的清单，需要你检查每一张集装箱货品清单，判断它们是否能装在同一只箱子里。对每箱货物清单，判断是否可以安全运输。如果没有不相容物品，则在一行中输出 Yes，否则输出 No～</p>
<p>分析：用map存储每一个货物的所有不兼容货物～在判断给出的一堆货物是否是相容的时候，判断任一货物的不兼容货物是否在这堆货物中～如果存在不兼容的货物，则这堆货物不能相容～如果遍历完所有的货物，都找不到不兼容的两个货物，则这堆货物就是兼容的～</p>
<p>用map存储每一个货物的所有不相容货物，然后逐一进行比较</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> M,N;  cin&gt;&gt;M&gt;&gt;N;</span><br><span class="line">    map&lt;string,vector&lt;string&gt;&gt; Map;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        string a,b; cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="keyword">if</span>(Map.<span class="built_in">find</span>(a)==Map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            vector&lt;string&gt; ss;  ss.<span class="built_in">push_back</span>(b);</span><br><span class="line">            Map[a] = ss;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            Map[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(Map.<span class="built_in">find</span>(b)==Map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            vector&lt;string&gt; ss;  ss.<span class="built_in">push_back</span>(a);</span><br><span class="line">            Map[b] = ss;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            Map[b].<span class="built_in">push_back</span>(a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="type">int</span> Q; cin&gt;&gt;Q;</span><br><span class="line">        <span class="function">vector&lt;string&gt; <span class="title">res</span><span class="params">(Q)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;Q;k++)&#123;</span><br><span class="line">            cin&gt;&gt;res[k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> ii=<span class="number">0</span>;ii&lt;res.<span class="built_in">size</span>();ii++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> jj=<span class="number">0</span>;jj&lt;res.<span class="built_in">size</span>();jj++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(ii==jj) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(Map.<span class="built_in">find</span>(res[ii])== Map.<span class="built_in">end</span>()) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    vector&lt;string&gt; temp = Map[res[ii]];</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> zz=<span class="number">0</span>;zz&lt;temp.<span class="built_in">size</span>();zz++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(temp[zz]==res[jj])&#123;</span><br><span class="line">                            flag = <span class="literal">false</span>; <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(flag==<span class="literal">false</span>) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">             <span class="keyword">if</span>(flag==<span class="literal">false</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag==<span class="literal">true</span>) cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210717193955512.png" alt="image-20210717193955512"></p>
<p>修改后，在查找是否兼容这一部分，需要通过map定位到该值所在的结点，然后往节点后的链表顺序查找，这样可能比较浪费时间。</p>
<p>牺牲空间的方法，首先开辟一个大空间res，存放所有可能的物品，每遍历一个物品，就往res中添入不可兼容的物品，之后再查找时，如果在res中，则不可兼容</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> M,N;  cin&gt;&gt;M&gt;&gt;N;</span><br><span class="line">    map&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;&gt; Map;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a,b; cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        Map[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">        Map[b].<span class="built_in">push_back</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> Q; cin&gt;&gt;Q;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(<span class="number">100000</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="keyword">while</span>(Q--)&#123;</span><br><span class="line">            cin&gt;&gt;x;</span><br><span class="line">            <span class="keyword">if</span>(res[x]==<span class="number">1</span>) flag = <span class="literal">false</span>;</span><br><span class="line">            res[x] = <span class="number">1</span>;   <span class="comment">//表示不兼容  </span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;Map[x].<span class="built_in">size</span>();j++)</span><br><span class="line">                res[Map[x][j]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag==<span class="literal">true</span>) cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210717202436733.png" alt="image-20210717202436733"></p>
<h3 id="PAT-1150"><a href="#PAT-1150" class="headerlink" title="PAT 1150"></a>PAT 1150</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210717210722721.png" alt="image-20210717210722721"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210717210738857.png" alt="image-20210717210738857"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210717210750029.png" alt="image-20210717210750029"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210717210800815.png" alt="image-20210717210800815"></p>
<p>题目大意：旅行商问题，给定一个图，并给定路径，判断该路径是否满足一下条件：</p>
<p>Ts a simple cycle 每个城市只访问一次，并且回到远点</p>
<p>Not a TS cycle 没有访问到每个城市，或者没有回到原点</p>
<p>NA not a TS cycle  路径不可达</p>
<p>TS cycle  多次访问每个城市</p>
<p>然后求距离最短的路径。</p>
<p>思路：构建邻接矩阵，一个visited数组判断是否访问过，按照路径一次模拟一遍即可，水题。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N,M; cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">    <span class="type">int</span> shortest = INT_MAX;  <span class="comment">//存放最短路径</span></span><br><span class="line">    <span class="type">int</span> shortestindex = <span class="number">-1</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">Graph</span>(N+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(N+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        <span class="type">int</span> d1,d2,dist; cin&gt;&gt;d1&gt;&gt;d2&gt;&gt;dist;</span><br><span class="line">        Graph[d1][d2] = dist;</span><br><span class="line">        Graph[d2][d1] = dist;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> T; cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> kk=<span class="number">1</span>;kk&lt;=T;kk++)&#123;</span><br><span class="line">        <span class="type">int</span> flag[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;  <span class="comment">//0 可达性  1 是否都访问过  2  是否多次访问</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">visited</span><span class="params">(N+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> total_cost = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> C;  cin&gt;&gt;C;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">path</span><span class="params">(C+<span class="number">1</span>)</span></span>;   <span class="comment">//路径也从1开始</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=C;i++)&#123;</span><br><span class="line">            cin&gt;&gt;path[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// visited[path[1]] = 1;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;C;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Graph[path[i]][path[i+<span class="number">1</span>]]==<span class="number">0</span>) &#123;</span><br><span class="line">                flag[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                total_cost += Graph[path[i]][path[i+<span class="number">1</span>]];</span><br><span class="line">                visited[path[i]] ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;visited.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[i]==<span class="number">0</span>) flag[<span class="number">1</span>] = <span class="number">1</span>;  <span class="comment">//没有访问过,flag=1 Not a TS cycle</span></span><br><span class="line">            <span class="keyword">if</span>(visited[i]&gt;<span class="number">1</span>) flag[<span class="number">2</span>] = <span class="number">1</span>;   <span class="comment">//多次访问  TS cycle;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//output</span></span><br><span class="line">        <span class="keyword">if</span>(!flag[<span class="number">0</span>] &amp;&amp; !flag[<span class="number">1</span>] &amp;&amp; !flag[<span class="number">2</span>] &amp;&amp; path[<span class="number">1</span>]==path[C])&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Path %d: %d (TS simple cycle)\n&quot;</span>,kk,total_cost);</span><br><span class="line">            <span class="keyword">if</span>(total_cost&lt;shortest)&#123;</span><br><span class="line">                shortest = total_cost;</span><br><span class="line">                shortestindex = kk;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(flag[<span class="number">0</span>])&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Path %d: NA (Not a TS cycle)\n&quot;</span>,kk);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(flag[<span class="number">1</span>] || path[<span class="number">1</span>]!=path[C])&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Path %d: %d (Not a TS cycle)\n&quot;</span>,kk,total_cost);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(flag[<span class="number">2</span>])&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Path %d: %d (TS cycle)\n&quot;</span>,kk,total_cost);</span><br><span class="line">            <span class="keyword">if</span>(total_cost&lt;shortest)&#123;</span><br><span class="line">                shortest = total_cost;</span><br><span class="line">                shortestindex = kk;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Shortest Dist(%d) = %d&quot;</span>,shortestindex,shortest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210717210659132.png" alt="image-20210717210659132"></p>
<h3 id="PAT-1151"><a href="#PAT-1151" class="headerlink" title="PAT 1151"></a>PAT 1151</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210718190008683.png" alt="image-20210718190008683"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210718190019702.png" alt="image-20210718190019702"></p>
<p>题目大意：给出中序序列和先序序列，再给出两个点，求这两个点的最近公共祖先～</p>
<p>柳神题解：不用建树～已知某个树的根结点，若a和b在根结点的左边，则a和b的最近公共祖先在当前子树根结点的左子树寻找，如果a和b在当前子树根结点的两边，在当前子树的根结点就是a和b的最近公共祖先，如果a和b在当前子树根结点的右边，则a和b的最近公共祖先就在当前子树的右子树寻找。中序加先序可以唯一确定一棵树，在不构建树的情况下，在每一层的递归中，可以得到树的根结点，在此时并入lca算法可以确定两个结点的公共祖先～</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; Inordered_Map;</span><br><span class="line"><span class="comment">// unordered_map&lt;int,int&gt; Preordered_Map;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">search_ancestor</span><span class="params">(vector&lt;<span class="type">int</span>&gt; preorder,vector&lt;<span class="type">int</span>&gt; inorder,<span class="type">int</span> node1,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> node2,<span class="type">int</span> pre_left,<span class="type">int</span> pre_right,<span class="type">int</span> in_left,<span class="type">int</span> in_right)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> in_position = Inordered_Map[preorder[pre_left]];   <span class="comment">//inordered的中间位置</span></span><br><span class="line">    <span class="type">int</span> n1_position = Inordered_Map[node1];</span><br><span class="line">    <span class="type">int</span> n2_position = Inordered_Map[node2];</span><br><span class="line">    <span class="type">int</span> mid_position = pre_left+in_position-in_left;  <span class="comment">//preorder的中间位置 </span></span><br><span class="line">    <span class="keyword">if</span>((n1_position-in_position)*(n2_position-in_position)&lt;<span class="number">0</span>)&#123;  <span class="comment">//a和b在当前子树根结点的两边</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;LCA of %d and %d is %d.\n&quot;</span>,node1,node2,inorder[in_position]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>((n1_position-in_position)*(n2_position-in_position)==<span class="number">0</span>)&#123;  <span class="comment">//a和b有一个是根节点</span></span><br><span class="line">        <span class="keyword">if</span>(n1_position==in_position)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d is an ancestor of %d.\n&quot;</span>,inorder[in_position],node2);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n2_position==in_position)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d is an ancestor of %d.\n&quot;</span>,inorder[in_position],node1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n1_position&lt;in_position &amp;&amp; n2_position&lt;in_position)&#123;</span><br><span class="line">        <span class="built_in">search_ancestor</span>(preorder,inorder,node1,node2,pre_left+<span class="number">1</span>,mid_position,in_left,in_position<span class="number">-1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n1_position&gt;in_position &amp;&amp; n2_position&gt;in_position)&#123;</span><br><span class="line">        <span class="built_in">search_ancestor</span>(preorder,inorder,node1,node2,mid_position+<span class="number">1</span>,pre_right,in_position+<span class="number">1</span>,in_right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> M,N; cin&gt;&gt;M&gt;&gt;N;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorder</span><span class="params">(N)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorder</span><span class="params">(N)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)  cin&gt;&gt;inorder[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)  cin&gt;&gt;preorder[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;inorder.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        Inordered_Map[inorder[i]] = i;</span><br><span class="line">        <span class="comment">// Preordered_Map[preorder[i]] = i;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是否存在</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        <span class="type">int</span> node1,node2;  cin&gt;&gt;node1&gt;&gt;node2;</span><br><span class="line">        <span class="keyword">if</span>(Inordered_Map.<span class="built_in">find</span>(node1)==Inordered_Map.<span class="built_in">end</span>() &amp;&amp; Inordered_Map.<span class="built_in">find</span>(node2)==Inordered_Map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ERROR: %d and %d are not found.\n&quot;</span>,node1,node2);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(Inordered_Map.<span class="built_in">find</span>(node1)==Inordered_Map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ERROR: %d is not found.\n&quot;</span>,node1);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(Inordered_Map.<span class="built_in">find</span>(node2)==Inordered_Map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ERROR: %d is not found.\n&quot;</span>,node2);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> n = preorder.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">            <span class="built_in">search_ancestor</span>(preorder,inorder,node1,node2,<span class="number">0</span>,n,<span class="number">0</span>,n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210718190202986.png" alt="image-20210718190202986"></p>
<p>问题出在递归过程中变量设置太多，导致递归栈溢出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void search_ancestor(vector&lt;int&gt; preorder,vector&lt;int&gt; inorder,int node1,</span><br><span class="line">    int node2,int pre_left,int pre_right,int in_left,int in_right)</span><br></pre></td></tr></table></figure>

<p>改成，将preorder,inorder设置成全局变量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void search_ancestor(int node1,int node2,int pre_left,int in_left,int in_right)</span><br></pre></td></tr></table></figure>

<p>修改后的代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; Inordered_Map;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; preorder,inorder;</span><br><span class="line"><span class="comment">// unordered_map&lt;int,int&gt; Preordered_Map;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">search_ancestor</span><span class="params">(<span class="type">int</span> node1,<span class="type">int</span> node2,<span class="type">int</span> pre_left,<span class="type">int</span> in_left,<span class="type">int</span> in_right)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> in_position = Inordered_Map[preorder[pre_left]];   <span class="comment">//inordered的中间位置</span></span><br><span class="line">    <span class="type">int</span> n1_position = Inordered_Map[node1];</span><br><span class="line">    <span class="type">int</span> n2_position = Inordered_Map[node2];</span><br><span class="line">    <span class="type">int</span> mid_position = pre_left+in_position-in_left;  <span class="comment">//preorder的中间位置 </span></span><br><span class="line">    <span class="keyword">if</span>((n1_position-in_position)*(n2_position-in_position)&lt;<span class="number">0</span>)&#123;  <span class="comment">//a和b在当前子树根结点的两边</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;LCA of %d and %d is %d.\n&quot;</span>,node1,node2,inorder[in_position]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>((n1_position-in_position)*(n2_position-in_position)==<span class="number">0</span>)&#123;  <span class="comment">//a和b有一个是根节点</span></span><br><span class="line">        <span class="keyword">if</span>(n1_position==in_position)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d is an ancestor of %d.\n&quot;</span>,inorder[in_position],node2);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n2_position==in_position)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d is an ancestor of %d.\n&quot;</span>,inorder[in_position],node1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n1_position&lt;in_position &amp;&amp; n2_position&lt;in_position)&#123;</span><br><span class="line">        <span class="built_in">search_ancestor</span>(node1,node2,pre_left+<span class="number">1</span>,in_left,in_position<span class="number">-1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n1_position&gt;in_position &amp;&amp; n2_position&gt;in_position)&#123;</span><br><span class="line">        <span class="built_in">search_ancestor</span>(node1,node2,mid_position+<span class="number">1</span>,in_position+<span class="number">1</span>,in_right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> M,N; cin&gt;&gt;M&gt;&gt;N;</span><br><span class="line">    preorder.<span class="built_in">resize</span>(N);</span><br><span class="line">    inorder.<span class="built_in">resize</span>(N);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)  cin&gt;&gt;inorder[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)  cin&gt;&gt;preorder[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;inorder.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        Inordered_Map[inorder[i]] = i;</span><br><span class="line">        <span class="comment">// Preordered_Map[preorder[i]] = i;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是否存在</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        <span class="type">int</span> node1,node2;  cin&gt;&gt;node1&gt;&gt;node2;</span><br><span class="line">        <span class="keyword">if</span>(Inordered_Map.<span class="built_in">find</span>(node1)==Inordered_Map.<span class="built_in">end</span>() &amp;&amp; Inordered_Map.<span class="built_in">find</span>(node2)==Inordered_Map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ERROR: %d and %d are not found.\n&quot;</span>,node1,node2);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(Inordered_Map.<span class="built_in">find</span>(node1)==Inordered_Map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ERROR: %d is not found.\n&quot;</span>,node1);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(Inordered_Map.<span class="built_in">find</span>(node2)==Inordered_Map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ERROR: %d is not found.\n&quot;</span>,node2);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> n = preorder.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">            <span class="built_in">search_ancestor</span>(node1,node2,<span class="number">0</span>,<span class="number">0</span>,n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210718190952587.png" alt="image-20210718190952587"></p>
<h2 id="2021-7-24"><a href="#2021-7-24" class="headerlink" title="2021.7.24"></a>2021.7.24</h2><h3 id="PAT-1144"><a href="#PAT-1144" class="headerlink" title="PAT 1144"></a>PAT 1144</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210724103108325.png" alt="image-20210724103108325"></p>
<p>题目大意：给一个数串，找到数串中没有出现的最小正整数</p>
<p>思路：用一个长度为N的哈希表就可以了，因为最小整数不可能超过N，符合条件就放入，不符合条件就跳过，最后从1开始遍历。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N; cin&gt;&gt;N;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">L</span><span class="params">(N)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">M</span><span class="params">(N+<span class="number">2</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        cin&gt;&gt;L[i];</span><br><span class="line">        <span class="keyword">if</span>(L[i]&gt;=<span class="number">1</span> &amp;&amp; L[i]&lt;=N)</span><br><span class="line">            M[L[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;N+<span class="number">2</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(M[i]==<span class="number">0</span>)&#123;</span><br><span class="line">            cout&lt;&lt;i;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210724103224067.png" alt="image-20210724103224067"></p>
<h3 id="PAT-1145"><a href="#PAT-1145" class="headerlink" title="PAT 1145"></a>PAT 1145</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210724143956305.png" alt="image-20210724143956305"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210724144007126.png" alt="image-20210724144007126"></p>
<p>题目大意：</p>
<p>（quadratic：平方的）</p>
<p><strong>给定一个序列，用平方探测法（只用正数）解决哈希冲突，然后给出m个数字（皆为正数），如果这个数字不能够被插入就输出”X cannot be inserted.”，然后输出这m个数字的平均查找次数</strong></p>
<p>思路：</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210724144235052.png" alt="image-20210724144235052"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//0  1  2  3  4</span></span><br><span class="line"><span class="comment">//10 6  11    4</span></span><br><span class="line"><span class="comment">//11 2次  4 1次  15 6次  2 2次</span></span><br><span class="line"><span class="comment">//11/4 = 2.8</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isprime</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="built_in">sqrt</span>(x);i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x%i==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> Msize,N,M;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;Msize&gt;&gt;N&gt;&gt;M;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isprime</span>(Msize)) Msize++;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Hash</span><span class="params">(Msize,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">//构建哈希表</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a;  cin&gt;&gt;a;</span><br><span class="line">        <span class="type">int</span> j;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;Msize;j++)&#123;   <span class="comment">//怎么判断插入不成功？</span></span><br><span class="line">            <span class="keyword">if</span>(Hash[(a+j*j)%Msize]==<span class="number">0</span>)&#123;</span><br><span class="line">                Hash[(a+j*j)%Msize] = a;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j==Msize) <span class="built_in">printf</span>(<span class="string">&quot;%d cannot be inserted.\n&quot;</span>,a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//平均查找次数</span></span><br><span class="line">    <span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        <span class="type">int</span> b;  cin&gt;&gt;b;</span><br><span class="line">        <span class="type">int</span> time = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;Msize;j++)&#123;   <span class="comment">//怎么判断找不到?</span></span><br><span class="line">            <span class="type">int</span> t = (b+j*j)%Msize;</span><br><span class="line">            <span class="keyword">if</span>(Hash[t]==b || Hash[t]==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            time++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;time&lt;&lt;endl;</span></span><br><span class="line">        sum += time;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.1f&quot;</span>,sum/M);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210724144253395.png" alt="image-20210724144253395"></p>
<h3 id="PAT-1146"><a href="#PAT-1146" class="headerlink" title="PAT 1146"></a>PAT 1146</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210724150143550.png" alt="image-20210724150143550"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210724150158871.png" alt="image-20210724150158871"></p>
<p>题目大意：判断一个序列是不是拓扑序列。</p>
<p>思路：构建邻接矩阵，计算入度，根据给出序列判断入度是否为0，然后将以该顶点为起点的边的终点的入度—1,依次判断下一个。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N,M;  <span class="comment">//N:定点数 M：边数</span></span><br><span class="line">    cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">    <span class="comment">//构建邻接矩阵</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">Graph</span>(N+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(N+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a,b; cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        Graph[a][b] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算每个顶点的入度</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">indegree</span><span class="params">(N+<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        <span class="type">int</span> in = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=N;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Graph[j][i]==<span class="number">1</span>) in++;</span><br><span class="line">        &#125;</span><br><span class="line">        indegree[i] = in;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是否为拓扑序列</span></span><br><span class="line">    <span class="type">int</span> T;  cin&gt;&gt;T;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;T;i++)&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">seq</span><span class="params">(N)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=N;j++)&#123;</span><br><span class="line">            cin&gt;&gt;seq[j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">indegree1</span><span class="params">(indegree)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;N;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(indegree1[seq[j]]==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=N;k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(Graph[seq[j]][k]==<span class="number">1</span>)&#123;</span><br><span class="line">                        indegree1[k]--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;res.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==res.<span class="built_in">size</span>()<span class="number">-1</span>) cout&lt;&lt;res[i];</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;res[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210724150354679.png" alt="image-20210724150354679"></p>
<h3 id="PAT-1147"><a href="#PAT-1147" class="headerlink" title="PAT 1147"></a>PAT 1147</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210724153528563.png" alt="image-20210724153528563"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210724153541846.png" alt="image-20210724153541846"></p>
<p>题目大意：给定一个完全二叉树，要求判断是否是大顶堆或小顶堆，并给出该二叉树的后序遍历。</p>
<p>判断大顶堆或小顶堆只需要遍历整个序列，判断seq[i] 和 seq[2<em>i] 和 seq[2</em>i+1]的关系即可。</p>
<p>后序遍历采用栈进行模拟，</p>
<p>如果有左节点且左节点没被访问过，左节点入栈，</p>
<p>如果左节点被访问过且右节点没被访问过，右节点入栈</p>
<p>如果是叶子节点，且左右节点都被访问过，则出栈，visited设1</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NOTHEAP -1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postorder</span><span class="params">(vector&lt;<span class="type">int</span>&gt; seq)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> size = seq.<span class="built_in">size</span>()<span class="number">-1</span>;  <span class="comment">//第0个结点不用</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">visited</span><span class="params">(size+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; S;</span><br><span class="line">    S.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(!S.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> node = S.<span class="built_in">top</span>();</span><br><span class="line">        <span class="keyword">if</span>(node*<span class="number">2</span>&lt;=size &amp;&amp; !visited[node*<span class="number">2</span>]) S.<span class="built_in">push</span>(node*<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(node*<span class="number">2</span>+<span class="number">1</span>&lt;=size &amp;&amp; !visited[node*<span class="number">2</span>+<span class="number">1</span>]) S.<span class="built_in">push</span>(node*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(node*<span class="number">2</span>&gt;size || (node*<span class="number">2</span>+<span class="number">1</span>&lt;=size &amp;&amp; visited[node*<span class="number">2</span>+<span class="number">1</span>])  <span class="comment">//访问该结点的条件 1、没有孩子结点 </span></span><br><span class="line">         || (node*<span class="number">2</span>+<span class="number">1</span>&gt;size &amp;&amp; node*<span class="number">2</span>&lt;=size &amp;&amp; visited[node*<span class="number">2</span>]))&#123;   <span class="comment">//2、如果有右节点，且被访问过 3、如果没有右结点且左节点被访问过</span></span><br><span class="line">            S.<span class="built_in">pop</span>();</span><br><span class="line">            visited[node] = <span class="number">1</span>;  <span class="comment">//标志该结点以访问过</span></span><br><span class="line">            res.<span class="built_in">push_back</span>(seq[node]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;res.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==res.<span class="built_in">size</span>()<span class="number">-1</span>)  cout&lt;&lt;res[i];</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;res[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> M,N;  cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">    <span class="keyword">while</span>(N--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//构建堆</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">seq</span><span class="params">(M+<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> max_or_min;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=M;i++)&#123;</span><br><span class="line">            cin&gt;&gt;seq[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断大顶堆or小顶堆</span></span><br><span class="line">        <span class="keyword">if</span>(seq[<span class="number">1</span>]&gt;seq[M]) max_or_min = MAX;</span><br><span class="line">        <span class="keyword">else</span> max_or_min = MIN;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=M;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(max_or_min==MAX)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="number">2</span>*i&lt;=M &amp;&amp; seq[<span class="number">2</span>*i]&gt;seq[i]) &#123;max_or_min = NOTHEAP;<span class="keyword">break</span>;&#125; </span><br><span class="line">                <span class="keyword">if</span>(<span class="number">2</span>*i+<span class="number">1</span>&lt;=M &amp;&amp; seq[<span class="number">2</span>*i+<span class="number">1</span>]&gt;seq[i])&#123; max_or_min = NOTHEAP;<span class="keyword">break</span>;&#125; </span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(max_or_min==MIN)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="number">2</span>*i&lt;=M &amp;&amp; seq[<span class="number">2</span>*i]&lt;seq[i]) &#123;max_or_min = NOTHEAP;<span class="keyword">break</span>;&#125; </span><br><span class="line">                <span class="keyword">if</span>(<span class="number">2</span>*i+<span class="number">1</span>&lt;=M &amp;&amp; seq[<span class="number">2</span>*i+<span class="number">1</span>]&lt;seq[i])&#123; max_or_min = NOTHEAP;<span class="keyword">break</span>;&#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(max_or_min==MAX) cout&lt;&lt;<span class="string">&quot;Max Heap&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(max_or_min==MIN) cout&lt;&lt;<span class="string">&quot;Min Heap&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(max_or_min==NOTHEAP) cout&lt;&lt;<span class="string">&quot;Not Heap&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="comment">//后序遍历</span></span><br><span class="line">        <span class="built_in">postorder</span>(seq);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210724154312977.png" alt="image-20210724154312977"></p>
<h2 id="2021-7-31"><a href="#2021-7-31" class="headerlink" title="2021.7.31"></a>2021.7.31</h2><h3 id="PAT-1140"><a href="#PAT-1140" class="headerlink" title="PAT 1140"></a>PAT 1140</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210731211941856.png" alt="image-20210731211941856"></p>
<p>题目大意：</p>
<p>题意：后面一个数是前面一个数的描述，一般第一个数是d，代表0-9的任意一个数，第二 数是第一个数的描述，就是将d+d的个数。同样，第三个数是第二个数的描述，依次，例如:1   11(前一个1是第一个数，后一个1是第一个中1的个数)    12（代表前一个数中有2个1）  1121（前面一个数中有1个1，1个2，数放前，个数放后）  122111   112213  12221131  1123123111 。</p>
<p>思路：采用模拟的方法，c表示当前字符，如果遍历到的字符不是c，则输出到temp中，如果是c，则c的个数size++.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> D,index;  cin&gt;&gt;D&gt;&gt;index;</span><br><span class="line">    string s = <span class="built_in">to_string</span>(D);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=index;i++)&#123;</span><br><span class="line">        string temp = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">int</span> size = <span class="number">1</span>;</span><br><span class="line">        <span class="type">char</span> c = s[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;s.<span class="built_in">length</span>();j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[j]==c)&#123;</span><br><span class="line">                size++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                temp = temp + c + <span class="built_in">to_string</span>(size);</span><br><span class="line">                c = s[j];</span><br><span class="line">                size = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = temp + c + <span class="built_in">to_string</span>(size);</span><br><span class="line">        s = temp;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;s&lt;&lt;endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210731212418772.png" alt="image-20210731212418772"></p>
<p>原因在于<img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210731225304119.png" alt="image-20210731225304119"></p>
<p>使用&#x3D;是深拷贝，需将temp重新拷贝一份再赋值给temp</p>
<p>使用+&#x3D; 是直接在后面append。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> D,index;  cin&gt;&gt;D&gt;&gt;index;</span><br><span class="line">    string s = <span class="built_in">to_string</span>(D);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=index;i++)&#123;</span><br><span class="line">        string temp = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">int</span> size = <span class="number">1</span>;</span><br><span class="line">        <span class="type">char</span> c = s[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;s.<span class="built_in">length</span>();j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[j]==c)&#123;</span><br><span class="line">                size++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                temp += c + <span class="built_in">to_string</span>(size);</span><br><span class="line">                c = s[j];</span><br><span class="line">                size = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        temp += c + <span class="built_in">to_string</span>(size);</span><br><span class="line">        s = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210731225217330.png" alt="image-20210731225217330"></p>
<h3 id="PAT-1141"><a href="#PAT-1141" class="headerlink" title="PAT 1141"></a>PAT 1141</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210731225429215.png" alt="image-20210731225429215"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210731225444048.png" alt="image-20210731225444048"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210731225453525.png" alt="image-20210731225453525"></p>
<p>问题描述：给定每个考生的成绩和学校，统计该学校的总成绩并排序。</p>
<p>思路：用一个Map用于查找学校信息，便于统计学校总成绩，然后扔到vector进行排序。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">inform</span>&#123;</span><br><span class="line">    string school;</span><br><span class="line">    <span class="type">double</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> number = <span class="number">0</span>;</span><br><span class="line">&#125;inform;</span><br><span class="line">unordered_map&lt;string,inform&gt; Map;</span><br><span class="line">vector&lt;inform&gt; StuList;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(inform a,inform b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.total==b.total &amp;&amp; a.number==b.number)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.school&lt;b.school;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a.total==b.total)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.number&lt;b.number;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.total&gt;b.total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N;  cin&gt;&gt;N;</span><br><span class="line">    <span class="keyword">while</span>(N--)&#123;   <span class="comment">//处理输入</span></span><br><span class="line">        string id;  <span class="type">int</span> score;  string school;</span><br><span class="line">        cin&gt;&gt;id&gt;&gt;score&gt;&gt;school;</span><br><span class="line">        <span class="built_in">transform</span>(school.<span class="built_in">begin</span>(),school.<span class="built_in">end</span>(),school.<span class="built_in">begin</span>(),::tolower);  <span class="comment">//全转小写</span></span><br><span class="line">        Map[school].school = school;</span><br><span class="line">        <span class="keyword">if</span>(id[<span class="number">0</span>]==<span class="string">&#x27;B&#x27;</span>)&#123;</span><br><span class="line">            Map[school].total += <span class="built_in">double</span>(score)/<span class="number">1.5</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(id[<span class="number">0</span>]==<span class="string">&#x27;A&#x27;</span>)&#123;</span><br><span class="line">            Map[school].total += score;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(id[<span class="number">0</span>]==<span class="string">&#x27;T&#x27;</span>)&#123;</span><br><span class="line">            Map[school].total += <span class="built_in">double</span>(score)*<span class="number">1.5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map[school].number++;</span><br><span class="line">    &#125;</span><br><span class="line">    unordered_map&lt;string,inform&gt;::iterator iter;</span><br><span class="line">    <span class="keyword">for</span>(iter=Map.<span class="built_in">begin</span>();iter!=Map.<span class="built_in">end</span>();iter++)&#123;</span><br><span class="line">        StuList.<span class="built_in">push_back</span>(iter-&gt;second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(StuList.<span class="built_in">begin</span>(),StuList.<span class="built_in">end</span>(),cmp);</span><br><span class="line">    <span class="type">int</span> len = StuList.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> rank = <span class="number">1</span>;</span><br><span class="line">    cout&lt;&lt;StuList.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i<span class="number">-2</span>&gt;=<span class="number">0</span> &amp;&amp; (<span class="type">int</span>)StuList[i<span class="number">-1</span>].total==(<span class="type">int</span>)StuList[i<span class="number">-2</span>].total)&#123;&#125;</span><br><span class="line">        <span class="keyword">else</span> rank = i;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %s %d %d&quot;</span>,rank,StuList[i<span class="number">-1</span>].school.<span class="built_in">c_str</span>(),(<span class="type">int</span>)(StuList[i<span class="number">-1</span>].total),StuList[i<span class="number">-1</span>].number);</span><br><span class="line">        <span class="keyword">if</span>(i!=len) cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210731231308137.png" alt="image-20210731231308137"></p>
<p>sort的使用，测试点五是一个坑，因为每个学校的分数相当于一个加权的成绩，在前期处理的时候就应该按照浮点数处理，只有在排序的时候将其转换为整数即可。</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210731231840300.png" alt="image-20210731231840300"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210731231858291.png" alt="image-20210731231858291"></p>
<p>正确代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">inform</span>&#123;</span><br><span class="line">    string school;</span><br><span class="line">    <span class="type">double</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> TWS;</span><br><span class="line">    <span class="type">int</span> number = <span class="number">0</span>;</span><br><span class="line">&#125;inform;</span><br><span class="line">unordered_map&lt;string,inform&gt; Map;</span><br><span class="line">vector&lt;inform&gt; StuList;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(inform a,inform b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.TWS==b.TWS &amp;&amp; a.number==b.number)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.school&lt;b.school;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a.TWS==b.TWS)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.number&lt;b.number;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.TWS&gt;b.TWS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N;  cin&gt;&gt;N;</span><br><span class="line">    <span class="keyword">while</span>(N--)&#123;   <span class="comment">//处理输入</span></span><br><span class="line">        string id;  <span class="type">int</span> score;  string school;</span><br><span class="line">        cin&gt;&gt;id&gt;&gt;score&gt;&gt;school;</span><br><span class="line">        <span class="built_in">transform</span>(school.<span class="built_in">begin</span>(),school.<span class="built_in">end</span>(),school.<span class="built_in">begin</span>(),::tolower);  <span class="comment">//全转小写</span></span><br><span class="line">        Map[school].school = school;</span><br><span class="line">        <span class="keyword">if</span>(id[<span class="number">0</span>]==<span class="string">&#x27;B&#x27;</span>)&#123;</span><br><span class="line">            Map[school].total += <span class="built_in">double</span>(score)/<span class="number">1.5</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(id[<span class="number">0</span>]==<span class="string">&#x27;A&#x27;</span>)&#123;</span><br><span class="line">            Map[school].total += score;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(id[<span class="number">0</span>]==<span class="string">&#x27;T&#x27;</span>)&#123;</span><br><span class="line">            Map[school].total += <span class="built_in">double</span>(score)*<span class="number">1.5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map[school].number++;</span><br><span class="line">    &#125;</span><br><span class="line">    unordered_map&lt;string,inform&gt;::iterator iter;</span><br><span class="line">    <span class="keyword">for</span>(iter=Map.<span class="built_in">begin</span>();iter!=Map.<span class="built_in">end</span>();iter++)&#123;</span><br><span class="line">        iter-&gt;second.TWS = iter-&gt;second.total;</span><br><span class="line">        StuList.<span class="built_in">push_back</span>(iter-&gt;second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(StuList.<span class="built_in">begin</span>(),StuList.<span class="built_in">end</span>(),cmp);</span><br><span class="line">    <span class="type">int</span> len = StuList.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> rank = <span class="number">1</span>;</span><br><span class="line">    cout&lt;&lt;StuList.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i<span class="number">-2</span>&gt;=<span class="number">0</span> &amp;&amp; (<span class="type">int</span>)StuList[i<span class="number">-1</span>].total==(<span class="type">int</span>)StuList[i<span class="number">-2</span>].total)&#123;&#125;</span><br><span class="line">        <span class="keyword">else</span> rank = i;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %s %d %d&quot;</span>,rank,StuList[i<span class="number">-1</span>].school.<span class="built_in">c_str</span>(),(<span class="type">int</span>)(StuList[i<span class="number">-1</span>].TWS),StuList[i<span class="number">-1</span>].number);</span><br><span class="line">        <span class="keyword">if</span>(i!=len) cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210731231804410.png" alt="image-20210731231804410"></p>
<h3 id="PAT-1142"><a href="#PAT-1142" class="headerlink" title="PAT 1142"></a>PAT 1142</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210731231938095-1677591493747.png" alt="image-20210731231938095"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210731231950482-1677591493747.png" alt="image-20210731231950482"></p>
<p>题目大意：问题描述：给定一个无向图，和一些顶点，判断这些顶点是否组成了集合（每两个顶点都相连）</p>
<p>Yes 是一个团，每两个顶点都相邻</p>
<p>Not Maximal  是一个团，但是可以再加入一个顶点，使得每两个顶点相连</p>
<p>Not a Clique  不是每两个顶点都相连。</p>
<p>思路：构造邻接矩阵，对给定序列依次判断是否是一个团，然后再尝试加入其他顶点，判断是否是最大团。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">inform</span>&#123;</span><br><span class="line">    string school;</span><br><span class="line">    <span class="type">double</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> TWS;</span><br><span class="line">    <span class="type">int</span> number = <span class="number">0</span>;</span><br><span class="line">&#125;inform;</span><br><span class="line">unordered_map&lt;string,inform&gt; Map;</span><br><span class="line">vector&lt;inform&gt; StuList;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(inform a,inform b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.TWS==b.TWS &amp;&amp; a.number==b.number)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.school&lt;b.school;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a.TWS==b.TWS)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.number&lt;b.number;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.TWS&gt;b.TWS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N;  cin&gt;&gt;N;</span><br><span class="line">    <span class="keyword">while</span>(N--)&#123;   <span class="comment">//处理输入</span></span><br><span class="line">        string id;  <span class="type">int</span> score;  string school;</span><br><span class="line">        cin&gt;&gt;id&gt;&gt;score&gt;&gt;school;</span><br><span class="line">        <span class="built_in">transform</span>(school.<span class="built_in">begin</span>(),school.<span class="built_in">end</span>(),school.<span class="built_in">begin</span>(),::tolower);  <span class="comment">//全转小写</span></span><br><span class="line">        Map[school].school = school;</span><br><span class="line">        <span class="keyword">if</span>(id[<span class="number">0</span>]==<span class="string">&#x27;B&#x27;</span>)&#123;</span><br><span class="line">            Map[school].total += <span class="built_in">double</span>(score)/<span class="number">1.5</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(id[<span class="number">0</span>]==<span class="string">&#x27;A&#x27;</span>)&#123;</span><br><span class="line">            Map[school].total += score;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(id[<span class="number">0</span>]==<span class="string">&#x27;T&#x27;</span>)&#123;</span><br><span class="line">            Map[school].total += <span class="built_in">double</span>(score)*<span class="number">1.5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map[school].number++;</span><br><span class="line">    &#125;</span><br><span class="line">    unordered_map&lt;string,inform&gt;::iterator iter;</span><br><span class="line">    <span class="keyword">for</span>(iter=Map.<span class="built_in">begin</span>();iter!=Map.<span class="built_in">end</span>();iter++)&#123;</span><br><span class="line">        iter-&gt;second.TWS = iter-&gt;second.total;</span><br><span class="line">        StuList.<span class="built_in">push_back</span>(iter-&gt;second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(StuList.<span class="built_in">begin</span>(),StuList.<span class="built_in">end</span>(),cmp);</span><br><span class="line">    <span class="type">int</span> len = StuList.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> rank = <span class="number">1</span>;</span><br><span class="line">    cout&lt;&lt;StuList.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i<span class="number">-2</span>&gt;=<span class="number">0</span> &amp;&amp; (<span class="type">int</span>)StuList[i<span class="number">-1</span>].total==(<span class="type">int</span>)StuList[i<span class="number">-2</span>].total)&#123;&#125;</span><br><span class="line">        <span class="keyword">else</span> rank = i;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %s %d %d&quot;</span>,rank,StuList[i<span class="number">-1</span>].school.<span class="built_in">c_str</span>(),(<span class="type">int</span>)(StuList[i<span class="number">-1</span>].TWS),StuList[i<span class="number">-1</span>].number);</span><br><span class="line">        <span class="keyword">if</span>(i!=len) cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210731232208835-1677591493747.png" alt="image-20210731232208835"></p>
<h3 id="PAT-1143"><a href="#PAT-1143" class="headerlink" title="PAT 1143"></a>PAT 1143</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210731232235278.png" alt="image-20210731232235278"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210731232247776.png" alt="image-20210731232247776"></p>
<p>题目大意：用先序遍历的方式给出一棵排序二叉树。让你回答n个询问。<br> 找出每个询问的最近公共祖先。</p>
<p>用TreeMap存树的每个结点，第一步判断是否存在  否则not found</p>
<p>第二部查找最近的公共祖孙，这里利用二叉排序树的特点，如果n1 和 n2 一个大于根节点 一个小于根节点，则根节点必定是公共祖先，否则递归进行查找。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">searchLCA</span><span class="params">(vector&lt;<span class="type">int</span>&gt; Tree,<span class="type">int</span> left,<span class="type">int</span> right,<span class="type">int</span> n1,<span class="type">int</span> n2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = Tree[left];</span><br><span class="line">    <span class="keyword">if</span>((n1&lt;t &amp;&amp; n2&gt;t) || (n1&gt;t &amp;&amp; n2&lt;t) || (n1==t||n2==t)) <span class="keyword">return</span> t;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> i = left+<span class="number">1</span>;  <span class="comment">//划分左右子树</span></span><br><span class="line">        <span class="keyword">while</span>(Tree[i]&lt;t) i++;</span><br><span class="line">        <span class="keyword">if</span>(n1&lt;t &amp;&amp; n2&lt;t) <span class="keyword">return</span> <span class="built_in">searchLCA</span>(Tree,left+<span class="number">1</span>,i<span class="number">-1</span>,n1,n2);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">searchLCA</span>(Tree,i,right,n1,n2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> M,N; cin&gt;&gt;M&gt;&gt;N;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Tree</span><span class="params">(N)</span></span>;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; TreeMap;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++) &#123;</span><br><span class="line">        cin&gt;&gt;Tree[i];</span><br><span class="line">        TreeMap[Tree[i]]++;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        <span class="type">int</span> n1,n2; cin&gt;&gt;n1&gt;&gt;n2;</span><br><span class="line">        <span class="keyword">if</span>(TreeMap.<span class="built_in">find</span>(n1)==TreeMap.<span class="built_in">end</span>() &amp;&amp; TreeMap.<span class="built_in">find</span>(n2)==TreeMap.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ERROR: %d and %d are not found.&quot;</span>,n1,n2);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(TreeMap.<span class="built_in">find</span>(n1)==TreeMap.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ERROR: %d is not found.&quot;</span>,n1);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(TreeMap.<span class="built_in">find</span>(n2)==TreeMap.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ERROR: %d is not found.&quot;</span>,n2);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> lca = <span class="built_in">searchLCA</span>(Tree,<span class="number">0</span>,N<span class="number">-1</span>,n1,n2);</span><br><span class="line">            <span class="keyword">if</span>(lca==n1)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d is an ancestor of %d.&quot;</span>,n1,n2);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(lca==n2)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d is an ancestor of %d.&quot;</span>,n2,n1);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;LCA of %d and %d is %d.&quot;</span>,n1,n2,lca);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i!=M<span class="number">-1</span>) cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210731232946850.png" alt="image-20210731232946850"></p>
<p>佬们的代码：他是直接利用先序遍历的特点，按顺序判断是否是祖先</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210731232910793.png" alt="image-20210731232910793"></p>
<h2 id="2021-8-7"><a href="#2021-8-7" class="headerlink" title="2021.8.7"></a>2021.8.7</h2><h3 id="PAT-1136"><a href="#PAT-1136" class="headerlink" title="PAT 1136"></a>PAT 1136</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807112248715.png" alt="image-20210807112248715"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807112302487.png" alt="image-20210807112302487"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807112313001.png" alt="image-20210807112313001"></p>
<p>题目大意：一个数加它的翻转能否在10次内得到一个回文数</p>
<p>思路：模拟大数加法，并且模拟反转过程。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">string <span class="title">add</span><span class="params">(string a,string b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string res;</span><br><span class="line">    <span class="type">int</span> len = a.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">int</span> jinwei = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> benwei = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=len<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="type">int</span> c = a[i]-<span class="string">&#x27;0&#x27;</span> + b[i]-<span class="string">&#x27;0&#x27;</span> + jinwei;</span><br><span class="line">        benwei = c%<span class="number">10</span>;</span><br><span class="line">        res = <span class="built_in">to_string</span>(benwei) + res;</span><br><span class="line">        jinwei = c/<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(jinwei!=<span class="number">0</span>) res = <span class="built_in">to_string</span>(jinwei) + res;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ispalindromic</span><span class="params">(string a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>,j=a.<span class="built_in">length</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=j)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] != a[j]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        i++; j--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    cin&gt;&gt;a;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">ispalindromic</span>(a) &amp;&amp; i&lt;=<span class="number">10</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s + &quot;</span>,a.<span class="built_in">c_str</span>());</span><br><span class="line">        string c = a;</span><br><span class="line">        <span class="built_in">reverse</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s = &quot;</span>,a.<span class="built_in">c_str</span>());</span><br><span class="line">        a = <span class="built_in">add</span>(a,c);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,a.<span class="built_in">c_str</span>());</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;<span class="number">10</span>) <span class="built_in">printf</span>(<span class="string">&quot;Not found in 10 iterations.&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%s is a palindromic number.&quot;</span>,a.<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807112447331.png" alt="image-20210807112447331"></p>
<h3 id="PAT-1137"><a href="#PAT-1137" class="headerlink" title="PAT 1137"></a>PAT 1137</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807162201003.png" alt="image-20210807162201003"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807162215605.png" alt="image-20210807162215605"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807162226330.png" alt="image-20210807162226330"></p>
<p>题目大意：</p>
<p>判断一个学生是否有资格获得整数的条件有2个：1.学生是否能编程&gt;&#x3D;200题 2.学生的总评成绩是否&gt;&#x3D;60</p>
<p>由于题目是分开给出各项成绩，而且Id唯一，所以我们可以使用Map方便查找。最后进行判断，判断完后排序。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">StuInfo</span>&#123;</span><br><span class="line">    string id;</span><br><span class="line">    <span class="type">int</span> assign = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> mid = <span class="number">0</span>; </span><br><span class="line">    <span class="type">int</span> <span class="keyword">final</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> G;</span><br><span class="line">&#125;StuInfo;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(StuInfo a,StuInfo b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.G==b.G) <span class="keyword">return</span> a.id&lt;b.id;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a.G&gt;b.G;</span><br><span class="line">&#125;</span><br><span class="line">unordered_map&lt;string,StuInfo&gt; Map;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> P,M,N;  cin&gt;&gt;P&gt;&gt;M&gt;&gt;N;</span><br><span class="line">    <span class="comment">//input</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; P; i++)&#123;</span><br><span class="line">        StuInfo stu;</span><br><span class="line">        cin&gt;&gt;stu.id&gt;&gt;stu.assign;</span><br><span class="line">        Map[stu.id] = stu;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; M; i++)&#123;</span><br><span class="line">        StuInfo stu;</span><br><span class="line">        cin&gt;&gt;stu.id&gt;&gt;stu.mid;</span><br><span class="line">        <span class="keyword">if</span>(Map.<span class="built_in">find</span>(stu.id)!=Map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            Map[stu.id].mid = stu.mid;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            Map[stu.id] = stu;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; N; i++)&#123;</span><br><span class="line">        StuInfo stu;</span><br><span class="line">        cin&gt;&gt;stu.id&gt;&gt;stu.<span class="keyword">final</span>;</span><br><span class="line">        <span class="keyword">if</span>(Map.<span class="built_in">find</span>(stu.id)!=Map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            Map[stu.id].<span class="keyword">final</span> = stu.<span class="keyword">final</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            Map[stu.id] = stu;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;StuInfo&gt; StuList;</span><br><span class="line">    unordered_map&lt;string,StuInfo&gt;::iterator iter;</span><br><span class="line">    <span class="keyword">for</span>(iter=Map.<span class="built_in">begin</span>();iter!=Map.<span class="built_in">end</span>();iter++)&#123;</span><br><span class="line">        StuInfo stu = iter-&gt;second;</span><br><span class="line">        <span class="keyword">if</span>(stu.assign&lt;<span class="number">200</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(stu.mid&gt;stu.<span class="keyword">final</span>) stu.G = (<span class="type">int</span>)((<span class="type">float</span>)stu.mid*<span class="number">0.4</span> + (<span class="type">float</span>)stu.<span class="keyword">final</span>*<span class="number">0.6</span> + <span class="number">0.5</span>);</span><br><span class="line">        <span class="keyword">else</span> stu.G = stu.<span class="keyword">final</span>;</span><br><span class="line">        <span class="keyword">if</span>(stu.G&lt;<span class="number">60</span>) <span class="keyword">continue</span>;</span><br><span class="line">        StuList.<span class="built_in">push_back</span>(stu);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(StuList.<span class="built_in">begin</span>(),StuList.<span class="built_in">end</span>(),cmp);</span><br><span class="line">    <span class="comment">//output</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;StuList.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        string name = StuList[i].id;</span><br><span class="line">        <span class="type">int</span> assign = StuList[i].assign;</span><br><span class="line">        <span class="type">int</span> mid = StuList[i].mid&gt;<span class="number">0</span> ? StuList[i].mid : <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> fin = StuList[i].<span class="keyword">final</span>&gt;<span class="number">0</span> ? StuList[i].<span class="keyword">final</span> : <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> G = StuList[i].G;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s %d %d %d %d\n&quot;</span>,name.<span class="built_in">c_str</span>(),assign,mid,fin,G);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807162636845.png" alt="image-20210807162636845"></p>
<p><strong>大坑</strong>：</p>
<p>题目中的-1的意思表示的是没有学生的某一项没有分数（而非分数为0！没有分数代表没来考试，而分数为0代表考试考了0分！）</p>
<p>所以mid的初值应该设为-1 而不应该设为0</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807162728149.png" alt="image-20210807162728149"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">StuInfo</span>&#123;</span><br><span class="line">    string id;</span><br><span class="line">    <span class="type">int</span> assign = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> mid = <span class="number">-1</span>;  <span class="comment">//-1代表没有成绩，不代表0分</span></span><br><span class="line">    <span class="type">int</span> <span class="keyword">final</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> G;</span><br><span class="line">&#125;StuInfo;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(StuInfo a,StuInfo b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.G==b.G) <span class="keyword">return</span> a.id&lt;b.id;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a.G&gt;b.G;</span><br><span class="line">&#125;</span><br><span class="line">unordered_map&lt;string,StuInfo&gt; Map;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> P,M,N;  cin&gt;&gt;P&gt;&gt;M&gt;&gt;N;</span><br><span class="line">    <span class="comment">//input</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; P; i++)&#123;</span><br><span class="line">        StuInfo stu;</span><br><span class="line">        cin&gt;&gt;stu.id&gt;&gt;stu.assign;</span><br><span class="line">        Map[stu.id] = stu;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; M; i++)&#123;</span><br><span class="line">        StuInfo stu;</span><br><span class="line">        cin&gt;&gt;stu.id&gt;&gt;stu.mid;</span><br><span class="line">        <span class="keyword">if</span>(Map.<span class="built_in">find</span>(stu.id)!=Map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            Map[stu.id].mid = stu.mid;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            Map[stu.id] = stu;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; N; i++)&#123;</span><br><span class="line">        StuInfo stu;</span><br><span class="line">        cin&gt;&gt;stu.id&gt;&gt;stu.<span class="keyword">final</span>;</span><br><span class="line">        <span class="keyword">if</span>(Map.<span class="built_in">find</span>(stu.id)!=Map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            Map[stu.id].<span class="keyword">final</span> = stu.<span class="keyword">final</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            Map[stu.id] = stu;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;StuInfo&gt; StuList;</span><br><span class="line">    unordered_map&lt;string,StuInfo&gt;::iterator iter;</span><br><span class="line">    <span class="keyword">for</span>(iter=Map.<span class="built_in">begin</span>();iter!=Map.<span class="built_in">end</span>();iter++)&#123;</span><br><span class="line">        StuInfo stu = iter-&gt;second;</span><br><span class="line">        <span class="keyword">if</span>(stu.assign&lt;<span class="number">200</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(stu.mid&gt;stu.<span class="keyword">final</span>) stu.G = (<span class="type">int</span>)((<span class="type">float</span>)stu.mid*<span class="number">0.4</span> + (<span class="type">float</span>)stu.<span class="keyword">final</span>*<span class="number">0.6</span> + <span class="number">0.5</span>);</span><br><span class="line">        <span class="keyword">else</span> stu.G = stu.<span class="keyword">final</span>;</span><br><span class="line">        <span class="keyword">if</span>(stu.G&lt;<span class="number">60</span>) <span class="keyword">continue</span>;</span><br><span class="line">        StuList.<span class="built_in">push_back</span>(stu);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(StuList.<span class="built_in">begin</span>(),StuList.<span class="built_in">end</span>(),cmp);</span><br><span class="line">    <span class="comment">//output</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;StuList.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        string name = StuList[i].id;</span><br><span class="line">        <span class="type">int</span> assign = StuList[i].assign;</span><br><span class="line">        <span class="type">int</span> mid = StuList[i].mid&gt;=<span class="number">0</span> ? StuList[i].mid : <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> fin = StuList[i].<span class="keyword">final</span>&gt;<span class="number">0</span> ? StuList[i].<span class="keyword">final</span> : <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> G = StuList[i].G;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s %d %d %d %d\n&quot;</span>,name.<span class="built_in">c_str</span>(),assign,mid,fin,G);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807162753507.png" alt="image-20210807162753507"></p>
<h3 id="PAT-1138"><a href="#PAT-1138" class="headerlink" title="PAT 1138"></a>PAT 1138</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807162840383.png" alt="image-20210807162840383"></p>
<p>题目大意：给出数的前序、中序，求后序输出的第一个值</p>
<p>思路：按照前序、中序序列构造树的方法，采用递归，中间需要用到Map来查找中序序列的位置。</p>
<p>如果有左子树，后序遍历的第一个序列在左子树中寻找，否则在右子树中寻找。只有一个节点，则Return；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; Map;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TreeBuild</span><span class="params">(vector&lt;<span class="type">int</span>&gt; preorder,vector&lt;<span class="type">int</span>&gt; inorder,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> pl,<span class="type">int</span> pr,<span class="type">int</span> il,<span class="type">int</span> ir)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pl==pr) <span class="keyword">return</span> preorder[pl];</span><br><span class="line">    <span class="type">int</span> cur = preorder[pl];</span><br><span class="line">    <span class="type">int</span> mid_cur = Map[cur];</span><br><span class="line">    <span class="keyword">if</span>(mid_cur==il)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">TreeBuild</span>(preorder,inorder,pl+<span class="number">1</span>,pr,il+<span class="number">1</span>,ir);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">TreeBuild</span>(preorder,inorder,pl+<span class="number">1</span>,pl+mid_cur-il,il,mid_cur<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N;  cin&gt;&gt;N;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorder</span><span class="params">(N,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorder</span><span class="params">(N,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++) cin&gt;&gt;preorder[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++) &#123;</span><br><span class="line">        cin&gt;&gt;inorder[i];</span><br><span class="line">        Map[inorder[i]]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">TreeBuild</span>(preorder,inorder,<span class="number">0</span>,N<span class="number">-1</span>,<span class="number">0</span>,N<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807163415544.png" alt="image-20210807163415544"></p>
<p>改进方法：函数传值的时候尽量不要把整个vector都传进去，否则会出现爆内存的情况。需要把vector设置成全局变量</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; Map;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; preorder,inorder;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TreeBuild</span><span class="params">(<span class="type">int</span> pl,<span class="type">int</span> pr,<span class="type">int</span> il,<span class="type">int</span> ir)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pl==pr) <span class="keyword">return</span> preorder[pl];</span><br><span class="line">    <span class="type">int</span> cur = preorder[pl];</span><br><span class="line">    <span class="type">int</span> mid_cur = Map[cur];</span><br><span class="line">    <span class="keyword">if</span>(mid_cur==il)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">TreeBuild</span>(pl+<span class="number">1</span>,pr,il+<span class="number">1</span>,ir);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">TreeBuild</span>(pl+<span class="number">1</span>,pl+mid_cur-il,il,mid_cur<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N;  cin&gt;&gt;N;</span><br><span class="line">    preorder.<span class="built_in">resize</span>(N,<span class="number">0</span>);</span><br><span class="line">    inorder.<span class="built_in">resize</span>(N,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++) cin&gt;&gt;preorder[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++) &#123;</span><br><span class="line">        cin&gt;&gt;inorder[i];</span><br><span class="line">        Map[inorder[i]]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">TreeBuild</span>(<span class="number">0</span>,N<span class="number">-1</span>,<span class="number">0</span>,N<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807192348410.png" alt="image-20210807192348410"></p>
<h3 id="PAT-1139"><a href="#PAT-1139" class="headerlink" title="PAT 1139"></a>PAT 1139</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807192751253.png" alt="image-20210807192751253"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807192805065.png" alt="image-20210807192805065"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807192815264.png" alt="image-20210807192815264"></p>
<p><strong>题意</strong>：如果一个男孩子A对一个女孩子B有好感，那么他需要跟他的好哥们C说，然后C再去找B的闺蜜，让闺蜜给B带话。</p>
<p>思路就是从A的同性朋友中找出C，再从B的同性朋友中找出D，然后C，D是好朋友的话，这个话就带到了。</p>
<p>但是输出那里规定A，B可以是同性，</p>
<p>If they are of the same gender, then both friends must be in the same gender as theirs.</p>
<p>emmmmmmm，这道题gay里gay气的。</p>
<p><strong>思路</strong>：Person结构体存储自己的Id,还有男朋友，女朋友（其实也可以一起存储），然后用一个Map&lt;id,Person&gt;方便使用Id找到相对应的朋友。</p>
<p>然后给定两个朋友A，朋友B，根据Map找到对应的A的男朋友或女朋友，and 找到B的男朋友或女朋友，最后写一个函数判断这两人之间是否存在关系，然后将存在关系的朋友排好序，输出。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; boyfriend;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; girlfriend;</span><br><span class="line">&#125;Person;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>,Person&gt; Map;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; a,pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.first==b.first) <span class="keyword">return</span> a.second&lt;b.second;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a.first&lt;b.first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isfriend</span><span class="params">(<span class="type">int</span> id,<span class="type">int</span> q)</span></span>&#123;</span><br><span class="line">    Person p = Map[id];</span><br><span class="line">    <span class="keyword">if</span>(q&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;p.boyfriend.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(q==p.boyfriend[i]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;p.girlfriend.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(q==p.girlfriend[i]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N,M;  cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">    <span class="comment">//input</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        <span class="type">int</span> id1,id2;  cin&gt;&gt;id1&gt;&gt;id2;</span><br><span class="line">        <span class="comment">//创建对象</span></span><br><span class="line">        <span class="keyword">if</span>(Map.<span class="built_in">find</span>(id1)==Map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            Person p; p.id = id1;</span><br><span class="line">            Map[id1] = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Map.<span class="built_in">find</span>(id2)==Map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            Person p; p.id = id2;</span><br><span class="line">            Map[id2] = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//加入朋友关系</span></span><br><span class="line">        <span class="keyword">if</span>(id2&gt;<span class="number">0</span>) Map[id1].boyfriend.<span class="built_in">push_back</span>(id2);</span><br><span class="line">        <span class="keyword">else</span> Map[id1].girlfriend.<span class="built_in">push_back</span>(id2);</span><br><span class="line">        <span class="keyword">if</span>(id1&gt;<span class="number">0</span>) Map[id2].boyfriend.<span class="built_in">push_back</span>(id1);</span><br><span class="line">        <span class="keyword">else</span> Map[id2].girlfriend.<span class="built_in">push_back</span>(id1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> K; cin&gt;&gt;K;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;K;k++)&#123;</span><br><span class="line">        <span class="type">int</span> id1,id2;  cin&gt;&gt;id1&gt;&gt;id2;</span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(id1&gt;<span class="number">0</span> &amp;&amp; id2&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; id1friend; vector&lt;<span class="type">int</span>&gt; id2friend;</span><br><span class="line">            Person p = Map[id1];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;p.boyfriend.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                id1friend.<span class="built_in">push_back</span>(p.boyfriend[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            Person q = Map[id2];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;q.boyfriend.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                id2friend.<span class="built_in">push_back</span>(q.boyfriend[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;id1friend.<span class="built_in">size</span>();i++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;id2friend.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">isfriend</span>(id1friend[i],id2friend[j]))&#123;</span><br><span class="line">                        res.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(<span class="built_in">abs</span>(id1friend[i]),<span class="built_in">abs</span>(id2friend[j])));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(id1&lt;<span class="number">0</span> &amp;&amp; id2&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; id1friend; vector&lt;<span class="type">int</span>&gt; id2friend;</span><br><span class="line">            Person p = Map[id1];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;p.girlfriend.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                id1friend.<span class="built_in">push_back</span>(p.girlfriend[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            Person q = Map[id2];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;q.girlfriend.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                id2friend.<span class="built_in">push_back</span>(q.girlfriend[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;id1friend.<span class="built_in">size</span>();i++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;id2friend.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">isfriend</span>(id1friend[i],id2friend[j]))&#123;</span><br><span class="line">                        res.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(<span class="built_in">abs</span>(id1friend[i]),<span class="built_in">abs</span>(id2friend[j])));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(id1&gt;<span class="number">0</span> &amp;&amp; id2&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; id1friend; vector&lt;<span class="type">int</span>&gt; id2friend;</span><br><span class="line">            Person p = Map[id1];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;p.boyfriend.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                id1friend.<span class="built_in">push_back</span>(p.boyfriend[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            Person q = Map[id2];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;q.girlfriend.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                id2friend.<span class="built_in">push_back</span>(q.girlfriend[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;id1friend.<span class="built_in">size</span>();i++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;id2friend.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">isfriend</span>(id1friend[i],id2friend[j]))&#123;</span><br><span class="line">                        res.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(<span class="built_in">abs</span>(id1friend[i]),<span class="built_in">abs</span>(id2friend[j])));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(id1&lt;<span class="number">0</span> &amp;&amp; id2&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; id1friend; vector&lt;<span class="type">int</span>&gt; id2friend;</span><br><span class="line">            Person p = Map[id1];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;p.girlfriend.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                id1friend.<span class="built_in">push_back</span>(p.girlfriend[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            Person q = Map[id2];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;q.boyfriend.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                id2friend.<span class="built_in">push_back</span>(q.boyfriend[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;id1friend.<span class="built_in">size</span>();i++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;id2friend.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">isfriend</span>(id1friend[i],id2friend[j]))&#123;</span><br><span class="line">                        res.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(<span class="built_in">abs</span>(id1friend[i]),<span class="built_in">abs</span>(id2friend[j])));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//output</span></span><br><span class="line">        <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>(),cmp);</span><br><span class="line">        cout&lt;&lt;res.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;res.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,res[i].first,res[i].second);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807193412853.png" alt="image-20210807193412853"></p>
<p>参考了以下柳神的代码</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807200903777.png" alt="image-20210807200903777"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">bool</span>&gt; arr;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node x,node y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.a != y.a ? x.a &lt; y.a : x.b &lt; y.b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m,k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v[<span class="number">10000</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        string a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="type">int</span> asa = <span class="built_in">abs</span>(<span class="built_in">stoi</span>(a)),asb = <span class="built_in">abs</span>(<span class="built_in">stoi</span>(b));</span><br><span class="line">        <span class="comment">// A/B ID 作为下标记录同性边数据，arr记录关系</span></span><br><span class="line">        <span class="keyword">if</span> (a.<span class="built_in">length</span>() == b.<span class="built_in">length</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            v[asa].<span class="built_in">push_back</span>(asb);</span><br><span class="line">            v[asb].<span class="built_in">push_back</span>(asa);</span><br><span class="line">        &#125;</span><br><span class="line">        arr[asa * <span class="number">10000</span> + asb] = arr[asb * <span class="number">10000</span> + asa] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> c, d;</span><br><span class="line">        cin &gt;&gt; c &gt;&gt; d;</span><br><span class="line">        vector&lt;node&gt; ans;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; v[<span class="built_in">abs</span>(c)].<span class="built_in">size</span>(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; v[<span class="built_in">abs</span>(d)].<span class="built_in">size</span>(); k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// A在寻找同性朋友时，需要避免找到他想要的伴侣B，所以当前朋友就是B或B的同性朋友就是A时舍弃该结果</span></span><br><span class="line">                <span class="keyword">if</span> (v[<span class="built_in">abs</span>(c)][j] == <span class="built_in">abs</span>(d) || <span class="built_in">abs</span>(c) == v[<span class="built_in">abs</span>(d)][k]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">// A/B，先找A的所有同性朋友C，再找B的所有同性朋友D，当C和D两人是朋友的时候则可以输出C和D</span></span><br><span class="line">                <span class="keyword">if</span> (arr[v[<span class="built_in">abs</span>(c)][j] * <span class="number">10000</span> + v[<span class="built_in">abs</span>(d)][k]] == <span class="literal">true</span>)</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(node&#123;v[<span class="built_in">abs</span>(c)][j], v[<span class="built_in">abs</span>(d)][k]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>(), cmp);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">int</span>(ans.<span class="built_in">size</span>()));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; ans.<span class="built_in">size</span>(); j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%04d %04d\n&quot;</span>, ans[j].a, ans[j].b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>改进后</strong>，重新捋一下<strong>思路</strong>：</p>
<p><font color="red">重点!!!</font></p>
<ul>
<li><p>题目简化后为A寻找同性伴侣B，D寻找同性伴侣A，然后A和B是朋友，则添加到结果中。</p>
</li>
<li><p>由于数据错综复杂，所以不适合采用邻接矩阵，我们只需要记录他们之间的关系即可，数据结构可以直接采用 map&lt;pair&lt;int,int&gt;,bool&gt;来存储两者间的关系，其中make_pair&lt;int,int&gt;可以使用哈希映射，比如make_pair&lt;a,b&gt;可以等价为 a*10000+b,同时不会导致哈希冲突。</p>
</li>
<li><p>如何寻找同性朋友呢，可以使用结构体Person, Person下有一个vector用于存储同性朋友，为了快速找到 id 对应的结构体Person，我们可以用map将id直接映射到Person中。</p>
</li>
<li><p>如果用Int接收朋友，会出现+0000和-0000的情况，不能判断是否为同性朋友，题目说we use a negative sign to represent girls. 用一个符号代表女性朋友，我们可以先用string接收，然后stoi(s)转成Int形，用s.length是否相同来判断是否为同性朋友。  (对应2、3个测试点)</p>
</li>
<li><p>输出的数据必须从小到大排序</p>
</li>
<li><p>A在寻找同性朋友时应该避免找到他的同性伴侣D，坑点（对应4、5、6测试点）</p>
</li>
<li><p>输出要保留4位小数  %04d  对应（2、3测试点）</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; gayfriend;  <span class="comment">//同性朋友</span></span><br><span class="line">&#125;Person;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>,Person&gt; Map;</span><br><span class="line"><span class="comment">// unordered_map&lt;pair&lt;int,int&gt;,bool&gt; isfriend;  key不能是pair类型</span></span><br><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">bool</span>&gt; isfriend;   <span class="comment">//可以建立Int,Int的哈希映射</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; a,pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.first==b.first) <span class="keyword">return</span> a.second&lt;b.second;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a.first&lt;b.first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N,M;  cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">    <span class="comment">//input</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        string sd1,sd2;  cin&gt;&gt;sd1&gt;&gt;sd2;</span><br><span class="line">        <span class="type">int</span> id1 = <span class="built_in">abs</span>(<span class="built_in">stoi</span>(sd1)),id2 = <span class="built_in">abs</span>(<span class="built_in">stoi</span>(sd2));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建对象</span></span><br><span class="line">        <span class="keyword">if</span>(Map.<span class="built_in">find</span>(id1)==Map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            Person p; p.id = id1;</span><br><span class="line">            Map[id1] = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Map.<span class="built_in">find</span>(id2)==Map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            Person p; p.id = id2;</span><br><span class="line">            Map[id2] = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建朋友关系</span></span><br><span class="line">        <span class="comment">// isfriend[make_pair(id1,id2)]=true;</span></span><br><span class="line">        <span class="comment">// isfriend[make_pair(id2,id1)]=true;</span></span><br><span class="line">        isfriend[id1*<span class="number">10000</span>+id2]=<span class="literal">true</span>;</span><br><span class="line">        isfriend[id2*<span class="number">10000</span>+id1]=<span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//如果是同性朋友关系</span></span><br><span class="line">        <span class="keyword">if</span>(sd1.<span class="built_in">length</span>()==sd2.<span class="built_in">length</span>())&#123;</span><br><span class="line">            Map[id1].gayfriend.<span class="built_in">push_back</span>(id2);</span><br><span class="line">            Map[id2].gayfriend.<span class="built_in">push_back</span>(id1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> K; cin&gt;&gt;K;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;K;k++)&#123;</span><br><span class="line">        <span class="type">int</span> id1,id2;  cin&gt;&gt;id1&gt;&gt;id2;</span><br><span class="line">        id1 = <span class="built_in">abs</span>(id1); id2 = <span class="built_in">abs</span>(id2);</span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        Person p1 = Map[id1];</span><br><span class="line">        Person p2 = Map[id2];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;p1.gayfriend.<span class="built_in">size</span>();i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;p2.gayfriend.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="type">int</span> fri1 = p1.gayfriend[i];</span><br><span class="line">                <span class="type">int</span> fri2 = p2.gayfriend[j];</span><br><span class="line">                <span class="keyword">if</span>(fri1==id2 || fri2==id1) <span class="keyword">continue</span>;  <span class="comment">// A在寻找同性朋友时，需要避免直接找到他想要的伴侣B</span></span><br><span class="line">                <span class="keyword">if</span>(isfriend[fri1*<span class="number">10000</span>+fri2] &amp;&amp; fri1!=fri2)&#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(fri1,fri2));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//output</span></span><br><span class="line">        <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>(),cmp);</span><br><span class="line">        cout&lt;&lt;res.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;res.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%04d %04d\n&quot;</span>,res[i].first,res[i].second);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210807205353302.png" alt="image-20210807205353302"></p>
<h2 id="2021-8-14"><a href="#2021-8-14" class="headerlink" title="2021.8.14"></a>2021.8.14</h2><h3 id="PAT-1132"><a href="#PAT-1132" class="headerlink" title="PAT 1132"></a>PAT 1132</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210814125130500.png" alt="image-20210814125130500"></p>
<img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20210814125141745.png" alt="image-20210814125141745" style="zoom:150%;">

<p>题目大意：<strong>一个偶数个位的正整数num，把它从中间分成左右两个整数a、b，问num能不能被a和b的乘积整除，能的话输出yes，不能的话输出no</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N;  cin&gt;&gt;N;</span><br><span class="line">    <span class="keyword">while</span> (N--)&#123;</span><br><span class="line">        string s; cin&gt;&gt;s;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> c = <span class="built_in">stoll</span>(s);</span><br><span class="line">        string s1 = s.<span class="built_in">substr</span>(<span class="number">0</span>,s.<span class="built_in">length</span>()/<span class="number">2</span>);</span><br><span class="line">        string s2 = s.<span class="built_in">substr</span>(s.<span class="built_in">length</span>()/<span class="number">2</span>,s.<span class="built_in">length</span>()/<span class="number">2</span>);</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> c1 = <span class="built_in">stoll</span>(s1);</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> c2 = <span class="built_in">stoll</span>(s2);</span><br><span class="line">        <span class="keyword">if</span>(c%(c1*c2)==<span class="number">0</span>)</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210814125236517.png" alt="image-20210814125236517"></p>
<p>因为没有判断c1*c2能不能是0，正确的是</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N;  cin&gt;&gt;N;</span><br><span class="line">    <span class="keyword">while</span> (N--)&#123;</span><br><span class="line">        string s; cin&gt;&gt;s;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> c = <span class="built_in">stoll</span>(s);</span><br><span class="line">        string s1 = s.<span class="built_in">substr</span>(<span class="number">0</span>,s.<span class="built_in">length</span>()/<span class="number">2</span>);</span><br><span class="line">        string s2 = s.<span class="built_in">substr</span>(s.<span class="built_in">length</span>()/<span class="number">2</span>,s.<span class="built_in">length</span>()/<span class="number">2</span>);</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> c1 = <span class="built_in">stoll</span>(s1);</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> c2 = <span class="built_in">stoll</span>(s2);</span><br><span class="line">        <span class="keyword">if</span>((c1*c2) &amp;&amp;c%(c1*c2)==<span class="number">0</span>)</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210814125323306.png" alt="image-20210814125323306"></p>
<h3 id="PAT-1133"><a href="#PAT-1133" class="headerlink" title="PAT 1133"></a>PAT 1133</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210814125357711.png" alt="image-20210814125357711"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210814125410450.png" alt="image-20210814125410450"></p>
<p>题目大意：给出一个链表，将链表分为三部分，第一部分小于0的数，第二部分小于&#x3D;K的数，第三部分，大于K的数。</p>
<p>思路：数据结构，一个结构体，存放地址address,数number，下一跳nextaddress，再采用map使得可以方便地根据address查找结点所在的位置，然后获取下一跳，以此类推。最后通过三次查找把合适的部分取出来放到vector中，这样就排好序了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    string address;</span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    string nextaddress;</span><br><span class="line">    <span class="type">bool</span> isvisited = <span class="literal">false</span>;</span><br><span class="line">&#125;node;</span><br><span class="line">unordered_map&lt;string,node&gt; M;</span><br><span class="line">vector&lt;node&gt; res;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string fadd;  cin&gt;&gt;fadd;</span><br><span class="line">    <span class="type">int</span> N,K; cin&gt;&gt;N&gt;&gt;K;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        node n; </span><br><span class="line">        cin&gt;&gt;n.address&gt;&gt;n.number&gt;&gt;n.nextaddress;</span><br><span class="line">        M[n.address] = n;</span><br><span class="line">    &#125;</span><br><span class="line">    string nextaddress = fadd;</span><br><span class="line">    <span class="comment">//第一遍寻找负数</span></span><br><span class="line">    <span class="keyword">while</span>(nextaddress!=<span class="string">&quot;-1&quot;</span>)&#123;</span><br><span class="line">        node n = M[nextaddress];</span><br><span class="line">        <span class="keyword">if</span>(!n.isvisited &amp;&amp; n.number&lt;<span class="number">0</span>) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(n);</span><br><span class="line">            M[nextaddress].isvisited = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nextaddress = n.nextaddress;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第一遍寻找小于K的数</span></span><br><span class="line">    nextaddress = fadd;</span><br><span class="line">    <span class="keyword">while</span>(nextaddress!=<span class="string">&quot;-1&quot;</span>)&#123;</span><br><span class="line">        node n = M[nextaddress];</span><br><span class="line">        <span class="keyword">if</span>(!n.isvisited &amp;&amp; n.number&lt;=K) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(n);</span><br><span class="line">            M[nextaddress].isvisited = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nextaddress = n.nextaddress;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第三遍加入剩余的数</span></span><br><span class="line">    nextaddress = fadd;</span><br><span class="line">    <span class="keyword">while</span>(nextaddress!=<span class="string">&quot;-1&quot;</span>)&#123;</span><br><span class="line">        node n = M[nextaddress];</span><br><span class="line">        <span class="keyword">if</span>(!n.isvisited) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(n);</span><br><span class="line">            M[nextaddress].isvisited = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nextaddress = n.nextaddress;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//output</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;res.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i!=res.<span class="built_in">size</span>()<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s %d %s\n&quot;</span>,res[i].address.<span class="built_in">c_str</span>(),res[i].number,res[i+<span class="number">1</span>].address.<span class="built_in">c_str</span>());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s %d -1&quot;</span>,res[i].address.<span class="built_in">c_str</span>(),res[i].number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210814125702974.png" alt="image-20210814125702974"></p>
<h3 id="PAT-1134"><a href="#PAT-1134" class="headerlink" title="PAT 1134"></a>PAT 1134</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210814125742396.png" alt="image-20210814125742396"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210814125753908.png" alt="image-20210814125753908"></p>
<p>题目大意：n个顶点和m条边的图，分别给出m条边的两端顶点，然后对其进行k次查询，每次查询输入一个顶点集合，要求判断这个顶点集合是否能完成顶点覆盖，即图中的每一条边都至少有一个顶点在这个集合中。</p>
<p>思路：很简单，将顶点集合用map存，然后遍历边，判断是否有一个顶点在map中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; edgeset;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N,M; cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        <span class="type">int</span> e1,e2; cin&gt;&gt;e1&gt;&gt;e2;</span><br><span class="line">        edgeset.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(e1,e2));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> K; cin&gt;&gt;K;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;K;i++)&#123;</span><br><span class="line">        <span class="type">int</span> n; cin&gt;&gt;n;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; Map;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="type">int</span> c;  cin&gt;&gt;c; Map[c]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;edgeset.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">            <span class="type">int</span> e1 = edgeset[j].first, e2 = edgeset[j].second;</span><br><span class="line">            <span class="keyword">if</span>(Map.<span class="built_in">find</span>(e1)==Map.<span class="built_in">end</span>() &amp;&amp; Map.<span class="built_in">find</span>(e2)==Map.<span class="built_in">end</span>())&#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag==<span class="literal">false</span>) cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210814125924885.png" alt="image-20210814125924885"></p>
<h3 id="PAT-1135"><a href="#PAT-1135" class="headerlink" title="PAT 1135"></a>PAT 1135</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210814145832177.png" alt="image-20210814145832177"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210814145853993.png" alt="image-20210814145853993"></p>
<p><strong>题目大意</strong>：给一棵二叉搜索树的前序遍历，判断它是否为红黑树，是输出Yes，否则输出No。</p>
<p>1、非红即黑</p>
<p>2、根结点是否为黑色       </p>
<p>3、将NULL看成1个叶子节点，为黑<code>black</code>色</p>
<p>4、如果1个结点是红色，它的孩子节点是否都为黑色       </p>
<p>5、从任意结点到叶子结点的路径中，黑色结点的个数是否相同       </p>
<p><strong>考场错误思路一</strong>：由于是二叉排序树加上先序序列，可以递归构造二叉树。然后dfs的过程中判断第4个条件，并统计第5个条件（黑色结点个数是否相同）</p>
<p>一开始理解错了，从根节点到叶子结点的路径中，黑色结点个数相同。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> val;   <span class="comment">//黑为正，红为负</span></span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;TreeNode;</span><br><span class="line"><span class="comment">//根据先序序列建树</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">BuildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt; preorder,<span class="type">int</span> le,<span class="type">int</span> ri)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(le&gt;ri) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">int</span> r = preorder[le];</span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(r);</span><br><span class="line">    <span class="type">int</span> i=le+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">abs</span>(preorder[i])&lt;<span class="built_in">abs</span>(r)) i++;</span><br><span class="line">    TreeNode* left = <span class="built_in">BuildTree</span>(preorder,le+<span class="number">1</span>,i<span class="number">-1</span>);</span><br><span class="line">    TreeNode* right = <span class="built_in">BuildTree</span>(preorder,i,ri);</span><br><span class="line">    root-&gt;left = left;</span><br><span class="line">    root-&gt;right = right;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断是否为红黑树</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; black_num;   <span class="comment">//统计路径上的黑色结点的数目</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DFS</span><span class="params">(TreeNode* root,<span class="type">int</span> black)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;val&lt;<span class="number">0</span>)&#123;  <span class="comment">//判断第四个条件，如果当前是红的，他的孩子结点一定是黑的</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left &amp;&amp; root-&gt;left-&gt;val&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right &amp;&amp; root-&gt;right-&gt;val&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;val&gt;<span class="number">0</span>) black++;   <span class="comment">//黑色结点+1</span></span><br><span class="line">    <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right)&#123;</span><br><span class="line">        black_num.<span class="built_in">push_back</span>(black);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;left &amp;&amp; root-&gt;right)  <span class="keyword">return</span> <span class="built_in">DFS</span>(root-&gt;left,black)&amp;&amp;<span class="built_in">DFS</span>(root-&gt;right,black);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;left) <span class="keyword">return</span> <span class="built_in">DFS</span>(root-&gt;left,black);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;right) <span class="keyword">return</span> <span class="built_in">DFS</span>(root-&gt;right,black);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_red_or_black</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    black_num.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">nullptr</span> || root-&gt;val&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">//第一个条件，根是黑的</span></span><br><span class="line">    <span class="type">bool</span> dfs = <span class="built_in">DFS</span>(root,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(dfs==<span class="literal">false</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;black_num.<span class="built_in">size</span>()<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(black_num[i]!=black_num[i+<span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N; cin&gt;&gt;N;</span><br><span class="line">    <span class="keyword">while</span> (N--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> total; cin&gt;&gt;total;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorder</span><span class="params">(total,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;total;i++)&#123;</span><br><span class="line">            cin&gt;&gt;preorder[i];</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* tree = <span class="built_in">BuildTree</span>(preorder,<span class="number">0</span>,total<span class="number">-1</span>);</span><br><span class="line">        <span class="type">bool</span> flag = <span class="built_in">is_red_or_black</span>(tree);</span><br><span class="line">        <span class="keyword">if</span>(flag) cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210814150547067.png" alt="image-20210814150547067"></p>
<p>第3个结点段错误，建树过程中存在一些问题。</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210814154047150.png" alt="image-20210814154047150"></p>
<p><strong>考场错误思路二</strong>：为了使得每一层到叶子结点的黑色结点数相同，我私自认为</p>
<p>&#x2F;&#x2F;判断是否为红黑树</p>
<p>&#x2F;&#x2F;1、红黑树一定是一棵平衡二叉树</p>
<p>&#x2F;&#x2F;2、红黑树一定层次分明,一层黑一层白</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> val;   <span class="comment">//黑为正，红为负</span></span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;TreeNode;</span><br><span class="line"><span class="comment">//根据先序序列建树</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">BuildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt; preorder,<span class="type">int</span> le,<span class="type">int</span> ri)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(le&gt;ri) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">int</span> r = preorder[le];</span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(r);</span><br><span class="line">    <span class="type">int</span> i=le+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;ri &amp;&amp; <span class="built_in">abs</span>(preorder[i])&lt;<span class="built_in">abs</span>(r)) i++;  <span class="comment">//隐藏的bug，一定要判断i&lt;ri右边界才能再加</span></span><br><span class="line">    TreeNode* left = <span class="built_in">BuildTree</span>(preorder,le+<span class="number">1</span>,i<span class="number">-1</span>);</span><br><span class="line">    TreeNode* right = <span class="built_in">BuildTree</span>(preorder,i,ri);</span><br><span class="line">    root-&gt;left = left;</span><br><span class="line">    root-&gt;right = right;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断是否为红黑树</span></span><br><span class="line"><span class="comment">//1、红黑树一定是一棵平衡二叉树</span></span><br><span class="line"><span class="comment">//2、红黑树一定层次分明,一层黑一层白</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gethigh</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> lefthigh = <span class="built_in">gethigh</span>(root-&gt;left);</span><br><span class="line">    <span class="type">int</span> righhigh = <span class="built_in">gethigh</span>(root-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>+<span class="built_in">max</span>(lefthigh,righhigh);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isbalanced</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> lh = <span class="built_in">gethigh</span>(root-&gt;left);</span><br><span class="line">    <span class="type">int</span> rh = <span class="built_in">gethigh</span>(root-&gt;right);</span><br><span class="line">    <span class="keyword">if</span>(lh-rh&gt;<span class="number">1</span> || rh-lh&gt;<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">isbalanced</span>(root-&gt;left) &amp;&amp; <span class="built_in">isbalanced</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">levelsearch</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> black = <span class="number">1</span>;  <span class="comment">//第一层是black</span></span><br><span class="line">    queue&lt;TreeNode*&gt; Q;</span><br><span class="line">    Q.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> lsize = Q.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;lsize;i++)&#123;</span><br><span class="line">            TreeNode* p = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;val*black&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;left) Q.<span class="built_in">push</span>(p-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;right) Q.<span class="built_in">push</span>(p-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        black*=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_red_or_black</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">nullptr</span> || root-&gt;val&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">//第一个条件，根是黑的</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">isbalanced</span>(root)) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">//不是平衡二叉树</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">levelsearch</span>(root)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N; cin&gt;&gt;N;</span><br><span class="line">    <span class="keyword">while</span> (N--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> total; cin&gt;&gt;total;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorder</span><span class="params">(total,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;total;i++)&#123;</span><br><span class="line">            cin&gt;&gt;preorder[i];</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* tree = <span class="built_in">BuildTree</span>(preorder,<span class="number">0</span>,total<span class="number">-1</span>);</span><br><span class="line">        <span class="type">bool</span> flag = <span class="built_in">is_red_or_black</span>(tree);</span><br><span class="line">        <span class="keyword">if</span>(flag) cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然是错误的，所以红黑树不是平衡二叉树</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210814155039169.png" alt="image-20210814155039169"></p>
<p><strong>正确思路</strong>：</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210814155458247.png" alt="image-20210814155458247"></p>
<p>这里是判断平衡二叉树的变体，算高度时只统计黑色结点的个数</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210814155547670.png" alt="image-20210814155547670"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> val;   <span class="comment">//黑为正，红为负</span></span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;TreeNode;</span><br><span class="line"><span class="comment">//根据先序序列建树</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">BuildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt; preorder,<span class="type">int</span> le,<span class="type">int</span> ri)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(le&gt;ri) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">int</span> r = preorder[le];</span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(r);</span><br><span class="line">    <span class="type">int</span> i=le+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;ri &amp;&amp; <span class="built_in">abs</span>(preorder[i])&lt;<span class="built_in">abs</span>(r)) i++;  <span class="comment">//隐藏的bug，一定要判断i&lt;ri右边界才能再加</span></span><br><span class="line">    TreeNode* left = <span class="built_in">BuildTree</span>(preorder,le+<span class="number">1</span>,i<span class="number">-1</span>);</span><br><span class="line">    TreeNode* right = <span class="built_in">BuildTree</span>(preorder,i,ri);</span><br><span class="line">    root-&gt;left = left;</span><br><span class="line">    root-&gt;right = right;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断是否为红黑树</span></span><br><span class="line"><span class="comment">//1、红黑树一定是一棵平衡二叉树</span></span><br><span class="line"><span class="comment">//2、红黑树一定层次分明,一层黑一层白</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gethigh</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> l = <span class="built_in">gethigh</span>(root-&gt;left);</span><br><span class="line">    <span class="type">int</span> r = <span class="built_in">gethigh</span>(root-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> root-&gt;val &gt; <span class="number">0</span> ? <span class="built_in">max</span>(l, r) + <span class="number">1</span> : <span class="built_in">max</span>(l, r);</span><br><span class="line">    <span class="comment">// return 1+max(l,r);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isbalanced</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> lh = <span class="built_in">gethigh</span>(root-&gt;left);</span><br><span class="line">    <span class="type">int</span> rh = <span class="built_in">gethigh</span>(root-&gt;right);</span><br><span class="line">    <span class="keyword">if</span>(lh!=rh) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">isbalanced</span>(root-&gt;left) &amp;&amp; <span class="built_in">isbalanced</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DFS</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;val&lt;<span class="number">0</span>)&#123;  <span class="comment">//判断第四个条件，如果当前是红的，他的孩子结点一定是黑的</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left &amp;&amp; root-&gt;left-&gt;val&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right &amp;&amp; root-&gt;right-&gt;val&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;left &amp;&amp; root-&gt;right)  <span class="keyword">return</span> <span class="built_in">DFS</span>(root-&gt;left)&amp;&amp;<span class="built_in">DFS</span>(root-&gt;right);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;left) <span class="keyword">return</span> <span class="built_in">DFS</span>(root-&gt;left);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;right) <span class="keyword">return</span> <span class="built_in">DFS</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_red_or_black</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">nullptr</span> || root-&gt;val&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">//第一个条件，根是黑的</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">isbalanced</span>(root)) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">//不是平衡二叉树</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">DFS</span>(root)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N; cin&gt;&gt;N;</span><br><span class="line">    <span class="keyword">while</span> (N--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> total; cin&gt;&gt;total;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorder</span><span class="params">(total,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;total;i++)&#123;</span><br><span class="line">            cin&gt;&gt;preorder[i];</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* tree = <span class="built_in">BuildTree</span>(preorder,<span class="number">0</span>,total<span class="number">-1</span>);</span><br><span class="line">        <span class="type">bool</span> flag = <span class="built_in">is_red_or_black</span>(tree);</span><br><span class="line">        <span class="keyword">if</span>(flag) cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210814155614848.png" alt="image-20210814155614848"></p>
<h2 id="2021-8-20"><a href="#2021-8-20" class="headerlink" title="2021.8.20"></a>2021.8.20</h2><h3 id="PAT-1128"><a href="#PAT-1128" class="headerlink" title="PAT 1128"></a>PAT 1128</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820184132575.png" alt="image-20210820184132575"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820184145438.png" alt="image-20210820184145438"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820184157300.png" alt="image-20210820184157300"></p>
<p>判断同一行同一列对角线上有无N皇后，同一列题目已经保证了，同一行用map保证，对角线判断j-i&#x3D;&#x3D;abs(row[j]-row[i] ） O(n*n)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="type">int</span> K;   cin&gt;&gt;K;</span><br><span class="line">    <span class="keyword">while</span>(K--)&#123;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> map[<span class="number">1001</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> N; cin&gt;&gt;N;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">row</span><span class="params">(N+<span class="number">1</span>,<span class="number">-1</span>)</span></span>;  <span class="comment">//第一个元素不用，下标表示col，数值表示row</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">            cin&gt;&gt;row[i];</span><br><span class="line">            <span class="keyword">if</span>(map[row[i]]==<span class="number">1</span>) flag=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> map[row[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;row.<span class="built_in">size</span>();i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;row.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j-i==<span class="built_in">abs</span>(row[j]-row[i])) &#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag) cout&lt;&lt;<span class="string">&quot;YES&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820184442560.png" alt="image-20210820184442560"></p>
<h3 id="PAT-1129"><a href="#PAT-1129" class="headerlink" title="PAT 1129"></a>PAT 1129</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820184523153.png" alt="image-20210820184523153"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820184533785.png" alt="image-20210820184533785"></p>
<p><strong>题目大意</strong>：给定一个序列，求目前出现次数最多的k个数字。如果数字出现次数相同，升序排列。</p>
<p><strong>解题思路</strong>：类似LRU，寻找出现次数最多的三个。</p>
<p>数据结构的设计，一个vector&lt;pair&lt;int,int&gt;&gt; KWindow;   存放出现次数最多的K个数字,pair-&gt;first代表数字，pair-&gt;second代表出现的次数，每加入一个数字，我们就要判断是否要更新KWindow.采用unordered_map存放这个数字在目前出现了几次。</p>
<p>判断是否需要更新KWindow? </p>
<p>情况一：新加入的数字在KWindow中，直接在KWindow中更新就好了，然后排序。</p>
<p>情况二：新加入的数字不在KWindow中，而且KWindow还没满，直接加入，然后排序。</p>
<p>情况三：新加入的数字不在KWindow中，而且KWindow满了，判断是否需要替换，由于之前已经排好序了，只要和最后一个比较，如果次数&lt;最后一个，或者次数相同，数字小于最后一个，则替换掉最后一个。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; input;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; Map;    <span class="comment">//统计在j之前出现的次数</span></span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; KWindow;  <span class="comment">//存放出现次数最多的K个数字</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">finda</span><span class="params">(<span class="type">int</span> target,<span class="type">int</span> fre)</span></span>&#123;  <span class="comment">//查找当前数字是不是在KWindow中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;KWindow.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(KWindow[i].first==target)&#123;</span><br><span class="line">            KWindow[i].second = fre;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; a,pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.second==b.second) <span class="keyword">return</span> a.first&lt;b.first;</span><br><span class="line">    <span class="keyword">return</span> a.second&gt;b.second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> Min = <span class="number">0</span>;  <span class="comment">//当前最小的次数</span></span><br><span class="line">    <span class="type">int</span> N,K; cin&gt;&gt;N&gt;&gt;K;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="type">int</span> temp; cin&gt;&gt;temp;</span><br><span class="line">        input.<span class="built_in">push_back</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;N;i++)&#123;</span><br><span class="line">        Map[input[i<span class="number">-1</span>]]++;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">finda</span>(input[i<span class="number">-1</span>],Map[input[i<span class="number">-1</span>]]))&#123;  <span class="comment">//本来就在窗口里面，不用处理</span></span><br><span class="line">            <span class="keyword">if</span>(KWindow.<span class="built_in">size</span>()&lt;K)&#123;  <span class="comment">//窗口还有容量</span></span><br><span class="line">                KWindow.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(input[i<span class="number">-1</span>],Map[input[i<span class="number">-1</span>]]));</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(Map[input[i<span class="number">-1</span>]]&gt;Min &amp;&amp; KWindow.<span class="built_in">size</span>()==K)&#123;</span><br><span class="line">                KWindow.<span class="built_in">pop_back</span>();</span><br><span class="line">                KWindow.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(input[i<span class="number">-1</span>],Map[input[i<span class="number">-1</span>]]));</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(Map[input[i<span class="number">-1</span>]]==Min &amp;&amp; KWindow.<span class="built_in">size</span>()==K)&#123;</span><br><span class="line">                <span class="keyword">if</span>(KWindow[KWindow.<span class="built_in">size</span>()<span class="number">-1</span>].first&gt;input[i<span class="number">-1</span>])&#123;</span><br><span class="line">                    KWindow.<span class="built_in">pop_back</span>();</span><br><span class="line">                    KWindow.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(input[i<span class="number">-1</span>],Map[input[i<span class="number">-1</span>]]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(KWindow.<span class="built_in">begin</span>(),KWindow.<span class="built_in">end</span>(),cmp);  <span class="comment">//将窗口排好序</span></span><br><span class="line">        Min = KWindow[KWindow.<span class="built_in">size</span>()<span class="number">-1</span>].second;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: &quot;</span>,input[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;KWindow.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            cout&lt;&lt;KWindow[i].first;</span><br><span class="line">            <span class="keyword">if</span>(i!=KWindow.<span class="built_in">size</span>()<span class="number">-1</span>) cout&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820185242648.png" alt="image-20210820185242648"></p>
<h3 id="PAT-1130"><a href="#PAT-1130" class="headerlink" title="PAT 1130"></a>PAT 1130</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820185308171.png" alt="image-20210820185308171"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820185322504.png" alt="image-20210820185322504"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820185334088.png" alt="image-20210820185334088"></p>
<p><strong>题目大意</strong>：给一个二叉树，输出中缀表达式，且加上括号表示运算的优先级</p>
<p><strong>解题思路</strong>：给定的输入建树的过程我感觉比较复杂。在输入的第一遍建立TreeNode，然后将string映射到TreeNode中，但这样会有一个问题，就是string的值可能相同，所以我给每个输入结点设置了一个id，第二遍结点全部都创建好了，我们就可以根据左子树所在的行数，和右子树所在的行数 所 映射到的结点建立连接。  最后就是寻找根节点的过程，用set就可以了，把有父节点的加入set，最后不在set的那个就是根节点。</p>
<p>后面就是中序遍历，很简单了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    string val;</span><br><span class="line">    TreeNode* left,*right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(string val):<span class="built_in">val</span>(val),<span class="built_in">left</span>(<span class="literal">nullptr</span>),<span class="built_in">right</span>(<span class="literal">nullptr</span>)&#123;&#125;;</span><br><span class="line">&#125;TreeNode;</span><br><span class="line">unordered_set&lt;<span class="type">int</span>&gt; Set;  <span class="comment">//用来寻找没有前驱的结点,寻找根节点</span></span><br><span class="line">unordered_map&lt;<span class="type">int</span>,TreeNode*&gt; MM;  <span class="comment">//建立id到TreeNode的映射</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">input</span></span><br><span class="line">&#123;</span><br><span class="line">    string val;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">int</span> left;</span><br><span class="line">    <span class="type">int</span> right;</span><br><span class="line">&#125;input;</span><br><span class="line">vector&lt;input&gt; I;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">BuildTree</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;I.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        TreeNode* r = MM[I[i].id];</span><br><span class="line">        <span class="keyword">if</span>(I[i].left!=<span class="number">-1</span>)&#123;</span><br><span class="line">            TreeNode* left = MM[I[I[i].left].id];</span><br><span class="line">            Set.<span class="built_in">insert</span>(I[I[i].left].id);</span><br><span class="line">            r-&gt;left = left;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span>(I[i].right!=<span class="number">-1</span>)&#123;</span><br><span class="line">            TreeNode* right = MM[I[I[i].right].id];</span><br><span class="line">            Set.<span class="built_in">insert</span>(I[I[i].right].id);</span><br><span class="line">            r-&gt;right = right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;I.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(Set.<span class="built_in">find</span>(I[i].id)==Set.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> MM[I[i].id];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preorder</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;left)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left-&gt;left || root-&gt;left-&gt;right)  <span class="comment">//如果不是叶子结点则加括号</span></span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;(&quot;</span>;</span><br><span class="line">        <span class="built_in">preorder</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left-&gt;left || root-&gt;left-&gt;right)</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;root-&gt;val;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right-&gt;left || root-&gt;right-&gt;right)</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;(&quot;</span>;</span><br><span class="line">        <span class="built_in">preorder</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right-&gt;left || root-&gt;right-&gt;right)</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    I.<span class="built_in">push_back</span>(input&#123;&#125;);  <span class="comment">//第一个数不用</span></span><br><span class="line">    <span class="type">int</span> N; cin&gt;&gt;N;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        input ii;  cin&gt;&gt;ii.val&gt;&gt;ii.left&gt;&gt;ii.right;</span><br><span class="line">        ii.id=i;</span><br><span class="line">        I.<span class="built_in">push_back</span>(ii);</span><br><span class="line">        TreeNode* r = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(ii.val);</span><br><span class="line">        MM[ii.id] = r;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* root = <span class="built_in">BuildTree</span>();</span><br><span class="line">    <span class="built_in">preorder</span>(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820185818116.png" alt="image-20210820185818116"></p>
<h3 id="PAT-1131"><a href="#PAT-1131" class="headerlink" title="PAT 1131"></a>PAT 1131</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820181205412.png" alt="image-20210820181205412"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820181223417.png" alt="image-20210820181223417"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820181241538.png" alt="image-20210820181241538"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820181255465.png" alt="image-20210820181255465"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820181307918.png" alt="image-20210820181307918"></p>
<p><strong>题目大意</strong>：</p>
<p>给出各地铁线所经过的站点，构成一张地铁交通图。再给出起点和终点，让你找出最快的一条路径，<strong>如果路径不唯一就选择中转次数最少的那一条</strong>。 </p>
<p><strong>解题思路</strong>：</p>
<p>我没有考虑到这一点，所以2，4测试点没有过。</p>
<p>1、本来想用Floyd算法，但是发线每条边权值都为1，所以用BFS搜索即可。</p>
<p>2、构造邻接矩阵有一个问题，就是要解决0000四位整数映射问题，不然开辟10000*10000个空间未免太大了，我的做法是读入是写到set中，然后遍历set建立string-int的映射，还有int-string的映射。</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820181854943.png" alt="image-20210820181854943"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820181916383.png" alt="image-20210820181916383"></p>
<p>3、建图，采用邻接矩阵，这里存储的是无向图，因此根据线路构造的时候要存储两次，邻接矩阵存储的边值代表线路（几号线）而不是代价。</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820182051111.png" alt="image-20210820182051111"></p>
<p>4、BFS寻找最短路径，用path来存储路径，path[i] &#x3D; j表示，从j-&gt;i，方便往回寻找</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820182130533.png" alt="image-20210820182130533"></p>
<p>5、找到后需要输出路径，顺着path往回寻找，将结果放到path_中。</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820182243168.png" alt="image-20210820182243168"></p>
<p>6、最后在把path带入到Graph中构造出所要的线路结果。</p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820182317542.png" alt="image-20210820182317542"></p>
<p><strong>代码</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;vector&lt;string&gt;&gt; input;   <span class="comment">//input[i]表示i+1号线的站点</span></span><br><span class="line">unordered_set&lt;string&gt; Set;  <span class="comment">//实现站点映射</span></span><br><span class="line">unordered_map&lt;string,<span class="type">int</span>&gt; MapStoI; <span class="comment">//相互映射</span></span><br><span class="line">unordered_map&lt;<span class="type">int</span>,string&gt; MapItoS; <span class="comment">//</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; Graph;   <span class="comment">//邻接矩阵</span></span><br><span class="line"><span class="type">int</span> kkk=<span class="number">0</span>;  <span class="comment">//结点数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(string start,string destination)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="type">int</span> begin = MapStoI[start];</span><br><span class="line">    <span class="type">int</span> end = MapStoI[destination];</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(kkk,<span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">path</span><span class="params">(kkk,<span class="number">0</span>)</span></span>;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; Q;</span><br><span class="line">    Q.<span class="built_in">push</span>(begin);</span><br><span class="line">    <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>())   <span class="comment">//BFS</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(t==end) <span class="keyword">break</span>;  <span class="comment">//找到了</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;kkk;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[i]==<span class="literal">false</span> &amp;&amp; Graph[t][i])&#123;</span><br><span class="line">                Q.<span class="built_in">push</span>(i);</span><br><span class="line">                visited[i] = <span class="literal">true</span>;  <span class="comment">//访问过</span></span><br><span class="line">                path[i] = t;  <span class="comment">//记录从t-i的路径</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//搜索路径</span></span><br><span class="line">    <span class="type">int</span> p = end;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path_;  path_.<span class="built_in">push_back</span>(p);</span><br><span class="line">    <span class="keyword">while</span>(p!=begin)&#123;</span><br><span class="line">        <span class="type">int</span> temp = path[p];</span><br><span class="line">        path_.<span class="built_in">push_back</span>(temp);</span><br><span class="line">        p = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;path_.<span class="built_in">size</span>()<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">reverse</span>(path_.<span class="built_in">begin</span>(),path_.<span class="built_in">end</span>());  <span class="comment">//反转</span></span><br><span class="line">    <span class="type">int</span> bbbb = path_[<span class="number">0</span>];  <span class="type">int</span> eeee = path_[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> xianlu = Graph[path_[<span class="number">0</span>]][path_[<span class="number">1</span>]];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;path_.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(Graph[path_[i]][path_[i<span class="number">-1</span>]]==xianlu) eeee = path_[i];</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Take Line#%d from %s to %s.\n&quot;</span>,xianlu,MapItoS[bbbb].<span class="built_in">c_str</span>(),MapItoS[eeee].<span class="built_in">c_str</span>());</span><br><span class="line">            xianlu = Graph[path_[i]][path_[i<span class="number">-1</span>]];</span><br><span class="line">            bbbb = eeee;</span><br><span class="line">            eeee = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Take Line#%d from %s to %s.\n&quot;</span>,xianlu,MapItoS[bbbb].<span class="built_in">c_str</span>(),MapItoS[end].<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BuildGraph</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Graph.<span class="built_in">resize</span>(kkk,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(kkk,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;input.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;input[i].<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">            Graph[MapStoI[input[i][j<span class="number">-1</span>]]][MapStoI[input[i][j]]] = i+<span class="number">1</span>;  <span class="comment">//后面的数字代表几号线 ,0 表示不连通</span></span><br><span class="line">            Graph[MapStoI[input[i][j]]][MapStoI[input[i][j<span class="number">-1</span>]]] = i+<span class="number">1</span>; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> M; cin&gt;&gt;M;</span><br><span class="line">    <span class="comment">//1  处理输入</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;  </span><br><span class="line">        <span class="type">int</span> N; cin&gt;&gt;N;</span><br><span class="line">        <span class="function">vector&lt;string&gt; <span class="title">C</span><span class="params">(N)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;N;j++)&#123;</span><br><span class="line">            cin&gt;&gt;C[j];</span><br><span class="line">            Set.<span class="built_in">insert</span>(C[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        input.<span class="built_in">push_back</span>(C);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2 站点映射</span></span><br><span class="line">    unordered_set&lt;string&gt;::iterator iter;</span><br><span class="line">    <span class="keyword">for</span>(iter=Set.<span class="built_in">begin</span>();iter!=Set.<span class="built_in">end</span>();iter++)&#123;</span><br><span class="line">        MapItoS[kkk] = *iter;</span><br><span class="line">        MapStoI[*iter]=kkk++;</span><br><span class="line">    &#125;<span class="comment">//映射完后共有Kkk个结点，从0..kkk-1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3 建图</span></span><br><span class="line">    <span class="built_in">BuildGraph</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4 广度优先搜索寻找最短路径</span></span><br><span class="line">    <span class="type">int</span> Q; cin&gt;&gt;Q;</span><br><span class="line">    <span class="keyword">while</span>(Q--)&#123;</span><br><span class="line">        string start,end; cin&gt;&gt;start&gt;&gt;end;</span><br><span class="line">        <span class="built_in">BFS</span>(start,end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820182348064.png" alt="image-20210820182348064"></p>
<p><strong>答案正解</strong>：</p>
<p>1、使用邻接表存储     2、使用line的键为a*10000+b,建立边到线路的映射      3、dfs暴力深搜</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> visit[<span class="number">10000</span>],minCnt,minTransfer;  <span class="comment">//是否访问过 最小代价  最小中转次数</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">v</span>(<span class="number">10000</span>);  <span class="comment">//采用邻接表存储</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; path,tempPath;<span class="comment">//路径vector</span></span><br><span class="line"><span class="type">int</span> start,end1;<span class="comment">//起点 终点</span></span><br><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; line;  <span class="comment">//结点到路线的映射</span></span><br><span class="line"><span class="comment">/*unordered_map&lt;int,int&gt;line存储两个结点的边所属的路线</span></span><br><span class="line"><span class="comment">假设边两端为a到b，line的键为a*10000+b,值为这条边所属的路线*/</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">transferCnt</span><span class="params">(vector&lt;<span class="type">int</span>&gt; a)</span></span>&#123;<span class="comment">//传入临时路径，传出中转站个数</span></span><br><span class="line">	<span class="type">int</span> cnt=<span class="number">-1</span>,preLine=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;a.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(line[a[i<span class="number">-1</span>]*<span class="number">10000</span>+a[i]] != preLine) </span><br><span class="line">			cnt++;<span class="comment">//换乘数cnt+1</span></span><br><span class="line">		preLine=line[a[i<span class="number">-1</span>]*<span class="number">10000</span>+a[i]];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> cnt;<span class="comment">//输出换乘数</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> cnt)</span></span>&#123; <span class="comment">//cnt为换乘数</span></span><br><span class="line">    <span class="comment">//搜索到路径，需要更新</span></span><br><span class="line">	<span class="keyword">if</span>(node==end1 &amp;&amp; (cnt&lt;minCnt || (cnt ==minCnt&amp;&amp;<span class="built_in">transferCnt</span>(tempPath) &lt;minTransfer))) &#123;</span><br><span class="line">		minCnt=cnt;<span class="comment">//更新cnt</span></span><br><span class="line">		minTransfer=<span class="built_in">transferCnt</span>(tempPath);<span class="comment">//更新最小换乘次数</span></span><br><span class="line">		path=tempPath;<span class="comment">//更新路径vector</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(node == end1) <span class="keyword">return</span>;<span class="comment">//搜索到，但不需要更新</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;v[node].<span class="built_in">size</span>();i++)&#123;  <span class="comment">//dfs寻找路径</span></span><br><span class="line">		<span class="keyword">if</span>(visit[v[node][i]] == <span class="number">0</span>)&#123;</span><br><span class="line">			visit[v[node][i]]=<span class="number">1</span>;<span class="comment">//加锁</span></span><br><span class="line">			tempPath.<span class="built_in">push_back</span>(v[node][i]);</span><br><span class="line">			<span class="built_in">dfs</span>( v[node][i] ,cnt+<span class="number">1</span>); <span class="comment">//cnt+1，进入下一层dfs</span></span><br><span class="line">			visit[v[node][i] ]=<span class="number">0</span>;<span class="comment">//解锁  类似回溯，只对这一层dfs有效</span></span><br><span class="line">			tempPath.<span class="built_in">pop_back</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;   </span><br><span class="line">	<span class="type">int</span> n,m,k,pre,temp;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);<span class="comment">//地铁路线数</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;m,&amp;pre);<span class="comment">//pre为m线路的首站</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;m;j++)&#123;<span class="comment">//for循环剩下的m-1个站</span></span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;temp);</span><br><span class="line">			v[pre].<span class="built_in">push_back</span>(temp);</span><br><span class="line">			<span class="comment">//首站为pre的线路(vector里)加上temp站</span></span><br><span class="line">			v[temp].<span class="built_in">push_back</span>(pre);</span><br><span class="line">			<span class="comment">//temp站的vector里加入首站(pre)</span></span><br><span class="line">			line[pre*<span class="number">10000</span>+temp]=line[temp*<span class="number">10000</span>+pre]=i+<span class="number">1</span>;</span><br><span class="line">			<span class="comment">//pre到temp的线路=temp到pre的线路+1</span></span><br><span class="line">			pre=temp;<span class="comment">//首站为temp</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;k);<span class="comment">//k次查询</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;start,&amp;end1);</span><br><span class="line">		<span class="comment">//查询start站到end1站</span></span><br><span class="line"> </span><br><span class="line">		<span class="comment">//minCnt为最小换乘数，minTransfer为换乘站</span></span><br><span class="line">		minCnt=<span class="number">99999</span>,minTransfer=<span class="number">99999</span>;<span class="comment">//初始化</span></span><br><span class="line">		tempPath.<span class="built_in">clear</span>();</span><br><span class="line">		tempPath.<span class="built_in">push_back</span>(start);<span class="comment">//把start压入临时路径vector</span></span><br><span class="line">		visit[start]=<span class="number">1</span>; <span class="comment">//加锁</span></span><br><span class="line">		<span class="built_in">dfs</span>(start,<span class="number">0</span>); <span class="comment">//递归DFS！！！！！！！！！</span></span><br><span class="line">		visit[start]=<span class="number">0</span>; <span class="comment">//解锁</span></span><br><span class="line"> </span><br><span class="line">		<span class="comment">//以下为output</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,minCnt);<span class="comment">//起点&amp;终点之间的min站数</span></span><br><span class="line">		<span class="type">int</span> preLine=<span class="number">0</span>,preTransfer=start;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;path.<span class="built_in">size</span>() ; j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(line[path[j<span class="number">-1</span>]*<span class="number">10000</span>+path[j]] != preLine)&#123;</span><br><span class="line">				<span class="keyword">if</span>(preLine != <span class="number">0</span>) <span class="comment">//每当line和preline不等则输出这句话</span></span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;Take Line#%d from %04d to %04d.\n&quot;</span>,</span><br><span class="line">					preLine,preTransfer,path[j<span class="number">-1</span>] );</span><br><span class="line">				preLine=line[path[j<span class="number">-1</span>]*<span class="number">10000</span>+path[j]];<span class="comment">//更新上一条线路号</span></span><br><span class="line">				preTransfer = path[j<span class="number">-1</span>];<span class="comment">//更新上一个换乘站</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;   </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Take Line#%d from %04d to %04d.\n&quot;</span>, </span><br><span class="line">				preLine,preTransfer,end1);<span class="comment">//输出最后一小截线路</span></span><br><span class="line">				<span class="comment">//preLine路线 从preTransfer站到end1站</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210820183834493.png" alt="image-20210820183834493"></p>
<h2 id="2021-8-29"><a href="#2021-8-29" class="headerlink" title="2021.8.29"></a>2021.8.29</h2><p>1h40min搞定  98分</p>
<h3 id="PAT-1124"><a href="#PAT-1124" class="headerlink" title="PAT 1124"></a>PAT 1124</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210829105622634.png" alt="image-20210829105622634"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210829105636286.png" alt="image-20210829105636286"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210829105648351.png" alt="image-20210829105648351"></p>
<p><strong>题目大意</strong>：明PAT考了满分，高兴之余决定发起微博转发抽奖活动，从转发的网友中按顺序每隔N个人就发出一个红包。请你编写程序帮助他确定中奖名单。注意：可能有人转发多次，但不能中奖多次。所以如果处于当前中奖位置的网友已经中过奖，则跳过他顺次取下一位。按照输入的顺序输出中奖名单，每个昵称占一行。如果没有人中奖，则输出“Keep going…”</p>
<p><strong>思路</strong>：只要读懂题目，没有任何头脑的题，一个while循环，加一个set判断重复轻松搞定。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> M,N,S;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    cin&gt;&gt;M&gt;&gt;N&gt;&gt;S;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">L</span><span class="params">(M+<span class="number">1</span>,<span class="string">&quot;&quot;</span>)</span></span>; </span><br><span class="line">    set&lt;string&gt; Set;</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=M;i++)&#123;</span><br><span class="line">        cin&gt;&gt;L[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> cur = S;</span><br><span class="line">    <span class="keyword">while</span>(cur&lt;=M)&#123;</span><br><span class="line">        <span class="keyword">if</span>(Set.<span class="built_in">find</span>(L[cur])==Set.<span class="built_in">end</span>())&#123;</span><br><span class="line">            Set.<span class="built_in">insert</span>(L[cur]);</span><br><span class="line">            res.<span class="built_in">push_back</span>(L[cur]);</span><br><span class="line">            cur += N;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cur += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(Set.<span class="built_in">size</span>()==<span class="number">0</span>) cout&lt;&lt;<span class="string">&quot;Keep going...&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;res.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            cout&lt;&lt;res[i]&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210829105856839.png" alt="image-20210829105856839"></p>
<h3 id="PAT-1125"><a href="#PAT-1125" class="headerlink" title="PAT 1125"></a>PAT 1125</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210829105926511.png" alt="image-20210829105926511"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210829105937843.png" alt="image-20210829105937843"></p>
<p>题目大意：　绳子每次打结长度都会减小到原来的一半，那么打结的顺序会影响到最终的长度。求最终长度不超过的数。</p>
<p>刚开始都没太懂题目的意思…最后想想应该是排序+模拟。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N; cin&gt;&gt;N;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Input</span><span class="params">(N,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++) cin&gt;&gt;Input[i];</span><br><span class="line">    <span class="built_in">sort</span>(Input.<span class="built_in">begin</span>(),Input.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> possible = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        possible = <span class="built_in">double</span>(possible)/<span class="number">2</span> + <span class="built_in">double</span>(Input[i])/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,possible);</span><br><span class="line">    <span class="comment">// printf(&quot;%.0f&quot;,possible);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210829110128163.png" alt="image-20210829110128163"></p>
<p>注意：只需排序一次，觉得要每次有新绳子就要排序一下，比你小的两个数的平均数肯定也是最小的呀！</p>
<p>测试点1是只有一段绳子，开始的两段绳子要特殊处理，总长度初值应该是最小绳子长度，而不是0</p>
<p>稍加修改</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N; cin&gt;&gt;N;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Input</span><span class="params">(N,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++) cin&gt;&gt;Input[i];</span><br><span class="line">    <span class="built_in">sort</span>(Input.<span class="built_in">begin</span>(),Input.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> possible = Input[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;N;i++)&#123;</span><br><span class="line">        possible = (possible+Input[i])/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,possible);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210829110627305.png" alt="image-20210829110627305"></p>
<h3 id="PAT-1126"><a href="#PAT-1126" class="headerlink" title="PAT 1126"></a>PAT 1126</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210829110921087.png" alt="image-20210829110921087"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210829110935002.png" alt="image-20210829110935002"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210829110945243.png" alt="image-20210829110945243"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210829110956289.png" alt="image-20210829110956289"></p>
<p>题目大意：</p>
<p>对于无向图来说：</p>
<ol>
<li>是欧拉图，连通且所有节点的度为偶数</li>
<li>是半欧拉图，连通且只有两个节点的度为奇数</li>
</ol>
<p>转化为统计图的度，然后判断几个节点的度是奇数，如果仅仅只是这样简单处理测试点3过不去，后向仔细看题看到了<img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210829111134310.png" alt="image-20210829111134310"></p>
<p>需要是连通图才可以。</p>
<p>由于懒得构造邻接矩阵再进行遍历，这里使用并查集来判断是不是完全连通图、</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> *parents;</span><br><span class="line">    <span class="type">int</span> total;</span><br><span class="line">    <span class="built_in">UnionFind</span>(<span class="type">int</span> total)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;total = total;</span><br><span class="line">        parents = <span class="keyword">new</span> <span class="type">int</span>[total+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=total;i++)&#123;</span><br><span class="line">            parents[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Union</span><span class="params">(<span class="type">int</span> node1,<span class="type">int</span> node2)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> p1 = <span class="built_in">find</span>(node1);</span><br><span class="line">        <span class="type">int</span> p2 = <span class="built_in">find</span>(node2);</span><br><span class="line">        <span class="keyword">if</span>(p1!=p2)&#123;</span><br><span class="line">            parents[p1] = p2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(parents[node]!=node)&#123;</span><br><span class="line">            parents[node] = parents[parents[node]];</span><br><span class="line">            node = parents[node];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isConnected</span><span class="params">(<span class="type">int</span> node1,<span class="type">int</span> node2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find</span>(node1)==<span class="built_in">find</span>(node2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEurn</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;total;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isConnected</span>(i,i+<span class="number">1</span>)==<span class="literal">false</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N,M; cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">degree</span><span class="params">(N+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    UnionFind* uf = <span class="keyword">new</span> <span class="built_in">UnionFind</span>(N);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        <span class="type">int</span> n1,n2; cin&gt;&gt;n1&gt;&gt;n2;</span><br><span class="line">        degree[n1]++; degree[n2]++;</span><br><span class="line">        uf-&gt;<span class="built_in">Union</span>(n1,n2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> oddnum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==N) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,degree[i]);</span><br><span class="line">        <span class="keyword">else</span>  <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,degree[i]);</span><br><span class="line">        <span class="keyword">if</span>(degree[i]%<span class="number">2</span>) oddnum++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(uf-&gt;<span class="built_in">isEurn</span>()==<span class="literal">false</span>) &#123;cout&lt;&lt;<span class="string">&quot;Non-Eulerian&quot;</span>; <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(oddnum==<span class="number">0</span>) cout&lt;&lt;<span class="string">&quot;Eulerian&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(oddnum==<span class="number">2</span>) cout&lt;&lt;<span class="string">&quot;Semi-Eulerian&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;Non-Eulerian&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210829111235971.png" alt="image-20210829111235971"></p>
<h3 id="PAT-1127"><a href="#PAT-1127" class="headerlink" title="PAT 1127"></a>PAT 1127</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210829111310015.png" alt="image-20210829111310015"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210829111320873.png" alt="image-20210829111320873"></p>
<p><strong>题目大意</strong>：给定中序和后序序列，建立一棵树，然后对这棵树进行Z型层序遍历。</p>
<p><strong>思路</strong>：就是在层序遍历的时候需要把层数分出来，然后设置一个flag，需要的时候把序列翻转。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode* left,*right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> val):<span class="built_in">val</span>(val),<span class="built_in">left</span>(<span class="literal">nullptr</span>),<span class="built_in">right</span>(<span class="literal">nullptr</span>)&#123;&#125;;</span><br><span class="line">&#125;TreeNode;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; inorder;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; postorder;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; M;</span><br><span class="line"><span class="function">TreeNode* <span class="title">BuildTree</span><span class="params">(<span class="type">int</span> inleft,<span class="type">int</span> inright,<span class="type">int</span> postleft,<span class="type">int</span> postright)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(inleft&gt;inright) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">// cout&lt;&lt;postright&lt;&lt;endl;</span></span><br><span class="line">    <span class="type">int</span> curnode = postorder[postright];</span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(curnode);</span><br><span class="line">    <span class="type">int</span> mid = M[curnode];</span><br><span class="line">    TreeNode* left = <span class="built_in">BuildTree</span>(inleft,mid<span class="number">-1</span>,postleft,postleft+mid<span class="number">-1</span>-inleft);</span><br><span class="line">    TreeNode* right = <span class="built_in">BuildTree</span>(mid+<span class="number">1</span>,inright,postleft+mid<span class="number">-1</span>-inleft+<span class="number">1</span>,postright<span class="number">-1</span>);</span><br><span class="line">    root-&gt;left = left;</span><br><span class="line">    root-&gt;right = right;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ZigZag</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> yinzi = <span class="number">-1</span>;</span><br><span class="line">    queue&lt;TreeNode*&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; temp;</span><br><span class="line">        <span class="type">int</span> levelsize = q.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;levelsize;i++)&#123;</span><br><span class="line">            TreeNode* node = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">            temp.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(yinzi==<span class="number">-1</span>)</span><br><span class="line">            <span class="built_in">reverse</span>(temp.<span class="built_in">begin</span>(),temp.<span class="built_in">end</span>());</span><br><span class="line">        yinzi *= <span class="number">-1</span>;</span><br><span class="line">        res.<span class="built_in">insert</span>(res.<span class="built_in">end</span>(),temp.<span class="built_in">begin</span>(),temp.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N; cin&gt;&gt;N;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="type">int</span> t; cin&gt;&gt;t; inorder.<span class="built_in">push_back</span>(t);</span><br><span class="line">        M[t] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="type">int</span> t; cin&gt;&gt;t; postorder.<span class="built_in">push_back</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* root = <span class="built_in">BuildTree</span>(<span class="number">0</span>,N<span class="number">-1</span>,<span class="number">0</span>,N<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">ZigZag</span>(root);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; res.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i==res.<span class="built_in">size</span>()<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,res[i]);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,res[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210829111516703.png" alt="image-20210829111516703"></p>
<h2 id="2021-9-5"><a href="#2021-9-5" class="headerlink" title="2021.9.5"></a>2021.9.5</h2><h3 id="PAT-1120"><a href="#PAT-1120" class="headerlink" title="PAT 1120"></a>PAT 1120</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210905154114163.png" alt="image-20210905154114163"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210905154125395.png" alt="image-20210905154125395"></p>
<p>题意：统计数的各位数字之和，并升序输出</p>
<p>用set啥的就行了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//8:15-8:25</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; Map;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N; cin&gt;&gt;N;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        string s; cin&gt;&gt;s;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;s.<span class="built_in">length</span>();j++)&#123;</span><br><span class="line">            count += s[j]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map[count]++;</span><br><span class="line">    &#125;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;::iterator iter;</span><br><span class="line">    <span class="keyword">for</span>(iter=Map.<span class="built_in">begin</span>();iter!=Map.<span class="built_in">end</span>();iter++)</span><br><span class="line">    &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(iter-&gt;first);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;res.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==res.<span class="built_in">size</span>()<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,res[i]);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,res[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210905154408271.png" alt="image-20210905154408271"></p>
<h3 id="PAT-1121"><a href="#PAT-1121" class="headerlink" title="PAT 1121"></a>PAT 1121</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210905154431389.png" alt="image-20210905154431389"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210905154440477.png" alt="image-20210905154440477"></p>
<p>题目大意：给N对夫妻编号，再给M个派对里的参与人的编号，输出单身的人的编号（包括夫妻没全部到场的也算单身）</p>
<p>用map统计夫妻配对的情况，再用一个map[10000]统计到场情况，最后一一排除即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Map</span><span class="params">(<span class="number">100000</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">input</span><span class="params">(<span class="number">100000</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; in;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="type">int</span> N; cin&gt;&gt;N;</span><br><span class="line">    <span class="keyword">while</span>(N--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t,b; cin&gt;&gt;t&gt;&gt;b;</span><br><span class="line">        Map[t]=b; Map[b]=t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> M; cin&gt;&gt;M;</span><br><span class="line">    <span class="keyword">while</span>(M--)&#123;</span><br><span class="line">        <span class="type">int</span> id; cin&gt;&gt;id;</span><br><span class="line">        in.<span class="built_in">push_back</span>(id);</span><br><span class="line">        input[id]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;in.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(input[Map[in[i]]]!=<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span> res.<span class="built_in">push_back</span>(in[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;res.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==res.<span class="built_in">size</span>()<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,res[i]);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,res[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210905154613535.png" alt="image-20210905154613535"></p>
<p>改用set存储M个人的信息，就可以通过</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Map</span><span class="params">(<span class="number">100000</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">input</span><span class="params">(<span class="number">100000</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; in;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="type">int</span> N; cin&gt;&gt;N;</span><br><span class="line">    <span class="keyword">while</span>(N--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t,b; cin&gt;&gt;t&gt;&gt;b;</span><br><span class="line">        Map[t]=b; Map[b]=t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> M; cin&gt;&gt;M;</span><br><span class="line">    <span class="keyword">while</span>(M--)&#123;</span><br><span class="line">        <span class="type">int</span> id; cin&gt;&gt;id;</span><br><span class="line">        in.<span class="built_in">push_back</span>(id);</span><br><span class="line">        input[id]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;in.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(input[Map[in[i]]]!=<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span> res.<span class="built_in">insert</span>(in[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it=res.<span class="built_in">begin</span>();it!=res.<span class="built_in">end</span>();it++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (it!=res.<span class="built_in">begin</span>())<span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%05d&quot;</span>,*it);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210905155315203.png" alt="image-20210905155315203"></p>
<h3 id="PAT-1122"><a href="#PAT-1122" class="headerlink" title="PAT 1122"></a>PAT 1122</h3><p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210905155357857.png" alt="image-20210905155357857"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210905155408391.png" alt="image-20210905155408391"></p>
<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210905155419998.png" alt="image-20210905155419998"></p>
<p>判断是否是哈密顿回路，随便写写就AC了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//8:40-9:00</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> V,E; cin&gt;&gt;V&gt;&gt;E;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">graph</span>(V+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(V+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;E;i++)&#123;</span><br><span class="line">        <span class="type">int</span> e1,e2; cin&gt;&gt;e1&gt;&gt;e2;</span><br><span class="line">        graph[e1][e2]=<span class="number">1</span>; graph[e2][e1]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> Q; cin&gt;&gt;Q;</span><br><span class="line">    <span class="keyword">while</span>(Q--)&#123;</span><br><span class="line">        <span class="type">int</span> n; cin&gt;&gt;n;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Input</span><span class="params">(n)</span></span>;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; Set;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) cin&gt;&gt;Input[i];</span><br><span class="line">        <span class="keyword">if</span>(Input.<span class="built_in">size</span>()!=V+<span class="number">1</span> || Input[<span class="number">0</span>]!=Input[V])&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;V;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(graph[Input[j]][Input[j+<span class="number">1</span>]]==<span class="number">1</span>)&#123;</span><br><span class="line">                Set.<span class="built_in">insert</span>(Input[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Set.<span class="built_in">size</span>()==V) cout&lt;&lt;<span class="string">&quot;YES&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/image-20210905155456226.png" alt="image-20210905155456226"></p>
<h3 id="PAT-1123"><a href="#PAT-1123" class="headerlink" title="PAT 1123"></a>PAT 1123</h3></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Lin Li</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/">http://example.com/2023/02/28/PAT%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">LinLi's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97/">算法系列</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/03/01/tags/" title="tags"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">tags</div></div></a></div><div class="next-post pull-right"><a href="/2023/02/28/GithubAction-Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/" title="GithubAction+Hexo搭建个人博客"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">GithubAction+Hexo搭建个人博客</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Lin Li</div><div class="author-info__description">今日事，今日毕</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">119</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#PAT%E7%94%B2%E7%BA%A7%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97"><span class="toc-number">1.</span> <span class="toc-text">PAT甲级刷题指南</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E3%80%8A%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E3%80%8BC-%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93-STL-%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.1.</span> <span class="toc-text">《算法笔记》C++标准模板库(STL)介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#vector"><span class="toc-number">1.1.1.</span> <span class="toc-text">vector</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%EF%BC%9A"><span class="toc-number">1.1.1.0.1.</span> <span class="toc-text">定义：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%9A"><span class="toc-number">1.1.1.0.2.</span> <span class="toc-text">初始化：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%EF%BC%9A"><span class="toc-number">1.1.1.0.3.</span> <span class="toc-text">访问：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="toc-number">1.1.1.0.4.</span> <span class="toc-text">常用函数：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%EF%BC%9A"><span class="toc-number">1.1.1.0.5.</span> <span class="toc-text">常见错误：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#set"><span class="toc-number">1.1.2.</span> <span class="toc-text">set</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%EF%BC%9A-1"><span class="toc-number">1.1.2.0.1.</span> <span class="toc-text">定义：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%9A-1"><span class="toc-number">1.1.2.0.2.</span> <span class="toc-text">初始化：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%EF%BC%9A-1"><span class="toc-number">1.1.2.0.3.</span> <span class="toc-text">访问：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%EF%BC%9A-1"><span class="toc-number">1.1.2.0.4.</span> <span class="toc-text">常用函数：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#string"><span class="toc-number">1.1.3.</span> <span class="toc-text">string</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%EF%BC%9A-2"><span class="toc-number">1.1.3.0.1.</span> <span class="toc-text">定义：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%9A-2"><span class="toc-number">1.1.3.0.2.</span> <span class="toc-text">初始化：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%EF%BC%9A-2"><span class="toc-number">1.1.3.0.3.</span> <span class="toc-text">访问：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%EF%BC%9A-2"><span class="toc-number">1.1.3.0.4.</span> <span class="toc-text">常用函数：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#string%E5%92%8Cchar-%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.1.3.0.5.</span> <span class="toc-text">string和char[]的转换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#string%E5%92%8Cint%E7%AD%89%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.1.3.0.6.</span> <span class="toc-text">string和int等类型的转换</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%A7%E5%B0%8F%E5%86%99%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">大小写转换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map"><span class="toc-number">1.1.4.</span> <span class="toc-text">map</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%EF%BC%9A-3"><span class="toc-number">1.1.4.0.1.</span> <span class="toc-text">定义：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%9A-3"><span class="toc-number">1.1.4.0.2.</span> <span class="toc-text">初始化：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%EF%BC%9A-3"><span class="toc-number">1.1.4.0.3.</span> <span class="toc-text">访问：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%EF%BC%9A-3"><span class="toc-number">1.1.4.0.4.</span> <span class="toc-text">常用函数：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#multimap"><span class="toc-number">1.1.4.0.5.</span> <span class="toc-text">multimap:</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#queue"><span class="toc-number">1.1.5.</span> <span class="toc-text">queue</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%EF%BC%9A-4"><span class="toc-number">1.1.5.0.1.</span> <span class="toc-text">定义：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#queue%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%9A"><span class="toc-number">1.1.5.0.2.</span> <span class="toc-text">queue初始化：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%EF%BC%9A-4"><span class="toc-number">1.1.5.0.3.</span> <span class="toc-text">访问：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%EF%BC%9A-4"><span class="toc-number">1.1.5.0.4.</span> <span class="toc-text">常用函数：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#priority-queue"><span class="toc-number">1.1.5.0.5.</span> <span class="toc-text">priority_queue:</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#stack"><span class="toc-number">1.1.6.</span> <span class="toc-text">stack</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%EF%BC%9A-5"><span class="toc-number">1.1.6.0.1.</span> <span class="toc-text">定义：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%9A-4"><span class="toc-number">1.1.6.0.2.</span> <span class="toc-text">初始化：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%EF%BC%9A-5"><span class="toc-number">1.1.6.0.3.</span> <span class="toc-text">访问：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%EF%BC%9A-5"><span class="toc-number">1.1.6.0.4.</span> <span class="toc-text">常用函数：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pair"><span class="toc-number">1.1.7.</span> <span class="toc-text">pair</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%EF%BC%9A-6"><span class="toc-number">1.1.7.0.1.</span> <span class="toc-text">定义：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%9A-5"><span class="toc-number">1.1.7.0.2.</span> <span class="toc-text">初始化：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%EF%BC%9A-6"><span class="toc-number">1.1.7.0.3.</span> <span class="toc-text">访问：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%EF%BC%9A-6"><span class="toc-number">1.1.7.0.4.</span> <span class="toc-text">常用函数：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E4%BA%8E%E4%BD%9C%E4%B8%BAmap%E7%9A%84%E9%94%AE%E5%80%BC%E5%AF%B9%E8%BF%9B%E8%A1%8C%E6%8F%92%E5%85%A5%EF%BC%9A"><span class="toc-number">1.1.7.0.5.</span> <span class="toc-text">常用于作为map的键值对进行插入：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#algorithm%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.8.</span> <span class="toc-text">algorithm常用函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#max-%E3%80%81min-%E3%80%81abs"><span class="toc-number">1.1.8.0.1.</span> <span class="toc-text">max()、min()、abs()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#swap"><span class="toc-number">1.1.8.0.2.</span> <span class="toc-text">swap</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#reverse"><span class="toc-number">1.1.8.0.3.</span> <span class="toc-text">reverse()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#fill"><span class="toc-number">1.1.8.0.4.</span> <span class="toc-text">fill()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#sort"><span class="toc-number">1.1.8.0.5.</span> <span class="toc-text">sort()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#lower-bound-%E5%92%8Cupper-bound"><span class="toc-number">1.1.8.0.6.</span> <span class="toc-text">lower_bound()和upper_bound()</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PAT%E7%9C%9F%E9%A2%98%E6%A8%A1%E6%8B%9F"><span class="toc-number">1.2.</span> <span class="toc-text">PAT真题模拟</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#PAT-1001"><span class="toc-number">1.2.1.</span> <span class="toc-text">PAT 1001</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PAT-1002"><span class="toc-number">1.2.2.</span> <span class="toc-text">PAT 1002</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PAT-1003-dijstra"><span class="toc-number">1.2.3.</span> <span class="toc-text">PAT 1003 (dijstra)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PAT-1004%EF%BC%88%E6%8C%89%E5%B1%82%E7%BB%9F%E8%AE%A1%E6%A0%91%E7%9A%84%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%EF%BC%89"><span class="toc-number">1.2.4.</span> <span class="toc-text">PAT 1004（按层统计树的叶子节点）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PAT-1005"><span class="toc-number">1.2.5.</span> <span class="toc-text">PAT 1005</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PAT-1006"><span class="toc-number">1.2.6.</span> <span class="toc-text">PAT 1006</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PAT-1007%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89"><span class="toc-number">1.2.7.</span> <span class="toc-text">PAT 1007（动态规划）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PAT-1008"><span class="toc-number">1.2.8.</span> <span class="toc-text">PAT 1008</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PAT-1009"><span class="toc-number">1.2.9.</span> <span class="toc-text">PAT 1009</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PAT-1010%EF%BC%88%E6%95%B0%E5%AD%A6%E9%A2%98%EF%BC%89"><span class="toc-number">1.2.10.</span> <span class="toc-text">PAT 1010（数学题）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PAT-1011"><span class="toc-number">1.2.11.</span> <span class="toc-text">PAT 1011</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PAT-1012"><span class="toc-number">1.2.12.</span> <span class="toc-text">PAT 1012</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PAT-1013%EF%BC%88%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F%EF%BC%89"><span class="toc-number">1.2.13.</span> <span class="toc-text">PAT 1013（连通分量）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PAT-1014-%E9%98%9F%E5%88%97%E6%A8%A1%E6%8B%9F"><span class="toc-number">1.2.14.</span> <span class="toc-text">PAT 1014 (队列模拟)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PAT-1015"><span class="toc-number">1.2.15.</span> <span class="toc-text">PAT 1015</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PAT-1016"><span class="toc-number">1.2.16.</span> <span class="toc-text">PAT 1016</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PAT-1039"><span class="toc-number">1.2.17.</span> <span class="toc-text">PAT 1039</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PAT-1040%EF%BC%88dp"><span class="toc-number">1.2.18.</span> <span class="toc-text">PAT 1040（dp)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PAT-1041"><span class="toc-number">1.2.19.</span> <span class="toc-text">PAT 1041</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PAT-1081"><span class="toc-number">1.2.20.</span> <span class="toc-text">PAT 1081</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2021-7-10"><span class="toc-number">1.3.</span> <span class="toc-text">2021.7.10</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#PAT-1152"><span class="toc-number">1.3.1.</span> <span class="toc-text">PAT 1152</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PAT-1153"><span class="toc-number">1.3.2.</span> <span class="toc-text">PAT 1153</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PAT-1154"><span class="toc-number">1.3.3.</span> <span class="toc-text">PAT 1154</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PAT-1155%EF%BC%88%E5%9B%9E%E6%BA%AF%EF%BC%89"><span class="toc-number">1.3.4.</span> <span class="toc-text">PAT 1155（回溯）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2021-7-17"><span class="toc-number">1.4.</span> <span class="toc-text">2021.7.17</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#PAT-1148"><span class="toc-number">1.4.1.</span> <span class="toc-text">PAT 1148</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PAT-1149"><span class="toc-number">1.4.2.</span> <span class="toc-text">PAT 1149</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PAT-1150"><span class="toc-number">1.4.3.</span> <span class="toc-text">PAT 1150</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PAT-1151"><span class="toc-number">1.4.4.</span> <span class="toc-text">PAT 1151</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2021-7-24"><span class="toc-number">1.5.</span> <span class="toc-text">2021.7.24</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#PAT-1144"><span class="toc-number">1.5.1.</span> <span class="toc-text">PAT 1144</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PAT-1145"><span class="toc-number">1.5.2.</span> <span class="toc-text">PAT 1145</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PAT-1146"><span class="toc-number">1.5.3.</span> <span class="toc-text">PAT 1146</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PAT-1147"><span class="toc-number">1.5.4.</span> <span class="toc-text">PAT 1147</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2021-7-31"><span class="toc-number">1.6.</span> <span class="toc-text">2021.7.31</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#PAT-1140"><span class="toc-number">1.6.1.</span> <span class="toc-text">PAT 1140</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PAT-1141"><span class="toc-number">1.6.2.</span> <span class="toc-text">PAT 1141</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PAT-1142"><span class="toc-number">1.6.3.</span> <span class="toc-text">PAT 1142</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PAT-1143"><span class="toc-number">1.6.4.</span> <span class="toc-text">PAT 1143</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2021-8-7"><span class="toc-number">1.7.</span> <span class="toc-text">2021.8.7</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#PAT-1136"><span class="toc-number">1.7.1.</span> <span class="toc-text">PAT 1136</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PAT-1137"><span class="toc-number">1.7.2.</span> <span class="toc-text">PAT 1137</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PAT-1138"><span class="toc-number">1.7.3.</span> <span class="toc-text">PAT 1138</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PAT-1139"><span class="toc-number">1.7.4.</span> <span class="toc-text">PAT 1139</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2021-8-14"><span class="toc-number">1.8.</span> <span class="toc-text">2021.8.14</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#PAT-1132"><span class="toc-number">1.8.1.</span> <span class="toc-text">PAT 1132</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PAT-1133"><span class="toc-number">1.8.2.</span> <span class="toc-text">PAT 1133</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PAT-1134"><span class="toc-number">1.8.3.</span> <span class="toc-text">PAT 1134</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PAT-1135"><span class="toc-number">1.8.4.</span> <span class="toc-text">PAT 1135</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2021-8-20"><span class="toc-number">1.9.</span> <span class="toc-text">2021.8.20</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#PAT-1128"><span class="toc-number">1.9.1.</span> <span class="toc-text">PAT 1128</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PAT-1129"><span class="toc-number">1.9.2.</span> <span class="toc-text">PAT 1129</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PAT-1130"><span class="toc-number">1.9.3.</span> <span class="toc-text">PAT 1130</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PAT-1131"><span class="toc-number">1.9.4.</span> <span class="toc-text">PAT 1131</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2021-8-29"><span class="toc-number">1.10.</span> <span class="toc-text">2021.8.29</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#PAT-1124"><span class="toc-number">1.10.1.</span> <span class="toc-text">PAT 1124</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PAT-1125"><span class="toc-number">1.10.2.</span> <span class="toc-text">PAT 1125</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PAT-1126"><span class="toc-number">1.10.3.</span> <span class="toc-text">PAT 1126</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PAT-1127"><span class="toc-number">1.10.4.</span> <span class="toc-text">PAT 1127</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2021-9-5"><span class="toc-number">1.11.</span> <span class="toc-text">2021.9.5</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#PAT-1120"><span class="toc-number">1.11.1.</span> <span class="toc-text">PAT 1120</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PAT-1121"><span class="toc-number">1.11.2.</span> <span class="toc-text">PAT 1121</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PAT-1122"><span class="toc-number">1.11.3.</span> <span class="toc-text">PAT 1122</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PAT-1123"><span class="toc-number">1.11.4.</span> <span class="toc-text">PAT 1123</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/01/DeepSeek-R1-Incentivizing-Reasoning-Capability-in-LLMs-via-Reinforcement-Learning/" title="DeepSeek-R1: Incentivizing Reasoning Capability in LLMs via Reinforcement Learning">DeepSeek-R1: Incentivizing Reasoning Capability in LLMs via Reinforcement Learning</a><time datetime="2025-02-01T11:11:48.000Z" title="发表于 2025-02-01 19:11:48">2025-02-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/01/DeepSeek-Coder-When-the-Large-Language-Model-Meets-Programming-The-Rise-of-Code-Intelligence/" title="DeepSeek-Coder: When the Large Language Model Meets Programming - The Rise of Code Intelligence">DeepSeek-Coder: When the Large Language Model Meets Programming - The Rise of Code Intelligence</a><time datetime="2025-02-01T02:43:19.000Z" title="发表于 2025-02-01 10:43:19">2025-02-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/30/LLM-Hallucinations-in-Practical-Code-Generation-Phenomena-Mechanism-and-Mitigation/" title="LLM Hallucinations in Practical Code Generation: Phenomena, Mechanism, and Mitigation">LLM Hallucinations in Practical Code Generation: Phenomena, Mechanism, and Mitigation</a><time datetime="2025-01-30T12:14:09.000Z" title="发表于 2025-01-30 20:14:09">2025-01-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/24/Benchmarking-Bias-in-Large-Language-Models-during-Role-Playing/" title="Benchmarking Bias in Large Language Models during Role-Playing">Benchmarking Bias in Large Language Models during Role-Playing</a><time datetime="2025-01-24T14:55:55.000Z" title="发表于 2025-01-24 22:55:55">2025-01-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/24/Diversity-Drives-Fairness-Ensemble-of-Higher-Order-Mutants-for-Intersectional-Fairness-of-Machine-Learning-Software/" title="Diversity Drives Fairness Ensemble of Higher Order Mutants for Intersectional Fairness of Machine Learning Software">Diversity Drives Fairness Ensemble of Higher Order Mutants for Intersectional Fairness of Machine Learning Software</a><time datetime="2025-01-24T12:23:10.000Z" title="发表于 2025-01-24 20:23:10">2025-01-24</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Lin Li</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>