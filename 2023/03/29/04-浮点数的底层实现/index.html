<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>04-浮点数的底层实现 | LinLi's Blog</title><meta name="author" content="Lin Li"><meta name="copyright" content="Lin Li"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="04-浮点数的底层实现从现在开始，我们就来分析Python中常见的内置对象、以及对应的实例对象，看看它们在底层是如何实现的。但说实话，我们在前面几节中介绍对象的时候，已经说了不少了，不过从现在开始要进行更深入的分析。 除了对象本身，还要看对象支持的操作在底层是如何实现的。我们首先以浮点数为例，因为它是最简单的，没错，浮点数比整型要简单。至于为什么，当我们分析整型的时候就知道了。 内部对象float">
<meta property="og:type" content="article">
<meta property="og:title" content="04-浮点数的底层实现">
<meta property="og:url" content="http://example.com/2023/03/29/04-%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/index.html">
<meta property="og:site_name" content="LinLi&#39;s Blog">
<meta property="og:description" content="04-浮点数的底层实现从现在开始，我们就来分析Python中常见的内置对象、以及对应的实例对象，看看它们在底层是如何实现的。但说实话，我们在前面几节中介绍对象的时候，已经说了不少了，不过从现在开始要进行更深入的分析。 除了对象本身，还要看对象支持的操作在底层是如何实现的。我们首先以浮点数为例，因为它是最简单的，没错，浮点数比整型要简单。至于为什么，当我们分析整型的时候就知道了。 内部对象float">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2023-03-29T02:29:03.000Z">
<meta property="article:modified_time" content="2023-04-12T02:36:59.412Z">
<meta property="article:author" content="Lin Li">
<meta property="article:tag" content="CPython">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/03/29/04-%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '04-浮点数的底层实现',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-04-12 10:36:59'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">89</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="LinLi's Blog"><span class="site-name">LinLi's Blog</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">04-浮点数的底层实现</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-29T02:29:03.000Z" title="发表于 2023-03-29 10:29:03">2023-03-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-04-12T02:36:59.412Z" title="更新于 2023-04-12 10:36:59">2023-04-12</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="04-浮点数的底层实现"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="04-浮点数的底层实现"><a href="#04-浮点数的底层实现" class="headerlink" title="04-浮点数的底层实现"></a>04-浮点数的底层实现</h2><p>从现在开始，我们就来分析Python中常见的内置对象、以及对应的实例对象，看看它们在底层是如何实现的。但说实话，我们在前面几节中介绍对象的时候，已经说了不少了，不过从现在开始要进行更深入的分析。</p>
<p>除了对象本身，还要看对象支持的操作在底层是如何实现的。我们首先以浮点数为例，因为它是最简单的，没错，浮点数比整型要简单。至于为什么，当我们分析整型的时候就知道了。</p>
<h3 id="内部对象"><a href="#内部对象" class="headerlink" title="内部对象"></a>内部对象</h3><p><strong>float实例对象定义在Include&#x2F;floatobject.h中，结构非常简单：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Include/floatobject.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    <span class="type">double</span> ob_fval;</span><br><span class="line">&#125; PyFloatObject;</span><br></pre></td></tr></table></figure>

<p><strong>除了PyObject这个公共的头部信息之外，只有一个额外的ob_fval，用于存储具体的值，而且直接使用的C中的double。</strong></p>
<p><img src="/2023/03/29/04-%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200801195351664-171093404.png" alt="img"></p>
<p>​        <strong>那么float类型对象在底层长啥样子呢？</strong>    </p>
<p><strong>与实例对象不同，float类型对象全局唯一，因此可以作为全局变量定义。底层对应PyFloat_Type，位于Objects&#x2F;floatobject.c中。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Objects/floatobject.c</span></span><br><span class="line">PyTypeObject PyFloat_Type = &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, <span class="number">0</span>)</span><br><span class="line">    <span class="string">&quot;float&quot;</span>,</span><br><span class="line">    <span class="keyword">sizeof</span>(PyFloatObject),</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    (destructor)float_dealloc,                  <span class="comment">/* tp_dealloc */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_print */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_getattr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_setattr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_reserved */</span></span><br><span class="line">    (reprfunc)float_repr,                       <span class="comment">/* tp_repr */</span></span><br><span class="line">    &amp;float_as_number,                           <span class="comment">/* tp_as_number */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_sequence */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_mapping */</span></span><br><span class="line">    (hashfunc)float_hash,                       <span class="comment">/* tp_hash */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_call */</span></span><br><span class="line">    (reprfunc)float_repr,                       <span class="comment">/* tp_str */</span></span><br><span class="line">    PyObject_GenericGetAttr,                    <span class="comment">/* tp_getattro */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_setattro */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_buffer */</span></span><br><span class="line">    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   <span class="comment">/* tp_flags */</span></span><br><span class="line">    float_new__doc__,                           <span class="comment">/* tp_doc */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_traverse */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_clear */</span></span><br><span class="line">    float_richcompare,                          <span class="comment">/* tp_richcompare */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_weaklistoffset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_iter */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_iternext */</span></span><br><span class="line">    float_methods,                              <span class="comment">/* tp_methods */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_members */</span></span><br><span class="line">    float_getset,                               <span class="comment">/* tp_getset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_base */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_dict */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_descr_get */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_descr_set */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_dictoffset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_init */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_alloc */</span></span><br><span class="line">    float_new,                                  <span class="comment">/* tp_new */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>PyFloat_Type中保存了很多关于浮点数对象的元信息，关键字段包括：</strong></p>
<ul>
<li><code>tp_name字段保存了类型名称，是一个char *，显然是&quot;float&quot;；</code></li>
<li><code>tp_dealloc、tp_init、tp_alloc和 tp_new字段是与对象创建销毁相关的函数；</code></li>
<li><code>tp_repr字段对应__repr__方法，生成语法字符串；</code></li>
<li><code>tp_str字段对应__str__方法，生成普通字符串；</code></li>
<li><code>tp_as_number字段对应数值对象支持的操作簇；</code></li>
<li><code>tp_hash字段是哈希值生成函数；</code></li>
</ul>
<p><strong>PyFloat_Type很重要，作为浮点类型对象，它决定了浮点数的生死和行为。</strong></p>
<h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><p><strong>在上一篇博客中，我们初步了解到创建实例对象的一般过程。对于内置类型的实例对象，可以使用Python&#x2F;C API创建，也可以通过调用类型对象创建。</strong></p>
<p><strong>调用类型对象float创建实例对象，Python执行的是type类型对象中的tp_call函数。tp_call中会先调用类型对象的tp_new为该对象的实例对象申请一份空间，申请完毕之后该对象就已经被创建了。然后会再调用tp_init，并将实例对象作为参数传递进去，进行初始化，也就是设置属性。</strong></p>
<p><strong>但是对于float来说，它内部的tp_init成员是0，从PyFloat_Type的定义我们也可以看到。说明float没有__init__函数，原因是float是一种很简单的类型对象，初始化操作只需要一个赋值语句，所以在tp_new中就可以完成。</strong></p>
<p>​        <strong>除了通过调用类型对象创建实例对象这种通用型方法之外，CPython还为内置类型对象提供了一些Python&#x2F;C  API来创建对应的实例对象。可以简化调用，提高效率。关于为什么可以提高效率，我们之前已经分析过了，我们说通过Python&#x2F;C  API创建的话，会直接解析成底层对应的数据结构，而通过类型对象调用的话则会有一些额外的开销。</strong>    </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyFloat_FromDouble</span><span class="params">(<span class="type">double</span> fval)</span>;</span><br><span class="line"></span><br><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyFloat_FromString</span><span class="params">(PyObject *v)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>以上是底层提供的两个创建浮点数的C API，当然还有其它的。</strong></p>
<ul>
<li><code>PyFloat_FromDouble：通过C中的double创建float对象；</code></li>
<li><code>PyFloat_FromString：通过字符串对象创建float对象；</code></li>
</ul>
<p><strong>以PyFloat_FromDouble为例，我们看看底层是怎么创建的？该函数同样位于Objects&#x2F;floatobject.c中。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyFloat_FromDouble</span><span class="params">(<span class="type">double</span> fval)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//我们之前在介绍引用计数的时候，说过引用计数为0了，那么对象会被销毁</span></span><br><span class="line">    <span class="comment">//但是对象所占的内存则不一定回收、或者说还给操作系统，而是会缓存起来</span></span><br><span class="line">    <span class="comment">//所以从这行代码我们就看到了，创建浮点数对象的时候会优先从缓存池里面获取</span></span><br><span class="line">    <span class="comment">//而缓存池是使用链表实现的，free_list(指针)指向的链表的第一个对象</span></span><br><span class="line">    PyFloatObject *op = free_list;</span><br><span class="line">    <span class="comment">//op不是NULL，说明缓存池中有对象，成功获取</span></span><br><span class="line">    <span class="keyword">if</span> (op != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//一旦获取了，那么要将free_list指向链表中当前获取的对象的下一个对象</span></span><br><span class="line">        <span class="comment">//但是Py_TYPE不是一个宏吗？它获取的应该是对象的ob_type啊，那么Py_TYPE(op)获取的不是PyFloat_Type指针吗？别急这一点我们后面会说</span></span><br><span class="line">        free_list = (PyFloatObject *) Py_TYPE(op); </span><br><span class="line">        <span class="comment">//并且将缓存池的内部可以使用的浮点数对象的数量减1</span></span><br><span class="line">        <span class="comment">//关于缓存池, 以及为什么要使用缓存池下面也会细说</span></span><br><span class="line">        <span class="comment">//目前先知道Python在分配浮点数对象的时候会先从缓存池里面获取就可以了</span></span><br><span class="line">        numfree--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//否则的话，调用PyObject_MALLOC申请内存，PyObject_MALLOC是基于malloc的一个封装</span></span><br><span class="line">        op = (PyFloatObject*) PyObject_MALLOC(<span class="keyword">sizeof</span>(PyFloatObject));</span><br><span class="line">        <span class="comment">//申请失败的话，证明内存不够了</span></span><br><span class="line">        <span class="keyword">if</span> (!op)</span><br><span class="line">            <span class="keyword">return</span> PyErr_NoMemory();</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//走到这里说明内存分配好了，PyFloatObject也创建了，但是不是还少了点啥呢？显然内部的成员还没有初始化</span></span><br><span class="line">    <span class="comment">//还是那句话内置类型的实例对象该分配多少空间，解释器了如指掌，因为通过PyFloatObject内部的成员一算就出来了。</span></span><br><span class="line">    <span class="comment">//因此虽然对象创建了，但是此时内部的ob_refcnt、ob_type、以及ob_fval三个成员还没有被初始化。</span></span><br><span class="line">    <span class="comment">//所以还要将其ob_refcnt设置为1(因为对于刚创建的对象来说,内部的引用计数显然为1)，将ob_type设置为指向PyFloat_Type的指针</span></span><br><span class="line">    <span class="comment">//而PyObject_INIT是一个宏，它就是专门用来设置ob_type以及ob_refcnt的，我们后面看这个宏的定义就知道了</span></span><br><span class="line">    (<span class="type">void</span>)PyObject_INIT(op, &amp;PyFloat_Type);</span><br><span class="line">    <span class="comment">//将内部的ob_fval成员设置为fval，所以此时三个成员都已经初始化完毕</span></span><br><span class="line">    op-&gt;ob_fval = fval;</span><br><span class="line">    <span class="comment">//将其转成PyObject *返回</span></span><br><span class="line">    <span class="keyword">return</span> (PyObject *) op;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所以整体流程如下：</strong></p>
<ul>
<li><code>1. 为实例对象分配内存空间，空间分配完了对象也就创建了，不过会优先使用缓存池；</code></li>
<li><code>2. 初始化实例对象内部的引用计数和类型指针；</code></li>
<li><code>3. 初始化ob_fval为指定的浮点值；</code></li>
</ul>
<p><strong>然后我们看一下PyObject_INIT这个宏，它位于Include&#x2F;objimpl.h中。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PyObject_INIT(op, typeobj) \</span></span><br><span class="line"><span class="meta">    ( Py_TYPE(op) = (typeobj), _Py_NewReference((PyObject *)(op)), (op) )</span></span><br><span class="line"><span class="comment">//这个宏接收两个参数，分别是：实例对象的指针和指向的类型对象的指针</span></span><br><span class="line"><span class="comment">//然后Py_TYPE(op)表示获取其内部的ob_type, 将其设置为typeobj, 而typeobj在源码中传入的就是&amp;PyFloat_Type</span></span><br><span class="line"><span class="comment">//然后是_Py_NewReference, 这个宏我们在上一篇博客中已经说过了，它用于将对象的引用计数初始化为1</span></span><br></pre></td></tr></table></figure>

<h3 id="对象的销毁"><a href="#对象的销毁" class="headerlink" title="对象的销毁"></a>对象的销毁</h3><p><strong>当删除一个变量时，Python会通过宏Py_DECREF或者Py_XDECREF来减少该变量指向的对象的引用计数；当引用计数为0时，就会回收该对象。而回收该对象会调用其类型对象中的tp_dealloc指向的函数。当然啦，CPython依旧为回收对象提供了一个宏，我们上一篇中也说过了。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _Py_Dealloc(op) (                               \</span></span><br><span class="line"><span class="meta">    _Py_INC_TPFREES(op) _Py_COUNT_ALLOCS_COMMA          \</span></span><br><span class="line"><span class="meta">    (*Py_TYPE(op)-&gt;tp_dealloc)((PyObject *)(op)))</span></span><br><span class="line"><span class="comment">// _Py_Dealloc(op)会调用op指向的对象的类型对象中的析构函数，同时将op自身作为参数传递进去，表示将op指向的对象回收。</span></span><br></pre></td></tr></table></figure>

<p><strong>而PyFloat_Type中的tp_dealloc成员被初始化为float_dealloc，所以析构函数最终执行的是float_dealloc，关于它的源代码我们会在一会儿介绍缓存池的时候细说。</strong></p>
<p><strong>总结一下的话，浮点数对象从创建到销毁整个生命周期所涉及的关键函数、宏、调用关系可以如下图所示：</strong></p>
<p><img src="/2023/03/29/04-%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200801195401032-229146894.png" alt="img"></p>
<p><strong>我们看到通过类型对象调用的方式来创建实例对象，最终也是要走Python&#x2F;C API的，肯定没有直接通过Python&#x2F;C API创建的方式快，因为前者多了几个步骤。</strong></p>
<blockquote>
<p><strong>所以如果是float(3.14)，那么最终也会调用PyFloat_FromDouble(3.14)；如果是float(“3.14”)，那么最终会调用PyFloat_FromString(“3.14”)。所以调用类型对象的时候，会先兜个圈子再去使用Python&#x2F;C API，肯定没有直接使用Python&#x2F;C API的效率高。</strong></p>
</blockquote>
<h3 id="缓存池"><a href="#缓存池" class="headerlink" title="缓存池"></a>缓存池</h3><p><strong>我们说浮点数这种对象是经常容易被创建和销毁的，如果每创建一个就分配一次内存、每销毁一个就回收一次内存的话，那效率会低到可想而知了。我们知道Python在操作系统之上封装了一个内存池，可以用于小内存对象的快速创建和销毁，这便是Python的内存池机制。但浮点数使用的频率很高，我们有时会创建和销毁大量的临时对象，所以如果每一次对象的创建和销毁都伴随着内存相关的操作的话，这个时候即便是有内存池机制，效率也是不高的。</strong></p>
<p><strong>考虑如下代码：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>pi = <span class="number">3.14</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = <span class="number">2.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = pi * r ** <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line"><span class="number">12.56</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>这个语句首先计算半径r的平方，然后根据结果创建一个临时对象，假设是t；然后再将pi和t进行相乘，得到最终结果并赋值给s；最终销毁临时变量t，所以这背后是隐藏着一个临时对象的创建和删除的。</strong></p>
<p><strong>当然这里一行代码可能感觉不到啥，假设我们要计算很多很多个半径对应的面积呢？显然需要写for循环，如果循环一万次就意味着要创建和销毁临时对象各一万次。</strong></p>
<p>因此，如果每一次创建对象都需要分配内存，销毁对象时需要回收内存的话，那么大量临时对象的创建和销毁就意味着要伴随大量的<font color="red">内存分配以及回收操作</font>，这显然是无法忍受的，更何况Python的for循环本身就已经够慢了。</p>
<p>​        <strong>因此Python在浮点数对象被销毁后，并不急着回收对象所占用的内存，换句话说其实对象还在，只是将该对象放入一个空闲的链表中。因为我们说对象可以理解为就是一片内存空间，对象如果被销毁，那么理论上内存空间要归还给操作系统，或者回到内存池中；但Python考虑到效率，并没有真正的销毁对象，而是将对象放入到链表中，占用的内存还在；后续如果再需要创建新的浮点数对象时，那么从链表中直接取出之前放入的对象(我们认为被回收的对象)，根据新的浮点数对象重新初始化对应的成员即可，这样就避免了内存分配造成的开销。而这个链表就是我们说的缓存池，当然不光浮点数对象有缓存池，Python中的很多其它对象也有对应的缓存池，比如列表。</strong>    </p>
<p><strong>浮点对象的空闲链表同样在 Objects&#x2F;floatobject.c中定义：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PyFloat_MAXFREELIST</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PyFloat_MAXFREELIST    100  </span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> numfree = <span class="number">0</span>;  </span><br><span class="line"><span class="type">static</span> PyFloatObject *free_list = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>PyFloat_MAXFREELIST：缓存池中能容纳float实例对象的最大数量, 显然不可能将所有要销毁的对象都放入到缓存池中, 这里是100个;</code></li>
<li><code>numfree：表示当前缓存池(链表)中的已经存在的float实例对象的数量, 初始为0;</code></li>
<li><code>free_list: 指向链表头结点的指针, 链表里面存储的都是PyFloatObject, 所以头节点的指针就是PyFloatObject *</code></li>
</ul>
<p><strong>但是问题来了，如果是通过链表来存储的话，那么对象肯定要有一个指针，来指向下一个对象，但是浮点数对象内部似乎没有这样的指针啊。是的，因为Python是使用内部的ob_type来指向下一个对象，本来ob_type指向的应该是PyFloat_Type，但是在链表中指向的是下一个PyFloatObject。</strong></p>
<p><img src="/2023/03/29/04-%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200801195410257-1986378240.png" alt="img"></p>
<p><strong>所以我们再回过头来看看PyFloat_FromDouble：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyFloat_FromDouble</span><span class="params">(<span class="type">double</span> fval)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//显然op是缓存池中第一个PyFloatObject的指针</span></span><br><span class="line">    PyFloatObject *op = free_list;</span><br><span class="line">    <span class="keyword">if</span> (op != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 这个时候链表中的第一个对象已经被取出来重新分配了，显然free_list要指向下一个PyFloatObject</span></span><br><span class="line">        <span class="comment">//我们说在链表中，ob_type被用于指向链表中的下一个PyFloatObject，换言之ob_type保存的是下一个PyFloatObject的地址</span></span><br><span class="line">        <span class="comment">//但ob_type虽然保存的是PyFloatObject的地址，但它的类型仍是struct _typeobject *, 或者说PyTypeObject *</span></span><br><span class="line">        <span class="comment">//所以在存储的时候，下一个PyFloatObject *一定是先转成了struct _typeobject *之后，再交给的ob_type,因为对于指针来说，是可以任意转化的</span></span><br><span class="line">        <span class="comment">//所以Py_TYPE(op)获取下一个对象的指针之后，还要再转成PyFloatObject *，然后交给free_list保存</span></span><br><span class="line">        <span class="comment">//如果没有下一个对象了，那么free_list就是NULL</span></span><br><span class="line">        <span class="comment">//因此在下一次分配的时候，上面if (op != NULL)就不成立了，因此会走下面的else，使用PyObject_MALLOC重新分配内存</span></span><br><span class="line">        free_list = (PyFloatObject *) Py_TYPE(op); </span><br><span class="line">        numfree--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        op = (PyFloatObject*) PyObject_MALLOC(<span class="keyword">sizeof</span>(PyFloatObject));</span><br><span class="line">        <span class="keyword">if</span> (!op)</span><br><span class="line">            <span class="keyword">return</span> PyErr_NoMemory();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line">    <span class="keyword">return</span> (PyObject *) op;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们说对象创建时，会先从缓存池中获取。既然创建时可以从缓存池获取，那么销毁的时候，肯定要放入到缓存池中。而销毁对象会调用类型对象的析构函数tp_dealloc，对于浮点数而言就是float_dealloc，我们看一下源代码，同样位于Objects&#x2F;floatobject.c中。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Objects/floatobject.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">float_dealloc</span><span class="params">(PyFloatObject *op)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="keyword">if</span> (PyFloat_CheckExact(op)) &#123;</span><br><span class="line">        <span class="comment">//如果numfree(当前缓存池中float实例对象的数量)达到了缓存池的最大容量</span></span><br><span class="line">        <span class="keyword">if</span> (numfree &gt;= PyFloat_MAXFREELIST)  &#123;</span><br><span class="line">            <span class="comment">//那么调用PyObject_FREE回收对象所占内存</span></span><br><span class="line">            PyObject_FREE(op);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//否则的话，说明没有达到最大容量限制，显然此时不会真的销毁对象，而是将其放入缓存池中</span></span><br><span class="line">        <span class="comment">//将numfree加1</span></span><br><span class="line">        numfree++;</span><br><span class="line">        <span class="comment">//我们说free_list指向链表的第一个元素，而这里是获取了op的ob_type,让其等于free_list，说明该对象内部的ob_type也指向了链表中的第一个元素</span></span><br><span class="line">        <span class="comment">//那么说明了什么，是不是意味着链表中第一个元素就变成该对象了。因此在将对象放入链表中的时候，是放在链表的头部位置</span></span><br><span class="line">        <span class="comment">//但我们说ob_type的类型是struct _typeobject *，所以还要将free_list进行转化</span></span><br><span class="line">        <span class="comment">//那么显然在获取的时候，还要再转成PyFloatObject *，这在上面的PyFloat_FromDouble中我们已经看到了</span></span><br><span class="line">        Py_TYPE(op) = (<span class="keyword">struct</span> _typeobject *)free_list;</span><br><span class="line">        <span class="comment">//我们说free_list指向链表中的第一个元素，但现在第一个元素变了</span></span><br><span class="line">        <span class="comment">//所以要让free_list = op, 指向新添加的PyFloatObject，因为它被插入到了链表的第一个位置上</span></span><br><span class="line">        free_list = op;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则的话，说明PyFloat_CheckExact(op)为假, PyFloat_CheckExact(op)是用于检测op是不是指向PyFloatObject</span></span><br><span class="line">    <span class="comment">//说明此时op可能指向的其实不是PyFloatObject *，所以通过Py_TYPE(op)-&gt;tp_free直接获取对应的类型对象的tp_free，然后释放掉op指向的对象所占的内存。</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        Py_TYPE(op)-&gt;tp_free((PyObject *)op);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        <strong>这便是Python的浮点数对象(或者浮点数空闲对象)缓存池的全部秘密，由于对象缓存池在提高对象分配效率方面发挥着至关重要的作用，所以Python中很多其它内置对象的实例对象也都实现了缓存池，我们后续在分析其它对象的时候会经常看到它的身影。</strong>    </p>
<p><strong>看一个思考题：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">1.414</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(a)</span><br><span class="line"><span class="number">2431274355248</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> a</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">1.732</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(b)</span><br><span class="line"><span class="number">2431274355248</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>我们看到两个对象的id是一样的，相信你肯定知道原因。因为a在del之后，指向对象被放入到缓存池中，然后创建b的时候会从缓存池中获取，所以a指向的对象被重新利用了，内存还是原来的那一块内存，所以前后地址没有变化。</strong></p>
<h3 id="对象的行为"><a href="#对象的行为" class="headerlink" title="对象的行为"></a>对象的行为</h3><p><strong>PyFloat_Type中定义了很多的函数指针，比如：type_repr、tp_str、tp_hash等等，这些函数指针将一起决定float实例对象的行为，例如：tp_hash决定float实例对象的哈希值是如何计算的：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>e = <span class="number">2.71</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hash</span>(e)</span><br><span class="line"><span class="number">1637148536541722626</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>tp_hash指向的是float_hash，还是那句话Python底层的函数命名以及API都是很有规律的，相信你能慢慢发现。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> Py_hash_t</span><br><span class="line"><span class="title function_">float_hash</span><span class="params">(PyFloatObject *v)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//我们看到调用了_Py_HashDouble，计算的就是ob_fval成员哈希值</span></span><br><span class="line">    <span class="keyword">return</span> _Py_HashDouble(v-&gt;ob_fval);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        <strong>由于加减乘除等数值操作很常见， Python 将其抽象成数值操作簇 PyNumberMethods，并让内部成员tp_as_number指向。数值操作集 PyNumberMethods 在头文件 Include&#x2F;object.h 中定义：</strong>    </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Include/object.h </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="comment">/* Number implementations must check *both*</span></span><br><span class="line"><span class="comment">    arguments for proper type and implement the necessary conversions</span></span><br><span class="line"><span class="comment">    in the slot functions themselves. */</span></span><br><span class="line"></span><br><span class="line">    binaryfunc nb_add;</span><br><span class="line">    binaryfunc nb_subtract;</span><br><span class="line">    binaryfunc nb_multiply;</span><br><span class="line">    binaryfunc nb_remainder;</span><br><span class="line">    binaryfunc nb_divmod;</span><br><span class="line">    ternaryfunc nb_power;</span><br><span class="line">    unaryfunc nb_negative;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    binaryfunc nb_inplace_add;</span><br><span class="line">    binaryfunc nb_inplace_subtract;</span><br><span class="line">    binaryfunc nb_inplace_multiply;</span><br><span class="line">    binaryfunc nb_inplace_remainder;</span><br><span class="line">    ternaryfunc nb_inplace_power;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125; PyNumberMethods;</span><br></pre></td></tr></table></figure>

<p><strong>PyNumberMethods定义了各种数学算子的处理函数，数值计算最终由这些函数执行。 处理函数根据参数个数可以分为： 一元函数(unaryfunc) 、 二元函数(binaryfunc) 和 三元函数(ternaryfunc )。</strong></p>
<p><strong>然后我们回到Objects&#x2F;floatobject.c中观察一下PyFloat_Type是如何初始化的。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> PyNumberMethods float_as_number = &#123;</span><br><span class="line">    float_add,          <span class="comment">/* nb_add */</span></span><br><span class="line">    float_sub,          <span class="comment">/* nb_subtract */</span></span><br><span class="line">    float_mul,          <span class="comment">/* nb_multiply */</span></span><br><span class="line">    float_rem,          <span class="comment">/* nb_remainder */</span></span><br><span class="line">    float_divmod,       <span class="comment">/* nb_divmod */</span></span><br><span class="line">    float_pow,          <span class="comment">/* nb_power */</span></span><br><span class="line">    (unaryfunc)float_neg, <span class="comment">/* nb_negative */</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">/* nb_inplace_add */</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">/* nb_inplace_subtract */</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">/* nb_inplace_multiply */</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">/* nb_inplace_remainder */</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">/* nb_inplace_power */</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>以加法为例，显然最终执行float_add，源码位于Objects&#x2F;floatobject.c中，显然它是一个二元函数。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">float_add</span><span class="params">(PyObject *v, PyObject *w)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//显然两个Python对象相加，一定是先将其转成C的对象相加，加完之后再根据结果创建新的Python对象</span></span><br><span class="line">    <span class="comment">//所以声明了两个double</span></span><br><span class="line">    <span class="type">double</span> a,b;</span><br><span class="line">    <span class="comment">//CONVERT_TO_DOUBLE是一个宏，不用想，功能肯定是将PyFloatObject里面的ob_fval抽出来给double变量，从名字上也能看出来</span></span><br><span class="line">    <span class="comment">//这个宏有兴趣可以去源码中看一下，也在当前文件中</span></span><br><span class="line">    CONVERT_TO_DOUBLE(v, a);  <span class="comment">// 将ob_fval赋值给a</span></span><br><span class="line">    CONVERT_TO_DOUBLE(w, b);  <span class="comment">// 将ob_fval赋值给b</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//PyFPE_START_PROTECT和下面的PyFPE_END_PROTECT也都是宏，作用我们一会儿说。</span></span><br><span class="line">    PyFPE_START_PROTECT(<span class="string">&quot;add&quot;</span>, <span class="keyword">return</span> <span class="number">0</span>)</span><br><span class="line">    <span class="comment">//将a和b相加赋值给a</span></span><br><span class="line">    a = a + b;</span><br><span class="line">    PyFPE_END_PROTECT(a)</span><br><span class="line">    <span class="comment">//根据相加后的结果创建新的PyFloatObject对象，当然返回的是泛型指针PyObject *</span></span><br><span class="line">    <span class="keyword">return</span> PyFloat_FromDouble(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所以以上就是float实例对象的运算，核心就是：</strong></p>
<ul>
<li><code>1. 定义两个double变量：a、b</code></li>
<li><code>2. 将用来相加的两个float实例对象中ob_fval维护的值抽出来赋值给a和b</code></li>
<li><code>3. 让a和b相加，将相加结果传入PyFloat_FromDouble中创建新的PyFloatObject，然后返回其PyObject *</code></li>
</ul>
<p><strong>所以如果是C中的两个浮点数相加，直接a +  b就可以了，编译之后就是一条简单的机器指令，然而Python则需要额外做很多其它工作。并且在介绍整型的时候，你会发现Python中的整型的相加会更麻烦，但对于C而言同样是一条简单的机器码就可以搞定。当然啦，因为Python3中的整型是不会溢出的，所以需要额外的一些处理，等介绍整型的时候再说吧。所以这里我们也知道Python为什么会比C慢几十倍了，从一个简单的加法上面就可以看出来。</strong></p>
<blockquote>
<p><strong>最后我们再说一下PyFPE_START_PROTECT和PyFPE_END_PROTECT这两个宏，其实它们对于我们了解浮点数在底层的计算没有什么意义。首先浮点数计算一般都遵循IEEE-754标准，如果计算时出现了错误，那么需要将IEEE-754异常转换成Python中的异常，而这两个宏就是用来干这件事情的。</strong></p>
<p><strong>所以我们不需要管它，这两个宏定义在Include&#x2F;pyfpe.h中，并且Python3.9的时候会被删除掉。</strong></p>
</blockquote>
<p>​        <strong>最后我们说一下Python解释器源代码的结构吧，因为我们每一次介绍函数的时候，都会说该函数定义在哪个文件里。所以突然想起来，介绍一下源代码的组织结构也是有必要的。</strong>    </p>
<p><img src="/2023/03/29/04-%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200801195419135-1770620855.png" alt="img"></p>
<p><strong>我们从官网上将源代码下载下来之后，大概长这样，里面有几个目录是我们需要关注的。</strong></p>
<ul>
<li><code>Include：该目录包含了Python所提供的所有头文件，主要包含了一些实例对象在底层的定义，比如listobject.h、dictobject.h等等。如果用户需要自己使用C或者C++来编写自定义模块扩展Python，那么也需要用到这里的头文件。</code></li>
<li><code>Lib：这个无需多说，该目录包含了python自带的所有标准库，Lib中的库基本上都是使用python编写的。</code></li>
<li><code>Modules：该目录中包含了所有用C语言编写的模块，比如_random、_io等，而且gc也在里面。Modules中的模块是那些对速度要求非常严格的模块，而有一些对速度没有太严格要求的模块，比如os，就是用Python编写，并且是放在Lib目录下的。</code></li>
<li><code>Parser：该目录中包含了python解释器中的Scanner和Parser部分，即对python源代码进行词法分析和语法分析的部分。除了这些，Parser还包含了一些有用的工具，这些工具能够根据Python语言的语法自动生成Python语言的词法和语法分析器，与YACC非常类似。</code></li>
<li><code>Objects：该目录包含了所有Python的内置类型对象的实现，以及其实例对象相关操作的实现，比如浮点数相关操作就位于文件floatobject.c中、列表相关操作就位于文件listobject.c中，文件名也很有规律。同时，该目录还包含了Python在运行时需要的所有内部使用对象的实现，因为有很多对象比如&lt;class &#39;function&#39;&gt;是没有暴露给Python的，但是在底层它们是实现了的。</code></li>
<li><code>Python：虚拟机的实现相关，是python运行的核心所在。</code></li>
</ul>
<h3 id="PyFloatObjectに侵入し"><a href="#PyFloatObjectに侵入し" class="headerlink" title="PyFloatObjectに侵入し"></a>PyFloatObjectに侵入し</h3><p><strong>最后我们修改一下源码：当对象放入到缓冲池中，我们打印一下放入的浮点数对象的地址；当对象从缓存池中取出时，我们打印一下取出的浮点数对象的地址。</strong></p>
<p>对象从内存池中取出的时候加一条Printf语句</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyFloat_FromDouble</span><span class="params">(<span class="type">double</span> fval)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyFloatObject *op;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> PyFloat_MAXFREELIST &gt; 0</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">Py_float_state</span> *<span class="title">state</span> =</span> get_float_state();</span><br><span class="line">    op = state-&gt;free_list;</span><br><span class="line">    <span class="keyword">if</span> (op != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> Py_DEBUG</span></span><br><span class="line">        <span class="comment">// PyFloat_FromDouble() must not be called after _PyFloat_Fini()</span></span><br><span class="line">        assert(state-&gt;numfree != <span class="number">-1</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        state-&gt;free_list = (PyFloatObject *) Py_TYPE(op);</span><br><span class="line">        state-&gt;numfree--;</span><br><span class="line">        OBJECT_STAT_INC(from_freelist);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Object gets from the memory pool,address -&gt; %p\n&quot;</span>,&amp;op);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        op = PyObject_Malloc(<span class="keyword">sizeof</span>(PyFloatObject));</span><br><span class="line">        <span class="keyword">if</span> (!op) &#123;</span><br><span class="line">            <span class="keyword">return</span> PyErr_NoMemory();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    _PyObject_Init((PyObject*)op, &amp;PyFloat_Type);</span><br><span class="line">    op-&gt;ob_fval = fval;</span><br><span class="line">    <span class="keyword">return</span> (PyObject *) op;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对象放入内存池中加一条Printf语句</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Objects/floatobject.c</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line">_PyFloat_ExactDealloc(PyObject *obj)</span><br><span class="line">&#123;</span><br><span class="line">    assert(PyFloat_CheckExact(obj));</span><br><span class="line">    PyFloatObject *op = (PyFloatObject *)obj;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> PyFloat_MAXFREELIST &gt; 0</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">Py_float_state</span> *<span class="title">state</span> =</span> get_float_state();</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> Py_DEBUG</span></span><br><span class="line">    <span class="comment">// float_dealloc() must not be called after _PyFloat_Fini()</span></span><br><span class="line">    assert(state-&gt;numfree != <span class="number">-1</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (state-&gt;numfree &gt;= PyFloat_MAXFREELIST)  &#123;</span><br><span class="line">        PyObject_Free(op);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    state-&gt;numfree++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Objects are put back into the memory poo,address -&gt; %p\n&quot;</span>,&amp;op);</span><br><span class="line">    Py_SET_TYPE(op, (PyTypeObject *)state-&gt;free_list);</span><br><span class="line">    state-&gt;free_list = op;</span><br><span class="line">    OBJECT_STAT_INC(to_freelist);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    PyObject_Free(op);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="/2023/03/29/04-%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200801195427317-1430841014.png" alt="img"></p>
<p><strong>我们看到在解释器刚启动的时候，内部就已经创建出很多对象了，然后我们自己来创建一个对象吧。</strong></p>
<p><img src="/2023/03/29/04-%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200801195432078-602851272.png" alt="img"></p>
<p><strong>我们第一次创建对象的时候，居然是从缓存池里面获取的，说明在解释器启动的时候那个链表中就已经有空闲对象了。然后我们使用Python获取其id，由于得到的是十进制整型，所以转成16进制，发现地址是一样的。然后放入到缓存池中，放入的对象的地址也是相同的，这和我们得到结论是一致的。</strong></p>
<p><img src="/2023/03/29/04-%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200801195437415-553253163.png" alt="img"></p>
<p><strong>我们再创建新的变量a、b并打印地址，然后删除a、b变量，再重新创建a、b变量、打印地址，结果发现它们存储的对象的地址在删除前后正好是相反的。至于原因，如果思考一下将对象放入缓存池、以及从缓存池获取对象的时候所采取的策略，那么很容易就明白了。</strong></p>
<p><strong>因为del a,  b的时候会先删除a，再删除b。删除a的时候，会将a指向的对象作为链表中的第一个元素，然后删除b的时候，会将b指向的对象作为链表中的第一个元素，所以之前a指向的对象就变成了链表中的第二个元素。而获取的时候，也会从链表的头部开始获取，所以当重新创建变量a的时候，其指向的对象实际上使用的是之前变量b指向的对象所占的内存，而一旦获取，那么free_list指针会向后移动；因此创建变量b的时候，其指向的对象显然使用的是之前变量a指向的对象所占的内存。因此前后打印的地址是相反的，所以我们算是通过实践从另一个角度印证了之前分析的结论。</strong></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>​        <strong>这一篇我们分析了Python中的浮点数在底层的实现方式，之所以选择浮点数是因为浮点数是最简单的了。至于整数，其实并没有那么简单，因为它的值底层是通过数组存储的，而浮点型底层是用一个double存储对应的值，所以更简单一些，我们就先拿浮点数”开刀了”。</strong>    </p>
<p>​        <strong>然后我们还介绍浮点数的创建和销毁，会调用类型对象内部的tp_dealloc，浮点数的话就是float_dealloc。当然为了保证效率，避免内存的创建和回收，Python底层为浮点数引入了缓存池机制，我们也分析了它的机制。当然浮点数还支持相关的数值型操作，PyFloat_Type中的tp_as_number指向了PyNumberMethods结构体，里面有大量的函数指针，每个指针指向了具体的函数，专门用于浮点数的运算。当然整型也有，只不过指针指向的函数是用于整型运算的。比如相加：对于浮点数来说，PyNumberMethods结构体成员nb_add指向了函数float_add；对于整数来说，nb_add则是指向了long_add。然后我们也以相加为例，看了float_add函数的实现，核心就是将Python中对象的值抽出来，转成C的类型，然后运算，最后再根据运算的结果，创建Python中的对象、返回。当然除了加法，它的减法、乘法、除法都是类似的，有兴趣可以”杀入”floatobject.c中，大肆探索一番。</strong>    </p>
<p>​        <strong>最后我们修改了PyFloatObject的部分源码，其实就是加上了两个printf语句，对float实例对象的缓存池机制进行了实践，并用之前的结论对结果进行了合理的解释。</strong>    </p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Lin Li</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/03/29/04-%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/">http://example.com/2023/03/29/04-%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">LinLi's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/CPython/">CPython</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/03/29/05-Python%E6%95%B4%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/" title="05-Python整数的底层实现"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">05-Python整数的底层实现</div></div></a></div><div class="next-post pull-right"><a href="/2023/03/29/03-Python%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E5%99%A8%E5%92%8C%E5%BA%95%E5%B1%82%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86/" title="03-Python引用计数器和底层对象管理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">03-Python引用计数器和底层对象管理</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/03/29/01-%E7%BC%96%E8%AF%91Cpython/" title="01-编译Cpython"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">01-编译Cpython</div></div></a></div><div><a href="/2023/03/29/02-%E4%B8%80%E5%88%87%E5%AF%B9%E8%B1%A1%E7%9A%86PyObject/" title="02-一切对象皆PyObject"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">02-一切对象皆PyObject</div></div></a></div><div><a href="/2023/03/29/06-Bytes%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BA%95%E5%B1%82%E6%93%8D%E4%BD%9C/" title="06-Bytes对象的底层操作"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">06-Bytes对象的底层操作</div></div></a></div><div><a href="/2023/03/29/03-Python%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E5%99%A8%E5%92%8C%E5%BA%95%E5%B1%82%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86/" title="03-Python引用计数器和底层对象管理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">03-Python引用计数器和底层对象管理</div></div></a></div><div><a href="/2023/03/29/05-Python%E6%95%B4%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/" title="05-Python整数的底层实现"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">05-Python整数的底层实现</div></div></a></div><div><a href="/2023/03/29/10-PyCodeObject%E5%AF%B9%E8%B1%A1%E5%92%8Cpyc%E6%96%87%E4%BB%B6/" title="10-PyCodeObject对象和pyc文件"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">10-PyCodeObject对象和pyc文件</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Lin Li</div><div class="author-info__description">今日事，今日毕</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">89</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#04-%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.</span> <span class="toc-text">04-浮点数的底层实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.1.</span> <span class="toc-text">内部对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">1.2.</span> <span class="toc-text">对象的创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%94%80%E6%AF%81"><span class="toc-number">1.3.</span> <span class="toc-text">对象的销毁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E6%B1%A0"><span class="toc-number">1.4.</span> <span class="toc-text">缓存池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%A1%8C%E4%B8%BA"><span class="toc-number">1.5.</span> <span class="toc-text">对象的行为</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PyFloatObject%E3%81%AB%E4%BE%B5%E5%85%A5%E3%81%97"><span class="toc-number">1.6.</span> <span class="toc-text">PyFloatObjectに侵入し</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">1.7.</span> <span class="toc-text">小结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/06/27/Testing-Database-Engines-via-Query-Plan-Guidance/" title="Testing Database Engines via Query Plan Guidance">Testing Database Engines via Query Plan Guidance</a><time datetime="2024-06-27T07:34:27.000Z" title="发表于 2024-06-27 15:34:27">2024-06-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/06/26/Detecting-Metadata-Related-Logical-Bugs-in-Database-Systems-via-Raw-Database-Construction/" title="Detecting Metadata-Related Logical Bugs in Database Systems via Raw Database Construction">Detecting Metadata-Related Logical Bugs in Database Systems via Raw Database Construction</a><time datetime="2024-06-26T02:41:32.000Z" title="发表于 2024-06-26 10:41:32">2024-06-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/06/21/Fuzz4All-Universal-Fuzzing-with-Large-Language-Models/" title="Fuzz4All Universal Fuzzing with Large Language Models">Fuzz4All Universal Fuzzing with Large Language Models</a><time datetime="2024-06-21T06:10:36.000Z" title="发表于 2024-06-21 14:10:36">2024-06-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/06/18/Detecting-Logic-Bugs-in-Database-Engines-via-Equivalent-Expression-Transformation/" title="Detecting Logic Bugs in Database Engines via Equivalent Expression Transformation">Detecting Logic Bugs in Database Engines via Equivalent Expression Transformation</a><time datetime="2024-06-18T07:48:17.000Z" title="发表于 2024-06-18 15:48:17">2024-06-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/24/Mozi-Discovering-DBMS-Bugs-via-Configuration-Based-Equivalent-Transformation/" title="Mozi: Discovering DBMS Bugs via Configuration-Based Equivalent Transformation">Mozi: Discovering DBMS Bugs via Configuration-Based Equivalent Transformation</a><time datetime="2024-05-24T09:07:56.000Z" title="发表于 2024-05-24 17:07:56">2024-05-24</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Lin Li</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>