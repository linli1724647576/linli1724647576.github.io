<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>08-解密Python中列表的底层实现 | LinLi's Blog</title><meta name="author" content="Lin Li"><meta name="copyright" content="Lin Li"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="08-解密Python中列表的底层实现楔子Python中的列表可以说使用的非常广泛了，在初学列表的时候，老师会告诉你列表就是一个大仓库，什么都可以存放。不过在最开始的几个章节中，我们花了很大的笔墨介绍了Python中的对象，并明白了Python中变量的本质，我们知道列表中存放的元素其实都是泛型指针PyObject *，所以到现在列表已经没有什么好神秘的了。 并且根据我们使用列表的经验，我们可以得出">
<meta property="og:type" content="article">
<meta property="og:title" content="08-解密Python中列表的底层实现">
<meta property="og:url" content="http://example.com/2023/03/29/08-%E8%A7%A3%E5%AF%86Python%E4%B8%AD%E5%88%97%E8%A1%A8%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/index.html">
<meta property="og:site_name" content="LinLi&#39;s Blog">
<meta property="og:description" content="08-解密Python中列表的底层实现楔子Python中的列表可以说使用的非常广泛了，在初学列表的时候，老师会告诉你列表就是一个大仓库，什么都可以存放。不过在最开始的几个章节中，我们花了很大的笔墨介绍了Python中的对象，并明白了Python中变量的本质，我们知道列表中存放的元素其实都是泛型指针PyObject *，所以到现在列表已经没有什么好神秘的了。 并且根据我们使用列表的经验，我们可以得出">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2023-03-29T14:37:11.000Z">
<meta property="article:modified_time" content="2023-04-12T02:37:37.908Z">
<meta property="article:author" content="Lin Li">
<meta property="article:tag" content="CPython">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/03/29/08-%E8%A7%A3%E5%AF%86Python%E4%B8%AD%E5%88%97%E8%A1%A8%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '08-解密Python中列表的底层实现',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-04-12 10:37:37'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">95</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="LinLi's Blog"><span class="site-name">LinLi's Blog</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">08-解密Python中列表的底层实现</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-29T14:37:11.000Z" title="发表于 2023-03-29 22:37:11">2023-03-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-04-12T02:37:37.908Z" title="更新于 2023-04-12 10:37:37">2023-04-12</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="08-解密Python中列表的底层实现"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="08-解密Python中列表的底层实现"><a href="#08-解密Python中列表的底层实现" class="headerlink" title="08-解密Python中列表的底层实现"></a>08-解密Python中列表的底层实现</h2><h3 id="楔子"><a href="#楔子" class="headerlink" title="楔子"></a>楔子</h3><p><strong>Python中的列表可以说使用的非常广泛了，在初学列表的时候，老师会告诉你列表就是一个大仓库，什么都可以存放。不过在最开始的几个章节中，我们花了很大的笔墨介绍了Python中的对象，并明白了Python中变量的本质，我们知道列表中存放的元素其实都是泛型指针PyObject *，所以到现在列表已经没有什么好神秘的了。</strong></p>
<p><strong>并且根据我们使用列表的经验，我们可以得出以下两个结论：</strong></p>
<ul>
<li><code>每个列表中的元素个数可以不一样：所以这是一个变长对象</code></li>
<li><code>可以对列表中的元素进行添加、删除、修改等操作，所以这是一个可变对象</code></li>
</ul>
<p><strong>在分析列表对应的底层结构之前，我们先来回顾一下列表的使用。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个列表，这里是通过Python/C API创建的</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lst</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 往列表尾部追加一个元素，此时是在本地操作的，返回值为None</span></span><br><span class="line"><span class="comment"># 但是列表被改变了</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lst.append(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lst</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从尾部弹出一个元素，会返回弹出的元素</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lst.pop()</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="comment"># 此时列表也会被修改</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lst</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="comment"># 另外在pop的时候还可以指定索引，弹出指定的元素</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lst.pop(<span class="number">0</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lst</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以在指定位置插入一个元素</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lst.insert(<span class="number">0</span>, <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lst</span><br><span class="line">[<span class="string">&#x27;x&#x27;</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过extend在尾部追加多个元素</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lst.extend([<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lst</span><br><span class="line">[<span class="string">&#x27;x&#x27;</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找指定元素第一次出现的位置</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lst.index(<span class="number">3</span>)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算某个元素在列表中出现的次数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lst.count(<span class="number">3</span>)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 翻转列表</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lst.reverse()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lst</span><br><span class="line">[<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="string">&#x27;x&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据元素的值删除第一个出现的元素</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lst.remove(<span class="number">4</span>)</span><br><span class="line">[<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="string">&#x27;x&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清空列表</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lst.clear()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lst</span><br><span class="line">[]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>上面的一些操作是列表经常使用的，但是在分析它的实现之前，我们肯定要了解它们的时间复杂度如何。这些东西即使不看源码，也是必须要知道的，尤其想要成为一名优秀的Python工程师。</strong></p>
<ul>
<li><code>append：会向尾部追加元素，所以时间复杂度为O(1)</code></li>
<li><code>pop：默认从尾部弹出元素，所以时间复杂度为O(1);如果不是尾部，而是从其它的位置弹出元素的话，那么该位置后面所有的元素都要向前移动，此时时间复杂度为O(n)</code></li>
<li><code>insert：向指定位置插入元素，该位置后面的所有元素都要向后移动，所以时间复杂度为O(n)</code></li>
</ul>
<p><strong>注意：由于列表里面的元素个数是可以自由变化的，所以列表有一个容量的概念，我们后面会说。当添加元素时，列表可能会扩容；同理当删除元素时，列表可能会缩容。</strong></p>
<p><strong>下面我们就来看一下列表对应的底层结构。</strong></p>
<h3 id="列表的内部结构–PyListObject"><a href="#列表的内部结构–PyListObject" class="headerlink" title="列表的内部结构–PyListObject"></a>列表的内部结构–PyListObject</h3><p>*<strong>list* 对象<code>(列表)</code>在 *Python* 内部，由 *PyListObject* 结构体表示，定义于头文件 *Include&#x2F;listobject.h* 中：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    PyObject **ob_item;</span><br><span class="line">    Py_ssize_t allocated;</span><br><span class="line">&#125; PyListObject;</span><br></pre></td></tr></table></figure>

<p><strong>我们看到里面有如下成员：</strong></p>
<ul>
<li><code>PyObject_VAR_HEAD: 变长对象的公共头部信息</code></li>
<li><code>ob_item：一个二级指针，指向一个PyObject *类型的指针数组，这个指针数组保存的便是对象的指针，而操作底层数组都是通过ob_item来进行操作的。</code></li>
<li><code>allocated：容量, 我们知道列表底层是使用了C的数组, 而底层数组的长度就是列表的容量</code></li>
</ul>
<p><strong>列表之所以要有容量的概念，是因为列表可以动态添加元素，但是底层的数组在创建完毕之后，其长度却是固定的。所以一旦添加新元素的时候，发现底层数组已经满了，这个时候只能申请一个更长的数组，同时把原来数组中的元素依次拷贝到新的数组里面<code>(这一过程就是列表的扩容)</code>，然后再将新元素添加进去。但是问题来了，总不可能每添加一个元素，就申请一次数组、将所有元素都拷贝一次吧。所以Python在列表扩容的时候，会将底层数组申请的长一些，可以在添加元素的时候不用每次都申请新的数组。</strong></p>
<p><img src="/2023/03/29/08-%E8%A7%A3%E5%AF%86Python%E4%B8%AD%E5%88%97%E8%A1%A8%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/Users\HUAWEI\Desktop\project\source_posts\08-解密Python中列表的底层实现\1229382-20200809040124028-249317005.png" alt="img"></p>
<p><strong>这便是列表的底层结构示意图，图中的object只是单纯的代指对象，不是Python中的基类object。我们看到底层数组的长度为5，说明此时列表的容量为5，但是里面只有3个PyObject  *指针，说明列表的ob_size是3，或者说列表里面此时有3个元素。注意：尽管底层数组的容量目前是5个，但是我们访问的时候，最多只能访问到第三个元素，也就是说索引最大只能是2，这是显而易见的，因为列表里面只有3个元素。</strong></p>
<p><strong>如果这个时候我们往列表中append一个元素，那么会将这个新元素设置在底层数组中索引为ob_size的位置、或者说第四个位置。一旦设置完，ob_size会自动加1，因为ob_size要和列表的长度保持一致。</strong></p>
<p><img src="/2023/03/29/08-%E8%A7%A3%E5%AF%86Python%E4%B8%AD%E5%88%97%E8%A1%A8%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/Users\HUAWEI\Desktop\project\source_posts\08-解密Python中列表的底层实现\1229382-20200809040129642-1322638478.png" alt="img"></p>
<p><strong>如果此时再往列表中append一个元素的话，那么还是将新元素设置在索引为ob_size的位置，此时也就是第5个位置。</strong></p>
<p><img src="/2023/03/29/08-%E8%A7%A3%E5%AF%86Python%E4%B8%AD%E5%88%97%E8%A1%A8%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/Users\HUAWEI\Desktop\project\source_posts\08-解密Python中列表的底层实现\1229382-20200809040138915-609447201.png" alt="img"></p>
<p><strong>列表的容量是5，但此时长度也达到了5，这说明当下一次append的时候已经没有办法再容纳新的元素了。因为此时列表的长度、或者说元素个数已经达到了容量，当然最直观的还是这里的底层数组，很明显全都占满了。那这个时候如果想再接收新的元素的话，要怎么办呢？显然只能扩容了。</strong></p>
<p><img src="/2023/03/29/08-%E8%A7%A3%E5%AF%86Python%E4%B8%AD%E5%88%97%E8%A1%A8%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/Users\HUAWEI\Desktop\project\source_posts\08-解密Python中列表的底层实现\1229382-20200809040145842-412135912.png" alt="img"></p>
<p><strong>原来的容量是5个，长度也是5个，当再来一个新元素的时候由于没有位置了，所以要扩容。但是扩容的时候肯定会将容量申请的大一些、即底层数组申请的长一些<code>(具体申请多长,Python内部有一个公式,我们后面会说)</code>，假设申请的新的底层数组长度是8，那么说明列表的容量就变成了8。然后将原来数组中的PyObject  *按照顺序依次拷贝到新的数组里面，再让ob_item指向新的数组。最后将要添加的新元素设置在新的数组中索引为ob_size的位置、即第6个位置，然后将ob_size加1，此时ob_size就变成了6。</strong></p>
<p><strong>以上便是列表底层在扩容的时候所经历的过程。</strong></p>
<blockquote>
<p><strong>由于扩容会申请新的数组，然后将旧数组的元素拷贝到新数组中，所以这是一个时间复杂度为O(n)的操作。而append可能会导致列表扩容，因此append最坏情况下也是一个O(n)的操作，只不过扩容不会频繁发生，所以append的平均时间复杂度还是O(1)。</strong></p>
</blockquote>
<p>​        <strong>另外我们还可以看到一个现象，那就是Python中的列表在底层是分开存储的，因为PyListObject结构体实例并没有存储相应的指针数组，而是存储了指向这个指针数组的二级指针。显然我们添加、删除、修改元素等操作，都是通过ob_item这个二级指针来间接操作这个指针数组。</strong>    </p>
<p>​        <strong>所以底层对应的PyListObject实例的大小其实是不变的，因为指针数组没有存在PyListObject里面。但是Python在计算内存大小的时候是会将这个指针数组也算进去的，所以Python中列表的大小是可变的。</strong>    </p>
<p><strong>而且我们知道，列表在append之后地址是不变的，至于原因上面的几张图已经解释的很清楚了。如果长度没有达到容量，那么append其实就是往底层数组中设置了一个新元素；如果达到容量了，那么会扩容，但是扩容只是申请一个新的指针数组，然后让ob_item重新指向罢了。所以底层数组会变，但是PyListObject结构体实例本身是没有变化的。因此列表无论是append、extend、pop、insert等等，只要是在本地操作，那么它的地址是不会变化的。</strong></p>
<p><strong>下面我们再来看看Python中的列表所占的内存大小是怎么算的：</strong></p>
<ul>
<li><code>PyObject_VAR_HEAD: 24字节</code></li>
<li><code>ob_item: 二级指针, 8字节</code></li>
<li><code>allocated: 8字节</code></li>
</ul>
<p><strong>但是不要忘记，在计算列表大小的时候，ob_item指向的指针数组也要算在内。所以：一个列表的大小 &#x3D; 40 + 8 * 指针数组长度<code>(或者列表容量)</code>。注意是底层数组长度、或者列表容量，可不是列表长度，因为底层数组一旦申请了，不管你用没用，大小就摆在那里了。就好比你租了间房子，就算不住，房租该交还是得交。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显然一个空数组占40个字节</span></span><br><span class="line"><span class="built_in">print</span>([].__sizeof__())  <span class="comment"># 40</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 40 + 3 * 8 = 64</span></span><br><span class="line"><span class="built_in">print</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;x&quot;</span> * <span class="number">1000</span>].__sizeof__())  <span class="comment"># 64</span></span><br><span class="line"><span class="comment"># 虽然里面有一个长度为1000的字符串，但我们说列表存放的都是指针, 所以大小都是8字节</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意: 我们通过l = [1, 2, 3]这种方式创建列表的话</span></span><br><span class="line"><span class="comment"># 不管内部元素有多少个, 其ob_size和allocated都是一样的</span></span><br><span class="line"><span class="comment"># 那么列表什么时候会扩容呢? 答案是在添加元素的时候发现容量不够了才会扩容</span></span><br><span class="line">lst = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line"><span class="comment"># 40 + 10 * 8 = 120</span></span><br><span class="line"><span class="built_in">print</span>(lst.__sizeof__())  <span class="comment"># 120</span></span><br><span class="line"><span class="comment"># 这个时候append一个元素</span></span><br><span class="line">lst.append(<span class="number">123</span>)</span><br><span class="line"><span class="built_in">print</span>(lst.__sizeof__())  <span class="comment"># 184</span></span><br><span class="line"><span class="comment"># 我们发现大小达到了184, (184 - 40) // 8 = 18, 说明扩容之后申请的底层数据的长度为18 </span></span><br></pre></td></tr></table></figure>

<p><strong>所以列表的大小我们就知道是怎么来的了，而且为什么列表在通过索引定位元素的时候，时间复杂度是O(1)。因为列表中存储的都是对象的指针，不管对象有多大，其指针大小是固定的，都是8字节。通过索引可以瞬间计算出偏移量，从而找到对应元素的指针，而操作指针会自动操作指针所指向的内存。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].__sizeof__())  <span class="comment"># 64</span></span><br><span class="line"><span class="built_in">print</span>([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]].__sizeof__())  <span class="comment"># 48</span></span><br></pre></td></tr></table></figure>

<p><strong>相信上面这个结果，你肯定能分析出原因。因为第一个列表中有3个指针，所以是40 + 24 &#x3D; 64；而第二个列表中有一个指针，所以是40 + 8 &#x3D; 48。用一张图来展示一下<code>[1, 2, 3]</code>和<code>[[1, 2, 3]]</code>的底层结构，看看它们之间的区别：</strong></p>
<p><img src="/2023/03/29/08-%E8%A7%A3%E5%AF%86Python%E4%B8%AD%E5%88%97%E8%A1%A8%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/Users\HUAWEI\Desktop\project\source_posts\08-解密Python中列表的底层实现\1229382-20200809040157535-1310257941.png" alt="img"></p>
<p>​        <strong>分析完PyListObject之后，我们来看看它支持的操作，显然我们要通过类型对象PyList_Type来查看。</strong>    </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">PyTypeObject PyList_Type = &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, <span class="number">0</span>)</span><br><span class="line">    <span class="string">&quot;list&quot;</span>,</span><br><span class="line">    <span class="keyword">sizeof</span>(PyListObject),</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    (destructor)list_dealloc,                   <span class="comment">/* tp_dealloc */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_vectorcall_offset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_getattr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_setattr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_async */</span></span><br><span class="line">    (reprfunc)list_repr,                        <span class="comment">/* tp_repr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_number */</span></span><br><span class="line">    &amp;list_as_sequence,                          <span class="comment">/* tp_as_sequence */</span></span><br><span class="line">    &amp;list_as_mapping,                           <span class="comment">/* tp_as_mapping */</span></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>我们看到，列表支持序列型操作和映射型操作，下面我们就来分析一下。</strong></p>
<h3 id="列表支持的操作"><a href="#列表支持的操作" class="headerlink" title="列表支持的操作"></a>列表支持的操作</h3><p><strong>我们看看平常使用的列表所支持的操作在底层是如何实现的。</strong></p>
<h4 id="自动扩容"><a href="#自动扩容" class="headerlink" title="自动扩容"></a>自动扩容</h4><p><strong>我们先来说说列表的扩容，因为我们知道列表是会自动扩容的，那么什么时候会扩容呢？我们说列表扩容的时候，是在添加元素时发现底层数组已经满了的情况下才会扩容。换句话说，一个列表在添加元素的时候会扩容，那么说明在添加元素之前，其内部的元素个数和容量是相等的。然后我们看看底层是怎么实现的，这些操作都位于Objects&#x2F;listobject.c中。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">list_resize</span><span class="params">(PyListObject *self, Py_ssize_t newsize)</span></span><br><span class="line">&#123;   <span class="comment">//参数self就是列表啦，newsize指的元素在添加之后的ob_size</span></span><br><span class="line">    <span class="comment">//比如列表的ob_size是5，那么在append的时候发现容量不够，所以会扩容，那么这里的newsize就是6</span></span><br><span class="line">    <span class="comment">//如果是extend添加3个元素，那么这里的newsize就是8</span></span><br><span class="line">    <span class="comment">//当然list_resize这个函数不仅可以扩容，也可以缩容，假设列表原来有1000个元素，这个时候将列表清空了</span></span><br><span class="line">    <span class="comment">//那么容量肯定缩小，不然会浪费内存，如果清空了列表，那么这里的newsize显然就是0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//items是一个二级指针，显然是用来指向指针数组的</span></span><br><span class="line">    PyObject **items;</span><br><span class="line">    <span class="comment">//新的容量，以及对应的内存大小</span></span><br><span class="line">    <span class="type">size_t</span> new_allocated, num_allocated_bytes;</span><br><span class="line">    <span class="comment">//获取原来的容量</span></span><br><span class="line">    Py_ssize_t allocated = self-&gt;allocated;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//如果newsize达到了容量的一半，但还没有超过容量, 那么意味着newsize、或者新的ob_size和容量是匹配的，所以不会变化</span></span><br><span class="line">    <span class="keyword">if</span> (allocated &gt;= newsize &amp;&amp; newsize &gt;= (allocated &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        assert(self-&gt;ob_item != <span class="literal">NULL</span> || newsize == <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//只需要将列表的ob_size设置为newsize即可</span></span><br><span class="line">        Py_SIZE(self) = newsize;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//走到这里说明容量和ob_size不匹配了，所以要进行扩容或者缩容。</span></span><br><span class="line">    <span class="comment">//因此要申请新的底层数组，申请多少个?这里给出了公式,一会儿我们可以通过Python进行测试</span></span><br><span class="line">    new_allocated = (<span class="type">size_t</span>)newsize + (newsize &gt;&gt; <span class="number">3</span>) + (newsize &lt; <span class="number">9</span> ? <span class="number">3</span> : <span class="number">6</span>);</span><br><span class="line">    <span class="comment">//显然容量不可能无限大，是有范围的，当然这个范围基本上是达不到的</span></span><br><span class="line">    <span class="keyword">if</span> (new_allocated &gt; (<span class="type">size_t</span>)PY_SSIZE_T_MAX / <span class="keyword">sizeof</span>(PyObject *)) &#123;</span><br><span class="line">        PyErr_NoMemory();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//如果newsize为0，那么容量也会变成0，假设将列表全部清空了，容量就会变成0</span></span><br><span class="line">    <span class="keyword">if</span> (newsize == <span class="number">0</span>)</span><br><span class="line">        new_allocated = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//我们说数组中存放的都是PyObject *, 所以要计算内存</span></span><br><span class="line">    num_allocated_bytes = new_allocated * <span class="keyword">sizeof</span>(PyObject *);</span><br><span class="line">    <span class="comment">//申请相应大小的内存，将其指针交给items</span></span><br><span class="line">    items = (PyObject **)PyMem_Realloc(self-&gt;ob_item, num_allocated_bytes);</span><br><span class="line">    <span class="keyword">if</span> (items == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//如果items是NULL, 代表申请失败</span></span><br><span class="line">        PyErr_NoMemory();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//然后让ob_item = items, 也就是指向新的数组, 此时列表就发生了扩容或缩容</span></span><br><span class="line">    self-&gt;ob_item = items;</span><br><span class="line">    <span class="comment">//将ob_size设置为newsize, 因为它维护列表内部元素的个数</span></span><br><span class="line">    Py_SIZE(self) = newsize;</span><br><span class="line">    <span class="comment">//将原来的容量大小设置为新的容量大小</span></span><br><span class="line">    self-&gt;allocated = new_allocated;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们看到还是很简单的，没有什么黑科技，下面我们就来分析一下列表扩容的时候，容量和元素个数之间的规律。其实在list_resize函数中是有注释的，其种一行写着：<code>The growth pattern is:  0, 4, 8, 16, 25, 35, 46, 58, 72, 88, ...</code></strong></p>
<p><strong>说明我们往一个空列表中不断append元素的时候，容量会按照上面的规律进行变化，我们来试一下。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 还记得底层是怎么改变容量的吗？</span></span><br><span class="line"><span class="comment"># 我们说有一个公式: new_allocated = (size_t)newsize + (newsize &gt;&gt; 3) + (newsize &lt; 9 ? 3 : 6);</span></span><br><span class="line"><span class="comment"># 我们来看一下</span></span><br><span class="line"></span><br><span class="line">lst = []</span><br><span class="line">allocated = <span class="number">0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;此时容量是: 0&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    lst.append(item)  <span class="comment"># 添加元素</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算ob_size</span></span><br><span class="line">    ob_size = <span class="built_in">len</span>(lst)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 判断ob_size和当前的容量</span></span><br><span class="line">    <span class="keyword">if</span> ob_size &gt; allocated:</span><br><span class="line">        <span class="comment"># lst的大小减去空列表的大小, 再除以8显然就是容量的大小, 因为不管你有没有用, 容量已经分配了</span></span><br><span class="line">        allocated = (lst.__sizeof__() - [].__sizeof__()) // <span class="number">8</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;列表扩容啦, 新的容量是: <span class="subst">&#123;allocated&#125;</span>&quot;</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">此时容量是: 0</span></span><br><span class="line"><span class="string">列表扩容啦, 新的容量是: 4</span></span><br><span class="line"><span class="string">列表扩容啦, 新的容量是: 8</span></span><br><span class="line"><span class="string">列表扩容啦, 新的容量是: 16</span></span><br><span class="line"><span class="string">列表扩容啦, 新的容量是: 25</span></span><br><span class="line"><span class="string">列表扩容啦, 新的容量是: 35</span></span><br><span class="line"><span class="string">列表扩容啦, 新的容量是: 46</span></span><br><span class="line"><span class="string">列表扩容啦, 新的容量是: 58</span></span><br><span class="line"><span class="string">列表扩容啦, 新的容量是: 72</span></span><br><span class="line"><span class="string">列表扩容啦, 新的容量是: 88</span></span><br><span class="line"><span class="string">列表扩容啦, 新的容量是: 106</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Process finished with exit code 0</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看到和官方给的结果是一样的，显然这是毫无疑问的，我们根据底层的公式也能算出来。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ob_size = <span class="number">0</span></span><br><span class="line">allocated = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(allocated, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    ob_size += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> ob_size &gt; allocated:</span><br><span class="line">        allocated = ob_size + (ob_size &gt;&gt; <span class="number">3</span>) + (<span class="number">3</span> <span class="keyword">if</span> ob_size &lt; <span class="number">9</span> <span class="keyword">else</span> <span class="number">6</span>)</span><br><span class="line">        <span class="built_in">print</span>(allocated, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line"><span class="comment"># 0 4 8 16 25 35 46 58 72 88 106 </span></span><br></pre></td></tr></table></figure>

<p>​        <strong>但还是那句话，扩容是指解释器发现容量不够的情况下才会扩容，如果我们直接通过lst &#x3D; []这种形式创建列表的话，那么其长度和容量是一样的。</strong>    </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">lst = [<span class="number">0</span>] * <span class="number">1000</span></span><br><span class="line"><span class="comment"># 长度和容量一致</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(lst), (lst.__sizeof__() - [].__sizeof__()) // <span class="number">8</span>)  <span class="comment"># 1000 1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 但此时添加一个元素的话, 那么ob_size会变成1001, 大于容量1000</span></span><br><span class="line"><span class="comment"># 所以此时列表就要扩容了, 执行list_resize, 里面的new_size就是1001, 然后是怎么分配容量来着</span></span><br><span class="line"><span class="comment"># new_allocated = (size_t)newsize + (newsize &gt;&gt; 3) + (newsize &lt; 9 ? 3 : 6);</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;新容量:&quot;</span>, <span class="number">1001</span> + (<span class="number">1001</span> &gt;&gt; <span class="number">3</span>) + (<span class="number">3</span> <span class="keyword">if</span> <span class="number">1001</span> &lt; <span class="number">9</span> <span class="keyword">else</span> <span class="number">6</span>))  <span class="comment"># 新容量: 1132</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># append一个元素，列表扩容</span></span><br><span class="line">lst.append(<span class="number">123</span>)</span><br><span class="line"><span class="comment"># 计算容量</span></span><br><span class="line"><span class="built_in">print</span>((lst.__sizeof__() - [].__sizeof__()) // <span class="number">8</span>)  <span class="comment"># 1132</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果是一样的, 因为底层就是这么实现的, 所以结果必须一样</span></span><br><span class="line"><span class="comment"># 只不过我们通过这种测试的方式证明了这一点, 也更加了解了底层的结构是什么样子的。</span></span><br></pre></td></tr></table></figure>

<p>​        <strong>介绍完扩容，那么介绍缩容，因为列表元素个数要是减少到和容量不匹配的话，也要进行缩容。</strong>    </p>
<p>​        <strong>举个生活中的例子，假设你租了10间屋子用于办公，显然你要付10间屋子的房租，不管你有没有住，一旦租了肯定是要付钱的。同理底层数组也是一样，只要你申请了，不管有没有元素，内存已经占用了。但有一天你用不到10间屋子了，假设会用8间或者9间，那么会让剩余的屋子闲下来。但由于退租比较麻烦，并且只闲下来一两间屋子，所以多余的屋子就不退了，还是会付10间屋子的钱，这样当没准哪天又要用的时候就不用重新租了。对于列表也是如此，如果在删除元素(相当于屋子不用了)的时候发现长度没有超过容量但是又达到了容量的一半，所以也不会缩容。但是，如果屋子闲了8间，也就是只需要两间屋子就足够了，那么此时肯定要退租了，闲了8间，可能会退掉6间。</strong>    </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">lst = [<span class="number">0</span>] * <span class="number">1000</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(lst), (lst.__sizeof__() - [].__sizeof__()) // <span class="number">8</span>)  <span class="comment"># 1000 1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除500个元素, 此时长度或者说ob_size就为500</span></span><br><span class="line">lst[<span class="number">500</span>:] = []</span><br><span class="line"><span class="comment"># 但是ob_size还是达到了容量的一半, 所以不会缩容</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(lst), (lst.__sizeof__() - [].__sizeof__()) // <span class="number">8</span>)  <span class="comment"># 500 1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果再删除一个元素的话, 那么不好意思, 显然就要进行缩容了, 因为ob_size变成了499, 小于1000 // 2</span></span><br><span class="line"><span class="comment"># 缩容之后容量怎么算呢? 还是之前那个公式</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">499</span> + (<span class="number">499</span> &gt;&gt; <span class="number">3</span>) + (<span class="number">3</span> <span class="keyword">if</span> <span class="number">499</span> &lt; <span class="number">9</span> <span class="keyword">else</span> <span class="number">6</span>))  <span class="comment"># 567</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试一下, 删除一个元素, 看看会不会按照我们期待的规则进行缩容</span></span><br><span class="line">lst.pop()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(lst), (lst.__sizeof__() - [].__sizeof__()) // <span class="number">8</span>)  <span class="comment"># 499 567</span></span><br></pre></td></tr></table></figure>

<p><strong>一切都和我们想的是一样的，另外在代码中我们还看到一个if语句，就是如果newsize是0，那么容量也是0，我们来测试一下。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">lst = [<span class="number">0</span>] * <span class="number">1000</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(lst), (lst.__sizeof__() - [].__sizeof__()) // <span class="number">8</span>)  <span class="comment"># 1000 1000</span></span><br><span class="line"></span><br><span class="line">lst[:] = []</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(lst), (lst.__sizeof__() - [].__sizeof__()) // <span class="number">8</span>)  <span class="comment"># 0 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果按照之前的容量变化公式的话, 会发现结果应该是3, 但是结果是0, 就是因为多了if判断:如果newsize是0, 就把容量也设置为0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">0</span> + (<span class="number">0</span> &gt;&gt; <span class="number">3</span>) + (<span class="number">3</span> <span class="keyword">if</span> <span class="number">0</span> &lt; <span class="number">9</span> <span class="keyword">else</span> <span class="number">6</span>))  <span class="comment"># 3</span></span><br><span class="line"><span class="comment"># 但为什么要这么做呢?因为Python认为, 列表长度为0的话，说明你不想用这个列表了, 所以多余的3个也没有必要申请了</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们还以租房为栗, 如果你一间屋子都不用了, 说明可能你不用这里的屋子办公了</span></span><br><span class="line"><span class="comment"># 因此多余3间屋子也没有必要再租了, 所以直接全部退掉</span></span><br></pre></td></tr></table></figure>

<p><strong>以上就是列表在改变容量时所采用的策略，我们从头到尾全部分析了一遍。</strong></p>
<h4 id="append追加元素"><a href="#append追加元素" class="headerlink" title="append追加元素"></a>append追加元素</h4><p><strong>append方法用于像尾部追加一个元素，我们看看底层实现。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">list_append</span><span class="params">(PyListObject *self, PyObject *object)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//显然调用的app1是核心, 它里面实现了添加元素的逻辑</span></span><br><span class="line">    <span class="comment">//Py_RETURN_NONE是一个宏，表示返回Python中的None, 因为list.append返回的就是None</span></span><br><span class="line">    <span class="keyword">if</span> (app1(self, object) == <span class="number">0</span>)</span><br><span class="line">        Py_RETURN_NONE;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">app1</span><span class="params">(PyListObject *self, PyObject *v)</span></span><br><span class="line">&#123;	<span class="comment">//self是列表，v是要添加的对象</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取列表的长度</span></span><br><span class="line">    Py_ssize_t n = PyList_GET_SIZE(self);</span><br><span class="line">    assert (v != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//如果长度已经达到了限制，那么无法再添加了, 会抛出OverflowError</span></span><br><span class="line">    <span class="keyword">if</span> (n == PY_SSIZE_T_MAX) &#123;</span><br><span class="line">        PyErr_SetString(PyExc_OverflowError,</span><br><span class="line">            <span class="string">&quot;cannot add more objects to list&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//还记得这个list_resize吗? self就是列表, n + 1就是newsize，或者说新的ob_size</span></span><br><span class="line">    <span class="comment">//会自动判断是否要进行扩容, 当然里面还有重要的一步，就是将列表的ob_size设置成newsize、也就是这里的n + 1</span></span><br><span class="line">    <span class="comment">//因为append之后列表长度大小会变化，而ob_size则要时刻维护这个大小</span></span><br><span class="line">    <span class="keyword">if</span> (list_resize(self, n+<span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//因为v作为了列表的一个元素，所以其指向的对象的引用计数要加1</span></span><br><span class="line">    Py_INCREF(v);</span><br><span class="line">    <span class="comment">//然后调用PyList_SET_ITEM，这是一个宏，它的作用就是设置元素的，我们下面会看这个宏长什么样</span></span><br><span class="line">    <span class="comment">//原来的列表长度为n, 里面的元素的最大索引是n - 1，那么追加的话就等于将元素设置在索引为n的地方</span></span><br><span class="line">    PyList_SET_ITEM(self, n, v);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//我们说PyList_SET_ITEM是用来设置元素的，设置在什么地方呢？显然是设置在底层数组中</span></span><br><span class="line"><span class="comment">//PyList_SET_ITEM一个宏,除了这个宏之外，还有很多其它的宏，它们位于Inlcude/listobject.h中</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PyList_GET_ITEM(op, i) (((PyListObject *)(op))-&gt;ob_item[i])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PyList_SET_ITEM(op, i, v) (((PyListObject *)(op))-&gt;ob_item[i] = (v))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PyList_GET_SIZE(op)    (assert(PyList_Check(op)),Py_SIZE(op))</span></span><br><span class="line"><span class="comment">//这些宏的作用是啥，一目了然</span></span><br></pre></td></tr></table></figure>

<h4 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h4><p><strong>我们在使用列表的时候，可以通过val &#x3D; lst[1]这种方式获取元素，那么底层是如何实现的呢？</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">list_subscript</span><span class="params">(PyListObject* self, PyObject* item)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//先看item是不是一个整型，显然这个item除了整型之外，也可以是切片</span></span><br><span class="line">    <span class="keyword">if</span> (PyIndex_Check(item)) &#123;</span><br><span class="line">        Py_ssize_t i;</span><br><span class="line">        <span class="comment">//这里检测i是否合法，因为Python的整型是没有限制的</span></span><br><span class="line">        <span class="comment">//但是列表的长度和容量都是由一个有具体类型的变量维护的，所以其个数肯定是有范围的</span></span><br><span class="line">        <span class="comment">//所以你输入一个lst[2 ** 100000]显然是不行的, 在Python中会报错IndexError: cannot fit &#x27;int&#x27; into an index-sized integer</span></span><br><span class="line">        i = PyNumber_AsSsize_t(item, PyExc_IndexError);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//设置异常</span></span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">-1</span> &amp;&amp; PyErr_Occurred())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果i小于0, 那么加上列表的长度, 变成正数索引</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">            i += PyList_GET_SIZE(self);</span><br><span class="line">        <span class="comment">//然后调用list_item</span></span><br><span class="line">        <span class="keyword">return</span> list_item(self, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (PySlice_Check(item)) &#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line">list_item(PyListObject *a, Py_ssize_t i)</span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//检测索引i的合法性，如果i &gt; 列表的长度, 那么会报出索引越界的错误。</span></span><br><span class="line">    <span class="keyword">if</span> (!valid_index(i, Py_SIZE(a))) &#123;</span><br><span class="line">        <span class="comment">//如果索引为负数也会报出索引越界错误,因为上面已经对负数索引做了处理了,但如果负数索引加上长度之后还是个负数, 那么同样报错。</span></span><br><span class="line">        <span class="comment">//假设列表长度是5, 你的索引是-100, 加上长度之后是-95，结果还是个负数, 所以也会报错</span></span><br><span class="line">        <span class="keyword">if</span> (indexerr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            indexerr = PyUnicode_FromString(</span><br><span class="line">                <span class="string">&quot;list index out of range&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (indexerr == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        PyErr_SetObject(PyExc_IndexError, indexerr);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过ob_item获取第i个元素</span></span><br><span class="line">    Py_INCREF(a-&gt;ob_item[i]);</span><br><span class="line">    <span class="comment">//返回</span></span><br><span class="line">    <span class="keyword">return</span> a-&gt;ob_item[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>显然获取元素的时候不光可以通过索引，还可以通过切片的方式。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">list_subscript</span><span class="params">(PyListObject* self, PyObject* item)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (PyIndex_Check(item)) &#123;</span><br><span class="line">        <span class="comment">//.......</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (PySlice_Check(item)) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        start: 切片的起始位置</span></span><br><span class="line"><span class="comment">        end: 切片的结束位置</span></span><br><span class="line"><span class="comment">        step: 切片的步长</span></span><br><span class="line"><span class="comment">        slicelength: 获取元素个数,比如[1:5:2],显然slicelength就是2, 因为只能获取索引为1和3的元素</span></span><br><span class="line"><span class="comment">        cur: 底层数组中元素的索引</span></span><br><span class="line"><span class="comment">        i: 循环变量, 因为切片的话只能循环获取每一个元素, 比如[1:5:2], 需要循环两次。第一次循环, 上面的cur就是1, 第二次循环cur就是3</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        Py_ssize_t start, stop, step, slicelength, cur, i;</span><br><span class="line">        <span class="comment">//返回的结果</span></span><br><span class="line">        PyObject* result;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//下面代码中会有所体现</span></span><br><span class="line">        PyObject* it;</span><br><span class="line">        PyObject **src, **dest;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//对切片item进行解包进行解包, 得到起始位置、结束位置、步长</span></span><br><span class="line">        <span class="keyword">if</span> (PySlice_Unpack(item, &amp;start, &amp;stop, &amp;step) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计算出slicelength, 因为即便我们指定的切片是[1:3:5], 但如果列表只有3个元素, 所以slicelength也只能是1</span></span><br><span class="line">        slicelength = PySlice_AdjustIndices(Py_SIZE(self), &amp;start, &amp;stop,</span><br><span class="line">                                            step);</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//如果slicelength为0, 那么不好意思, 表示没有元素可以获取, 因此直接返回一个空列表即可</span></span><br><span class="line">        <span class="keyword">if</span> (slicelength &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//PyList_New表示创建一个PyListObject, 里面的参数表示底层数组的长度</span></span><br><span class="line">            <span class="comment">//另外对于创建列表，Python底层只提供了PyList_New这一种Python/C API</span></span><br><span class="line">            <span class="comment">//当我们执行lst = [1, 2, 3]的时候就会执行PyList_New(3)</span></span><br><span class="line">            <span class="keyword">return</span> PyList_New(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果步长为1, 那么会调用list_slice,这个函数内部的逻辑很简单,首先接收一个PyListObject *和两个整型(ilow, ihigh)</span></span><br><span class="line">        <span class="comment">//然后在内部会创建一个PyListObject *np, 申请相应的底层数组，设置allocated</span></span><br><span class="line">        <span class="comment">//然后将参数列表中索引为ilow的元素到索引为ihigh的元素依次拷贝到np -&gt; ob_item里面, 然后这是ob_size并返回</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (step == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> list_slice(self, start, stop);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//走到这里说明步长不为1, 我们说result是一个PyListObject *, 底层数组没有存储在PyListObject中，而是通过ob_item发生关联</span></span><br><span class="line">            <span class="comment">//所以这一步是申请底层数组、设置容量的，容量就是这里的slicelength, 上面的list_slice中也调用了这一步</span></span><br><span class="line">            result = list_new_prealloc(slicelength);</span><br><span class="line">            <span class="keyword">if</span> (!result) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">			</span><br><span class="line">            <span class="comment">//src是一个二级指针, 也就是self -&gt; ob_item</span></span><br><span class="line">            src = self-&gt;ob_item;</span><br><span class="line">            <span class="comment">//同理dest是result -&gt; ob_item</span></span><br><span class="line">            dest = ((PyListObject *)result)-&gt;ob_item;</span><br><span class="line">            <span class="comment">//进行循环, cur从start开始遍历, 每次加上step步长</span></span><br><span class="line">            <span class="keyword">for</span> (cur = start, i = <span class="number">0</span>; i &lt; slicelength;</span><br><span class="line">                 cur += (<span class="type">size_t</span>)step, i++) &#123;</span><br><span class="line">                <span class="comment">//it就是self -&gt; ob_item中的元素</span></span><br><span class="line">                it = src[cur];</span><br><span class="line">                <span class="comment">//增加指向的对象的引用计数</span></span><br><span class="line">                Py_INCREF(it);</span><br><span class="line">                <span class="comment">//将其设置到dest中</span></span><br><span class="line">                dest[i] = it;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将大小设置为slicelength，说明通过切片创建新列表, 其长度和容量也是一致的</span></span><br><span class="line">            Py_SIZE(result) = slicelength;</span><br><span class="line">            <span class="comment">//返回结果</span></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//此时说明item不合法</span></span><br><span class="line">        PyErr_Format(PyExc_TypeError,</span><br><span class="line">                     <span class="string">&quot;list indices must be integers or slices, not %.200s&quot;</span>,</span><br><span class="line">                     item-&gt;ob_type-&gt;tp_name);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们发现这个和字符串类似啊，因为通过字符串也支持切片的方式获取。</strong></p>
<blockquote>
<p><strong>随着源码的分析，我们也渐渐明朗Python的操作在底层是如何实现的了，真的一点不神秘，实现的逻辑非常简单。</strong></p>
</blockquote>
<h4 id="设置元素"><a href="#设置元素" class="headerlink" title="设置元素"></a>设置元素</h4><p><strong>获取元素知道了，设置元素也不难了。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">list_ass_subscript</span><span class="params">(PyListObject* self, PyObject* item, PyObject* value)</span></span><br><span class="line">&#123;	<span class="comment">//在list_subscript的基础上多了一个value参数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (PyIndex_Check(item)) &#123;</span><br><span class="line">        <span class="comment">//依旧是进行检测i是否合法</span></span><br><span class="line">        Py_ssize_t i = PyNumber_AsSsize_t(item, PyExc_IndexError);</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">-1</span> &amp;&amp; PyErr_Occurred())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//索引小于0，则加上列表的长度</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">            i += PyList_GET_SIZE(self);</span><br><span class="line">        <span class="comment">//调用list_ass_item进行设置，我们之前见到了list_item，是用来基于索引获取的</span></span><br><span class="line">        <span class="comment">//这里的list_ass_item是基于索引进行元素设置的</span></span><br><span class="line">        <span class="keyword">return</span> list_ass_item(self, i, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (PySlice_Check(item)) &#123;</span><br><span class="line">    	<span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line">list_ass_item(PyListObject *a, Py_ssize_t i, PyObject *v)</span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//判断索引是否越界</span></span><br><span class="line">    <span class="keyword">if</span> (!valid_index(i, Py_SIZE(a))) &#123;</span><br><span class="line">        PyErr_SetString(PyExc_IndexError,</span><br><span class="line">                        <span class="string">&quot;list assignment index out of range&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里的list_ass_slice后面会说</span></span><br><span class="line">    <span class="keyword">if</span> (v == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> list_ass_slice(a, i, i+<span class="number">1</span>, v);</span><br><span class="line">    <span class="comment">//增加v指向对象的引用计数，因为指向它的指针被传到了列表中</span></span><br><span class="line">    Py_INCREF(v);</span><br><span class="line">    <span class="comment">//将第i个元素设置成v</span></span><br><span class="line">    Py_SETREF(a-&gt;ob_item[i], v);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通过索引设置元素，逻辑很容易，关键是通过切片设置元素会比较复杂。而复杂的原因就在于步长，我们通过Python来演示一下。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 首先通过切片进行设置的话, 右值一定要是一个可迭代对象</span></span><br><span class="line">lst[<span class="number">0</span>: <span class="number">3</span>] = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>]</span><br><span class="line"><span class="comment"># 会将lst[0]设置为11, lst[1]设置为22, lst[2]设置为33</span></span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># [11, 22, 33, 4, 5, 6, 7, 8]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 而且它们的长度是可以不相等的</span></span><br><span class="line"><span class="comment"># 这里表示将[0: 3]的元素设置为[1, 2], lst[0]设置成1, lst[1]设置成2</span></span><br><span class="line"><span class="comment"># 问题来了, lst[2]咋办? 由于右值中已经没有元素与之匹配了, 那么lst[2]就会被删掉</span></span><br><span class="line">lst[<span class="number">0</span>: <span class="number">3</span>] = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># [1, 2, 4, 5, 6, 7, 8]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 所以我们如果想删除[0: 3]的元素, 那么只需要执行lst[0: 3] = []即可</span></span><br><span class="line"><span class="comment"># 因为[]里面没有元素能与之匹配, 所以lst中[0: 3]的元素由于匹配不到, 所以直接就没了</span></span><br><span class="line"><span class="comment"># 当然由于Python的动态特性, lst[0: 3] = []、lst[0: 3] = ()、lst[0: 3] = &quot;&quot;等等都是可以的</span></span><br><span class="line">lst[<span class="number">0</span>: <span class="number">3</span>] = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># [5, 6, 7, 8]</span></span><br><span class="line"><span class="comment"># 实际上我们del lst[0]的时候, 实际上就是执行了lst[0: 1] = []</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当然如果右值元素多的话也是可以的</span></span><br><span class="line">lst[<span class="number">0</span>: <span class="number">1</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># [1, 2, 3, 4, 6, 7, 8]</span></span><br><span class="line"><span class="comment"># lst[0]匹配1很好理解, 但是此时左边已经结束了, 所以剩余的元素会依次插在后面</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后重点来了, 如果切片有步长的话, 那么两边一定要匹配</span></span><br><span class="line"><span class="comment"># 由于此时lst中有8个元素, lst[:: 2]会得到4个元素, 那么右边的可迭代对象的长度也是4</span></span><br><span class="line">lst[:: <span class="number">2</span>] = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># [&#x27;a&#x27;, 2, &#x27;b&#x27;, 4, &#x27;c&#x27;, 7, &#x27;d&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 但是，如果长度不一致</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    lst[:: <span class="number">2</span>] = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="comment"># 显然会报错</span></span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># attempt to assign sequence of size 3 to extended slice of size 4</span></span><br></pre></td></tr></table></figure>

<p><strong>至于通过切片来设置元素，源码很长，这里就不分析了，总之核心如下：</strong></p>
<ul>
<li><code>如果步长为1: 那么会调用list_ass_slice。我们说:  list_item是基于索引获取元素、list_slice是基于切片获取元素、list_ass_item是基于索引设置元素、list_ass_slice是基于切片设置元素。而list_ass_slice内部的代码逻辑也很长，但是核心并不难, 我们通过lst[a: b] = [v1, v2, v3, ...]这种方式就会走这里的list_ass_slice。</code></li>
<li><code>如果步长不为1，那么就是采用循环的方式逐个设置。</code></li>
</ul>
<p><strong>主要是考虑的情况比较多，但是核心逻辑并不复杂，有兴趣可以自己去深入了解一下。</strong></p>
<h4 id="insert插入元素"><a href="#insert插入元素" class="headerlink" title="insert插入元素"></a>insert插入元素</h4><p><strong>insert用来在指定的位置插入元素，我们知道它是一个时间复杂度为O(n)的一个操作，因为插入位置后面的所有元素都要向后移动。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">PyList_Insert</span><span class="params">(PyObject *op, Py_ssize_t where, PyObject *newitem)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//类型检查</span></span><br><span class="line">    <span class="keyword">if</span> (!PyList_Check(op)) &#123;</span><br><span class="line">        PyErr_BadInternalCall();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//底层又调用ins1</span></span><br><span class="line">    <span class="keyword">return</span> ins1((PyListObject *)op, where, newitem);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">ins1</span><span class="params">(PyListObject *self, Py_ssize_t where, PyObject *v)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">/*参数self：PyListObject *</span></span><br><span class="line"><span class="comment">    参数where：索引</span></span><br><span class="line"><span class="comment">    参数v：插入的值，这是一个PyObject *指针，因为list里面存的都是指针</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//i:后面for循环遍历用的，n则是当前列表的元素个数</span></span><br><span class="line">    Py_ssize_t i, n = Py_SIZE(self);</span><br><span class="line">    <span class="comment">//指向指针数组的二级指针</span></span><br><span class="line">    PyObject **items;</span><br><span class="line">    <span class="comment">//如果v是NULL，错误的内部调用</span></span><br><span class="line">    <span class="keyword">if</span> (v == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        PyErr_BadInternalCall();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//列表的元素个数不可能无限增大，一般当你还没创建到PY_SSIZE_T_MAX个对象时</span></span><br><span class="line">    <span class="comment">//你内存就已经玩完了，但是python仍然做了检测，当达到这个PY_SSIZE_T_MAX时，会报出内存溢出错误</span></span><br><span class="line">    <span class="keyword">if</span> (n == PY_SSIZE_T_MAX) &#123;</span><br><span class="line">        PyErr_SetString(PyExc_OverflowError,</span><br><span class="line">            <span class="string">&quot;cannot add more objects to list&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//调整列表容量，既然要inert，那么就势必要多出一个元素</span></span><br><span class="line">    <span class="comment">//这个元素还没有设置进去，但是先把这个坑给留出来</span></span><br><span class="line">    <span class="comment">//当然如果容量够的话，是不会扩容的，只有当容量不够的时候才会扩容</span></span><br><span class="line">    <span class="keyword">if</span> (list_resize(self, n+<span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//确定插入点</span></span><br><span class="line">    <span class="keyword">if</span> (where &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//这里可以看到如果where小于0，那么我们就加上n，也就是当前列表的元素个数</span></span><br><span class="line">        <span class="comment">//比如有6个元素，那么我们where=-1，加上6，就是5，显然就是insert在最后一个索引的位置上 </span></span><br><span class="line">        where += n;</span><br><span class="line">        <span class="comment">//如果吃撑了，写个-100，加上元素的个数还是小于0</span></span><br><span class="line">        <span class="keyword">if</span> (where &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//那么where=0，就在开头插入</span></span><br><span class="line">            where = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果where &gt; n，那么就索引为n的位置插入，</span></span><br><span class="line">    <span class="comment">//可元素个数为n，最大索引是n-1啊，对，所以此时就相当于append</span></span><br><span class="line">    <span class="keyword">if</span> (where &gt; n)</span><br><span class="line">        where = n;</span><br><span class="line">    <span class="comment">//拿到原来的二级指针，指向一个指针数组</span></span><br><span class="line">    items = self-&gt;ob_item;</span><br><span class="line">    <span class="comment">//然后不断遍历，把索引为i的值赋值给索引为i+1</span></span><br><span class="line">    <span class="comment">//既然是在where处插入那么where之前的就不需要动了，到where处就停止了</span></span><br><span class="line">    <span class="keyword">for</span> (i = n; --i &gt;= where; )</span><br><span class="line">        items[i+<span class="number">1</span>] = items[i];</span><br><span class="line">    <span class="comment">//增加v指向的对象的引用计数，因为列表中的元素也引用了该对象</span></span><br><span class="line">    Py_INCREF(v);</span><br><span class="line">    <span class="comment">//将索引为where的值设置成v</span></span><br><span class="line">    items[where] = v;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所以可以看到，Python插入数据是非常灵活的。不管你在什么位置插入，都是合法的。因为它会自己调整位置，在确定位置之后，会将当前位置以及之后的所有元素向后挪动一个位置，空出来的地方设置为插入的值。</strong></p>
<h4 id="pop弹出元素"><a href="#pop弹出元素" class="headerlink" title="pop弹出元素"></a>pop弹出元素</h4><p><strong>pop默认是从尾部弹出元素的，因为如果不指定索引的话，默认是-1。当然我们也可以指定索引，弹出指定索引对应的元素。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">list_pop_impl</span><span class="params">(PyListObject *self, Py_ssize_t index)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//弹出的对象的指针，因为弹出一个元素实际上是先用某个变量保存起来，然后再从列表中删掉</span></span><br><span class="line">    PyObject *v;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//下面代码中体现</span></span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//如果列表长度为0，显然没有元素可以弹, 因此会报错</span></span><br><span class="line">    <span class="keyword">if</span> (Py_SIZE(self) == <span class="number">0</span>) &#123;</span><br><span class="line">        PyErr_SetString(PyExc_IndexError, <span class="string">&quot;pop from empty list&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//索引小于0，那么加上列表的长度得到正数索引</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span>)</span><br><span class="line">        index += Py_SIZE(self);</span><br><span class="line">    <span class="comment">//依旧是调用valid_index，判断是否越界。显然pop没有insert那么智能</span></span><br><span class="line">    <span class="comment">//insert的话，索引在加上列表长度之和还小于0，那么默认是在索引为0的地方插入</span></span><br><span class="line">    <span class="comment">//但是pop就不行了，pop的话会报出索引越界错误，同理索引大于等于列表长度，insert会等价于append,而pop同样报出索引越界错误</span></span><br><span class="line">    <span class="keyword">if</span> (!valid_index(index, Py_SIZE(self))) &#123;</span><br><span class="line">        PyErr_SetString(PyExc_IndexError, <span class="string">&quot;pop index out of range&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据索引获取指定位置的元素</span></span><br><span class="line">    v = self-&gt;ob_item[index];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这里同样是一个快分支，如果index是最后一个元素</span></span><br><span class="line">    <span class="keyword">if</span> (index == Py_SIZE(self) - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//那么直接调用list_resize即可，我们说只要涉及元素的添加、删除都要执行list_resize</span></span><br><span class="line">        <span class="comment">//至于容量是否变化，就看是否满足newsize和allocated之间的关系,如果allocated//2 &lt;= newsize &lt;= allocated，那么容量就不变</span></span><br><span class="line">        <span class="comment">//list_resize中会将ob_size设置成newsize，也就是原来的ob_size减去1, 因为是在尾部删除的，所以只需要将ob_size设置为ob_size-1即可</span></span><br><span class="line">        status = list_resize(self, Py_SIZE(self) - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//list_resize执行成功会返回0</span></span><br><span class="line">        <span class="keyword">if</span> (status &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//直接将对象的指针返回</span></span><br><span class="line">            <span class="keyword">return</span> v; </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则说明不是快分支</span></span><br><span class="line">    Py_INCREF(v);</span><br><span class="line">    <span class="comment">//这里调用了list_ass_slice, 这一步等价于self[index: index + 1] = []</span></span><br><span class="line">    status = list_ass_slice(self, index, index+<span class="number">1</span>, (PyObject *)<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (status &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//设置失败，减少引用计数</span></span><br><span class="line">        Py_DECREF(v);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回指针</span></span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所以pop本质上也是调用了list_ass_slice。</strong></p>
<h4 id="index查询元素的索引"><a href="#index查询元素的索引" class="headerlink" title="index查询元素的索引"></a>index查询元素的索引</h4><p><strong>index可以接收一个元素，返回该元素首次出现的索引。当然还可以额外指定一个start和end，表示查询的范围</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">list_index_impl</span><span class="params">(PyListObject *self, PyObject *value, Py_ssize_t start,</span></span><br><span class="line"><span class="params">                Py_ssize_t stop)</span></span><br><span class="line">&#123;</span><br><span class="line">    Py_ssize_t i;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//如果start小于0，加上长度。</span></span><br><span class="line">    <span class="comment">//还小于0，那么等于0</span></span><br><span class="line">    <span class="keyword">if</span> (start &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        start += Py_SIZE(self);</span><br><span class="line">        <span class="keyword">if</span> (start &lt; <span class="number">0</span>)</span><br><span class="line">            start = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (stop &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果stop小于0，加上长度</span></span><br><span class="line">        <span class="comment">//还小于0，那么等于0</span></span><br><span class="line">        stop += Py_SIZE(self);</span><br><span class="line">        <span class="keyword">if</span> (stop &lt; <span class="number">0</span>)</span><br><span class="line">            stop = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从start开始循环</span></span><br><span class="line">    <span class="keyword">for</span> (i = start; i &lt; stop &amp;&amp; i &lt; Py_SIZE(self); i++) &#123;</span><br><span class="line">        <span class="comment">//获取相应元素</span></span><br><span class="line">        PyObject *obj = self-&gt;ob_item[i];</span><br><span class="line">        <span class="comment">//增加引用计数，因为有指针指向它</span></span><br><span class="line">        Py_INCREF(obj);</span><br><span class="line">        <span class="comment">//进行比较PyObject_RichCompareBool是一个富比较，接收三个参数：元素1、元素2、操作(这里显然是Py_EQ)</span></span><br><span class="line">        <span class="comment">//相等返回1，不相等返回0</span></span><br><span class="line">        <span class="type">int</span> cmp = PyObject_RichCompareBool(obj, value, Py_EQ);</span><br><span class="line">        <span class="comment">//比较完之后，减少引用计数</span></span><br><span class="line">        Py_DECREF(obj);</span><br><span class="line">        <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//如果相等，返回其索引</span></span><br><span class="line">            <span class="keyword">return</span> PyLong_FromSsize_t(i);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//循环走完一圈，发现都没有相等的，那么报错，提示元素不再列表中</span></span><br><span class="line">    PyErr_Format(PyExc_ValueError, <span class="string">&quot;%R is not in list&quot;</span>, value);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所以lst.index是一个时间复杂度为O(n)的操作，因为它在底层要循环整个列表，如果运气好，可以第一个元素就是，运气不好可能就好循环整个列表了。同理后面要说的if value in lst这种方式也是一样的，因为都要循环整个列表，只不过后者返回的是一个布尔值。</strong></p>
<h4 id="count查询元素出现的次数"><a href="#count查询元素出现的次数" class="headerlink" title="count查询元素出现的次数"></a>count查询元素出现的次数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">list_count</span><span class="params">(PyListObject *self, PyObject *value)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//初始为0</span></span><br><span class="line">    Py_ssize_t count = <span class="number">0</span>;</span><br><span class="line">    Py_ssize_t i;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//遍历每一个元素</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; Py_SIZE(self); i++) &#123;</span><br><span class="line">        <span class="comment">//获取元素</span></span><br><span class="line">        PyObject *obj = self-&gt;ob_item[i];</span><br><span class="line">        <span class="comment">//如果相等，那么count自增1，继续下一次循环</span></span><br><span class="line">        <span class="comment">//注意这里的相等，判断的是什么呢？显然是对象的地址，如果地址一样，那么肯定指向同一个对象，所以一定相等。</span></span><br><span class="line">        <span class="keyword">if</span> (obj == value) &#123;</span><br><span class="line">           count++;</span><br><span class="line">           <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Py_INCREF(obj);</span><br><span class="line">        <span class="comment">//走到这里说明地址不一样，但是地址不一样只能说明a is b不成立，但并不代表a == b不成立，所以调用PyObject_RichCompareBool进行判断</span></span><br><span class="line">        <span class="type">int</span> cmp = PyObject_RichCompareBool(obj, value, Py_EQ);</span><br><span class="line">        Py_DECREF(obj);</span><br><span class="line">        <span class="comment">//大于0，说明相等，count++</span></span><br><span class="line">        <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">            count++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回count</span></span><br><span class="line">    <span class="keyword">return</span> PyLong_FromSsize_t(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>count毫无疑问，无论在什么情况下，它都是一个时间复杂度为O(n)的操作，因为列表必须要从头遍历到尾。</strong></p>
<h4 id="remove根据元素的值删除元素"><a href="#remove根据元素的值删除元素" class="headerlink" title="remove根据元素的值删除元素"></a>remove根据元素的值删除元素</h4><p><strong>除了根据索引删除元素之外，也可以元素指向的对象维护的值删除元素，删除第一个出现元素。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">list_remove</span><span class="params">(PyListObject *self, PyObject *value)</span></span><br><span class="line">&#123;</span><br><span class="line">    Py_ssize_t i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; Py_SIZE(self); i++) &#123;</span><br><span class="line">        <span class="comment">//从头开始遍历，获取元素</span></span><br><span class="line">        PyObject *obj = self-&gt;ob_item[i];</span><br><span class="line">        Py_INCREF(obj);</span><br><span class="line">        <span class="comment">//比较是否相等</span></span><br><span class="line">        <span class="type">int</span> cmp = PyObject_RichCompareBool(obj, value, Py_EQ);</span><br><span class="line">        Py_DECREF(obj);</span><br><span class="line">        <span class="comment">//如果相等</span></span><br><span class="line">        <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//调用list_ass_slice删除元素</span></span><br><span class="line">            <span class="keyword">if</span> (list_ass_slice(self, i, i+<span class="number">1</span>,</span><br><span class="line">                               (PyObject *)<span class="literal">NULL</span>) == <span class="number">0</span>)</span><br><span class="line">                <span class="comment">//返回None</span></span><br><span class="line">                Py_RETURN_NONE;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则说明元素不在列表中</span></span><br><span class="line">    PyErr_SetString(PyExc_ValueError, <span class="string">&quot;list.remove(x): x not in list&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="reverse翻转列表"><a href="#reverse翻转列表" class="headerlink" title="reverse翻转列表"></a>reverse翻转列表</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">list_reverse_impl</span><span class="params">(PyListObject *self)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//如果列表长度不大于1的话, 那么直接返回其本身即可</span></span><br><span class="line">    <span class="keyword">if</span> (Py_SIZE(self) &gt; <span class="number">1</span>)</span><br><span class="line">        <span class="comment">//大于1的话，执行reverse_slice, 传递了两个参数</span></span><br><span class="line">        <span class="comment">//第一个参数self -&gt; ob_item显然是底层数组首元素的地址</span></span><br><span class="line">        <span class="comment">//而第二个参数self-&gt;ob_item + Py_SIZE(self)则是底层数组中索引为ob_size的元素的地址</span></span><br><span class="line">        <span class="comment">//但是很明显能访问的最大索引应该是ob_size - 1才对, 别急我们继续往下看, 看一下reverse_slice函数的实现</span></span><br><span class="line">        reverse_slice(self-&gt;ob_item, self-&gt;ob_item + Py_SIZE(self));</span><br><span class="line">    Py_RETURN_NONE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">reverse_slice</span><span class="params">(PyObject **lo, PyObject **hi)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(lo &amp;&amp; hi);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//我们看到又执行了一次--hi,将hi移动到了ob_size - 1位置，也就是说此时二级指针hi保存的还是索引为ob_size - 1的元素的值</span></span><br><span class="line">    <span class="comment">//所以个人觉得有点纳闷, 直接reverse_slice(self-&gt;ob_item, self-&gt;ob_item + Py_SIZE(self) - 1);不行吗</span></span><br><span class="line">    --hi;</span><br><span class="line">    <span class="comment">//当lo小于hi的时候</span></span><br><span class="line">    <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">        PyObject *t = *lo;</span><br><span class="line">        *lo = *hi;</span><br><span class="line">        *hi = t;</span><br><span class="line">        <span class="comment">//上面三步就等价于 *lo, *hi = *hi, *lo, 但是C不支持这么写</span></span><br><span class="line">        <span class="comment">//所以我们看到就是将索引为0的元素和索引为ob_size-1的元素进行了交换，前后两个指针继续靠近,指向的元素继续交换，知道两个指针相遇</span></span><br><span class="line">        ++lo;</span><br><span class="line">        --hi;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所以到现在，你还认为Python中的列表神秘吗？虽然我们不可能写出一个Python解释器，但是底层的一些思想其实并没有那么难，作为一名程序猿很容易想的到。</strong></p>
<h4 id="两个列表相加"><a href="#两个列表相加" class="headerlink" title="两个列表相加"></a>两个列表相加</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">list_concat</span><span class="params">(PyListObject *a, PyObject *bb)</span></span><br><span class="line">&#123;</span><br><span class="line">    Py_ssize_t size;  <span class="comment">//相加之后的列表长度</span></span><br><span class="line">    Py_ssize_t i; <span class="comment">//循环变量</span></span><br><span class="line">    <span class="comment">//两个二级指针，指向ob_item</span></span><br><span class="line">    PyObject **src, **dest;</span><br><span class="line">    <span class="comment">//新的列表</span></span><br><span class="line">    PyListObject *np;</span><br><span class="line">    <span class="comment">//类型检测</span></span><br><span class="line">    <span class="keyword">if</span> (!PyList_Check(bb)) &#123;</span><br><span class="line">        PyErr_Format(PyExc_TypeError,</span><br><span class="line">                  <span class="string">&quot;can only concatenate list (not \&quot;%.200s\&quot;) to list&quot;</span>,</span><br><span class="line">                  bb-&gt;ob_type-&gt;tp_name);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> b ((PyListObject *)bb)</span></span><br><span class="line">    <span class="comment">//判断长度是否溢出</span></span><br><span class="line">    <span class="keyword">if</span> (Py_SIZE(a) &gt; PY_SSIZE_T_MAX - Py_SIZE(b))</span><br><span class="line">        <span class="keyword">return</span> PyErr_NoMemory();</span><br><span class="line">    <span class="comment">//计算新列表的长度</span></span><br><span class="line">    size = Py_SIZE(a) + Py_SIZE(b);</span><br><span class="line">    <span class="comment">//设置np -&gt; ob_item指向的底层数组</span></span><br><span class="line">    np = (PyListObject *) list_new_prealloc(size);</span><br><span class="line">    <span class="keyword">if</span> (np == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取a -&gt; ob_item和np -&gt; ob_item</span></span><br><span class="line">    src = a-&gt;ob_item;</span><br><span class="line">    dest = np-&gt;ob_item;</span><br><span class="line">    <span class="comment">//将元素依次拷贝过去, 增加引用计数</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; Py_SIZE(a); i++) &#123;</span><br><span class="line">        PyObject *v = src[i];</span><br><span class="line">        Py_INCREF(v);</span><br><span class="line">        dest[i] = v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取b-&gt;ob_item</span></span><br><span class="line">    <span class="comment">//获取np-&gt;ob_item + Py_SIZE(a), 要从Py_SIZE(a)的位置开始设置, 否则就把之前的元素覆盖掉了</span></span><br><span class="line">    src = b-&gt;ob_item;</span><br><span class="line">    dest = np-&gt;ob_item + Py_SIZE(a);</span><br><span class="line">    <span class="comment">//将元素依次拷贝过去, 增加引用计数</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; Py_SIZE(b); i++) &#123;</span><br><span class="line">        PyObject *v = src[i];</span><br><span class="line">        Py_INCREF(v);</span><br><span class="line">        dest[i] = v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置ob_size</span></span><br><span class="line">    Py_SIZE(np) = size;</span><br><span class="line">    <span class="comment">//返回np</span></span><br><span class="line">    <span class="keyword">return</span> (PyObject *)np;</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> b</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="判断元素是否在列表中"><a href="#判断元素是否在列表中" class="headerlink" title="判断元素是否在列表中"></a>判断元素是否在列表中</h4><p><strong>对于一个序列来说，可以使用in操作符，等价于调用其<code>__contains__</code>魔法方法。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">list_contains</span><span class="params">(PyListObject *a, PyObject *el)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyObject *item;</span><br><span class="line">    Py_ssize_t i;</span><br><span class="line">    <span class="type">int</span> cmp;</span><br><span class="line">	<span class="comment">//挨个循环，比较是否相等。存在cmp会等于1，cmp == 0 &amp;&amp; i &lt; Py_SIZE(a)不满足，直接返回</span></span><br><span class="line">    <span class="comment">//不相等则为0, 会一直比完列表中所有的元素</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, cmp = <span class="number">0</span> ; cmp == <span class="number">0</span> &amp;&amp; i &lt; Py_SIZE(a); ++i) &#123;</span><br><span class="line">        item = PyList_GET_ITEM(a, i);</span><br><span class="line">        Py_INCREF(item);</span><br><span class="line">        cmp = PyObject_RichCompareBool(el, item, Py_EQ);</span><br><span class="line">        Py_DECREF(item);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>真的非常简单，没有什么好说的。</strong></p>
<h4 id="列表的深浅拷贝"><a href="#列表的深浅拷贝" class="headerlink" title="列表的深浅拷贝"></a>列表的深浅拷贝</h4><p><strong>列表的深浅拷贝也是初学者容易犯的错误之一，我们看一个Python的例子。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">lst = [[]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认是浅拷贝, 这个过程会创建一个新列表, 会将里面的指针拷贝一份</span></span><br><span class="line"><span class="comment"># 但是指针指向的内存并没有拷贝</span></span><br><span class="line">lst_cp = lst.copy()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 两个对象的地址是一样的</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(lst[<span class="number">0</span>]), <span class="built_in">id</span>(lst_cp[<span class="number">0</span>]))  <span class="comment"># 2207105155392 2207105155392</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 操作lst[0], 会改变lst_cp[0]</span></span><br><span class="line">lst[<span class="number">0</span>].append(<span class="number">123</span>)</span><br><span class="line"><span class="built_in">print</span>(lst, lst_cp)  <span class="comment"># [[123]] [[123]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 操作lst_cp[0], 会改变lst[0]</span></span><br><span class="line">lst_cp[<span class="number">0</span>].append(<span class="number">456</span>)</span><br><span class="line"><span class="built_in">print</span>(lst, lst_cp)  <span class="comment"># [[123, 456]] [[123, 456]]</span></span><br></pre></td></tr></table></figure>

<p><strong>我们通过索引或者切片也是一样的道理</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lst = [[], <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">val = lst[<span class="number">0</span>]</span><br><span class="line">lst_cp = lst[<span class="number">0</span>: <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(lst[<span class="number">0</span>] <span class="keyword">is</span> val <span class="keyword">is</span> lst_cp[<span class="number">0</span>])  <span class="comment"># True</span></span><br><span class="line"><span class="comment"># 此外，lst[:]完全等价于lst.copy()</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>之所以会有这样现象，是因为我们说过Python中变量、容器里面的元素都是一个泛型指针PyObject *，在传递的时候会传递指针， 但是在操作的时候会操作指针指向的内存。</strong></p>
<p><strong>所以lst.copy()就是创建了一个新列表，然后把元素拷贝了过去，并且这里的元素是指针。因为只是拷贝指针，没有拷贝指针指向的对象<code>(内存)</code>，所以它们的地址都是一样的，因为指向的是同一个对象。</strong></p>
</blockquote>
<p><strong>但如果我们就想在拷贝指针的同时也拷贝指针指向的对象呢？答案是使用一个叫copy的模块。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line">lst = [[]]</span><br><span class="line"><span class="comment"># 此时拷贝的时候，就会把指针指向的对象也给拷贝一份</span></span><br><span class="line">lst_cp1 = copy.deepcopy(lst)</span><br><span class="line">lst_cp2 = lst[:]</span><br><span class="line"></span><br><span class="line">lst_cp2[<span class="number">0</span>].append(<span class="number">123</span>)</span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># [[123]]</span></span><br><span class="line"><span class="built_in">print</span>(lst_cp1)  <span class="comment"># [[]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># lst[:]这种方式也是浅拷贝, 所以修改lst_cp2[0], 也会影响lst[0]</span></span><br><span class="line"><span class="comment"># 但是没有影响lst_cp1[0], 证明它们是相互独立的, 因为指向的是不同的对象</span></span><br></pre></td></tr></table></figure>

<p><strong>浅拷贝示意图如下：</strong></p>
<p><img src="/2023/03/29/08-%E8%A7%A3%E5%AF%86Python%E4%B8%AD%E5%88%97%E8%A1%A8%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/Users\HUAWEI\Desktop\project\source_posts\08-解密Python中列表的底层实现\1229382-20200809040208452-2140599376.png" alt="img"></p>
<p><strong>里面的两个底层数组的元素是一样的</strong></p>
<p><strong>深拷贝示意图如下：</strong></p>
<p><img src="/2023/03/29/08-%E8%A7%A3%E5%AF%86Python%E4%B8%AD%E5%88%97%E8%A1%A8%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/Users\HUAWEI\Desktop\project\source_posts\08-解密Python中列表的底层实现\1229382-20200809040216408-1830378933.png" alt="img"></p>
<p><strong>里面的两个底层数组的元素是不一样的</strong></p>
<p><strong>注意：copy.deepcopy虽然在拷贝指针的同时会将指针指向的对象也拷贝一份，但这仅仅是针对于可变对象，对于不可变对象是不会拷贝的。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line">lst = [[], <span class="string">&quot;古明地觉&quot;</span>]</span><br><span class="line">lst_cp = copy.deepcopy(lst)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(lst[<span class="number">0</span>] <span class="keyword">is</span> lst_cp[<span class="number">0</span>])  <span class="comment"># False</span></span><br><span class="line"><span class="built_in">print</span>(lst[<span class="number">1</span>] <span class="keyword">is</span> lst_cp[<span class="number">1</span>])  <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<p><strong>为什么会这样，其实原因很简单。因为不可变对象是不支持本地修改的，你若想修改只能指向新的对象，但是对其它的变量则没有影响，其它变量该指向谁就还指向谁。因为a &#x3D;  b只是将对象的指针拷贝一份给a，然后a和b都指向了同一个对象，至于a和b本身则是没有任何关系的。如果此时b指向了新的对象，是完全不会影响a的，a还是指向原来的对象。所以如果一个指针指向的对象不支持本地修改，那么深拷贝不会拷贝对象本身，因为指向的是不可变对象，所以不会有修改一个影响另一个的情况出现。</strong></p>
<p><strong>关于列表还有一些陷阱：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">lst = [[]] * <span class="number">5</span></span><br><span class="line">lst[<span class="number">0</span>].append(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># [[1], [1], [1], [1], [1]]</span></span><br><span class="line"><span class="comment"># 列表乘上一个n，等于把列表里面的元素重复n次</span></span><br><span class="line"><span class="comment"># 注意: 类似于lst = [1, 2, 3], 虽然我们写的是整数，但是它存储的并不是整数，而是其指针</span></span><br><span class="line"><span class="comment"># 所以会把指针重复5次, 因此列表里面5个指针都指向了同一个列表</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这种方式创建的话，里面的元素都指向了不同的列表</span></span><br><span class="line">lst = [[], [], [], [], []]</span><br><span class="line">lst[<span class="number">0</span>].append(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># [[1], [], [], [], []]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 再比如字典，在后续系列中会说</span></span><br><span class="line">d = <span class="built_in">dict</span>.fromkeys([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [])</span><br><span class="line"><span class="built_in">print</span>(d)  <span class="comment"># &#123;1: [], 2: [], 3: [], 4: []&#125;</span></span><br><span class="line">d[<span class="number">1</span>].append(<span class="number">123</span>)</span><br><span class="line"><span class="built_in">print</span>(d)  <span class="comment"># &#123;1: [123], 2: [123], 3: [123], 4: [123]&#125;</span></span><br><span class="line"><span class="comment"># 它们都指向了同一个列表，因此这种陷阱在工作中要注意, 因为一不小心就会出现大问题</span></span><br></pre></td></tr></table></figure>

<h3 id="创建PyListObject"><a href="#创建PyListObject" class="headerlink" title="创建PyListObject"></a>创建PyListObject</h3><p><strong>我们说创建一个列表，Python底层只提供了唯一一个Python&#x2F;C API，也就是PyList_New。这个函数接收一个size参数，从而允许我们在创建一个PyListObject对象时指定底层数组的长度。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyList_New</span><span class="params">(Py_ssize_t size)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//声明一个PyListObject *对象</span></span><br><span class="line">    PyListObject *op;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHOW_ALLOC_COUNT</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> initialized = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!initialized) &#123;</span><br><span class="line">        Py_AtExit(show_alloc);</span><br><span class="line">        initialized = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">//如果size小于0，直接抛异常</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        PyErr_BadInternalCall();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//缓存池是否可用，如果可用</span></span><br><span class="line">    <span class="keyword">if</span> (numfree) &#123;</span><br><span class="line">        <span class="comment">//将缓存池内对象个数减1</span></span><br><span class="line">        numfree--;</span><br><span class="line">        <span class="comment">//从缓存池中获取</span></span><br><span class="line">        op = free_list[numfree];</span><br><span class="line">        <span class="comment">//设置引用计数</span></span><br><span class="line">        _Py_NewReference((PyObject *)op);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHOW_ALLOC_COUNT</span></span><br><span class="line">        count_reuse++;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//不可用的时候，申请内存</span></span><br><span class="line">        op = PyObject_GC_New(PyListObject, &amp;PyList_Type);</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHOW_ALLOC_COUNT</span></span><br><span class="line">        count_alloc++;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果size小于等于0，ob_item设置为NULL</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">0</span>)</span><br><span class="line">        op-&gt;ob_item = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//否则的话，创建一个指定容量的指针数组，然后让ob_item指向它</span></span><br><span class="line">        <span class="comment">//所以是先创建PyListObject对象, 然后创建底层数组, 最后通过ob_item建立联系</span></span><br><span class="line">        op-&gt;ob_item = (PyObject **) PyMem_Calloc(size, <span class="keyword">sizeof</span>(PyObject *));</span><br><span class="line">        <span class="keyword">if</span> (op-&gt;ob_item == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            Py_DECREF(op);</span><br><span class="line">            <span class="keyword">return</span> PyErr_NoMemory();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置ob_size和allocated，然后返回op</span></span><br><span class="line">    Py_SIZE(op) = size;</span><br><span class="line">    op-&gt;allocated = size;</span><br><span class="line">    _PyObject_GC_TRACK(op);</span><br><span class="line">    <span class="keyword">return</span> (PyObject *) op;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们注意到源码里面有一个缓冲池，是的，创建PyListObject对象时，会先检测缓冲池free_lists里面是否有可用的对象，有的话直接拿来用，否则通过malloc在系统堆上申请。缓冲池中最多维护80个PyListObject对象。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Empty list reuse scheme to save calls to malloc and free */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PyList_MAXFREELIST</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PyList_MAXFREELIST 80</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">static</span> PyListObject *free_list[PyList_MAXFREELIST];</span><br></pre></td></tr></table></figure>

<p><strong>根据之前的经验我们知道，既然能从缓存池中获取，那么在执行析构函数的时候也要把列表放到缓存池里面。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">list_dealloc</span><span class="params">(PyListObject *op)</span></span><br><span class="line">&#123;</span><br><span class="line">    Py_ssize_t i;</span><br><span class="line">    PyObject_GC_UnTrack(op);</span><br><span class="line">    Py_TRASHCAN_SAFE_BEGIN(op)</span><br><span class="line">    <span class="keyword">if</span> (op-&gt;ob_item != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        i = Py_SIZE(op);</span><br><span class="line">        <span class="comment">//将底层数组中每个指针指向的对象的引用计数都减去1</span></span><br><span class="line">        <span class="keyword">while</span> (--i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            Py_XDECREF(op-&gt;ob_item[i]);</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">//然后释放底层数组所占的内存</span></span><br><span class="line">        PyMem_FREE(op-&gt;ob_item);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断缓冲池里面PyListObject对象的个数，如果没满，就添加到缓存池</span></span><br><span class="line">    <span class="comment">//注意：我们看到执行到这一步的时候, 底层数组已经被释放掉了</span></span><br><span class="line">    <span class="keyword">if</span> (numfree &lt; PyList_MAXFREELIST &amp;&amp; PyList_CheckExact(op))</span><br><span class="line">        free_list[numfree++] = op;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//否则的话再释放掉PyListObject对象所占的内存</span></span><br><span class="line">        Py_TYPE(op)-&gt;tp_free((PyObject *)op);</span><br><span class="line">    Py_TRASHCAN_SAFE_END(op)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们知道在创建一个新的PyListObject对象时，实际上是分为两步的，先创建PyListObject对象，然后创建底层数组，最后让PyListObject对象中的ob_item成员指向这个底层数组。同理，在销毁一个PyListObject对象时，先销毁ob_item维护的底层数组，然后再释放PyListObject对象自身<code>(如果缓存池已满的情况下)</code>。</strong></p>
<p><strong>现在可以很清晰地明白了，原本空荡荡的缓存池其实是被已经死去的PyListObject对象填充了，在以后创建新的PyListObject对象时，Python会首先唤醒这些死去的PyListObject对象，给它们一个洗心革面、重新做人的机会。但需要注意，这里缓存的仅仅是PyListObject对象，对于底层数组，其ob_item已经不再指向了。从list_dealloc中我们看到，PyListObject对象在放进缓存池之前，ob_item指向的数组就已经被释放掉了，同时数组中指针指向的对象的引用计数会减1。所以最终数组中这些指针指向的对象也大难临头各自飞了，或生存、或毁灭，总之此时和PyListObject之间已经没有任何联系了。但是为什么要这么做呢？为什么不连底层数组也一起维护呢？可以想一下，如果继续维护的话，数组中指针指向的对象永远不会被释放，那么很可能会产生悬空指针的问题，所以这些指针指向的对象所占的空间必须交还给系统<code>(前提是没有其它指针指向了)</code>。</strong></p>
<p><strong>但是实际上，是可以将PyListObject对象维护的底层数组进行保留的，即只将数组中指针指向的对象的引用计数减1，然后将数组中的指针都设置为NULL，不再指向之前的对象了，但是并不释放底层数组本身所占用的内存空间。因此这样一来，释放的内存不会交给系统堆，那么再次分配的时候，速度会快很多。但是这样带来一个问题，就是这些内存没人用也会一直占着，并且只能供PyListObject对象的ob_item指向的底层数组使用，因此Python还是为避免消耗过多内存，采取将底层数组的内存交换给了系统堆这样的做法，在时间和空间上选择了空间。</strong></p>
<h3 id="元组的底层结构–PyTupleObject"><a href="#元组的底层结构–PyTupleObject" class="headerlink" title="元组的底层结构–PyTupleObject"></a>元组的底层结构–PyTupleObject</h3><p><strong>因为元组比较简单，和列表比较相似，所以就放在一起介绍了。我们知道元组，就相当于不支持元素添加、修改、删除等操作的列表。</strong></p>
<p><strong>元组的实现机制非常简单，可以看做是在列表的基础上删除了<code>增删改</code>等操作。既然如此，那要元组有什么用呢？毕竟元组的功能只是列表的子集。元组存在的最大一个特点就是，它可以作为字典的key、以及可以作为集合的元素。因为字典和集合存储数据的原理是哈希表，字典和集合我们后续章节会说。对于列表这样的可变对象来说是可以动态改变的，而哈希值是一开始就计算好的，显然如果支持动态修改的话，那么哈希值肯定会变，这是不允许的。所以如果我们希望字典的key是一个序列，显然元组再适合不过了。</strong></p>
<p><strong>从tuple的特点也能看出：tuple的底层是一个变长对象，但同时也是一个不可变对象。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    PyObject *ob_item[<span class="number">1</span>];</span><br><span class="line">&#125; PyTupleObject;</span><br></pre></td></tr></table></figure>

<p><strong>可以看到，对于不可变对象来说，它底层结构体定义也非常简单。一个引用计数、一个类型、一个指针数组。这里的1可以想象成n，我们在PyLongObject中说过。</strong></p>
<p><strong>并且我们发现不像列表，元组没有allocated，这是因为它是不可变的，不支持resize操作。至于维护的值，同样是指针组成的数组，数组里面的每一个指针都指向了具体的值。</strong></p>
<h4 id="PyTupleObject的创建"><a href="#PyTupleObject的创建" class="headerlink" title="PyTupleObject的创建"></a>PyTupleObject的创建</h4><p><strong>正如列表一样，Python创建PyTupleObject也提供了类似的初始化方法。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyTuple_New</span><span class="params">(Py_ssize_t size)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//PyTupleObject指针</span></span><br><span class="line">    PyTupleObject *op;</span><br><span class="line">    Py_ssize_t i;</span><br><span class="line">    <span class="keyword">if</span> (size &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        PyErr_BadInternalCall();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> PyTuple_MAXSAVESIZE &gt; 0</span></span><br><span class="line">    <span class="comment">//元组同样有缓存池</span></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span> &amp;&amp; free_list[<span class="number">0</span>]) &#123;</span><br><span class="line">        op = free_list[<span class="number">0</span>];</span><br><span class="line">        Py_INCREF(op);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> COUNT_ALLOCS</span></span><br><span class="line">        tuple_zero_allocs++;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  </span></span><br><span class="line">        <span class="comment">//如果长度为0，那么直接返回</span></span><br><span class="line">        <span class="keyword">return</span> (PyObject *) op;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (size &lt; PyTuple_MAXSAVESIZE &amp;&amp; (op = free_list[size]) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//从缓存池中获取</span></span><br><span class="line">        free_list[size] = (PyTupleObject *) op-&gt;ob_item[<span class="number">0</span>];</span><br><span class="line">        numfree[size]--;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> COUNT_ALLOCS</span></span><br><span class="line">        fast_tuple_allocs++;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="comment">/* Inline PyObject_InitVar */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> Py_TRACE_REFS</span></span><br><span class="line">        <span class="comment">//设置ob_size，和ob_type</span></span><br><span class="line">        Py_SIZE(op) = size;</span><br><span class="line">        Py_TYPE(op) = &amp;PyTuple_Type;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="comment">//引用计数初始化为1</span></span><br><span class="line">        _Py_NewReference((PyObject *)op);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 元组的元素个数同样有限制，但我们说这个限制一般达不到 */</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="type">size_t</span>)size &gt; ((<span class="type">size_t</span>)PY_SSIZE_T_MAX - <span class="keyword">sizeof</span>(PyTupleObject) -</span><br><span class="line">                    <span class="keyword">sizeof</span>(PyObject *)) / <span class="keyword">sizeof</span>(PyObject *)) &#123;</span><br><span class="line">            <span class="keyword">return</span> PyErr_NoMemory();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//申请空间</span></span><br><span class="line">        op = PyObject_GC_NewVar(PyTupleObject, &amp;PyTuple_Type, size);</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        op-&gt;ob_item[i] = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> PyTuple_MAXSAVESIZE &gt; 0</span></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        free_list[<span class="number">0</span>] = op;</span><br><span class="line">        ++numfree[<span class="number">0</span>];</span><br><span class="line">        Py_INCREF(op);          <span class="comment">/* extra INCREF so that this is never freed */</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHOW_TRACK_COUNT</span></span><br><span class="line">    count_tracked++;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    _PyObject_GC_TRACK(op);</span><br><span class="line">    <span class="keyword">return</span> (PyObject *) op;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>和PyListObject初始化类似，同样需要做一些类型检测，内存是否溢出等等。</strong></p>
<p><strong>当然有了列表的经验，元组的一些底层操作我们就不分析了，它是列表的子集。</strong></p>
<h4 id="静态资源缓存"><a href="#静态资源缓存" class="headerlink" title="静态资源缓存"></a>静态资源缓存</h4><p><strong>列表和元组两者在通过索引查找元素的时候是一致的，但是元组除了能作为字典的key之外，还有一个特点，就是分配的速度比较快。一方面是因为由于其不可变性，使得在编译的时候就确定了，另一方面就是它还具有静态资源缓存的作用。</strong></p>
<p><strong>对于一些静态变量，比如元组，如果它不被使用并且占用空间不大时，Python 会暂时缓存这部分内存。这样，下次我们再创建同样大小的元组时，Python  就可以不用再向操作系统发出请求，去寻找内存，而是可以直接分配之前缓存的内存空间，这样就能大大加快程序的运行速度。你可以理解为PyTupleObject对象在被析构时，不仅对象本身没有被回收，连底层的指针数组也被缓存起来了。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> timeit <span class="keyword">import</span> timeit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t1 = timeit(stmt=<span class="string">&quot;x1 = [1, 2, 3, 4, 5]&quot;</span>, number=<span class="number">1000000</span>)</span><br><span class="line">t2 = timeit(stmt=<span class="string">&quot;x2 = (1, 2, 3, 4, 5)&quot;</span>, number=<span class="number">1000000</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">round</span>(t1, <span class="number">2</span>))  <span class="comment"># 0.05</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">round</span>(t2, <span class="number">2</span>))  <span class="comment"># 0.01</span></span><br></pre></td></tr></table></figure>

<p><strong>可以看到用时，元组只是列表的五分之一。这便是元组的另一个优势，可以将资源缓存起来。</strong></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Lin Li</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/03/29/08-%E8%A7%A3%E5%AF%86Python%E4%B8%AD%E5%88%97%E8%A1%A8%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/">http://example.com/2023/03/29/08-%E8%A7%A3%E5%AF%86Python%E4%B8%AD%E5%88%97%E8%A1%A8%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">LinLi's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/CPython/">CPython</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/03/29/09-%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/" title="09-字典和集合的底层实现"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">09-字典和集合的底层实现</div></div></a></div><div class="next-post pull-right"><a href="/2023/03/29/07-Python%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/" title="07-Python字符串的底层实现"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">07-Python字符串的底层实现</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/03/29/01-%E7%BC%96%E8%AF%91Cpython/" title="01-编译Cpython"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">01-编译Cpython</div></div></a></div><div><a href="/2023/03/29/02-%E4%B8%80%E5%88%87%E5%AF%B9%E8%B1%A1%E7%9A%86PyObject/" title="02-一切对象皆PyObject"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">02-一切对象皆PyObject</div></div></a></div><div><a href="/2023/03/29/04-%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/" title="04-浮点数的底层实现"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">04-浮点数的底层实现</div></div></a></div><div><a href="/2023/03/29/06-Bytes%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BA%95%E5%B1%82%E6%93%8D%E4%BD%9C/" title="06-Bytes对象的底层操作"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">06-Bytes对象的底层操作</div></div></a></div><div><a href="/2023/03/29/03-Python%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E5%99%A8%E5%92%8C%E5%BA%95%E5%B1%82%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86/" title="03-Python引用计数器和底层对象管理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">03-Python引用计数器和底层对象管理</div></div></a></div><div><a href="/2023/03/29/05-Python%E6%95%B4%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/" title="05-Python整数的底层实现"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">05-Python整数的底层实现</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Lin Li</div><div class="author-info__description">今日事，今日毕</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">95</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#08-%E8%A7%A3%E5%AF%86Python%E4%B8%AD%E5%88%97%E8%A1%A8%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.</span> <span class="toc-text">08-解密Python中列表的底层实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A5%94%E5%AD%90"><span class="toc-number">1.1.</span> <span class="toc-text">楔子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84%E2%80%93PyListObject"><span class="toc-number">1.2.</span> <span class="toc-text">列表的内部结构–PyListObject</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%E6%94%AF%E6%8C%81%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">1.3.</span> <span class="toc-text">列表支持的操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E6%89%A9%E5%AE%B9"><span class="toc-number">1.3.1.</span> <span class="toc-text">自动扩容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#append%E8%BF%BD%E5%8A%A0%E5%85%83%E7%B4%A0"><span class="toc-number">1.3.2.</span> <span class="toc-text">append追加元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0"><span class="toc-number">1.3.3.</span> <span class="toc-text">获取元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E5%85%83%E7%B4%A0"><span class="toc-number">1.3.4.</span> <span class="toc-text">设置元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#insert%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A0"><span class="toc-number">1.3.5.</span> <span class="toc-text">insert插入元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pop%E5%BC%B9%E5%87%BA%E5%85%83%E7%B4%A0"><span class="toc-number">1.3.6.</span> <span class="toc-text">pop弹出元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#index%E6%9F%A5%E8%AF%A2%E5%85%83%E7%B4%A0%E7%9A%84%E7%B4%A2%E5%BC%95"><span class="toc-number">1.3.7.</span> <span class="toc-text">index查询元素的索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#count%E6%9F%A5%E8%AF%A2%E5%85%83%E7%B4%A0%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0"><span class="toc-number">1.3.8.</span> <span class="toc-text">count查询元素出现的次数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#remove%E6%A0%B9%E6%8D%AE%E5%85%83%E7%B4%A0%E7%9A%84%E5%80%BC%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-number">1.3.9.</span> <span class="toc-text">remove根据元素的值删除元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#reverse%E7%BF%BB%E8%BD%AC%E5%88%97%E8%A1%A8"><span class="toc-number">1.3.10.</span> <span class="toc-text">reverse翻转列表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E5%88%97%E8%A1%A8%E7%9B%B8%E5%8A%A0"><span class="toc-number">1.3.11.</span> <span class="toc-text">两个列表相加</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E5%85%83%E7%B4%A0%E6%98%AF%E5%90%A6%E5%9C%A8%E5%88%97%E8%A1%A8%E4%B8%AD"><span class="toc-number">1.3.12.</span> <span class="toc-text">判断元素是否在列表中</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%E7%9A%84%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">1.3.13.</span> <span class="toc-text">列表的深浅拷贝</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAPyListObject"><span class="toc-number">1.4.</span> <span class="toc-text">创建PyListObject</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E7%BB%84%E7%9A%84%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E2%80%93PyTupleObject"><span class="toc-number">1.5.</span> <span class="toc-text">元组的底层结构–PyTupleObject</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#PyTupleObject%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">1.5.1.</span> <span class="toc-text">PyTupleObject的创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E7%BC%93%E5%AD%98"><span class="toc-number">1.5.2.</span> <span class="toc-text">静态资源缓存</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/17/Movery-A-Precise-Approach-for-Modified-Vulnerable-Code-Clone-Discovery-from-Modified-Open-Source-Software-Components/" title="Movery A Precise Approach for Modified Vulnerable Code Clone Discovery from Modified Open-Source Software Components">Movery A Precise Approach for Modified Vulnerable Code Clone Discovery from Modified Open-Source Software Components</a><time datetime="2024-08-17T14:09:41.000Z" title="发表于 2024-08-17 22:09:41">2024-08-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/30/Translating-between-SQL-Dialects-for-Cloud-Migration/" title="Translating between SQL Dialects for Cloud Migration">Translating between SQL Dialects for Cloud Migration</a><time datetime="2024-07-30T07:48:40.000Z" title="发表于 2024-07-30 15:48:40">2024-07-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/30/Mallet-SQL-Dialect-Translation-with-LLM-Rule-Generation/" title="Mallet: SQL Dialect Translation with LLM Rule Generation">Mallet: SQL Dialect Translation with LLM Rule Generation</a><time datetime="2024-07-30T07:47:16.000Z" title="发表于 2024-07-30 15:47:16">2024-07-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/11/Keep-It-Simple-Testing-Databases-via-Differential-Query-Plans/" title="Keep It Simple: Testing Databases via Differential Query Plans">Keep It Simple: Testing Databases via Differential Query Plans</a><time datetime="2024-07-11T03:23:01.000Z" title="发表于 2024-07-11 11:23:01">2024-07-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/08/WINGFUZZ-Implementing-Continuous-Fuzzing-for-DBMSs/" title="WINGFUZZ: Implementing Continuous Fuzzing for DBMSs">WINGFUZZ: Implementing Continuous Fuzzing for DBMSs</a><time datetime="2024-07-08T05:48:21.000Z" title="发表于 2024-07-08 13:48:21">2024-07-08</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Lin Li</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>