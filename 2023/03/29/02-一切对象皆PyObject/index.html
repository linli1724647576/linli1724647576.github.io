<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>02-一切对象皆PyObject | LinLi's Blog</title><meta name="author" content="Lin Li"><meta name="copyright" content="Lin Li"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="02-一切皆对象PyObject一切皆对象PyObjectPython中一切皆对象，int str list dict tuple都是对象，类型也是对象。程序员可以通过class创建自己的对象，对象对于程序员来说是数据，对计算机来说是一块内存。  Python中还有一个特殊的类型(对象)，叫做object，它是所有类型对象的基类。不管是什么类，内置的类也好，我们自定义的类也罢，它们都继承自obje">
<meta property="og:type" content="article">
<meta property="og:title" content="02-一切对象皆PyObject">
<meta property="og:url" content="http://example.com/2023/03/29/02-%E4%B8%80%E5%88%87%E5%AF%B9%E8%B1%A1%E7%9A%86PyObject/index.html">
<meta property="og:site_name" content="LinLi&#39;s Blog">
<meta property="og:description" content="02-一切皆对象PyObject一切皆对象PyObjectPython中一切皆对象，int str list dict tuple都是对象，类型也是对象。程序员可以通过class创建自己的对象，对象对于程序员来说是数据，对计算机来说是一块内存。  Python中还有一个特殊的类型(对象)，叫做object，它是所有类型对象的基类。不管是什么类，内置的类也好，我们自定义的类也罢，它们都继承自obje">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2023-03-29T02:21:58.000Z">
<meta property="article:modified_time" content="2023-04-12T02:35:45.735Z">
<meta property="article:author" content="Lin Li">
<meta property="article:tag" content="CPython">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/03/29/02-%E4%B8%80%E5%88%87%E5%AF%B9%E8%B1%A1%E7%9A%86PyObject/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '02-一切对象皆PyObject',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-04-12 10:35:45'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">81</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="LinLi's Blog"><span class="site-name">LinLi's Blog</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">02-一切对象皆PyObject</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-29T02:21:58.000Z" title="发表于 2023-03-29 10:21:58">2023-03-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-04-12T02:35:45.735Z" title="更新于 2023-04-12 10:35:45">2023-04-12</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="02-一切对象皆PyObject"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="02-一切皆对象PyObject"><a href="#02-一切皆对象PyObject" class="headerlink" title="02-一切皆对象PyObject"></a>02-一切皆对象PyObject</h2><h3 id="一切皆对象PyObject"><a href="#一切皆对象PyObject" class="headerlink" title="一切皆对象PyObject"></a>一切皆对象PyObject</h3><p>Python中一切皆对象，int str list dict tuple都是对象，类型也是对象。程序员可以通过class创建自己的对象，对象对于程序员来说是数据，对计算机来说是一块内存。</p>
<p><img src="/2023/03/29/02-%E4%B8%80%E5%88%87%E5%AF%B9%E8%B1%A1%E7%9A%86PyObject/image-20230308194406865.png" alt="image-20230308194406865"></p>
<p>Python中还有一个特殊的类型(对象)，叫做object，它是所有类型对象的基类。不管是什么类，内置的类也好，我们自定义的类也罢，它们都继承自object。因此，object是所有类型对象的”基类”、或者说”父类”。</p>
<p><img src="/2023/03/29/02-%E4%B8%80%E5%88%87%E5%AF%B9%E8%B1%A1%E7%9A%86PyObject/image-20230310144138069.png" alt="image-20230310144138069"></p>
<p><strong>我们说可以使用type和__class__查看一个对象的类型，并且还可以通过isinstance来判断该对象是不是某个已知类型的实例对象；那如果想查看一个类型对象都继承了哪些类该怎么做呢？我们目前都是使用issubclass来判断某个类型对象是不是另一个已知类型对象的子类，那么可不可以直接获取某个类型对象都继承了哪些类呢？</strong></p>
<p><strong>答案是可以的，方法有三种，我们分别来看一下：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>: <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(<span class="title class_ inherited__">A</span>): <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>(B, C): <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 首先D继承自B和C, C又继承A, 我们现在要来查看D继承的父类</span></span><br><span class="line"><span class="comment"># 方法一: 使用__base__</span></span><br><span class="line"><span class="built_in">print</span>(D.__base__)  <span class="comment"># &lt;class &#x27;__main__.B&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法二: 使用__bases__</span></span><br><span class="line"><span class="built_in">print</span>(D.__bases__)  <span class="comment"># (&lt;class &#x27;__main__.B&#x27;&gt;, &lt;class &#x27;__main__.C&#x27;&gt;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法三: 使用__mro__</span></span><br><span class="line"><span class="built_in">print</span>(D.__mro__)</span><br><span class="line"><span class="comment"># (&lt;class &#x27;__main__.D&#x27;&gt;, &lt;class &#x27;__main__.B&#x27;&gt;, &lt;class &#x27;__main__.C&#x27;&gt;, &lt;class &#x27;__main__.A&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>__base__: 如果继承了多个类, 那么只显示继承的第一个类, 没有显示继承则返回一个&lt;class &#39;object&#39;&gt;;</code></li>
<li><code>__bases__: 返回一个元组, 会显示所有直接继承的父类, 如果没有显示的继承, 则返回(&lt;class &#39;object&#39;&gt;,);</code></li>
<li><code>__mro__: mro表示Method Resolution Order, 表示方法查找顺序, 会从自身除法, 找到最顶层的父类, 因此返回自身、继承的基类、以及基类继承的基类, 一直找到object;</code></li>
</ul>
<p>最后我们来看一下type和object，估计这两个老铁之间的关系会让很多人感到困惑。</p>
<p>我们说type是所有类的元类，而object是所有的基类，这就说明type是要继承自object的，而object的类型是type。</p>
<p><img src="/2023/03/29/02-%E4%B8%80%E5%88%87%E5%AF%B9%E8%B1%A1%E7%9A%86PyObject/image-20230310144509108.png" alt="image-20230310144509108"></p>
<p>这就怪了，这难道不是一个先有鸡还是先有蛋的问题吗？其实不是的，这两个对象是共存的，它们之间的定义其实是互相依赖的。至于到底是怎么肥事，我们后面在看解释器源码的时候就会很清晰了。</p>
<p><strong>总之目前记住两点：</strong></p>
<ul>
<li><code>1. type站在类型金字塔的最顶端, 任何的对象按照类型追根溯源, 最终得到的都是type;</code></li>
<li><code>2. object站在继承金字塔的最顶端, 任何的类型对象按照继承追根溯源, 最终得到的都是object;</code></li>
</ul>
<p>我们说type的类型还是type，但是object的基类则不再是object，而是一个None。为什么呢？其实答案很简单，我们说Python在查找属性或方法的时候，会回溯继承链，自身如果没有的话，就会按照__mro__指定的顺序去基类中查找。所以继承链一定会有一个终点，否则就会像没有出口的递归一样出现死循环了。</p>
<p>最后将上面那张关系图再完善一下的话：</p>
<p><img src="/2023/03/29/02-%E4%B8%80%E5%88%87%E5%AF%B9%E8%B1%A1%E7%9A%86PyObject/image-20230310144643701.png" alt="image-20230310144643701"></p>
<h3 id="实现对象机制的基石-PyOBject"><a href="#实现对象机制的基石-PyOBject" class="headerlink" title="实现对象机制的基石-PyOBject"></a>实现对象机制的基石-PyOBject</h3><p><strong>根据对象的不同特点还可以进一步分类：</strong></p>
<ul>
<li><code>可变对象：对象创建之后可以本地修改;</code></li>
<li><code>不可变对象：对象创建之后不可以本地修改;</code></li>
<li><code>定长对象：对象所占用的内存大小固定;</code></li>
<li><code>不定长对象：对象所占用的内存大小不固定;</code></li>
</ul>
<p>但是”对象”在Python的底层是如何实现的呢？我们知道标准的Python解释器是C语言实现的CPython，但C并不是一个面向对象的语言，那么它是如何实现Python中的面向对象的呢？</p>
<p>首先对于人的思维来说，对象是一个比较形象的概念，但对于计算机来说，对象却是一个抽象的概念。它并不能理解这是一个整数，那是一个字符串，计算机所知道的一切都是字节。通常的说法是：对象是数据以及基于这些数据的操作的集合。在计算机中，一个对象实际上就是一片被分配的内存空间，这些内存可能是连续的，也可能是离散的。</p>
<p><strong>而Python中的任何对象在C中都对应一个结构体实例，在Python中创建一个对象，等价于在C中创建一个结构体实例。所以Python中的对象本质上就是C中malloc函数为结构体实例在堆区申请的一块内存。</strong></p>
<p>Python中一切皆对象，而所有的对象都拥有一些共同的信息(也叫头部信息)，这些信息就在PyObject中，PyObject是Python整个对象机制的核心，我们来看看它的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Include/object.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">object</span> &#123;</span></span><br><span class="line">    _PyObject_HEAD_EXTRA</span><br><span class="line">    Py_ssize_t ob_refcnt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">ob_type</span>;</span></span><br><span class="line">&#125; PyObject;</span><br></pre></td></tr></table></figure>

<p><font color="red"><strong>PyObject_HEAD_EXTRA</strong></font>    </p>
<p>PyObject_HEAD_EXTRA 定义了两个双向链表，用于指向堆上创建的活着的对象</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Define pointers to support a doubly-linked list of all live heap objects. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _PyObject_HEAD_EXTRA            \</span></span><br><span class="line"><span class="meta">    PyObject *_ob_next;           \</span></span><br><span class="line"><span class="meta">    PyObject *_ob_prev;</span></span><br></pre></td></tr></table></figure>

<p><font color="red"><strong>Ob_refcnt</strong></font></p>
<p>ob_refcnt定义了引用计数器</p>
<p>当一个对象被引用时，那么ob_refcnt会自增1；引用解除时，ob_refcnt自减1。而一旦对象的引用计数为0时，那么这个对象就会被回收。</p>
<p>那么在哪些情况下，引用计数会加1呢？哪些情况下，引用计数会减1呢？</p>
<p><strong>导致引用计数加1的情况：</strong></p>
<ul>
<li><code>对象被创建：比如name = &quot;古明地觉&quot;, 此时对象就是&quot;古明地觉&quot;这个字符串, 创建成功时它的引用计数为1</code></li>
<li><code>变量传递使得对象被新的变量引用：比如Name = name</code></li>
<li><code>引用该对象的某个变量作为参数传到一个函数或者类中：比如func(name)</code></li>
<li><code>引用该对象的某个变量作为元组、列表、集合等容器的一个元素：比如lst = [name]</code></li>
</ul>
<p><strong>导致引用计数减1的情况：</strong></p>
<ul>
<li><code>引用该对象的变量被显示的销毁：del name</code></li>
<li><code>对象的引用指向了别的对象：name = &quot;椎名真白&quot;</code></li>
<li><code>引用该对象的变量离开了它的作用域，比如函数的局部变量在函数执行完毕的时候会被销毁</code></li>
<li><code>引用该对象的变量所在的容器被销毁，或者被从容器里面删除</code></li>
</ul>
<p>所以我们使用del删除一个对象，并不是删除这个对象，我们没有这个权力，del只是使对象的引用计数减一，至于到底删不删是解释器判断对象引用计数是否为0决定的。为0就删，不为0就不删，就这么简单。</p>
<p>而ob_refcnt的类型是<strong>Py_ssize_t</strong>，在64位机器上直接把这个类型看成long即可<code>(话说这都2020年了，不会还有人用32位机器吧)</code>，因此一个对象的引用计数不能超过long所表示的最大范围。但是显然，如果不是吃饱了撑的写恶意代码，是不可能超过这个范围的。</p>
<p><font color="red"><strong>ob_type：类型指针</strong></font></p>
<p>我们说一个对象是有类型的，类型对象描述实例对象的数据和行为，而ob_type存储的便是对应类型对象的指针，所以类型对象在底层对应的是struct  _typeobject实例。从这里我们可以看出，所有的类型对象在底层都是由同一个结构体实例化得到的，因为PyObject是所有的对象共有的，它们的ob_type指向的都是struct _typeobject。</p>
<blockquote>
<p><strong>所以不同的实例对象对应不同的结构体，但是类型对象对应的都是同一个结构体。</strong></p>
</blockquote>
<p>因此我们看到PyObject的定义非常简单，就是一个引用计数和一个类型指针，所以Python中的任意对象都必有：引用计数和类型这两个属性。</p>
<h3 id="实现变长对象的基石–PyVarObject"><a href="#实现变长对象的基石–PyVarObject" class="headerlink" title="实现变长对象的基石–PyVarObject"></a>实现变长对象的基石–PyVarObject</h3><p>我们说PyObject是所有对象的核心，它包含了所有对象都共有的信息，但是还有那么一个属性虽然不是每个对象都有，但至少有一大半的对象会有，能猜到是什么吗？</p>
<p>我们说Python中的对象根据所占的内存是否固定可以分为定长对象和变长对象，而变长对象显然有一个长度的概念，比如字符串、列表、元组等等，即便是相同的实例对象，但是长度不同，所占的内存也是不同的。比如：字符串内部有多少个字符、元组、列表内部有多少个元素，显然这里的多少*也是Python中很多对象的共有特征，虽然不像引用计数和类型那样是每个对象都必有的，但也是相当大一部分对象所具有的。</p>
<p><strong>所以针对变长对象，Python底层也提供了一个结构体，因为Python很多都是变长对象。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Include/object.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject ob_base;</span><br><span class="line">    Py_ssize_t ob_size; <span class="comment">/* Number of items in variable part */</span></span><br><span class="line">&#125; PyVarObject;</span><br></pre></td></tr></table></figure>

<p>所以我们看到PyVarObject实际上是PyObject的一个扩展，它在PyObject的基础上提供了一个ob_size字段，用于记录内部的元素个数。比如列表，列表<code>(PyListObject实例)</code>中的ob_size维护的就是列表的元素个数，插入一个元素，ob_size会加1，删除一个元素，ob_size会减1。所以我们使用len获取列表的元素个数是一个时间复杂度为O(1)的操作，因为ob_size是时刻都和内部的元素个数保持一致，使用len获取元素个数的时候会直接访问ob_size。</p>
<p><font color="green">因此在Python中，所有的变长对象都拥有PyVarObject，而所有的对象都拥有PyObject，这就使得在Python中，对”对象”的引用变得非常统一，我们只需要一个PyObject  *就可以引用任意一个对象，而不需要管这个对象实际是一个什么对象。所以在Python中，所有的变量、以及容器内部的元素，本质上都是一个PyObject *。</font></p>
<p>由于PyObject和PyVarObject要经常被使用，所以Python提供了两个宏，方便定义。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Include/object.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PyObject_HEAD          PyObject ob_base;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PyObject_VAR_HEAD      PyVarObject ob_base;</span></span><br></pre></td></tr></table></figure>

<p><strong>比如定长对象浮点数，在底层对应的结构体为PyFloatObject，只需在头部PyObject的基础上再加上一个double即可。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Include/Cpython/floatobject.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    <span class="type">double</span> ob_fval;</span><br><span class="line">&#125; PyFloatObject;</span><br></pre></td></tr></table></figure>

<p><strong>而对于变长对象列表，在底层对应的结构体是PyListObject，所以它需要在PyVarObject的基础上再加上一个指向数组的二级指针和一个容量即可。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Include/Cpython/listobject.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    PyObject **ob_item;</span><br><span class="line">    Py_ssize_t allocated;</span><br><span class="line">&#125; PyListObject;</span><br></pre></td></tr></table></figure>

<p><strong>这上面的每一个成员都代表什么，我们之前已经分析过了。ob_item就是指向指针数组的二级指针，而allocated表示已经分配的容量，一旦添加元素的时候发现ob_size自增1之后会大于allocated，那么解释器就会对ob_item指向的指针数组进行扩容了。更准确的说，是申请一个容量更大数组，然后将原来指向的指针数组内部的元素按照顺序一个一个地拷贝到新的数组里面去，并让ob_item指向新的数组，这一点在分析PyListObject的时候会细说。所以我们看到列表在添加元素的时候，地址是不会改变的，即使容量不够了也没有关系，直接让ob_item指向新的数组就好了，至于PyListObject对象本身的地址是不会变化的。</strong></p>
<p>最后再来<font color="green">介绍两个宏定义</font>，这个是针对于类型对象的，我们后面在介绍类型对象的时候会经常见到这两个宏定义。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Include/object.h</span><br><span class="line">#define PyObject_HEAD_INIT(type)        \</span><br><span class="line">    &#123; _PyObject_EXTRA_INIT              \</span><br><span class="line">    1, type &#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define PyVarObject_HEAD_INIT(type, size)       \</span><br><span class="line">    &#123; PyObject_HEAD_INIT(type) size &#125;,</span><br></pre></td></tr></table></figure>

<p>先看PyObject_HEAD_INIT，里面的_PyObject_EXTRA_INIT是用来实现refchain这个双向链表的，我们目前不需要管。里面的1指的是引用计数，我们看到刚创建的时候默认是设置为1的，至于type就是该类型对象的类型了，这个是作为宏的参数传进来的；而PyVarObject_HEAD_INIT，则是在PyObject_HEAD_INIT的基础之上，增加了一个size，显然我们从名字也能看出来这个size是什么。当然目前只是介绍这两个宏，先有个印象，类型对象的实现我们下面就会说。</p>
<h3 id="实现类型对象的基石–PyTypeObject"><a href="#实现类型对象的基石–PyTypeObject" class="headerlink" title="实现类型对象的基石–PyTypeObject"></a>实现类型对象的基石–PyTypeObject</h3><p>通过PyObject和PyVarObject，我们看到了Python中所有对象的共有信息以及变长对象的共有信息。对于任何一个对象，不管它是什么类型，内部必有引用计数<code>(ob_refcnt)</code>和类型指针<code>(ob_type)</code>；对于任意一个变长对象，不管它是什么类型，除了引用计数和类型指针之外，内部还有一个表示元素个数的ob_size。</p>
<p><strong>然目前是没有什么问题，一切都是符合我们的预期的，但是当我们顺着时间轴回溯的话，就会发现端倪。比如：</strong></p>
<ul>
<li><code>1. 当在内存中创建对象、分配空间的时候，解释器要给该对象分配多大的空间？显然不能随便分配，那么该对象的内存信息在什么地方？</code></li>
<li><code>2. 一个对象是支持相应的操作的，解释器怎么判断该对象支持哪些操作呢？再比如一个整型可以和一个整型相乘，但是一个列表也可以和一个整型相乘，即使是相同的操作，但不同类型的对象执行也会有不同的结果，那么此时解释器又是如何进行区分的？</code></li>
</ul>
<p>想都不用想，这些信息肯定都在对象所对应的类型对象中。而且占用的空间大小实际上是对象的一个元信息，这样的元信息和其所属类型是密切相关的，因此它一定会出现在与之对应的类型对象当中。至于支持的操作就更不用说了，我们平时自定义类的时候，方法都写在什么地方，显然都是写在类里面，因此一个对象支持的操作显然定义在类型对象当中。</p>
<p>而将一个对象和其类型对象关联起来的，毫无疑问正是该对象内部的PyObject中的ob_type，也就是类型指针。我们通过对象的ob_type成员即可获取指向的类型对象的指针，通过该指针可以获取存储在类型对象中的某些元信息。</p>
<p>下面我们来看看类型对象在底层是怎么定义的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Include/object.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">object</span> &#123;</span></span><br><span class="line">    Py_ssize_t ob_refcnt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">ob_type</span>;</span></span><br><span class="line">&#125; PyObject; <span class="comment">//_typeobject正是PyObject里面的一个成员</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Include/Cpython/object.h</span></span><br><span class="line"><span class="comment">// 类型对象对应的结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> &#123;</span></span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *tp_name;</span><br><span class="line">    Py_ssize_t tp_basicsize, tp_itemsize; </span><br><span class="line">    destructor tp_dealloc;</span><br><span class="line">    printfunc tp_print;</span><br><span class="line">    getattrfunc tp_getattr;</span><br><span class="line">    setattrfunc tp_setattr;</span><br><span class="line">    PyAsyncMethods *tp_as_async; <span class="comment">/* formerly known as tp_compare (Python 2)</span></span><br><span class="line"><span class="comment">                                    or tp_reserved (Python 3) */</span></span><br><span class="line">    reprfunc tp_repr;</span><br><span class="line">    PyNumberMethods *tp_as_number;</span><br><span class="line">    PySequenceMethods *tp_as_sequence;</span><br><span class="line">    PyMappingMethods *tp_as_mapping;</span><br><span class="line">    hashfunc tp_hash;</span><br><span class="line">    ternaryfunc tp_call;</span><br><span class="line">    reprfunc tp_str;</span><br><span class="line">    getattrofunc tp_getattro;</span><br><span class="line">    setattrofunc tp_setattro;</span><br><span class="line">    PyBufferProcs *tp_as_buffer;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> tp_flags;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *tp_doc; <span class="comment">/* Documentation string */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    traverseproc tp_traverse;</span><br><span class="line"></span><br><span class="line">    inquiry tp_clear;</span><br><span class="line">    richcmpfunc tp_richcompare;</span><br><span class="line"></span><br><span class="line">    Py_ssize_t tp_weaklistoffset;</span><br><span class="line"></span><br><span class="line">    getiterfunc tp_iter;</span><br><span class="line">    iternextfunc tp_iternext;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PyMethodDef</span> *<span class="title">tp_methods</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PyMemberDef</span> *<span class="title">tp_members</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PyGetSetDef</span> *<span class="title">tp_getset</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">tp_base</span>;</span></span><br><span class="line">    PyObject *tp_dict;</span><br><span class="line">    descrgetfunc tp_descr_get;</span><br><span class="line">    descrsetfunc tp_descr_set;</span><br><span class="line">    Py_ssize_t tp_dictoffset;</span><br><span class="line">    initproc tp_init;</span><br><span class="line">    allocfunc tp_alloc;</span><br><span class="line">    newfunc tp_new;</span><br><span class="line">    freefunc tp_free; <span class="comment">/* Low-level free-memory routine */</span></span><br><span class="line">    inquiry tp_is_gc; <span class="comment">/* For PyObject_IS_GC */</span></span><br><span class="line">    PyObject *tp_bases;</span><br><span class="line">    PyObject *tp_mro; <span class="comment">/* method resolution order */</span></span><br><span class="line">    PyObject *tp_cache;</span><br><span class="line">    PyObject *tp_subclasses;</span><br><span class="line">    PyObject *tp_weaklist;</span><br><span class="line">    destructor tp_del;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> tp_version_tag;</span><br><span class="line"></span><br><span class="line">    destructor tp_finalize;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> COUNT_ALLOCS</span></span><br><span class="line">    Py_ssize_t tp_allocs;</span><br><span class="line">    Py_ssize_t tp_frees;</span><br><span class="line">    Py_ssize_t tp_maxalloc;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">tp_prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">tp_next</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125; PyTypeObject;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>类型对象在底层对应的是struct _typeobject，当然也是PyTypeObject，它里面的成员非常非常多，我们暂时挑几个重要的说，因为有一部分成员并不是那么重要，我们在后续会慢慢说。</strong></p>
<p><strong>目前我们了解到Python中的类型对象在底层就是一个PyTypeObject实例，它保存了实例对象的元信息，描述对象的类型。</strong></p>
<blockquote>
<p><strong>Python中的实例对象在底层对应不同的结构体实例，而类型对象则是对应同一个结构体实例，换句话说无论是int、str、dict等等等等，它们在C的层面都是由PyTypeObject这个结构体实例化得到的，只不过成员的值不同PyTypeObject这个结构体在实例化之后得到的类型对象也不同。</strong></p>
</blockquote>
<p><font color="green"><strong>我们看一下PyTypeObject内部几个非常关键的成员：</strong></font></p>
<ul>
<li><code>PyObject_VAR_HEAD：我们说这是一个宏，对应一个PyVarObject，所以类型对象是一个变长对象。而且类型对象也有引用计数和类型，这与我们前面分析的是一致的。</code></li>
<li><code>tp_name：类型的名称，而这是一个char *，显然它可以是int、str、dict之类的。</code></li>
<li><code>tp_basicsize, tp_itemsize：创建对应实例对象时所需要的内存信息。</code></li>
<li><code>tp_dealloc：其实例对象执行析构函数时所作的操作。</code></li>
<li><code>tp_print：其实例对象被打印时所作的操作。</code></li>
<li><code>tp_as_number：其实例对象为数值时，所支持的操作。这是一个结构体指针，指向的结构体中的每一个成员都是一个函数指针，其函数就是整型对象可以执行的操作，比如：四则运算、左移、右移、取模等等</code></li>
<li><code>tp_as_sequence：其实例对象为序列时，所支持的操作。同样是一个结构体指针。</code></li>
<li><code>tp_as_mapping：其实例对象为映射时，所支持的操作。也是一个结构体指针。</code></li>
<li><code>tp_base：继承的基类。</code></li>
</ul>
<p><strong>我们暂时就挑这么几个，事实上从名字上你也能看出来这每一个成员代表的含义。而且这里面的成员虽然多，但并非每一个类型对象都具备，比如int类型它就没有tp_as_sequence和tp_as_mapping，所以int类型的这两个成员的值都是0。</strong></p>
<p><strong>具体的我们就在分析具体的类型对象的时候再说吧，然后先来看看Python对象在底层都叫什么名字吧。</strong></p>
<ul>
<li><code>整型 -&gt; PyLongObject结构体实例,  int -&gt; PyLong_Type(PyTypeObject结构体实例)</code></li>
<li><code>字符串 -&gt; PyUnicodeObject结构体实例,  str -&gt; PyUnicode_Type(PyTypeObject结构体实例)</code></li>
<li><code>浮点数 -&gt; PyFloatObject结构体实例,  float -&gt; PyFloat_Type(PyTypeObject结构体实例)</code></li>
<li><code>复数 -&gt; PyComplexObject结构体实例,  complex -&gt; PyComplex_Type(PyTypeObject结构体实例)</code></li>
<li><code>元组 -&gt; PyTupleObject结构体实例,  tuple -&gt; PyTuple_Type(PyTypeObject结构体实例)</code></li>
<li><code>列表 -&gt; PyListObject结构体实例,  list -&gt; PyList_Type(PyTypeObject结构体实例)</code></li>
<li><code>字典 -&gt; PyDictObject结构体实例,  dict -&gt; PyDict_Type(PyTypeObject结构体实例)</code></li>
<li><code>集合 -&gt; PySetObject结构体实例,  set -&gt; PySet_Type(PyTypeObject结构体实例)</code></li>
<li><code>不可变集合 -&gt; PyFrozenSetObject结构体实例,  frozenset -&gt; PyFrozenSet_Type(PyTypeObject结构体实例)</code></li>
<li><code>元类：PyType_Type(PyTypeObject结构体实例)</code></li>
</ul>
<p><strong>所以Python中的对象在底层的名字都遵循一定的标准，包括解释器提供的Python&#x2F;C API也是如此。</strong></p>
<p><font color="green"><strong>下面以浮点数为例，考察一下类型对象和实例对象之间的关系。</strong></font></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; float</span><br><span class="line">&lt;class &#x27;float&#x27;&gt;</span><br><span class="line">&gt;&gt;&gt; pi = 3.14</span><br><span class="line">&gt;&gt;&gt; e = 2.71</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; type(pi) is type(e) is float</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/03/29/02-%E4%B8%80%E5%88%87%E5%AF%B9%E8%B1%A1%E7%9A%86PyObject/image-20230312165701421.png" alt="image-20230312165701421"></p>
<p><strong>两个变量均指向了浮点数(PyFloatObject结构体实例)，除了公共头部字段ob_refcnt和ob_type，专有字段ob_fval保存了对应的数值；浮点类型float则对应PyTypeObject结构体实例(PyFloat_Type)，保存了类型名、内存分配信息以及浮点数相关操作。而将这两者关联起来的就是ob_type这个类型指针，它位于PyObject中，是所有对象共有的，而Python便是根据这个ob_type来判断该对象的类型，进而获取该对象的元信息。</strong></p>
<blockquote>
<p><strong>我们说变量只是一个指针，那么int、float、dict这些是不是变量，显然是的，函数和类也是一个变量，所以它们在底层也是一个指针。只不过这些变量是内置的，直接指向了具体的PyTypeObject实例。只是为了方便，有时我们用int、float等等，来代指指向的对象。比如：float指向了底层的PyFloat_Type，所以它其实是PyFloat_Type的指针，但为了表述方便我们会直接用float来代指PyFloat_Type。</strong></p>
<p><strong>而且类型对象在解释器启动的时候就已经是创建好了的，不然的话我们怎么能够直接用呢？类型对象创建完毕之后，直接让float指向相应的类型对象。</strong></p>
</blockquote>
<p><strong>我们来看一下float对应的类型对象在底层是怎么定义的吧。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Object/floatobject.c</span></span><br><span class="line">PyTypeObject PyFloat_Type = &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, <span class="number">0</span>)</span><br><span class="line">    <span class="string">&quot;float&quot;</span>,</span><br><span class="line">    <span class="keyword">sizeof</span>(PyFloatObject),</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    (destructor)float_dealloc,                  <span class="comment">/* tp_dealloc */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_vectorcall_offset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_getattr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_setattr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_async */</span></span><br><span class="line">    (reprfunc)float_repr,                       <span class="comment">/* tp_repr */</span></span><br><span class="line">    &amp;float_as_number,                           <span class="comment">/* tp_as_number */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_sequence */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_mapping */</span></span><br><span class="line">    (hashfunc)float_hash,                       <span class="comment">/* tp_hash */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_call */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_str */</span></span><br><span class="line">    PyObject_GenericGetAttr,                    <span class="comment">/* tp_getattro */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_setattro */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_buffer */</span></span><br><span class="line">    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE |</span><br><span class="line">        _Py_TPFLAGS_MATCH_SELF,               <span class="comment">/* tp_flags */</span></span><br><span class="line">    float_new__doc__,                           <span class="comment">/* tp_doc */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_traverse */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_clear */</span></span><br><span class="line">    float_richcompare,                          <span class="comment">/* tp_richcompare */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_weaklistoffset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_iter */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_iternext */</span></span><br><span class="line">    float_methods,                              <span class="comment">/* tp_methods */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_members */</span></span><br><span class="line">    float_getset,                               <span class="comment">/* tp_getset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_base */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_dict */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_descr_get */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_descr_set */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_dictoffset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_init */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_alloc */</span></span><br><span class="line">    float_new,                                  <span class="comment">/* tp_new */</span></span><br><span class="line">    .tp_vectorcall = (vectorcallfunc)float_vectorcall,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>我们看到PyFloat_Type在源码中就直接被创建了，这是必须的，否则我们就没有办法直接访问float这个变量了，然后先看结构体中的第4行，我们看到tp_name被初始化成了”float”；第5行表示实例对象所占的字节数，我们看到就是一个PyFloatObject实例所占的内存大小，并且显然这个值是不会变的，说明无论创建多少个实例对象，它们的大小都是不变的，这也符合我们之前的测试结果，都是24字节。</strong></p>
<p><strong>再往下就是一些各种操作对应的函数指针，最后我们来看一下第3行，显然它接收的是一个PyVarObject，PyVarObject_HEAD_INIT这个宏无需赘言，但重点是里面的&amp;PyType_Type，说明了float被设置成了type类型。</strong></p>
<p><strong>而且所有的类型对象(还有元类)在底层都被定义成了静态的全局变量，因为它们的声明周期是伴随着整个解释器的，并且在任意地方都可以访问。</strong></p>
<p><font color="red"><strong>模改CPython如何修改Type的打印信息？</strong></font></p>
<p>例如，修改float的打印信息，进入到floatobject.h中，进入 PyAPI_DATA(PyTypeObject) PyFloat_Type; 中，进入(reprfunc)float_repr</p>
<p><img src="/2023/03/29/02-%E4%B8%80%E5%88%87%E5%AF%B9%E8%B1%A1%E7%9A%86PyObject/image-20230309105008756.png" alt="image-20230309105008756"></p>
<p>重新编译CPython，发现打印的结果为：</p>
<p><img src="/2023/03/29/02-%E4%B8%80%E5%88%87%E5%AF%B9%E8%B1%A1%E7%9A%86PyObject/image-20230309105144313.png" alt="image-20230309105144313"></p>
<h3 id="类型对象的类型–PyType-Type"><a href="#类型对象的类型–PyType-Type" class="headerlink" title="类型对象的类型–PyType_Type"></a>类型对象的类型–PyType_Type</h3><p>我们考察了float类型对象，知道它在C的层面是PyFloat_Type这个静态全局变量，它的类型是type，包括我们自定义的类的类型也是type。而type在Python中是一个至关重要的对象，它是所有类型对象的类型，我们称之为元类型<code>(meta class)</code>，或者元类。借助元类型，我们可以实现很多神奇的高级操作。那么type在C的层面又长啥样呢？</p>
<p>在介绍PyFloat_Type的时候我们知道了type在底层对应PyType_Type，而它在”Object&#x2F;typeobject.c”中定义，因为我们说所有的类型对象加上元类都是要预先定义好的，所以要源码中就必须要以静态全局变量的形式出现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Object/typeobject.c</span></span><br><span class="line">PyTypeObject PyType_Type = &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, <span class="number">0</span>)</span><br><span class="line">    <span class="string">&quot;type&quot;</span>,                                     <span class="comment">/* tp_name */</span></span><br><span class="line">    <span class="keyword">sizeof</span>(PyHeapTypeObject),                   <span class="comment">/* tp_basicsize */</span></span><br><span class="line">    <span class="keyword">sizeof</span>(PyMemberDef),                        <span class="comment">/* tp_itemsize */</span></span><br><span class="line">    (destructor)type_dealloc,                   <span class="comment">/* tp_dealloc */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    (reprfunc)type_repr,                        <span class="comment">/* tp_repr */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们所有的类型对象加上元类都是PyTypeObject这个结构体实例化得到的，所以它们内部的成员都是一样的，只不过传入的值不同，实例化之后的结果也不同，可以是PyLong_Type、可以是PyFloat_Type，也可以是这里的PyType_Type。</p>
<p><strong>PyType_Type的内部成员和PyFloat_Type是一样的，但是我们还是要重点看一下里面的宏PyVarObject_HEAD_INIT，我们看到它传递的是一个&amp;PyType_Type，说明它把自身的类型也设置成了PyType_Type，换句话说，PyType_Type里面的ob_type成员指向的还是PyType_Type。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; type.__class__</span><br><span class="line">&lt;class &#x27;type&#x27;&gt;</span><br><span class="line">&gt;&gt;&gt; type.__class__.__class__.__class__.__class__.__class__ is type</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; type(type(type(type(type(type))))) is type</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>显然不管我们套娃多少次，最终的结果都是True，显然这也是符合我们的预期的。</strong></p>
<h3 id="类型对象的基类–PyBaseObject-Type"><a href="#类型对象的基类–PyBaseObject-Type" class="headerlink" title="类型对象的基类–PyBaseObject_Type"></a>类型对象的基类–PyBaseObject_Type</h3><p>我们说Python中有两个类型对象比较特殊，一个是站在类型金字塔顶端的type，一个是站在继承金字塔顶端的object。说完了type，我们来说说object，我们说类型对象内部的tp_base表示继承的基类，对于PyType_Type来讲，它内部的tp_base肯定是PyBaseObject_Type。</p>
<p><strong>但令我们吃鲸的是，它的tp_base居然是个0，如果为0的话则表示没有这个属性。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0,                                          /* tp_base */</span><br></pre></td></tr></table></figure>

<p><strong>不是说type的基类是object吗？为啥tp_base是0，事实上如果你去看PyFloat_Type的话，它内部的tp_base也是0。为0的原因就在于我们目前看到的类型对象是一个半成品，因为Python的动态性，显然不可能在定义的时候就将所有成员属性都设置好、然后解释器一启动就会得到我们平时使用的类型对象。目前看到的类型对象是一个半成品，有一部分成员属性是在解释器启动之后再进行动态完善的。</strong></p>
<blockquote>
<p><strong>至于是怎么完善的，都有哪些成员需要解释器启动之后才能完善，我们后续系列会说。</strong></p>
</blockquote>
<p><font color="green">而PyBaseObject_Type位于Object&#x2F;object.c中，我们来一睹其芳容。</font></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Object/object.c</span></span><br><span class="line">PyTypeObject PyBaseObject_Type = &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, <span class="number">0</span>)</span><br><span class="line">    <span class="string">&quot;object&quot;</span>,                                   <span class="comment">/* tp_name */</span></span><br><span class="line">    <span class="keyword">sizeof</span>(PyObject),                           <span class="comment">/* tp_basicsize */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_itemsize */</span></span><br><span class="line">    object_dealloc,                             <span class="comment">/* tp_dealloc */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    object_repr,                                <span class="comment">/* tp_repr */</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>我们看到PyBaseObject_Type的类型也被设置成了PyType_Type，而PyType_Type类型在被完善之后，它的tp_base也会指向PyBaseObject_Type。所以之前我们说Python中的type和object是同时出现的，它们的定义是需要依赖彼此的。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; object.__class__</span><br><span class="line">&lt;class &#x27;type&#x27;&gt;</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>注意：解释器在完善PyBaseObject_Type的时候，是不会设置其tp_base的，因为继承链必须有一个终点，否对象沿着继承链进行属性查找的时候就会陷入死循环，而object已经是继承链的顶点了。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(object.__base__)</span><br><span class="line">None</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>object -&gt; PyBaseObject_Type</code></li>
<li><code>object() -&gt; PyBaseObject</code></li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><img src="/2023/03/29/02-%E4%B8%80%E5%88%87%E5%AF%B9%E8%B1%A1%E7%9A%86PyObject/image-20230312171839520.png" alt="image-20230312171839520"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Lin Li</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/03/29/02-%E4%B8%80%E5%88%87%E5%AF%B9%E8%B1%A1%E7%9A%86PyObject/">http://example.com/2023/03/29/02-%E4%B8%80%E5%88%87%E5%AF%B9%E8%B1%A1%E7%9A%86PyObject/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">LinLi's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/CPython/">CPython</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/03/29/03-Python%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E5%99%A8%E5%92%8C%E5%BA%95%E5%B1%82%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86/" title="03-Python引用计数器和底层对象管理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">03-Python引用计数器和底层对象管理</div></div></a></div><div class="next-post pull-right"><a href="/2023/03/29/01-%E7%BC%96%E8%AF%91Cpython/" title="01-编译Cpython"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">01-编译Cpython</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/03/29/01-%E7%BC%96%E8%AF%91Cpython/" title="01-编译Cpython"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">01-编译Cpython</div></div></a></div><div><a href="/2023/03/29/04-%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/" title="04-浮点数的底层实现"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">04-浮点数的底层实现</div></div></a></div><div><a href="/2023/03/29/06-Bytes%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BA%95%E5%B1%82%E6%93%8D%E4%BD%9C/" title="06-Bytes对象的底层操作"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">06-Bytes对象的底层操作</div></div></a></div><div><a href="/2023/03/29/03-Python%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E5%99%A8%E5%92%8C%E5%BA%95%E5%B1%82%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86/" title="03-Python引用计数器和底层对象管理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">03-Python引用计数器和底层对象管理</div></div></a></div><div><a href="/2023/03/29/05-Python%E6%95%B4%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/" title="05-Python整数的底层实现"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">05-Python整数的底层实现</div></div></a></div><div><a href="/2023/03/29/10-PyCodeObject%E5%AF%B9%E8%B1%A1%E5%92%8Cpyc%E6%96%87%E4%BB%B6/" title="10-PyCodeObject对象和pyc文件"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">10-PyCodeObject对象和pyc文件</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Lin Li</div><div class="author-info__description">今日事，今日毕</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">81</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#02-%E4%B8%80%E5%88%87%E7%9A%86%E5%AF%B9%E8%B1%A1PyObject"><span class="toc-number">1.</span> <span class="toc-text">02-一切皆对象PyObject</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E5%88%87%E7%9A%86%E5%AF%B9%E8%B1%A1PyObject"><span class="toc-number">1.1.</span> <span class="toc-text">一切皆对象PyObject</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%E7%9A%84%E5%9F%BA%E7%9F%B3-PyOBject"><span class="toc-number">1.2.</span> <span class="toc-text">实现对象机制的基石-PyOBject</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%8F%98%E9%95%BF%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9F%BA%E7%9F%B3%E2%80%93PyVarObject"><span class="toc-number">1.3.</span> <span class="toc-text">实现变长对象的基石–PyVarObject</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E7%B1%BB%E5%9E%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9F%BA%E7%9F%B3%E2%80%93PyTypeObject"><span class="toc-number">1.4.</span> <span class="toc-text">实现类型对象的基石–PyTypeObject</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%B1%BB%E5%9E%8B%E2%80%93PyType-Type"><span class="toc-number">1.5.</span> <span class="toc-text">类型对象的类型–PyType_Type</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9F%BA%E7%B1%BB%E2%80%93PyBaseObject-Type"><span class="toc-number">1.6.</span> <span class="toc-text">类型对象的基类–PyBaseObject_Type</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">1.7.</span> <span class="toc-text">小结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/08/Recommending-Analogical-APIs-via-Knowledge-Graph-Embedding/" title="Recommending Analogical APIs via Knowledge Graph Embedding">Recommending Analogical APIs via Knowledge Graph Embedding</a><time datetime="2024-05-08T08:26:56.000Z" title="发表于 2024-05-08 16:26:56">2024-05-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/01/No-More-Manual-Tests-Evaluating-and-Improving-ChatGPT-for-Unit-Test-Generation/" title="No More Manual Tests Evaluating and Improving ChatGPT for Unit Test Generation">No More Manual Tests Evaluating and Improving ChatGPT for Unit Test Generation</a><time datetime="2024-05-01T03:13:48.000Z" title="发表于 2024-05-01 11:13:48">2024-05-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/04/08/%E6%B7%B1%E5%BA%A6%E6%B4%9E%E5%AF%9F-%E5%85%B3%E4%BA%8EJavaScript%E5%BC%80%E6%BA%90%E7%94%9F%E6%80%81%E4%B8%AD%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E%E7%9A%84%E7%A0%94%E7%A9%B6/" title="深度洞察 |关于JavaScript开源生态中安全漏洞的研究">深度洞察 |关于JavaScript开源生态中安全漏洞的研究</a><time datetime="2024-04-08T10:31:29.000Z" title="发表于 2024-04-08 18:31:29">2024-04-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/01/Detecting-Logic-Bugs-in-Graph-Database-Management-Systems-via-Injective-and-Surjective-Graph-Query-Transformation/" title="Detecting Logic Bugs in Graph Database Management Systems via Injective and Surjective Graph Query Transformation">Detecting Logic Bugs in Graph Database Management Systems via Injective and Surjective Graph Query Transformation</a><time datetime="2024-03-01T10:34:41.000Z" title="发表于 2024-03-01 18:34:41">2024-03-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/01/Finding-Bugs-in-Gremlin-Based-Graph-Database-Systems-via-Randomized-Differential-Testing/" title="Finding Bugs in Gremlin-Based Graph Database Systems via Randomized Differential Testing">Finding Bugs in Gremlin-Based Graph Database Systems via Randomized Differential Testing</a><time datetime="2024-03-01T03:26:47.000Z" title="发表于 2024-03-01 11:26:47">2024-03-01</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Lin Li</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>