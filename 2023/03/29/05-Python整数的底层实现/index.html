<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>05-Python整数的底层实现 | LinLi's Blog</title><meta name="author" content="Lin Li"><meta name="copyright" content="Lin Li"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="05-Python整数的底层实现这次我们来分析一下Python中的整数是如何实现的，我们知道Python中的整数是不会溢出的，换句话说，它可以计算无穷大的数。只要你的内存足够，它就能计算，但是对于C来说显然是不行的，可Python底层又是C实现的，那么它是怎么做到整数不会溢出的呢？ 既然想知道答案，那么看一下Python中的整型在底层是怎么定义的就行了。 int实例对象的底层实现Python中的整">
<meta property="og:type" content="article">
<meta property="og:title" content="05-Python整数的底层实现">
<meta property="og:url" content="http://example.com/2023/03/29/05-Python%E6%95%B4%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/index.html">
<meta property="og:site_name" content="LinLi&#39;s Blog">
<meta property="og:description" content="05-Python整数的底层实现这次我们来分析一下Python中的整数是如何实现的，我们知道Python中的整数是不会溢出的，换句话说，它可以计算无穷大的数。只要你的内存足够，它就能计算，但是对于C来说显然是不行的，可Python底层又是C实现的，那么它是怎么做到整数不会溢出的呢？ 既然想知道答案，那么看一下Python中的整型在底层是怎么定义的就行了。 int实例对象的底层实现Python中的整">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2023-03-29T02:30:14.000Z">
<meta property="article:modified_time" content="2023-04-12T02:37:09.352Z">
<meta property="article:author" content="Lin Li">
<meta property="article:tag" content="CPython">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/03/29/05-Python%E6%95%B4%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '05-Python整数的底层实现',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-04-12 10:37:09'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">122</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="LinLi's Blog"><span class="site-name">LinLi's Blog</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">05-Python整数的底层实现</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-29T02:30:14.000Z" title="发表于 2023-03-29 10:30:14">2023-03-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-04-12T02:37:09.352Z" title="更新于 2023-04-12 10:37:09">2023-04-12</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="05-Python整数的底层实现"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="05-Python整数的底层实现"><a href="#05-Python整数的底层实现" class="headerlink" title="05-Python整数的底层实现"></a>05-Python整数的底层实现</h2><p>这次我们来分析一下Python中的整数是如何实现的，我们知道Python中的整数是不会溢出的，换句话说，它可以计算无穷大的数。只要你的内存足够，它就能计算，但是对于C来说显然是不行的，可Python底层又是C实现的，那么它是怎么做到整数不会溢出的呢？</p>
<p>既然想知道答案，那么看一下Python中的整型在底层是怎么定义的就行了。</p>
<h3 id="int实例对象的底层实现"><a href="#int实例对象的底层实现" class="headerlink" title="int实例对象的底层实现"></a>int实例对象的底层实现</h3><p><strong>Python中的整数底层对应的结构体是PyLongObject，它位于longobject.h中。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//longobject.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">longobject</span> <span class="title">PyLongObject</span>;</span> <span class="comment">/* Revealed in longintrepr.h */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//longintrepr.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">longobject</span> &#123;</span></span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    digit ob_digit[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//合起来可以看成</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    digit ob_digit[<span class="number">1</span>];</span><br><span class="line">&#125; PyLongObject;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果把这个PyLongObject更细致的展开一下就是</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Py_ssize_t ob_refcnt; <span class="comment">//引用计数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">ob_type</span>;</span> <span class="comment">//类型</span></span><br><span class="line">    Py_ssize_t ob_size; <span class="comment">//维护的元素个数</span></span><br><span class="line">    digit ob_digit[<span class="number">1</span>]; <span class="comment">//digit类型的数组,长度为1</span></span><br><span class="line">&#125; PyLongObject;</span><br></pre></td></tr></table></figure>

<p><strong>别的先不说，就冲里面的ob_size我们就可以思考一番。首先Python中的整数有大小、但应该没有长度的概念吧，那为什么会有一个ob_size呢？从结构体成员来看，这个ob_size指的应该就是ob_digit数组的长度，而这个ob_digit数组显然只能是用来维护具体的值了。而数组的长度不同，那么对应的整数占用的内存也不同。所以答案出来了，整数虽然没有我们生活中的那种长度的概念，但它是个变长对象，因为不同的整数占用的内存可能是不一样的。</strong></p>
<p><strong>因此这个ob_size它指的是底层数组的长度，因为Python中整数对应的值在底层是使用数组来存储的。尽管它没有字符串、列表那种长度的概念，或者说无法对整型使用len方法，但它是个变长对象。</strong></p>
<p>​        <strong>那么下面的重点就在这个ob_digit数组了，我们要从它的身上挖掘信息，看看Python中整数对应的值(比如123)，是怎么放在这个数组里面的。不过首先我们要看看这个digit是个什么类型，它同样定义在longintrepr.h中</strong>    </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//PYLONG_BITS_IN_DIGIT是一个宏，如果你的机器是64位的，那么它会被定义为30，32位机器则会被定义为15</span></span><br><span class="line"><span class="comment">//至于这个宏是做什么的我们先不管</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> PYLONG_BITS_IN_DIGIT == 30</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> digit;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> PYLONG_BITS_IN_DIGIT == 15</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> digit;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><strong>而我们的机器现在基本上都是64位的，所以PYLONG_BITS_IN_DIGIT会等于30，因为digit等价于uint32_t<code>(unsigned int)</code>，所以它是一个无符号32位整型。</strong></p>
<p><strong>所以ob_digit这个数组是一个无符号32位整型数组，长度为1。当然这个数组具体多长则取决于你要存储的Python整数有多大，因为C中数组的长度不属于类型信息，你可以看成是长度n，而这个n是多少要取决于你的整数大小。显然整数越大，这个数组就越长，那么占用空间就越大。</strong></p>
<p>​        <strong>搞清楚了PyLongObject里面的所有成员，那么下面我们就来分析ob_digit是怎么存储Python中的整数，以及Python中的整数为什么不会溢出。</strong>    </p>
<p>​        <strong>不过说实话，关于Python的整数不会溢出这个问题，其实相信很多人已经有答案了，因为底层是使用数组存储的嘛，而数组的长度又没有限制，所以当然不会溢出啦。</strong>    </p>
<p>​        <strong>另外，还存在一个问题，那就是digit是一个无符号32位整型，那负数怎么存储？别着急，我们会举栗说明，将上面的疑问一一解答。</strong>    </p>
<p><strong>首先如果你是Python的设计者，要保证整数不会溢出，你会怎么办？我们把问题简化一下，假设有一个8位的无符号整数类型，我们知道它能表示的最大数字是255，但这时候如果我想表示256，要怎么办？</strong></p>
<p><strong>可能有人会想，那用两个数来存储不就好了。一个存储255，一个存储1，将这两个数放在数组里面。这个答案的话，虽然有些接近，但其实还有很大偏差：那就是我们并不能简单地按照大小拆分的，256拆分为255和1，要是265就拆分成255和10，而是要通过二进制的方式，我们来简单看一下。</strong></p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">我们知道<span class="number">8</span>位整数最大就是 <span class="number">2</span> ^ <span class="number">8</span> <span class="selector-tag">-</span> <span class="number">1</span>,也就是它的八位全部都是<span class="number">1</span>,结果是<span class="number">255</span></span><br><span class="line">所以<span class="number">255</span>对应的数组就是: <span class="selector-attr">[255]</span>, 因为此时一个<span class="number">8</span>位整数就能存下</span><br><span class="line"></span><br><span class="line">但如果是<span class="number">256</span>,那么<span class="number">8</span>位显然存不下了,此时就还需要一个位</span><br><span class="line">所以这个时候会使用两个<span class="number">8</span>位整数, 但并不是简单的相加, 而是使用一个新的<span class="number">8</span>位整数来模拟更高的位</span><br></pre></td></tr></table></figure>

<p>​        <strong>而Python底层也是类似这种做法，但是考虑的会更加全面。下面就以Python中的整数为例，看看底层数组的存储方式。</strong>    </p>
<p><strong>整数0：</strong></p>
<p><strong>注意：当要表示的整数为0时，ob_digit这个数组为空，不存储任何值，ob_size为0，表示这个整数的值为0，这是一种特殊情况。</strong></p>
<p><img src="/2023/03/29/05-Python%E6%95%B4%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200805002206919-1398161118.png" alt="img"></p>
<p><strong>整数1：</strong></p>
<p><img src="/2023/03/29/05-Python%E6%95%B4%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200805002212476-1473281999.png" alt="img"></p>
<p><strong>当然存储的值为1时，ob_size的值就是1，此时ob_digit数组就是[1]。</strong></p>
<p><strong>整数-1：</strong></p>
<p><img src="/2023/03/29/05-Python%E6%95%B4%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200805002220242-1580767637.png" alt="img"></p>
<p><strong>我们看到ob_digit数组没有变化，但是ob_size变成了-1，没错，整数的正负号是通过这里的ob_size决定的。ob_digit存储的其实是绝对值，无论n取多少，<code>-n</code>和<code>n</code>对应的ob_digit是完全一致的，但是ob_size则互为相反数。所以ob_size除了表示数组的长度之外，还可以表示对应整数的正负。</strong></p>
<p><strong>所以我们之前说整数越大，底层的数组就越长。更准确的说是绝对值越大，底层数组就越长。所以Python在比较两个整型的大小时，会先比较ob_size，如果ob_size不一样则可以直接比较出大小来。显然ob_size越大，对应的整数越大，不管ob_size是正是负，都符合这个结论，可以想一下。</strong></p>
<p><strong>整数2 ^ 30 -1：</strong></p>
<p><img src="/2023/03/29/05-Python%E6%95%B4%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200805002228080-1963789840.png" alt="img"></p>
<p><strong>如果想表示2 ^30 - 1<code>(^这里代指幂运算,当然对于Python程序猿来说两个星号也是幂运算,表达的意义是一样的)</code>，那么也可以使用一个digit表示。虽然如此，但为什么突然举2 ^ 30 - 1这个数字呢？答案是，虽然digit是4字节、32位，但是Python只用30个位。</strong></p>
<blockquote>
<p><strong>之所以这么做是和加法进位有关系，如果32个位全部用来存储其绝对值，那么相加产生进位的时候，可能会溢出，比如有一个将32个位全部占满的整数<code>(2 ^ 32 - 1)</code>，即便它只加上1，也会溢出。这个时候为了解决这个问题，就需要先强制转换为64位再进行运算。</strong></p>
<p><strong>但如果只用30个位的话，那么加法是不会溢出的，或者说相加之后依旧可以用32位整数保存。因为30个位最大就是2 ^ 30 - 1，即便两个这样的值相加，结果也是(2 ^ 30 - 1) * 2，即：2 ^ 31 - 2。而32个位的话最大是2 ^ 32 - 1，所以肯定不会溢出的；如果一开始30个位就存不下，那么数组中会有两个digit。</strong></p>
</blockquote>
<p><strong>所以虽然将32位全部用完，可以只用一个digit表示更多、更大的整数，但是可能面临相加之后一个digit存不下的情况，于是只用30个位，如果数值大到30个位存不下的话，那么就会多使用一个digit。可能有人发现了，如果是用31个位的话，那么相加产生的最大值就是2 ^ 32 - 2，结果依旧可以使用一个32位整型存储啊，那Python为啥要牺牲两个位呢？答案是为了乘法运算。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 还记得这个宏吗？PYLONG_BITS_IN_DIGIT指的就是Python使用digit的位数</span></span><br><span class="line"><span class="comment">// 我们看到在32位机器上，digit相当于2字节、16位的整型，而它用了15位，只牺牲了一个位</span></span><br><span class="line"><span class="comment">// 64 位机器上则牺牲两个位</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> PYLONG_BITS_IN_DIGIT == 30</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> digit;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> PYLONG_BITS_IN_DIGIT == 15</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> digit;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><strong>整数2 ^ 30：</strong></p>
<p><strong>问题来了，我们说digit只用30位，所以2 ^ 30 - 1是一个digit能存储的最大值，那么现在是2 ^ 30，所以数组中就要有两个digit了。</strong></p>
<p><img src="/2023/03/29/05-Python%E6%95%B4%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200805002236296-672861305.png" alt="img"></p>
<p><em><em>我们看到此时就用两个digit来存储了，此时的数组里面的元素就是0和1，而且充当高位的放在后面，因为我们说了使用新的digit来模拟更高的位。由于一个digit只用30位，那么数组中第一个digit的最低位就是1，第二个digit的最低位就是31，第三个digit的最低位就是61，以此类推，所以如果ob_digit为[a, b, c]，那么对应的整数就为: a * 2 *</em> 0 + b * 2 *</em> 30 + c  * 2 ** 60，如果ob_digit不止3个，那么就按照30个位往上加，比如ob_digit还有第四个元素d，那么就再加上d * 2  ** 90即可。**</p>
<p><strong>再比如我们反推一下，如果a &#x3D; 88888888888，那么底层数组ob_digit中的值是多少？</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = <span class="number">88888888888</span></span><br><span class="line"><span class="comment"># 我们说1个digit用30个位, 那么n个digit所能表示的最大整数就是2 ** (30 * n) - 1, 至于原因的话其实很好理解，但我们还是可以严格推导一下</span></span><br><span class="line"><span class="comment"># 我们以n = 2为例, 显然两个digit最高能表示 (2 ** 30 - 1) + (2 ** 30 - 1) * 2 ** 30,</span></span><br><span class="line"><span class="comment"># 它等于 (2 ** 30 - 1) + (2 ** 60 - 2 ** 30) = 2 ** 60 - 1, 因此两个digit最大可以表示 2 ** 60 - 1</span></span><br><span class="line"><span class="comment"># 同理你可以n取3, 看看(2 ** 30 - 1) + (2 ** 30 - 1) * 2 ** 30 + (2 ** 30 - 1) * 2 ** 60是不是等于2 ** 90 - 1</span></span><br><span class="line"><span class="comment"># 或者试试更大的数, 结论都是成立的</span></span><br><span class="line"><span class="built_in">print</span>(np.log2(a))  <span class="comment"># 36.37128404230425</span></span><br><span class="line"><span class="comment"># 36超过了30个位、但小于90个位, 因此需要两个digit</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们说 &quot;整数 = ob_digit[0] + ob_digit[1] * 2 ** 30 + ob_digit[2] * 2 ** 60 + ...&quot;</span></span><br><span class="line"><span class="comment"># 但是对于ob_digit长度为2的情况下, 这里的a = ob_digit[0] + ob_digit[1] * 2 ** 30</span></span><br><span class="line"><span class="built_in">print</span>(a // <span class="number">2</span> ** <span class="number">30</span>)  <span class="comment"># 82</span></span><br><span class="line"><span class="built_in">print</span>(a - <span class="number">82</span> * <span class="number">2</span> ** <span class="number">30</span>)  <span class="comment"># 842059320</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 说明此时底层对应的ob_digit数组就是[842059320, 82]</span></span><br></pre></td></tr></table></figure>

<p><img src="/2023/03/29/05-Python%E6%95%B4%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200805002245710-535862489.png" alt="img"></p>
<p><strong>我们修改解释器源代码重新编译，通过在创建整数的时候打印ob_digit里面的元素的值，也印证了这个结论。</strong></p>
<p>​        <strong>这个时候，我们可以分析整数所占的字节了。相信所有人都知道可以使用sys.getsizeof计算大小，但是这大小到底是怎么来的，估计会一头雾水。因为Python中对象的大小，是根据底层的结构体计算出来的。</strong>    </p>
<p>​        <strong>我们说ob_refcnt、ob_type、ob_size这三个是整数所必备的，它们都是8字节，加起来24字节。所以任何一个整数所占内存都至少24字节，至于具体占多少，则取决于ob_digit里面的元素都多少个。</strong>    </p>
<p>​        <strong>因此Python中整数所占内存 &#x3D; 24 + 4 * ob_digit数组长度</strong>    </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果是0的话, ob_digit数组为空, 所以此时就是24字节</span></span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(<span class="number">0</span>))  <span class="comment"># 24</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果是1的话, ob_digit数组有一个元素, 所以此时是24 + 4 = 28字节</span></span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(<span class="number">1</span>))  <span class="comment"># 28</span></span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(<span class="number">2</span> ** <span class="number">30</span> - <span class="number">1</span>))  <span class="comment"># 28</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 一个digit只用30位, 所以最大能表示2 ** 30 - 1</span></span><br><span class="line"><span class="comment"># 如果是2 ** 30, 那么就需要两个元素, 所以是24 + 4 * 2 = 32字节</span></span><br><span class="line"><span class="comment"># 如果是两个digit, 那么能表示的最大整数就是2 ** 60 - 1</span></span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(<span class="number">2</span> ** <span class="number">30</span>))  <span class="comment"># 32</span></span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(<span class="number">2</span> ** <span class="number">60</span> - <span class="number">1</span>))  <span class="comment"># 32</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">相信下面的不需要解释了</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(<span class="number">1</span> &lt;&lt; <span class="number">60</span>))  <span class="comment"># 36</span></span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof((<span class="number">1</span> &lt;&lt; <span class="number">90</span>) - <span class="number">1</span>))  <span class="comment"># 36</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(<span class="number">1</span> &lt;&lt; <span class="number">90</span>))  <span class="comment"># 40</span></span><br></pre></td></tr></table></figure>

<h3 id="小整数对象池"><a href="#小整数对象池" class="headerlink" title="小整数对象池"></a>小整数对象池</h3><p><strong>由于分析过了浮点数以及浮点类型对象，因此int类型对象的实现以及int实例对象的创建啥的就不说了，可以自己去源码中查看，我们后面会着重介绍它的一些操作。还是那句话，Python中的API设计的很优美，都非常的相似，比如创建浮点数可以使用PyFloat_FromDouble、PyFloat_FromString等等，那么创建整数也可以使用PyLong_FromLong、PyLong_FromDouble、PyLong_FromString等等，直接去Objects中对应的源文件中查看即可。</strong></p>
<p><strong>这里说一下Python中的小整数对象池，我们知道Python中的整数属于不可变对象，运算之后会创建新的对象。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">666</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(a)</span><br><span class="line"><span class="number">2431274354736</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a += <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(a)</span><br><span class="line"><span class="number">2431274355024</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>所以这种做法就势必会有性能缺陷，因为程序运行时会有大量对象的创建和销毁。根据浮点数的经验，我们猜测Python应该也对整数使用了缓存池吧。答案是差不多，只不过不是缓存池，而是</strong><font color="red"><strong>小整数对象池</strong></font></p>
<p><strong>Python将那些使用频率高的整数预先创建好，而且都是单例模式，这些预先创建好的整数会放在一个静态数组里面，我们称为小整数对象池。如果需要使用的话会直接拿来用，而不用重新创建。注意：这些整数在Python解释器启动的时候，就已经创建了。</strong></p>
<p><strong>小整数对象池的实现位于longobject.c中。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NSMALLPOSINTS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NSMALLPOSINTS           257</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NSMALLNEGINTS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NSMALLNEGINTS           5</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyLongObject small_ints[NSMALLNEGINTS + NSMALLPOSINTS];</span><br></pre></td></tr></table></figure>

<ul>
<li><code>NSMALLPOSINTS宏规定了对象池中正数的个数 (从 0 开始，包括 0 )，默认 257 个；</code></li>
<li><code>NSMALLNEGINTS宏规定了对象池中负数的个数，默认5个；</code></li>
<li><code>small_ints是一个整数对象数组，保存预先创建好的小整数对象；</code></li>
</ul>
<p><strong>以默认配置为例，Python解释器在启动的时候就会预先创建一个可以容纳262个整数的数组，并会依次初始化 -5 到 256<code>(包括两端)</code>之间的262个PyLongObject。所以小整数对象池的结构如下：</strong></p>
<p><img src="/2023/03/29/05-Python%E6%95%B4%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200805002308727-1460169599.png" alt="img"></p>
<p><strong>但是为什么要实现缓存从-5到256之间的整数呢？因为Python认为这个范围内的整数使用频率最高，而缓存这些整数的内存相对可控。因此这只是某种权衡，很多程序的开发场景都没有固定的正确答案，需要根据实际情况来权衡利弊。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">256</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">256</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(a), <span class="built_in">id</span>(b)</span><br><span class="line">(<span class="number">140714000246400</span>, <span class="number">140714000246400</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">257</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">257</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(a), <span class="built_in">id</span>(b)</span><br><span class="line">(<span class="number">2431274355184</span>, <span class="number">2431274354896</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>256位于小整数对象池内，所以全局唯一，需要使用的话直接去取即可，因此它们的地址是一样的。但是257不再小整数对象池内，所以它们的地址不一样。</strong></p>
<p><strong>我们上面是在交互式下演示的，但如果有小伙伴不是通过交互式的话，那么会得到出乎意料的结果。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">257</span></span><br><span class="line">b = <span class="number">257</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a) == <span class="built_in">id</span>(b))  <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<p><strong>可能有人会好奇，为什么地址又是一样的了，257明明不在小整数对象池中啊。虽然涉及到了后面的内容，但是提前解释一下也是可以的。主要区别就在于一个是在交互式下执行的，另一个是通过 python3 xxx.py的方式执行的。</strong></p>
<blockquote>
<p><strong>首先Python的编译单元是函数，每个函数都有自己的作用域，在这个作用域中出现的所有常量都是唯一的，并且都位于常量池中，由co_consts指向。虽然我们上面的不是函数，而是在全局作用域中，但是全局你也可以看成是一个函数，它也是一个独立的编译单元。同一个编译单元中，常量只会出现一次。</strong></p>
<p><strong>当a &#x3D; 257的时候，会创建257这个整数、并放入常量池中；所以b &#x3D; 257的时候就不会再创建了，因为常量池中已经有了，所以会直接从常量池中获取，因此它们的地址是一样的，因为是同一个PyLongObject。</strong></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python3.6下执行, 该系列的所有代码都是基于Python3.8, 但是这里先使用Python3.6, 至于原因, 后面会说</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>():</span><br><span class="line">    a = <span class="number">256</span></span><br><span class="line">    b = <span class="number">257</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">id</span>(a), <span class="built_in">id</span>(b)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f2</span>():</span><br><span class="line">    a = <span class="number">256</span></span><br><span class="line">    b = <span class="number">257</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">id</span>(a), <span class="built_in">id</span>(b)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(f1())  <span class="comment"># (140042202371968, 140042204149712)</span></span><br><span class="line"><span class="built_in">print</span>(f2())  <span class="comment"># (140042202371968, 140042204255024)</span></span><br></pre></td></tr></table></figure>

<p><strong>此时f1和f2显然是两个独立的编译单元，256属于小整数对象池中的整数、全局唯一，因此即便不在同一个编译单元的常量池中，它的地址也是唯一的，因为它是预先定义好的，所以直接拿来用。但是257显然不是小整数对象池中的整数，而且不在同一个编译单元的常量池中，所以地址是不一样的。</strong></p>
<p><strong>而对于交互式环境来说，因为我们输入一行代码就会立即执行一行，所以任何一行可独立执行的代码都是一个独立的编译单元。注意：是可独立执行的代码，比如变量赋值、函数、方法调用等等；但如果是if、for、while、def等等需要多行表示的话，比如：<code>if 2 &gt; 1:</code>，显然这就不是一行可独立执行的代码，它还依赖你输入的下面的内容。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> <span class="number">2</span> &gt; <span class="number">1</span>:  <span class="comment"># 此时按下回车，我们看到不再是&gt;&gt;&gt;, 而是..., 代表还没有结束, 还需要你下面的内容</span></span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&quot;2 &gt; 1&quot;</span>)</span><br><span class="line"><span class="meta">... </span> <span class="comment"># 此时这个if语句整体才是一个独立的编译单元</span></span><br><span class="line"><span class="number">2</span> &gt; <span class="number">1</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>但是像a &#x3D; 1、foo()、lst.appned(123)这些显然它们是一行可独立执行的代码，因此在交互式中它们是独立的编译单元。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">257</span>  <span class="comment"># 此时这行代码已经执行了，它是一个独立的编译单元</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">257</span>  <span class="comment"># 这行代码也是独立的编译单元，所以它里面的常量池为空，因此要重新创建</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(a), <span class="built_in">id</span>(b)  <span class="comment"># 由于它们是不同常量池内的整数，所以id是不一样的。</span></span><br><span class="line">(<span class="number">2431274355184</span>, <span class="number">2431274354896</span>)</span><br></pre></td></tr></table></figure>

<p><strong>但是问题来了，看看下面的代码，a和b的地址为啥又一样了呢？666和777明显也不在常量池中啊。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">666</span>;b=<span class="number">666</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(a), <span class="built_in">id</span>(b)</span><br><span class="line">(<span class="number">2431274354896</span>, <span class="number">2431274354896</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b = <span class="number">777</span>, <span class="number">777</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(a), <span class="built_in">id</span>(b)</span><br><span class="line">(<span class="number">2431274354800</span>, <span class="number">2431274354800</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>显然此时应该已经猜到原因了，因为上面两种方式无论哪一种，都是在同一行，因此整体会作为一个编译单元，所以地址是一样的。</strong></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>():</span><br><span class="line">    a = <span class="number">256</span></span><br><span class="line">    b = <span class="number">2</span> ** <span class="number">30</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">id</span>(a), <span class="built_in">id</span>(b)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f2</span>():</span><br><span class="line">    a = <span class="number">256</span></span><br><span class="line">    b = <span class="number">2</span> ** <span class="number">30</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">id</span>(a), <span class="built_in">id</span>(b)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(f1())  <span class="comment"># (140714000246400, 2355781138896)</span></span><br><span class="line"><span class="built_in">print</span>(f2())  <span class="comment"># (140714000246400, 2355781138896)</span></span><br></pre></td></tr></table></figure>

<p><strong>但是在Python3.8中，如果是通过 python xxx.py的方式执行的话，即便是大整数、并且不再同一个编译单元的常量池中，它们的地址也是一样的，说明Python在3.8版本的时候做了优化。</strong></p>
<blockquote>
<p><strong>另外，如果没有特殊说明，那么我们这个系列的所有代码都是在Python3.8下执行的。说实话，我就是因为发现在Python3.8中，打印的地址都是一样的，才在上面试了一下Python3.6。但是Python3.8中具体是怎么优化的，这里就暂时不讨论了<code>(明明是你没有仔细研究)</code>。</strong></p>
</blockquote>
<h3 id="整数运算"><a href="#整数运算" class="headerlink" title="整数运算"></a>整数运算</h3><p><strong>整数溢出是程序开发中一大难题，由此引发的 BUG  不计其数，而且相当隐蔽。之前使用golang刷LeetCode的时候，怎么也通不过，最后发现是因为LeetCode后台有一个测试用例比较特殊，导致整数太大，golang中的int64存不下。而Python 选择从语言层面彻底解决这个痛点，殚心竭虑地设计了整数对象。而我们也探索了整数对象，并初步掌握了整数对象的内部结构。</strong></p>
<p><strong>Python中的整数是串联了多个C中的digit<code>(uint32_t)</code>，通过一个C数组的形式来实现整数的表示。这么做的好处就是Python中的整数没有长度限制了，因此不会溢出<code>(而浮点数使用C的double，所以它会溢出)</code>。之所以不会溢出，是因为数组是没有长度限制的，所以只要你的内存足够，就可以算任意大的数。所以Python表示：存不下？会溢出？这都不是事儿，直接继续往数组里面塞digit就ok了。</strong></p>
<blockquote>
<p><strong>这里再重温一下PyLongObject的数据结构，我们说它是一个变长对象。ob_size指的是数组的长度，并且它除了表示长度还能体现出整数的正负，而ob_digit这个数组只用来存储其绝对值。</strong></p>
<p><strong>但是说实话，用整数数组实现大整数的思路其实平白无奇，但难点在于大整数 数学运算 的实现，它们才是重点，也是也比较考验编程功底的地方。</strong></p>
<p><strong>所以我们在分析浮点数的时候，一直说整数要比浮点数复杂，原因就在于此。浮点数相加的话直接两个double相加即可，但是整数相加可就没有那么简单了。</strong></p>
</blockquote>
<p><strong>整数支持的操作定义在什么地方相信不用我说了，直接去longobject.c中查看就可以了，根据浮点数的经验我们知道PyLong_Type中的tp_as_number成员也指向了PyNumberMethods结构体实例，里面的成员都是指向与整型运算相关的函数的指针。</strong></p>
<p><strong>注意：图中有一个箭头画错了，应该是 ob_type 指向 PyLong_Type，但图中不小心变成了 ob_size。</strong></p>
<p><img src="/2023/03/29/05-Python%E6%95%B4%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200805002525586-1003237779.png" alt="img"></p>
<h4 id="整数的大小比较"><a href="#整数的大小比较" class="headerlink" title="整数的大小比较"></a>整数的大小比较</h4><p><strong>先来看看Python中的整数在底层是如何比较的吧。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">long_compare</span><span class="params">(PyLongObject *a, PyLongObject *b)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//sign是一个8字节的long, 用来表示a和b之间的比较结果</span></span><br><span class="line">    <span class="comment">//如果a == b, 那么sign = 0; 如果a &gt; b, 那么sign &gt; 0; 如果a &lt; b, 那么sign &lt; 0</span></span><br><span class="line">    Py_ssize_t sign;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//Py_SIZE是一个宏:获取对象的ob_size,除此之外我们之前还见到了Py_REFCNT和Py_TYPE, 用来获取对象的引用计数和类型指针</span></span><br><span class="line">    <span class="comment">//如果两个整数的ob_size不一样, 我们说a和b一定不相等, 所以可以直接比较出大小</span></span><br><span class="line">    <span class="keyword">if</span> (Py_SIZE(a) != Py_SIZE(b)) &#123;</span><br><span class="line">        <span class="comment">//如果一正一负, 那么肯定正的大, 因为ob_size还体现整数的正负, 所以正的ob_size对应的整数也会更大</span></span><br><span class="line">        <span class="comment">//如果都为正, 那么ob_size越大, 对应数组元素就越多, 显然整数就越大</span></span><br><span class="line">        <span class="comment">//如果都为负, 那么ob_size越大, 其绝对值就越小, 因为越接近0,所以对应的整数的绝对值也越小</span></span><br><span class="line">          <span class="comment">//但因为是负数,所以乘上-1之后,所以整数值反而会越大。比如: 1 &lt; 100, 但是乘上-1之后, 小于号就要变成大于号</span></span><br><span class="line">        <span class="comment">//因此无论是哪种情况，如果两个整数的ob_size不一样，是可以直接比较出大小的。</span></span><br><span class="line">        sign = Py_SIZE(a) - Py_SIZE(b);</span><br><span class="line">        <span class="comment">//所以sign &gt; 0的话a &gt; b, sign &lt; 0的话a &lt; b, 因为ob_size不一样, 所以sign不可能等于0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果相等, 那么说明a和b的符号相同, 数组中使用的digit也是一样的</span></span><br><span class="line">        <span class="comment">//那么接下来就只能挨个比较数组中的digit了</span></span><br><span class="line">        <span class="comment">//这里是获取数组的长度, 赋值给变量i</span></span><br><span class="line">        Py_ssize_t i = Py_ABS(Py_SIZE(a));</span><br><span class="line">        <span class="comment">//我们之前说，一个digit存不下，那么会使用两个digit, 以此类推</span></span><br><span class="line">        <span class="comment">//并且代表整数高位的digit会放在后面, 而比较两个数的大小显然是从高位开始比</span></span><br><span class="line">        <span class="comment">//因此遍历数组是从后往前遍历的, 先比较a -&gt; ob_digit[n]和 b -&gt; ob_digit[n]</span></span><br><span class="line">        <span class="comment">//如果一样就比较a -&gt; ob_digit[n-1]和a -&gt; ob_digit[n-1],直到将数组的元素全部比完,显然只要有一个不一样,就可以直接决定绝对值的大小</span></span><br><span class="line">        <span class="keyword">while</span> (--i &gt;= <span class="number">0</span> &amp;&amp; a-&gt;ob_digit[i] == b-&gt;ob_digit[i])</span><br><span class="line">            <span class="comment">//进行while循环, i是数组的长度, 因此数组的最大索引是i - 1, 所以这里的--i会先将i自减1,再判断自减1之后的i是否&gt;=0</span></span><br><span class="line">            <span class="comment">//然后比较a-&gt;ob_digit[i]和b-&gt;ob_digit[i], 如果数组内元素全部一样, 那么循环结束之后i肯定是-1,只要有一个不一样, 那么i一定&gt;=0</span></span><br><span class="line">            ;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//所以如果i &lt; 0,说明两个整数的数组全部一样, 因此两个整数是一样的</span></span><br><span class="line">            <span class="comment">//所以sign = 0</span></span><br><span class="line">            sign = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//否则的话, 说明数组中索引为i的元素不一样, 那么直接相减就可以了</span></span><br><span class="line">            <span class="comment">//如果sign大于0, 显然a对应的绝对值比大, 否则a对应的绝对值比b小</span></span><br><span class="line">            sign = (sdigit)a-&gt;ob_digit[i] - (sdigit)b-&gt;ob_digit[i];</span><br><span class="line">            <span class="keyword">if</span> (Py_SIZE(a) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="comment">//但是我们说计算的是绝对值，如果ob_size小于0，绝对值越大其值反而越小，那么sign还要乘上-1</span></span><br><span class="line">                sign = -sign;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//因此最终: a &gt; b则sign &gt; 0, a &lt; b则sign &lt; 0, a == b则sign == 0</span></span><br><span class="line">    <span class="comment">//然后这里是一个嵌套的三元表达式, sign大于0则直接返回1表示a &gt; b, 小于0返回-1表示a &lt; b, 等于0则返回0表示a == b</span></span><br><span class="line">    <span class="keyword">return</span> sign &lt; <span class="number">0</span> ? <span class="number">-1</span> : sign &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所以我们看到Python中的整数就是按照上面这种方式比较的，总的来说就是先比较ob_size，ob_size不一样则可以直接比较。如果ob_size一样的话，那么会从后往前挨个比较数组中的元素，最终确定大小关系。</strong></p>
<h4 id="整数的相加"><a href="#整数的相加" class="headerlink" title="整数的相加"></a>整数的相加</h4><p><strong>再来看看Python中的整数在底层是如何相加的，加法的实现显然是long_add，我们看一下。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">long_add</span><span class="params">(PyLongObject *a, PyLongObject *b)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//a和b是两个PyLongObject *</span></span><br><span class="line">    <span class="comment">//z显然是指向a和b相加之后的PyLongObject</span></span><br><span class="line">    PyLongObject *z;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//CHECK_BINOP是一个宏, 接收两个指针, 检测它们是不是都指向PyLongObject</span></span><br><span class="line">    CHECK_BINOP(a, b);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//判断a和b的ob_size的绝对值是不是都小于等于1, 如果是的话, 那么说明数组中最多只有一个元素</span></span><br><span class="line">    <span class="comment">//数组没有元素,说明整数是0;有一个元素,那么直接取出来、再判断正负号即可,然后直接相加。</span></span><br><span class="line">    <span class="comment">//所以显然这里走的是快分支,因为绝对值超过2 ** 30 - 1的整数还是比较少的</span></span><br><span class="line">    <span class="keyword">if</span> (Py_ABS(Py_SIZE(a)) &lt;= <span class="number">1</span> &amp;&amp; Py_ABS(Py_SIZE(b)) &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//MEDIUM_VALUE是一个宏, 接收一个abs(ob_size) &lt;= 1的PyLongObject的指针</span></span><br><span class="line">        <span class="comment">//如果ob_size是0, 那么结果为0; 如果ob_size绝对值为1, 那么结果为 ob_digit[0] 或者 -ob_digit[0]</span></span><br><span class="line">        <span class="comment">//所以直接将MEDIUM_VALUE(a) + MEDIUM_VALUE(b)之后的结果转成PyLongObject,然后返回其指针即可</span></span><br><span class="line">        <span class="comment">//因此如果数组中元素不超过1个的话, 那么显然是可以直接相加的</span></span><br><span class="line">        <span class="keyword">return</span> PyLong_FromLong(MEDIUM_VALUE(a) + MEDIUM_VALUE(b));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//走到这里, 说明至少有一方的ob_size大于1</span></span><br><span class="line">    <span class="comment">//如果a &lt; 0</span></span><br><span class="line">    <span class="keyword">if</span> (Py_SIZE(a) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果a &lt; 0并且b &lt; 0</span></span><br><span class="line">        <span class="keyword">if</span> (Py_SIZE(b) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//说明两者符号相同, 那么通过x_add直接将两个整数相加即可</span></span><br><span class="line">            <span class="comment">//这个x_add专门用于整数的绝对值相加,并且会返回PyLongObject *,它的实现我们后面会说</span></span><br><span class="line">            <span class="comment">//所以z指向的PyLongObject的内部成员是已经设置好了的</span></span><br><span class="line">            <span class="comment">//只不过x_add加的是两者的绝对值, z指向的PyLongObject内部ob_type的符号我们还需要再度判断一下</span></span><br><span class="line">            z = x_add(a, b);</span><br><span class="line">            <span class="keyword">if</span> (z != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                assert(Py_REFCNT(z) == <span class="number">1</span>);</span><br><span class="line">                <span class="comment">//因为a和b指向的整数都是负数, 所以将相加之后还要将ob_size乘上-1</span></span><br><span class="line">                Py_SIZE(z) = -(Py_SIZE(z));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//走到这里说明a &lt; 0并且b &gt; 0, 那么直接让b - a即可, 此时得到的结果一定是正</span></span><br><span class="line">            <span class="comment">//因此不需要考虑ob_size的符号问题</span></span><br><span class="line">            z = x_sub(b, a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//走到这里说明a &gt; 0并且b &lt; 0, 所以让a - b即可</span></span><br><span class="line">        <span class="keyword">if</span> (Py_SIZE(b) &lt; <span class="number">0</span>)</span><br><span class="line">            z = x_sub(a, b);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//此时两个整数均为正, 直接相加</span></span><br><span class="line">            z = x_add(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回z的指针</span></span><br><span class="line">    <span class="keyword">return</span> (PyObject *)z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所以long_add这个函数并不长，但是调用了辅助函数x_add和x_sub，显然核心逻辑是在这两个函数里面。至于long_add函数，它的逻辑如下：</strong></p>
<ul>
<li><code>1. 定义一个变量z, 用于保存计算结果;</code></li>
<li><code>2. 判断两个整数底层对应的数组是不是都不超过1, 如果是的话那么通过宏MEDIUM_VALUE直接将其转成C中的一个digit, 然后直接相加、返回即可。显然这里走的是快分支,或者快速通道;</code></li>
<li><code>3. 但如果有一方ob_size绝对值不小于1, 那么判断两者的符号。如果都为负,那么通过x_add计算两者绝对值之和、再将ob_size乘上-1即可;</code></li>
<li><code>4. 如果a的ob_size小于0, b的ob_size大于0, 那么通过x_sub计算b和a绝对值之差即可;</code></li>
<li><code>5. 如果a的ob_size大于0, b的ob_size小于0, 那么通过x_sub计算a和b绝对值之差即可;</code></li>
<li><code>6. 如果a的ob_size大于0, b的ob_size大于0, 那么通过x_add计算让b和a绝对值之和即可;</code></li>
</ul>
<p><strong>所以Python中整数的设计非常的巧妙，ob_digit虽然是用来维护具体数值，但是它并没有考虑正负，而是通过ob_size来表示整数的正负号。这样运算的时候，计算的都是整数的绝对值，因此实现起来会方便很多。将绝对值计算出来之后，再通过ob_size来判断正负号。</strong></p>
<p><strong>因此long_add将整数加法转成了 “绝对值加法(x_add)”和”绝对值减法(x_sub)”：</strong></p>
<ul>
<li><code>x_add(a, b), 计算两者的绝对值之和, 即:|a| + |b|;</code></li>
<li><code>x_sub(a, b), 计算两者的绝对值之差, 即:|a| - |b|;</code></li>
</ul>
<p><img src="/2023/03/29/05-Python%E6%95%B4%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200805002538412-969820254.png" alt="img"></p>
<p><strong>由于绝对值加、减法不用考虑符号对计算结果的影响，实现更为简单，这是Python将整数运算转化成绝对值运算的缘由。虽然我们还没看到x_add和x_sub是如何对整数的绝对值进行相加和相减运算的，但也能从中体会到程序设计中逻辑的 划分 与 组合 的艺术，优秀的代码真的很美。</strong></p>
<blockquote>
<p><strong>那么下面我们的重心就在x_add和x_sub中了，看看它们是如何对大整数绝对值进行运算的。但是你可能会有疑问，大整数运算肯定很复杂，效率会差吧。显然这是必然的，整数数值越大，整数对象底层数组越长，运算开销也就越大。好在运算处理函数均以快速通道对小整数运算进行优化，将额外开销降到最低。</strong></p>
<p><strong>比如上面的long_add，如果a和b对应的整数的绝对值都小于等于2 ^  30 - 1，那么会直接转成C中的整型进行运算，性能损耗极小。并且走快速通道的整数的范围是：-(2 ^ 30 - 1) ~ 2 ^ 30 -  1，即：-1073741823 ~ 1073741823，显然它可以满足我们绝大部分的运算场景。</strong></p>
</blockquote>
<p>​        <strong>绝对值加法x_add：</strong>    </p>
<p><strong>在介绍绝对值加法之前，先来看看几个宏，先不管它们是干什么的，会在x_add中有体现：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//longintrepr.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PyLong_SHIFT    30</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PyLong_BASE     ((digit)1 &lt;&lt; PyLong_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PyLong_MASK     ((digit)(PyLong_BASE - 1))</span></span><br><span class="line"><span class="comment">//所以PyLong_MASK等于(1 &lt;&lt; 30) - 1, 就等于2 ** 30 - 1, 说明32个位, 前两个位为0, 后面三十个位则都是1</span></span><br></pre></td></tr></table></figure>

<p><strong>此外，再想象一下我们平时算加法的时候是怎么算的：</strong></p>
<p><img src="/2023/03/29/05-Python%E6%95%B4%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200805002550125-674752602.png" alt="img"></p>
<p><strong>而x_add在逻辑和上面是类似的，下面分析x_add的实现：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> PyLongObject *</span><br><span class="line"><span class="title function_">x_add</span><span class="params">(PyLongObject *a, PyLongObject *b)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//显然a和b指向了两个要想加的整数对象</span></span><br><span class="line">    <span class="comment">//这里获取a和b的ob_size的绝对值</span></span><br><span class="line">    Py_ssize_t size_a = Py_ABS(Py_SIZE(a)), size_b = Py_ABS(Py_SIZE(b));</span><br><span class="line">    <span class="comment">//根据a和b的相加结果所创建的新的PyLongObject的指针</span></span><br><span class="line">    PyLongObject *z;</span><br><span class="line">    <span class="comment">//循环变量</span></span><br><span class="line">    Py_ssize_t i;</span><br><span class="line">    <span class="comment">//重点也是最难理解的地方: carry用于每个部分的运算结果(可不是大神带你carry哦)</span></span><br><span class="line">    digit carry = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//如果size_a小于size_b</span></span><br><span class="line">    <span class="keyword">if</span> (size_a &lt; size_b) &#123;</span><br><span class="line">        <span class="comment">//那么将a和b进行交换, 以及size_a和size_b也进行交换, 为什么这么做呢?因为方便</span></span><br><span class="line">        <span class="comment">//我们小时候计算两个整数相加时候, 如果一个位数多,一个位数少, 也会习惯将位数多的放在左边</span></span><br><span class="line">        <span class="comment">//最终从右往左, 也就是从低位往高位逐个相加, 大于10则进1</span></span><br><span class="line">        &#123; PyLongObject *temp = a; a = b; b = temp; &#125;</span><br><span class="line">        &#123; Py_ssize_t size_temp = size_a;</span><br><span class="line">            size_a = size_b;</span><br><span class="line">            size_b = size_temp; &#125;</span><br><span class="line">        <span class="comment">//如果size_a和size_b相等, 或者size_a大于size_b, 那么该if就无需执行了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里是创建一个ob_size为size_a + 1的PyLongObject, 然后返回其指针</span></span><br><span class="line">    z = _PyLong_New(size_a+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//但为什么是size_a + 1呢?</span></span><br><span class="line">    <span class="comment">//因为此时size_a 一定不小于 size_b, 那么a和b相加之后的z的ob_size一定不小于size_a</span></span><br><span class="line">    <span class="comment">//但是也可以也可能比size_a多1, 比如: a = 2 ** 60 - 1, b = 1</span></span><br><span class="line">    <span class="comment">//所以相加之后结果为2 ** 60次方, 所以ob_size就变成了3, 因此在创建z的时候，ob_digit的容量会等于size_a + 1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//正常情况下, z是一个PyLongObject *, 但如果z == NULL, 表示分配失败(解释器也会异常退出)</span></span><br><span class="line">    <span class="comment">//但说实话, 除非你内存不够了, 否则这种情况不会发生</span></span><br><span class="line">    <span class="keyword">if</span> (z == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//重点来了, 如果a和b的ob_size不一样, 那么size_a会大于size_b</span></span><br><span class="line">    <span class="comment">//所以显然是先以size_b为准, 两者从低位向高位依次对应相加; 当b到头了, 再单独算a的剩余部分;</span></span><br><span class="line">    <span class="comment">//假设size_a == 4, size_b == 2, 对应到ob_digit的话</span></span><br><span class="line">    <span class="comment">//就是a -&gt; ob_digit[0] + b -&gt; ob_digit[0], 作为z -&gt; ob_digit[0], 当然还需要考虑进位, 下面说</span></span><br><span class="line">    <span class="comment">//然后a -&gt; ob_digit[1] + b -&gt; ob_digit[1], 作为z -&gt; ob_digit[1], 此时b到头了</span></span><br><span class="line">    <span class="comment">//继续a -&gt; ob_digit[2]作为z -&gt; ob_digit[2], a -&gt; ob_digit[3]作为z -&gt; ob_digit[3]</span></span><br><span class="line">    <span class="comment">//此时a和b相加就结束了, 如果不考虑相加进位的话, 那么整体流程就是这个样子。然后我们继续往下看</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//从索引为0开始遍历, 以i &lt; size_b为条件</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size_b; ++i) &#123;</span><br><span class="line">        <span class="comment">//将a-&gt;ob_digit[i] + b-&gt;ob_digit[i]作为carry, 显然carry如果没有超过2 ** 30 - 1的话</span></span><br><span class="line">        <span class="comment">//显然它就是z -&gt; ob_digit[i]</span></span><br><span class="line">        carry += a-&gt;ob_digit[i] + b-&gt;ob_digit[i];</span><br><span class="line">        <span class="comment">//但是carry是可能溢出的, 所以z -&gt; ob_digit[i] = carry &amp; PyLong_MASK</span></span><br><span class="line">        <span class="comment">//这个PyLong_MASK就是我们在介绍x_add之前先介绍的几个宏之一, 它表示的是2 ** 30 - 1</span></span><br><span class="line">        <span class="comment">//我们说它的前两个位为0, 后面三十个位全是1, 因此对于后面三十个位来说, 在和carry进行&quot;与运算&quot;之后,对应的位还和carry保持一致</span></span><br><span class="line">        <span class="comment">//所以在carry小于等于2 ** 30 - 1的时候carry &amp; PyLong_MASK就等于carry</span></span><br><span class="line">        <span class="comment">//但如果carry大于2 ** 30 - 1, 由于PyLong_MASK的前两位为0, 所以这一步可以确保carry不会超过2 ** 30 - 1</span></span><br><span class="line">        z-&gt;ob_digit[i] = carry &amp; PyLong_MASK;</span><br><span class="line">        <span class="comment">//但是carry的前两位显然不可以丢, 所以它们要作用在数组中下一个元素相加的结果上</span></span><br><span class="line">        <span class="comment">//比如a -&gt; ob_digit[0] + b -&gt; ob_digit[0]得到结果正好是2 ** 32 - 1, 那么carry的前两位也是1</span></span><br><span class="line">        <span class="comment">//而数组中下一元素相加之后, 其结果对应的位要比本次循环高出30</span></span><br><span class="line">        <span class="comment">//所以这里将carry右移30位, 然后作用到下一次循环中</span></span><br><span class="line">        carry &gt;&gt;= PyLong_SHIFT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; size_a; ++i) &#123;</span><br><span class="line">        <span class="comment">//如果当b到头了, 那么继续从当前的i开始, 直到i == size_a, 逻辑还是和上面一样的</span></span><br><span class="line">        <span class="comment">//只不过将a-&gt;ob_digit[i] + b-&gt;ob_digit[i]换成了a-&gt;ob_digit[i], 因为b到头了</span></span><br><span class="line">        carry += a-&gt;ob_digit[i];</span><br><span class="line">        <span class="comment">//这里也要&quot;与上&quot;PyLong_MASK, 因为也可能存在进位的情况, 拿生活中的99999 + 1为例</span></span><br><span class="line">        <span class="comment">//此时a = 99999, b = 1, 显然第一次循环b就到头了, 但后面单独循环a的时候, 依旧是要加进位的</span></span><br><span class="line">        <span class="comment">//所以这里也是同理</span></span><br><span class="line">        z-&gt;ob_digit[i] = carry &amp; PyLong_MASK;</span><br><span class="line">        <span class="comment">//carry右移30位</span></span><br><span class="line">        carry &gt;&gt;= PyLong_SHIFT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//两个循环结束之后, 其实还差一步, 还拿99999 + 1举例子, 按照顺序相加最后得到的是00000</span></span><br><span class="line">    <span class="comment">//因为最后还进了一个1, 所以这里的carry也是同理, 因此z的ob_size要比size_a多1, 目的就在于此</span></span><br><span class="line">    z-&gt;ob_digit[i] = carry;</span><br><span class="line">    <span class="comment">//但如果最后的carry没有进位的话, 显然其结果就是0, 所以最后没有直接返回z, 而是返回了long_normalize(z)</span></span><br><span class="line">    <span class="comment">//这个long_normalize函数作用就是从后往前依次检查ob_digit的元素, 如果为0, 那么就将其ob_size减去1, 直到出现一个不为0的元素</span></span><br><span class="line">    <span class="comment">//当然对于我们当前来说, 显然最多只会检查一次</span></span><br><span class="line">    <span class="keyword">return</span> long_normalize(z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Python中的整数在底层实现的很巧妙，不理解的话可以多看几遍，然后我们在Python的层面上再反推一下，进一步感受底层运算的过程。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 假设有a和b两个整数, 当然这里是使用列表直接模拟的底层数组ob_digit</span></span><br><span class="line">a = [<span class="number">1073741744</span>, <span class="number">999</span>, <span class="number">765</span>, <span class="number">123341</span>]</span><br><span class="line">b = [<span class="number">841</span>, <span class="number">1073741633</span>, <span class="number">2332</span>]</span><br><span class="line"><span class="comment"># 然后创建z, 表示a和b的相加结果</span></span><br><span class="line">z = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为了更直观, 我们一步步手动相加</span></span><br><span class="line"><span class="comment"># 首先是将a[0] + b[0], 得到carry</span></span><br><span class="line">carry = a[<span class="number">0</span>] + b[<span class="number">0</span>]</span><br><span class="line"><span class="comment"># 然后carry &amp; (2 ** 30 - 1), 我们看到结果是761</span></span><br><span class="line"><span class="built_in">print</span>(carry &amp; (<span class="number">2</span> ** <span class="number">30</span> - <span class="number">1</span>))  <span class="comment"># 761</span></span><br><span class="line"><span class="comment"># 因为如果carry小于等于 2 ** 30 - 1, 那么结果就是carry, 而这里是761, 显然carry肯定大于 2 ** 30 - 1</span></span><br><span class="line"><span class="built_in">print</span>(carry &gt; <span class="number">2</span> ** <span class="number">30</span> - <span class="number">1</span>)  <span class="comment"># True</span></span><br><span class="line"><span class="comment"># 因为carry &amp; (2 ** 30 - 1) == 761, 所以z的第一个元素就是761</span></span><br><span class="line">z.append(<span class="number">761</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后计算a[1] + b[1]得到新的carry, 但是之前的carry大于 2 ** 30 - 1</span></span><br><span class="line"><span class="comment"># 所以还要再加上之前的右移30位的carry</span></span><br><span class="line">carry = (carry &gt;&gt; <span class="number">30</span>) + a[<span class="number">1</span>] + b[<span class="number">1</span>]</span><br><span class="line"><span class="comment"># 然后carry &amp; (2 ** 30 - 1)得到809</span></span><br><span class="line"><span class="built_in">print</span>(carry &amp; (<span class="number">2</span> ** <span class="number">30</span> - <span class="number">1</span>))  <span class="comment"># 809</span></span><br><span class="line"><span class="comment"># 说明carry依旧大于 2 ** 30 - 1</span></span><br><span class="line"><span class="built_in">print</span>(carry &gt; <span class="number">2</span> ** <span class="number">30</span> - <span class="number">1</span>)  <span class="comment"># True</span></span><br><span class="line"><span class="comment"># 然后z的第二个元素就是809</span></span><br><span class="line">z.append(<span class="number">809</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算a[2] + b[2]的时候也是同理</span></span><br><span class="line">carry = (carry &gt;&gt; <span class="number">30</span>) + a[<span class="number">2</span>] + b[<span class="number">2</span>]</span><br><span class="line"><span class="comment"># 但是显然此时的carry已经不大于 2 ** 30 - 1了</span></span><br><span class="line"><span class="built_in">print</span>(carry &gt; <span class="number">2</span> ** <span class="number">30</span> - <span class="number">1</span>)  <span class="comment"># False</span></span><br><span class="line"><span class="comment"># 所以carry和carry &amp; (2 ** 30 - 1)的结果都是carry本身</span></span><br><span class="line"><span class="built_in">print</span>(carry, carry &amp; (<span class="number">2</span> ** <span class="number">30</span> - <span class="number">1</span>))  <span class="comment"># 3098 3098</span></span><br><span class="line"><span class="comment"># 说明z的第三个元素是3098</span></span><br><span class="line">z.append(<span class="number">3098</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时b到头了, 所以直接将a[3]作为carry, 当然我们不知道carry是否大于2 ** 30 - 1</span></span><br><span class="line"><span class="comment"># 所以还是右移30位即可, 不过carry不大于2 ** 30 - 1的话, 那么 carry &gt;&gt; 30 就是0罢了</span></span><br><span class="line">carry = (carry &gt;&gt; <span class="number">30</span>) + a[<span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(carry)  <span class="comment"># 123341</span></span><br><span class="line"><span class="comment"># 说明z的最后一个元素是123341, 当然理论上我们还要在对carry和 2 ** 30 - 1进行一次判断</span></span><br><span class="line"><span class="comment"># 当然由于我们知道carry肯定不会超过2 ** 30 - 1, 所以就不判断了</span></span><br><span class="line">z.append(<span class="number">123341</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时z为[761, 809, 3098, 123341]</span></span><br><span class="line"><span class="built_in">print</span>(z)  <span class="comment"># [761, 809, 3098, 123341]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 所以ob_digit为[1073741744, 999, 765, 123341]和[841, 1073741633, 2332]的两个PyLongObject相加</span></span><br><span class="line"><span class="comment"># 得到的新的PyLongObject的ob_digit为[761, 809, 3098, 123341]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们根据ob_digit按照规则转成整数, 那么a + b的结果要和z是相等的</span></span><br><span class="line">a = <span class="number">1073741744</span> + <span class="number">999</span> * <span class="number">2</span> ** <span class="number">30</span> + <span class="number">765</span> * <span class="number">2</span> ** <span class="number">60</span> + <span class="number">123341</span> * <span class="number">2</span> ** <span class="number">90</span></span><br><span class="line">b = <span class="number">841</span> + <span class="number">1073741633</span> * <span class="number">2</span> ** <span class="number">30</span> + <span class="number">2332</span> * <span class="number">2</span> ** <span class="number">60</span></span><br><span class="line">z = <span class="number">761</span> + <span class="number">809</span> * <span class="number">2</span> ** <span class="number">30</span> + <span class="number">3098</span> * <span class="number">2</span> ** <span class="number">60</span> + <span class="number">123341</span> * <span class="number">2</span> ** <span class="number">90</span></span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># 152688762386380073438430860672944</span></span><br><span class="line"><span class="built_in">print</span>(b)  <span class="comment"># 2689765870042689307465</span></span><br><span class="line"><span class="built_in">print</span>(z)  <span class="comment"># 152688762389069839308473549980409</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显然结果为True, 由此证明我们之前的结论是成立的。</span></span><br><span class="line"><span class="built_in">print</span>(a + b == z)  <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<p>​        <strong>看完绝对值加法x_add之后，再来看看绝对值减法x_sub，显然有了加法的经验之后再看减法会简单很多。</strong>    </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> PyLongObject *</span><br><span class="line"><span class="title function_">x_sub</span><span class="params">(PyLongObject *a, PyLongObject *b)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//依旧是获取两者的ob_size的绝对值</span></span><br><span class="line">    Py_ssize_t size_a = Py_ABS(Py_SIZE(a)), size_b = Py_ABS(Py_SIZE(b));</span><br><span class="line">    <span class="comment">//z指向相加之后的PyLongObject</span></span><br><span class="line">    PyLongObject *z;</span><br><span class="line">    <span class="comment">//循环变量</span></span><br><span class="line">    Py_ssize_t i;</span><br><span class="line">    <span class="comment">//如果size_a 小于 size_b, 那么sign就是-1, 否则就是1</span></span><br><span class="line">    <span class="type">int</span> sign = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//之前carry保存的相加的结果, borrow保存相减的结果</span></span><br><span class="line">    <span class="comment">//名字很形象, 相加要进位叫carry、相减要结尾叫borrow</span></span><br><span class="line">    digit borrow = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果size_a比size_b小, 说明a的绝对值比b小</span></span><br><span class="line">    <span class="keyword">if</span> (size_a &lt; size_b) &#123;</span><br><span class="line">        <span class="comment">//那么令sign = -1, 相减之后再乘上sign</span></span><br><span class="line">        <span class="comment">//因为计算的是绝对值之差, 符号是在绝对值之差计算完毕之后通过sign判断的</span></span><br><span class="line">        sign = <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//然后依旧交换两者的位置, 相减的时候也确保大的一方在左边</span></span><br><span class="line">        <span class="comment">//相加的时候其实大的一方在左边还是在右边没有太大影响, 但是相减的时候大的一方在左边显然会省事很多</span></span><br><span class="line">        <span class="comment">//但是交换之后再相减, 肯定要变符号, 因此将sign设置为-1</span></span><br><span class="line">        &#123; PyLongObject *temp = a; a = b; b = temp; &#125;</span><br><span class="line">        &#123; Py_ssize_t size_temp = size_a;</span><br><span class="line">            size_a = size_b;</span><br><span class="line">            size_b = size_temp; &#125;</span><br><span class="line">        <span class="comment">//可能有人会有疑问了，那如果a的ob_size是1, b的ob_size是-3，一正一负,此时起到的效果是相加才对啊</span></span><br><span class="line">        <span class="comment">//是的, 所以此时会将a和b传到x_add里面，而不是这里, 后面我们会总结</span></span><br><span class="line">        <span class="comment">//由于ob_digit里面的元素都为正, 所以x_add计算的是绝对值之和，x_sub计算的绝对值之差, 总之在理解逻辑的时候把a和b都想象成正数即可</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (size_a == size_b) &#123;</span><br><span class="line">        <span class="comment">//这一个条件语句可能有人会觉得费解，我们分析一下</span></span><br><span class="line">        <span class="comment">//如果两者相等, 那么两个ob_digit里面对应的元素也是有几率都相等的</span></span><br><span class="line">        i = size_a;</span><br><span class="line">        <span class="comment">//所以从ob_digit的尾巴开始遍历</span></span><br><span class="line">        <span class="keyword">while</span> (--i &gt;= <span class="number">0</span> &amp;&amp; a-&gt;ob_digit[i] == b-&gt;ob_digit[i])</span><br><span class="line">            ;</span><br><span class="line">        <span class="comment">//如果都相等, 那么i会等于-1</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//所以直接返回0即可</span></span><br><span class="line">            <span class="keyword">return</span> (PyLongObject *)PyLong_FromLong(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//下面下面是为了计算相减之后的PyLongObject的ob_size</span></span><br><span class="line">        <span class="comment">//如果对应元素不相等, 假设a的ob_digit里面的元素是[2, 3, 4, 5], b的ob_digit是[1, 2, 3, 5]</span></span><br><span class="line">        <span class="comment">//因此上面的while循环结束之后, i会等于2, 显然只需要计算[2, 3, 4]和[1, 2, 3]之间的差即可, 因为最高位的5是一样的</span></span><br><span class="line">        <span class="comment">//然后判断索引为i时, 对应的值谁大谁小</span></span><br><span class="line">        <span class="keyword">if</span> (a-&gt;ob_digit[i] &lt; b-&gt;ob_digit[i]) &#123;</span><br><span class="line">            <span class="comment">//如果a-&gt;ob_digit[i] &lt; b-&gt;ob_digit[i], 那么同样说明a小于b, 因此将sign设置为-1, 然后交换a和b的位置</span></span><br><span class="line">            sign = <span class="number">-1</span>;</span><br><span class="line">            &#123; PyLongObject *temp = a; a = b; b = temp; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//因为做减法, 所以size_a和size_b直接设置成i + 1即可, 因为高位在减法的时候会被抵消掉, 所以它们完全可以忽略</span></span><br><span class="line">        size_a = size_b = i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里依旧是申请空间</span></span><br><span class="line">    z = _PyLong_New(size_a);</span><br><span class="line">    <span class="comment">//申请失败返回NULL</span></span><br><span class="line">    <span class="keyword">if</span> (z == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//然后下面的逻辑和x_add是类似的</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size_b; ++i) &#123;</span><br><span class="line">        <span class="comment">//让a-&gt;ob_digit[i] - b-&gt;ob_digit[i], 但如果存在借位, 那么还要减掉</span></span><br><span class="line">        <span class="comment">//但是问题来了, 我们说digit貌似是无符号的吧, 但是对于低位来说a-&gt;ob_digit[i] 是完全可以小于 b-&gt;ob_digit[i]的</span></span><br><span class="line">        <span class="comment">//但是这样减出来不成负数了, 所以C语言中有这么个特点, 比如：这里相减得到的是-100</span></span><br><span class="line">        <span class="comment">//那么结果就是2 ** 32 - 100, 因为digit是无符号32位, 所以存储的负数会变成 2 ** 32 + 该负数, 或者2 ** 32 - 负数的绝对值</span></span><br><span class="line">        <span class="comment">//以我们平时做的减法为例：32 - 19, 我们知道结果是13, 但是低位的2减去低位的9结果是-7, 如果是负数</span></span><br><span class="line">        <span class="comment">//那么要像高位借个1, 从而得到10,因此最后一位是10 - 7 = 3</span></span><br><span class="line">        <span class="comment">//以此为例, a -&gt; ob_digit[i] - b -&gt; ob_digit[i], 如果小于0, 那么肯定要像数组中i + 1的元素进行借位, 但我们说它会比当前高30个位</span></span><br><span class="line">        borrow = a-&gt;ob_digit[i] - b-&gt;ob_digit[i] - borrow;</span><br><span class="line">        <span class="comment">//因此这里借个1, 借的就不是10了, 而是2 ** 30次方</span></span><br><span class="line">        <span class="comment">//所以borrow为负, 那么结果显然加上2 ** 30才对, 但是当前borrow加的是2 ** 32次方</span></span><br><span class="line">        <span class="comment">//所以将borrow 还要 与上 PyLong_MASK，然后其结果才是z-&gt;ob_digit[i]的值</span></span><br><span class="line">        z-&gt;ob_digit[i] = borrow &amp; PyLong_MASK;</span><br><span class="line">        <span class="comment">//如果真的借了个1, 那么ob_digit中下一个元素肯定是要减去1的, 所以borrow右移30位</span></span><br><span class="line">        borrow &gt;&gt;= PyLong_SHIFT;</span><br><span class="line">        <span class="comment">//和1进行与运算, 如果a -&gt; ob_digit[i] - b -&gt; ob_digit[i]为负, 那么就必须要借位</span></span><br><span class="line">        <span class="comment">//但由于digit只用30个位, 因此再加上2 ** 32次方之后，其结果的第31位一定是1</span></span><br><span class="line">        <span class="comment">//所以borrow右移30位之后, 再和1进行与运算之后结果肯定是1, 由此可以判断这次相减一定是借位了</span></span><br><span class="line">        <span class="comment">//如果为0代表结果为正、没有加上2 ** 32次方,那么结果borrow &amp; 1的结果就是0</span></span><br><span class="line">        borrow &amp;= <span class="number">1</span>; </span><br><span class="line">        <span class="comment">//所以Python底层的整数只用了30个位真的非常巧妙, 尤其是在减法的时候</span></span><br><span class="line">        <span class="comment">//因为借位一次借2 ** 30, 可由于C的特性会加上2 ** 32次方, 但是它们的结果只有前两个高位不一样, 后面30个位是一样的</span></span><br><span class="line">        <span class="comment">//所以再与上PyLong_MASK, 所以就等价于加上了2 ** 30次方，从而得到正确的结果</span></span><br><span class="line">        <span class="comment">//但如果一旦借位, 那么数组下一个元素要减去1。但问题是怎么判断它有没有借位呢？判断有没有借位就是判断两个元素相减之后是否为负</span></span><br><span class="line">        <span class="comment">//如果为负数,那么C会将这个负数加上2 ** 32次方, 而两个不超过2 ** 30 - 1的数相减得到的负数的绝对值显然也不会超过2 ** 30 - 1</span></span><br><span class="line">        <span class="comment">//换句话说其结果对应的第31位一定是0, 那么再和32个位全部是1的2 ** 32次方相加, 得到的结果的第31位一定是1</span></span><br><span class="line">        <span class="comment">//所以再让borrow右移30位、并和1进行与运算。如果结果为1, 证明相减为负数, 确实像下一个元素借了1, 因此下一次循环的会减去1</span></span><br><span class="line">        <span class="comment">//如果borrow为0, 那么就证明a-&gt;ob_digit[i] - b-&gt;ob_digit[i]得到的结果为正,根本不需要借位, 所以下一次循环等于减了一个0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果size_a和size_b一样, 那么这里的for循环是不会满足条件的, 但不一样的话, 肯定会走这里</span></span><br><span class="line">    <span class="keyword">for</span> (; i &lt; size_a; ++i) &#123;</span><br><span class="line">        <span class="comment">//我们看到这里的逻辑和之前分析x_add是类似的</span></span><br><span class="line">        borrow = a-&gt;ob_digit[i] - borrow;</span><br><span class="line">        z-&gt;ob_digit[i] = borrow &amp; PyLong_MASK;</span><br><span class="line">        borrow &gt;&gt;= PyLong_SHIFT;</span><br><span class="line">        borrow &amp;= <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//只不过由于不会产生进位, 因此不需要对borrow再做额外判断, x_add中最后还要判断carry有没有进位</span></span><br><span class="line">    assert(borrow == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sign &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果sign &lt; 0, 那么证明是负数</span></span><br><span class="line">        Py_SIZE(z) = -Py_SIZE(z);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后同样从后往前将z -&gt; ob_digit中为0的元素删掉, 直到遇见一个不为0的元素, 比如: 10000 - 9999, 虽然位数多, 但是结果是1</span></span><br><span class="line">    <span class="comment">//而z -&gt; ob_digit在申请空间的时候只是根据长度申请的, 所以最后还需要这样的一次判断</span></span><br><span class="line">    <span class="keyword">return</span> long_normalize(z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所以Python整数在底层的设计确实很精妙，尤其是在减法的时候，强烈建议多看几遍回味一下。</strong></p>
<h4 id="整数的相减"><a href="#整数的相减" class="headerlink" title="整数的相减"></a>整数的相减</h4><p><strong>整数的相减调用的是long_sub函数，显然long_sub和long_add的思路都是一样的，核心还是在x_add和x_sub上面，所以long_sub就没有什么可细说的了。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">long_sub</span><span class="params">(PyLongObject *a, PyLongObject *b)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//z指向a和b相加之后的PyLongObject</span></span><br><span class="line">    PyLongObject *z;</span><br><span class="line">    <span class="comment">//判断a和b是否均指向PyLongObject</span></span><br><span class="line">    CHECK_BINOP(a, b);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//这里依旧是快分支</span></span><br><span class="line">    <span class="keyword">if</span> (Py_ABS(Py_SIZE(a)) &lt;= <span class="number">1</span> &amp;&amp; Py_ABS(Py_SIZE(b)) &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//直接相减，然后转成PyLongObject返回其指针</span></span><br><span class="line">        <span class="keyword">return</span> PyLong_FromLong(MEDIUM_VALUE(a) - MEDIUM_VALUE(b));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//a小于0</span></span><br><span class="line">    <span class="keyword">if</span> (Py_SIZE(a) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//a小于0，b小于0</span></span><br><span class="line">        <span class="keyword">if</span> (Py_SIZE(b) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//调用绝对值减法, 因为两者符号一样</span></span><br><span class="line">            z = x_sub(a, b);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//此时两者符号不一样，那么相加起到的是相加的效果</span></span><br><span class="line">            z = x_add(a, b);</span><br><span class="line">        <span class="keyword">if</span> (z != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">//但是x_add和x_sub运算的是绝对值, x_sub中考虑的sign是基于绝对值而言的</span></span><br><span class="line">            <span class="comment">//比如：x_sub接收的a和b的ob_size分别是-5和-3, 那么得到的结果肯定是正的, 因为会用绝对值大的减去绝对值小的</span></span><br><span class="line">            <span class="comment">//而显然这里的结果应该是负数, 所以还要乘上-1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//如果x_sub接收的a和b的ob_size分别是-3和-5, 由于还是用绝对值大的减去绝对值小的,所以会交换、从而变号，得到的结果是负的</span></span><br><span class="line">            <span class="comment">//而显然这里的结果应该是正数, 所以也要乘上-1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//至于x_add就更不用说了, 当a为负、b为正的时候, a - b，就等于a和b的绝对值相加乘上-1</span></span><br><span class="line">            assert(Py_SIZE(z) == <span class="number">0</span> || Py_REFCNT(z) == <span class="number">1</span>);</span><br><span class="line">            Py_SIZE(z) = -(Py_SIZE(z));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//a大于0, b小于0, 所以a - b等于a和b的绝对值相加</span></span><br><span class="line">        <span class="keyword">if</span> (Py_SIZE(b) &lt; <span class="number">0</span>)</span><br><span class="line">            z = x_add(a, b);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//a大于0, b大于0, 所以直接绝对值相减即可</span></span><br><span class="line">            <span class="comment">//而正数等于其绝对值, 所以x_sub里面考虑的符号就是真正的结果的符号</span></span><br><span class="line">            <span class="comment">//如果是上面的负数, 那么还要乘上-1</span></span><br><span class="line">            z = x_sub(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回结果</span></span><br><span class="line">    <span class="keyword">return</span> (PyObject *)z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所以关于什么时候调用x_add、什么时候调用x_sub，我们总结一下，总之核心就在于它们都是对绝对值进行运算的，掌握好这一点就不难了：</strong></p>
<p><strong>a + b</strong></p>
<ul>
<li><code>如果a是正、b是正，调用x_add(a, b)，直接对绝对值相加返回结果</code></li>
<li><code>如果a是负、b是负，调用x_add(a, b)，但相加的是绝对值，所以long_add中在接收到结果之后还要对ob_size乘上-1</code></li>
<li><code>如果a是正、b是负，调用x_sub(a,  b)，此时等价于a的绝对值减去b的绝对值。并且x_sub是使用绝对值大的减去绝对值小的，如果a的绝对值大，那么显然正常；如果a的绝对值小，x_sub中会交换，但同时也会自动变号，因此结果也是正常的。举个普通减法的例子：5 + -3, 那么在x_sub中就是5 - 3; 如果是3 + -5, 那么在x_sub中就是-(5 - 3),  因为发生了交换。但不管那种情况，符号都是一样的</code></li>
<li><code>如果a是负、b是正，调用x_sub(b, a)，此时等价于b的绝对值减去a的绝对值。所以这个和上面a是正、b是负是等价的。</code></li>
</ul>
<p><strong>所以符号相同，会调用x_add、符号不同会调用x_sub。</strong></p>
<p><strong>a - b</strong></p>
<ul>
<li><code>如果a是正、b是负，调用x_add(a, b)直接对a和b的绝对值相加即可</code></li>
<li><code>如果a是正、b是正，调用x_sub(a, b)直接对a和b的绝对值相减即可，会根据绝对值自动处理符号，而a、b为正，所以针对绝对值处理的符号，也是a - b的符号</code></li>
<li><code>如果a是负、b是正，调用x_add(a, b)对绝对值进行相加, 但是结果显然为负，因此在long_sub中还要对结果的ob_size成员乘上-1</code></li>
<li><code>如果a是负、b是负，调用x_sub(a, b)对绝对值进行相减, 会根据绝对值自动处理符号,  但是在为负的情况下绝对值越大，其值反而越小, 因此针对绝对值处理的符号，和a -  b的符号是相反的。所以最终在long_sub中，也要对结果的ob_size成员乘上-1。举个普通减法的例子：-5 - -3,  那么在x_sub中就类似于5 - 3; 如果是-3 - -5, 那么在x_sub中就类似于-(5 - 3),  因为发生了交换。但不管那种情况得到的值的正负号都是相反的，所以要再乘上-1</code></li>
</ul>
<p><strong>所以符号相同，会调用x_sub、符号不同会调用x_add。</strong></p>
<p>​        <strong>所以可以仔细回味一下Python中整数的设计思想，以及运算方式。为什么只使用digit的30个位, 以及在相加、相减的时候是怎么做的。</strong>    </p>
<p>​        <strong>当然还有乘法和除法，乘法Python内部采用的是效率更高的karatsuba算法，相当来说比较复杂，有兴趣可以自己查看一下。重点还是了解Python中的整数在底层是怎么存储的，以及为什么要这么存储。</strong>    </p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><strong>这一节我们介绍了整数的底层实现，并分析了Python中的整数为什么不会溢出，以及Python如何计算一个整数所占的字节。当然我们还说了小整数对象池，以及通过分析源码中的long_add和long_sub来了解底层是如何对整数进行运算的。</strong></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Lin Li</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/03/29/05-Python%E6%95%B4%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/">http://example.com/2023/03/29/05-Python%E6%95%B4%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">LinLi's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/CPython/">CPython</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/03/29/06-Bytes%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BA%95%E5%B1%82%E6%93%8D%E4%BD%9C/" title="06-Bytes对象的底层操作"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">06-Bytes对象的底层操作</div></div></a></div><div class="next-post pull-right"><a href="/2023/03/29/04-%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/" title="04-浮点数的底层实现"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">04-浮点数的底层实现</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/03/29/01-%E7%BC%96%E8%AF%91Cpython/" title="01-编译Cpython"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">01-编译Cpython</div></div></a></div><div><a href="/2023/03/29/02-%E4%B8%80%E5%88%87%E5%AF%B9%E8%B1%A1%E7%9A%86PyObject/" title="02-一切对象皆PyObject"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">02-一切对象皆PyObject</div></div></a></div><div><a href="/2023/03/29/04-%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/" title="04-浮点数的底层实现"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">04-浮点数的底层实现</div></div></a></div><div><a href="/2023/03/29/06-Bytes%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BA%95%E5%B1%82%E6%93%8D%E4%BD%9C/" title="06-Bytes对象的底层操作"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">06-Bytes对象的底层操作</div></div></a></div><div><a href="/2023/03/29/03-Python%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E5%99%A8%E5%92%8C%E5%BA%95%E5%B1%82%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86/" title="03-Python引用计数器和底层对象管理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">03-Python引用计数器和底层对象管理</div></div></a></div><div><a href="/2023/03/29/10-PyCodeObject%E5%AF%B9%E8%B1%A1%E5%92%8Cpyc%E6%96%87%E4%BB%B6/" title="10-PyCodeObject对象和pyc文件"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">10-PyCodeObject对象和pyc文件</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Lin Li</div><div class="author-info__description">今日事，今日毕</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">122</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#05-Python%E6%95%B4%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.</span> <span class="toc-text">05-Python整数的底层实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#int%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.1.</span> <span class="toc-text">int实例对象的底层实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E6%95%B4%E6%95%B0%E5%AF%B9%E8%B1%A1%E6%B1%A0"><span class="toc-number">1.2.</span> <span class="toc-text">小整数对象池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E8%BF%90%E7%AE%97"><span class="toc-number">1.3.</span> <span class="toc-text">整数运算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E7%9A%84%E5%A4%A7%E5%B0%8F%E6%AF%94%E8%BE%83"><span class="toc-number">1.3.1.</span> <span class="toc-text">整数的大小比较</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E7%9A%84%E7%9B%B8%E5%8A%A0"><span class="toc-number">1.3.2.</span> <span class="toc-text">整数的相加</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E7%9A%84%E7%9B%B8%E5%87%8F"><span class="toc-number">1.3.3.</span> <span class="toc-text">整数的相减</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">2.</span> <span class="toc-text">小结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/08/%E8%A7%A3%E5%86%B3Camera-ready-%E2%9C%98-Problem-Not-all-fonts-are-embedded-%E9%97%AE%E9%A2%98/" title="解决Camera ready ✘ Problem: Not all fonts are embedded. 问题">解决Camera ready ✘ Problem: Not all fonts are embedded. 问题</a><time datetime="2025-04-08T14:19:21.000Z" title="发表于 2025-04-08 22:19:21">2025-04-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/21/Sequence-Oriented-DBMS-Fuzzing/" title="Sequence-Oriented DBMS Fuzzing">Sequence-Oriented DBMS Fuzzing</a><time datetime="2025-02-21T09:35:08.000Z" title="发表于 2025-02-21 17:35:08">2025-02-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/18/AGENTLESS-Demystifying-LLM-based-Software-Engineering-Agents/" title="AGENTLESS: Demystifying LLM-based Software Engineering Agents">AGENTLESS: Demystifying LLM-based Software Engineering Agents</a><time datetime="2025-02-18T12:16:29.000Z" title="发表于 2025-02-18 20:16:29">2025-02-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/01/DeepSeek-R1-Incentivizing-Reasoning-Capability-in-LLMs-via-Reinforcement-Learning/" title="DeepSeek-R1: Incentivizing Reasoning Capability in LLMs via Reinforcement Learning">DeepSeek-R1: Incentivizing Reasoning Capability in LLMs via Reinforcement Learning</a><time datetime="2025-02-01T11:11:48.000Z" title="发表于 2025-02-01 19:11:48">2025-02-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/01/DeepSeek-Coder-When-the-Large-Language-Model-Meets-Programming-The-Rise-of-Code-Intelligence/" title="DeepSeek-Coder: When the Large Language Model Meets Programming - The Rise of Code Intelligence">DeepSeek-Coder: When the Large Language Model Meets Programming - The Rise of Code Intelligence</a><time datetime="2025-02-01T02:43:19.000Z" title="发表于 2025-02-01 10:43:19">2025-02-01</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Lin Li</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>