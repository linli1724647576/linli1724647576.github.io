<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>10-PyCodeObject对象和pyc文件 | LinLi's Blog</title><meta name="author" content="Lin Li"><meta name="copyright" content="Lin Li"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="10-Python中的PyCodeObject对象与pyc文件楔子当我们想要执行一个py文件的时候，只需要python  xxx.py即可，但是你有没有想过这背后的流程是怎么样的呢？从这里开始我们就开始进入到Python虚拟机的环节了，之前都是在介绍Python中的一些内置对象，不过虚拟机的执行流程、以及背后的原理却更是值得我们关注的。 这里我们先来说一下Python执行py文件的流程：  1.">
<meta property="og:type" content="article">
<meta property="og:title" content="10-PyCodeObject对象和pyc文件">
<meta property="og:url" content="http://example.com/2023/03/29/10-PyCodeObject%E5%AF%B9%E8%B1%A1%E5%92%8Cpyc%E6%96%87%E4%BB%B6/index.html">
<meta property="og:site_name" content="LinLi&#39;s Blog">
<meta property="og:description" content="10-Python中的PyCodeObject对象与pyc文件楔子当我们想要执行一个py文件的时候，只需要python  xxx.py即可，但是你有没有想过这背后的流程是怎么样的呢？从这里开始我们就开始进入到Python虚拟机的环节了，之前都是在介绍Python中的一些内置对象，不过虚拟机的执行流程、以及背后的原理却更是值得我们关注的。 这里我们先来说一下Python执行py文件的流程：  1.">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2023-03-29T14:44:24.000Z">
<meta property="article:modified_time" content="2023-04-12T02:37:56.758Z">
<meta property="article:author" content="Lin Li">
<meta property="article:tag" content="CPython">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/03/29/10-PyCodeObject%E5%AF%B9%E8%B1%A1%E5%92%8Cpyc%E6%96%87%E4%BB%B6/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '10-PyCodeObject对象和pyc文件',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-04-12 10:37:56'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">75</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="LinLi's Blog"><span class="site-name">LinLi's Blog</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">10-PyCodeObject对象和pyc文件</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-29T14:44:24.000Z" title="发表于 2023-03-29 22:44:24">2023-03-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-04-12T02:37:56.758Z" title="更新于 2023-04-12 10:37:56">2023-04-12</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="10-PyCodeObject对象和pyc文件"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="10-Python中的PyCodeObject对象与pyc文件"><a href="#10-Python中的PyCodeObject对象与pyc文件" class="headerlink" title="10-Python中的PyCodeObject对象与pyc文件"></a>10-Python中的PyCodeObject对象与pyc文件</h2><h3 id="楔子"><a href="#楔子" class="headerlink" title="楔子"></a>楔子</h3><p><strong>当我们想要执行一个py文件的时候，只需要python  xxx.py即可，但是你有没有想过这背后的流程是怎么样的呢？从这里开始我们就开始进入到Python虚拟机的环节了，之前都是在介绍Python中的一些内置对象，不过虚拟机的执行流程、以及背后的原理却更是值得我们关注的。</strong></p>
<p><strong>这里我们先来说一下Python执行py文件的流程：</strong></p>
<ul>
<li><code>1. 首先将文件里面的内容读取出来, 所以从这个角度上讲, 文件名不一定非要是.py结尾, .txt也是可以的, 只要文件里面的内容符合Python代码规范即可</code></li>
<li><code>2. 读取文件里面的内容之后会对其进行分词, 将源代码切分成一个一个的token</code></li>
<li><code>3. 然后Python编译器会对token进行语法解析, 建立抽象语法树(AST, abstract syntax tree)</code></li>
<li><code>4. 编译器再将得到AST编译成字节码</code></li>
<li><code>5. 最终由Python虚拟机来执行字节码</code></li>
</ul>
<p><strong>首先我们从中看到了Python编译器、Python虚拟机，而且我们平常还会说Python解释器，那么三者之间有什么区别呢？</strong></p>
<blockquote>
<p><strong>实际上Python解释器 &#x3D; Python编译器 + Python虚拟机，Python编译器负责将Python源代码编译成字节码<code>(包括文件读取、分词、建立AST、编译成字节码)</code>，Python虚拟机负责执行这些字节码。</strong></p>
</blockquote>
<p><strong>那么Python编译器和Python虚拟机都在什么地方呢？如果打开Python的安装目录，会发现有一个python.exe，点击的时候会通过它来启动一个终端。</strong></p>
<p><img src="https://img2020.cnblogs.com/blog/1229382/202008/1229382-20200815023105176-468360562.png" alt="img"></p>
<p><strong>但问题是这个文件大小还不到100K，不可能容纳一个解释器加一个虚拟机，所以下面还有一个python38.dll，没错，编译器、虚拟机都藏身于python38.dll当中。</strong></p>
<p><strong>因此Python代码并不是直接就一步到胃、变成机器码，而是先被Python编译器编译成字节码，中间存在一个编译的过程。而之所以要存在编译，是为了能够让虚拟机更快速的执行，而且还可以尽早的检测出语法上的错误。</strong></p>
<p><strong>那么下面我们就来看看Python中的字节码长什么样子。</strong></p>
<h3 id="Python编译器的编译结果–PyCodeObject对象"><a href="#Python编译器的编译结果–PyCodeObject对象" class="headerlink" title="Python编译器的编译结果–PyCodeObject对象"></a>Python编译器的编译结果–PyCodeObject对象</h3><p><strong>我们知道Python代码的编译结果是字节码，里面必然隐藏了Python运行的秘密，因此不管是深入理解虚拟机还是调优Python的运行效率，字节码都是绕不过去的一个坎。</strong></p>
<blockquote>
<p><strong>注意：我们这里会研究字节码，但是不会研究Python是怎么编译得到字节码。因为Python编译器的工作原理和其它语言基本类似，很多关于编译原理的书籍都有介绍，编译这个过程不是Python特有的。并且研究Python的编译过程，对于我们开发帮助不是很大。</strong></p>
<p><strong>所以我们只需要知道Python解释器的背后有一个编译器会通过”读取文件”、”对源代码分词”、”分词之后会语法解析建立AST”、”对AST编译”得到字节码即可，至于这一列步骤是怎么做的、是怎么将源代码变成的字节码不是我们需要关心的，我们的重点是研究字节码本身以及虚拟机。</strong></p>
</blockquote>
<h4 id="PyCodeObject对象和pyc文件"><a href="#PyCodeObject对象和pyc文件" class="headerlink" title="PyCodeObject对象和pyc文件"></a>PyCodeObject对象和pyc文件</h4><p><strong>首先做Python开发的肯定都见过这个pyc文件，它一般位于<code>__pycache__</code>目录中，那么这个pyc文件和字节码之间有什么关系呢？</strong></p>
<p><strong>首先我们知道，Python执行这个文件首先要进行的动作就是编译，编译会得到字节码。然而除了字节码之外，还应该包含一些其它的信息，这些信息也是Python运行的时候所必须的。</strong></p>
<p><strong>在编译过程中，像常量值、字符串这些源代码当中的静态信息都会被Python编译器收集起来，并且这些静态信息也都会体现在编译之后的结果里面。在Python运行期间，这些源文件提供的静态信息都会被存储在一个运行时的对象当中，当Python运行结束时，这个运行时对象中所包含的信息还会被存储在一种文件中。这个对象和文件就是我们接下来要探讨的重点：PyCodeObject对象和pyc文件。</strong></p>
<blockquote>
<p><strong>Python中的字节码只是一个PyBytesObject对象、或者说一段字节序列，PyCodeObject对象中有一个成员co_code，它是一个指针，指向了这段字节序列。但是这个对象除了有co_code指向字节码之外，还有很多其它成员，负责保存代码涉及到的常量、变量<code>(名字、符号)</code>等等</strong></p>
<p><strong>所以我们知道了，pyc文件里面的内容是PyCodeObject对象。对于Python编译器来说，PyCodeObject对象才是其真正的编译结果，而pyc文件是这个对象在硬盘上表现形式。</strong></p>
</blockquote>
<p><strong>在程序运行期间，编译结果存在于内存的PyCodeObject对象当中，而Python结束运行之后，编译结果又被保存到了pyc文件当中。当下一次运行的时候，Python会根据pyc文件中记录的编译结果直接建立内存中的PyCodeObject对象，而不需要再度重新编译了。</strong></p>
<h4 id="python源码中的PyCodeObject对象"><a href="#python源码中的PyCodeObject对象" class="headerlink" title="python源码中的PyCodeObject对象"></a>python源码中的PyCodeObject对象</h4><p><strong>我们说Python编译器会将Python源代码编译成字节码，虚拟机执行的也是字节码，所以要理解虚拟机的运行时<code>(runtime)</code>行为，就必须要先掌握字节码。而我们说字节码是被底层结构体PyCodeObject的成员co_code指向，那么我们就必须来看看这个结构体了，它的定义位于 *Include&#x2F;code.h* 中。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_HEAD		<span class="comment">/* 头部信息, 我们看到真的一切皆对象, 字节码也是个对象 */</span>	</span><br><span class="line">    <span class="type">int</span> co_argcount;            <span class="comment">/* 可以通过位置参数传递的参数个数 */</span></span><br><span class="line">    <span class="type">int</span> co_posonlyargcount;     <span class="comment">/* 只能通过位置参数传递的参数个数,  Python3.8新增 */</span></span><br><span class="line">    <span class="type">int</span> co_kwonlyargcount;      <span class="comment">/* 只能通过关键字参数传递的参数个数 */</span></span><br><span class="line">    <span class="type">int</span> co_nlocals;             <span class="comment">/* 代码块中局部变量的个数，也包括参数 */</span></span><br><span class="line">    <span class="type">int</span> co_stacksize;           <span class="comment">/* 执行该段代码块需要的栈空间 */</span></span><br><span class="line">    <span class="type">int</span> co_flags;               <span class="comment">/* 参数类型标识 */</span></span><br><span class="line">    <span class="type">int</span> co_firstlineno;         <span class="comment">/* 代码块在对应文件的行号 */</span></span><br><span class="line">    PyObject *co_code;          <span class="comment">/* 指令集, 也就是字节码, 它是一个bytes对象 */</span></span><br><span class="line">    PyObject *co_consts;        <span class="comment">/* 常量池, 一个元组，保存代码块中的所有常量。 */</span></span><br><span class="line">    PyObject *co_names;         <span class="comment">/* 一个元组,保存代码块中引用的其它作用域的变量 */</span></span><br><span class="line">    PyObject *co_varnames;      <span class="comment">/* 一个元组,保存当前作用域中的变量 */</span></span><br><span class="line">    PyObject *co_freevars;      <span class="comment">/* 内层函数引用的外层函数的作用域中的变量 */</span></span><br><span class="line">    PyObject *co_cellvars;      <span class="comment">/* 外层函数中作用域中被内层函数引用的变量，本质上和co_freevars是一样的 */</span></span><br><span class="line"></span><br><span class="line">    Py_ssize_t *co_cell2arg;    <span class="comment">/* 无需关注 */</span></span><br><span class="line">    PyObject *co_filename;      <span class="comment">/* 代码块所在的文件名 */</span></span><br><span class="line">    PyObject *co_name;          <span class="comment">/* 代码块的名字，通常是函数名或者类名 */</span></span><br><span class="line">    PyObject *co_lnotab;        <span class="comment">/* 字节码指令与python源代码的行号之间的对应关系，以PyByteObject的形式存在 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//剩下的无需关注了</span></span><br><span class="line">    <span class="type">void</span> *co_zombieframe;       <span class="comment">/* for optimization only (see frameobject.c) */</span></span><br><span class="line">    PyObject *co_weakreflist;   <span class="comment">/* to support weakrefs to code objects */</span></span><br><span class="line">    <span class="type">void</span> *co_extra;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *co_opcache_map;</span><br><span class="line">    _PyOpcache *co_opcache;</span><br><span class="line">    <span class="type">int</span> co_opcache_flag; </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> co_opcache_size; </span><br><span class="line">&#125; PyCodeObject;</span><br></pre></td></tr></table></figure>

<p><strong>这里面的每一个成员，我们后面都会逐一演示进行说明。总之Python编译器在对Python源代码进行编译的时候，对于代码中的每一个block，都会创建一个PyCodeObject与之对应。但是多少代码才算得上是一个block呢？事实上，Python有一个简单而清晰的规则：当进入一个新的名字空间，或者说作用域时，我们就算是进入了一个新的block了。这里又引出了名字空间，别急，我们后面会一点一点说，总之先举个栗子：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    a = <span class="number">123</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    a = []</span><br></pre></td></tr></table></figure>

<p><strong>我们仔细观察一下上面这个文件，它在编译完之后会有三个PyCodeObject对象，一个是对应整个py文件的，一个是对应class A的，一个是对应def foo的。因为这是三个不同的作用域，所以会有三个PyCodeObject对象。</strong></p>
<p><strong>在这里，我们开始提及Python中一个至关重要的概念–名字空间(name  space)、也叫命名空间、名称空间，都是一个东西。名字空间是符号的上下文环境，符号的含义取决于名字空间。更具体的说，一个变量名对应的变量值什么，在Python中是不确定的，需要命名空间来决定。</strong></p>
<p>对于某个符号、或者名字<code>(我们在前面系列中说过Python的变量只是一个名字)</code>，比如说上面代码中的a，在某个名字空间中，它可能指向一个PyLongObject对象；而在另一个名字空间中，它可能指向一个PyListObject对象。但是在一个名字空间中，一个符号只能有一种含义。而且名字空间可以一层套一层的形成一条<code>名字空间链</code>，Python虚拟机在执行的时候，会有很大一部分时间消耗在从<code>名字空间链</code>中确定一个符号所对应的对象是什么。这也侧面说明了，Python为什么比较慢。</p>
<p><strong>如果你现在名字空间还不是很了解，不要紧，随着剖析的深入，你一定会对名字空间和Python在名字空间链上的行为有着越来越深刻的理解。总之现在需要记住的是：一个code block对应一个名字空间<code>(或者说作用域)</code>、同时也对应一个PyCodeObject对象。在Python中，类、函数、module都对应着一个独自的名字空间，因此都会有一个PyCodeObject与之对应。</strong></p>
<h4 id="如何在Python中访问PyCodeObject对象"><a href="#如何在Python中访问PyCodeObject对象" class="headerlink" title="如何在Python中访问PyCodeObject对象"></a>如何在Python中访问PyCodeObject对象</h4><p><strong>那么我们如何才能在Python中获取到PyCodeObject对象呢？PyCodeObject对象在Python中也是一个对象，它的类型对象是<code>&lt;class &#39;code&#39;&gt;</code>。但是这个类，底层没有暴露给我们，所以code对于Python来说只是一个没有定义的变量罢了。</strong></p>
<p><strong>但是我们可以通过其它的方式进行获取，首先来看看如何通过函数来获取该函数对应的字节码。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(func.__code__))  <span class="comment"># &lt;class &#x27;code&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>我们可以通过函数的<code>__code__</code>拿到底层对应的PyCodeObject对象，当然也可以获取里面的属性，我们来演示一下。</strong></p>
<p>​        <strong>co_argcount：可以通过位置参数传递的参数个数</strong>    </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">a, b, c=<span class="number">3</span></span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="built_in">print</span>(foo.__code__.co_argcount)  <span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bar</span>(<span class="params">a, b, *args</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="built_in">print</span>(bar.__code__.co_argcount)  <span class="comment"># 2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a, b, *args, c</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="built_in">print</span>(func.__code__.co_argcount)  <span class="comment"># 2</span></span><br></pre></td></tr></table></figure>

<p><strong>foo中的参数a、b、c都可以通过位置参数传递，所以结果是3；对于bar，显然是两个，这里不包括<code>\*args</code>；而函数func，显然是两个，因为参数c只能通过关键字参数传递。</strong></p>
<p>​        <strong>co_posonlyargcount：只能通过位置参数传递的参数个数，python3.8新增</strong>    </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">a, b, c</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(foo.__code__.co_posonlyargcount)  <span class="comment"># 0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bar</span>(<span class="params">a, b, /, c</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(bar.__code__.co_posonlyargcount)  <span class="comment"># 2</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：这里是只能通过位置参数传递的参数个数。</strong></p>
<p>​        <strong>co_kwonlyargcount：只能通过关键字参数传递的参数个数</strong>    </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">a, b=<span class="number">1</span>, c=<span class="number">2</span>, *, d, e</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(foo.__code__.co_kwonlyargcount)  <span class="comment"># 2</span></span><br></pre></td></tr></table></figure>

<p><strong>这里是d和e，它们必须通过关键字参数传递。</strong></p>
<p>​        <strong>co_nlocals：代码块中局部变量的个数，也包括参数</strong>    </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">a, b, *, c</span>):</span><br><span class="line">    name = <span class="string">&quot;xxx&quot;</span></span><br><span class="line">    age = <span class="number">16</span></span><br><span class="line">    gender = <span class="string">&quot;f&quot;</span></span><br><span class="line">    c = <span class="number">33</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(foo.__code__.co_nlocals)  <span class="comment"># 6</span></span><br></pre></td></tr></table></figure>

<p><strong>局部变量：a、b、c、name、age、gender，所以我们看到在编译成字节码的时候函数内局部变量的个数就已经确定了，因为它是静态存储的。</strong></p>
<p>​        <strong>co_stacksize：执行该段代码块需要的栈空间</strong>    </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">a, b, *, c</span>):</span><br><span class="line">    name = <span class="string">&quot;xxx&quot;</span></span><br><span class="line">    age = <span class="number">16</span></span><br><span class="line">    gender = <span class="string">&quot;f&quot;</span></span><br><span class="line">    c = <span class="number">33</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(foo.__code__.co_stacksize)  <span class="comment"># 1</span></span><br></pre></td></tr></table></figure>

<p><strong>这个不需要关注</strong></p>
<p>​        <strong>co_firstlineno：代码块在对应文件的起始行</strong>    </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">a, b, *, c</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显然是文件的第一行</span></span><br><span class="line"><span class="built_in">print</span>(foo.__code__.co_firstlineno)  <span class="comment"># 1</span></span><br></pre></td></tr></table></figure>

<p><strong>如果函数出现了调用呢？</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    <span class="keyword">return</span> bar</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bar</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(foo().__code__.co_firstlineno)  <span class="comment"># 5</span></span><br></pre></td></tr></table></figure>

<p><strong>如果执行foo，那么会返回函数bar，调用的就是bar函数的字节码，那么得到就是<code>def bar():</code>所在的行数。因为每个函数都有自己独自的命名空间，以及PyCodeObject对象。</strong></p>
<p>​        <strong>co_names：一个元组，保存代码块中不在当前作用域的变量</strong>    </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">c = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="built_in">print</span>(a, b, c)</span><br><span class="line">    d = (<span class="built_in">list</span>, <span class="built_in">int</span>, <span class="built_in">str</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(foo.__code__.co_names)  <span class="comment"># (&#x27;print&#x27;, &#x27;c&#x27;, &#x27;list&#x27;, &#x27;int&#x27;, &#x27;str&#x27;)</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看到print、c、list、int、str都是全局或者内置变量，函数、类也可以看成是变量，它们都不在当前foo函数的作用域中。</strong></p>
<p>​        <strong>co_varnames：一个元组，保存在当前作用域中的变量</strong>    </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">c = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="built_in">print</span>(a, b, c)</span><br><span class="line">    d = (<span class="built_in">list</span>, <span class="built_in">int</span>, <span class="built_in">str</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(foo.__code__.co_varnames)  <span class="comment"># (&#x27;a&#x27;, &#x27;b&#x27;, &#x27;d&#x27;)</span></span><br></pre></td></tr></table></figure>

<p><strong>a、b、d是位于当前foo函数的作用域当中的，所以编译阶段便确定了局部变量是什么。</strong></p>
<p>​        <strong>co_consts：常量池，一个元组对象，保存代码块中的所有常量。</strong>    </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">123</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">a, b</span>):</span><br><span class="line">    c = <span class="string">&quot;abc&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line">    <span class="built_in">print</span>(<span class="literal">True</span>, <span class="literal">False</span>, <span class="built_in">list</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], &#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>&#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&gt;&gt;&gt;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># list不属于常量</span></span><br><span class="line"><span class="built_in">print</span>(foo.__code__.co_consts)  <span class="comment"># (None, &#x27;abc&#x27;, True, False, 1, 2, 3, &#x27;a&#x27;, &#x27;&gt;&gt;&gt;&#x27;)</span></span><br></pre></td></tr></table></figure>

<p><strong>co_consts里面出现的都是常量，而<code>[1, 2, 3]</code>和<code>&#123;&quot;a&quot;: 1&#125;</code>，则是将里面元素单独拿出来了。不过可能有人好奇里面的None是从哪里来的。首先a和b是不是函数的参数啊，所以co_consts里面还要有两个常量，但是我们还没传参呢，所以使用None来代替。</strong></p>
<p>​        <strong>co_freevars：内层函数引用的外层函数的作用域中的变量</strong>    </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>():</span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">    b = <span class="number">2</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f2</span>():</span><br><span class="line">        <span class="built_in">print</span>(a)</span><br><span class="line">    <span class="keyword">return</span> f2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里调用的是f2的字节码</span></span><br><span class="line"><span class="built_in">print</span>(f1().__code__.co_freevars)  <span class="comment"># (&#x27;a&#x27;,)</span></span><br></pre></td></tr></table></figure>

<p>​        <strong>co_cellvars：外层函数中作用域中被内层函数引用的变量，本质上和co_freevars是一样的</strong>    </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>():    </span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">    b = <span class="number">2</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f2</span>():</span><br><span class="line">        <span class="built_in">print</span>(a)</span><br><span class="line">    <span class="keyword">return</span> f2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 但这里调用的是f1的字节码</span></span><br><span class="line"><span class="built_in">print</span>(f1.__code__.co_cellvars)  <span class="comment"># (&#x27;a&#x27;,)</span></span><br></pre></td></tr></table></figure>

<p>​        <strong>co_filename：代码块所在的文件名</strong>    </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(foo.__code__.co_filename)  <span class="comment"># D:/satori/1.py</span></span><br></pre></td></tr></table></figure>

<p>​        <strong>co_name：代码块的名字，通常是函数名或者类名</strong>    </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(foo.__code__.co_name)  <span class="comment"># foo</span></span><br></pre></td></tr></table></figure>

<p>​        <strong>co_code：字节码</strong>    </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">a, b, /, c, *, d, e</span>):</span><br><span class="line">    f = <span class="number">123</span></span><br><span class="line">    g = <span class="built_in">list</span>()</span><br><span class="line">    g.extend([<span class="built_in">tuple</span>, <span class="built_in">getattr</span>, <span class="built_in">print</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(foo.__code__.co_code)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">b&#x27;d\x01&#125;\x05t\x00\x83\x00&#125;\x06|\x06\xa0\x01t\x02t\x03t\x04g\x03\xa1\x01\x01\x00d\x00S\x00&#x27;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 这便是字节码, 当然单单是这些字节码肯定不够的, 所以还需要其它的静态信息</span></span><br><span class="line"><span class="comment"># 其它的信息显然连同字节码一样, 都位于PyCodeObject中</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># co_lnotab: 字节码指令与python源代码的行号之间的对应关系，以PyByteObject的形式存在</span></span><br><span class="line"><span class="built_in">print</span>(foo.__code__.co_lnotab)  <span class="comment"># b&#x27;\x00\x01\x04\x01\x06\x01&#x27;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">然而事实上，Python不会直接记录这些信息，而是会记录增量值。比如说：</span></span><br><span class="line"><span class="string">字节码在co_code中的偏移量            .py文件中源代码的行号</span></span><br><span class="line"><span class="string">0                                  1  </span></span><br><span class="line"><span class="string">6                                  2</span></span><br><span class="line"><span class="string">50                                 7</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">那么co_lnotab就应该是: 0 1 6 1 44 5</span></span><br><span class="line"><span class="string">0和1很好理解, 就是co_code和.py文件的起始位置</span></span><br><span class="line"><span class="string">而6和1表示字节码的偏移量是6, .py文件的行号增加了1</span></span><br><span class="line"><span class="string">而44和5表示字节码的偏移量是44, .py文件的行号增加了5</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="pyc文件"><a href="#pyc文件" class="headerlink" title="pyc文件"></a>pyc文件</h4><p><strong>每一个PyCodeObject对象中都包含了一个co_code指针，指向code block中所有代码经过编译后得到的byte  code序列。前面我们说到，Python会将字节码序列和PyCodeObject对象一起存储在pyc文件中。但不幸的是，事实并不总是这样。有时，当我们运行一个简单的程序时并没有产生pyc文件，因此我们猜测：有些python程序只是临时完成一些琐碎的工作，这样的程序仅仅只会运行一次，然后就不会再使用了，因此也就没有保存至pyc文件的必要。</strong></p>
<p><strong>如果我们在代码中加上了一个import  abc这样语句，再执行你就会发现Python为其生成了pyc文件，这就说明import会触发pyc的生成。实际上，在运行过程中，如果碰到import  abc这样的语句，那么Python会在设定好的path中寻找abc.pyc或者abc.dll文件，如果没有这些文件，而是只发现了abc.py，那么Python会先将abc.py编译成PyCodeObject，然后创建pyc文件，并将PyCodeObject写到pyc文件里面去。接下来，再对abc.pyc进行import动作，对，并不是编译成PyCodeObject对象之后直接使用，而是先写到pyc里面去，然后将pyc文件的PyCodeObject对象重新在内存中复制出来。</strong></p>
<p><font color="red"><strong>关于python的import机制，我们后面章节会剖析，这里只是用来完成pyc文件的触发。当然得到pyc文件有很多方法，比如使用py_compile模块。</strong></font></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># a.py</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line"><span class="comment"># b.py</span></span><br><span class="line"><span class="keyword">import</span> a</span><br></pre></td></tr></table></figure>

<p><strong>执行b.py的时候，会发现创建了a.cpython-38.pyc。另外关于pyc文件的创建位置，会在当前文件的同级目录下的<code>__pycache__</code>目录中创建，名字就叫做：py文件名.cpython-版本号.pyc</strong></p>
<h4 id="通过compile获取PyCodeObject对象"><a href="#通过compile获取PyCodeObject对象" class="headerlink" title="通过compile获取PyCodeObject对象"></a>通过compile获取PyCodeObject对象</h4><p><strong>事实上我们已经介绍了一种方法去获取相应的PyCodeObject对象，但是还有没有其他的方法呢？答案是通过内置函数compile，但是在介绍compile之前，先介绍一下eval和exec。</strong></p>
<p>​        <strong>eval：传入一个字符串，然后把字符串里面的内容拿出来。</strong>    </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line"><span class="comment"># 所以eval(&quot;a&quot;)就等价于a</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">eval</span>(<span class="string">&quot;a&quot;</span>))  <span class="comment"># 1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">eval</span>(<span class="string">&quot;1 + 1 + 1&quot;</span>))  <span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意：eval是有返回值的，返回值就是字符串里面内容。</span></span><br><span class="line"><span class="comment"># 或者说eval是可以作为右值的，比如a = eval(&quot;xxx&quot;)</span></span><br><span class="line"><span class="comment"># 所以eval里面绝不可以出现诸如赋值之类的，比如 print(eval(&quot;a = 3&quot;))，那么这个语句等价于print(a = 3)，这样显然会出现语法错误的</span></span><br><span class="line"><span class="comment"># 因此eval里面把字符串剥掉之后就是一个普通的值，不可以出现诸如if、def等语句</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">eval</span>(<span class="string">&quot;xxx&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> NameError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># name &#x27;xxx&#x27; is not defined</span></span><br></pre></td></tr></table></figure>

<p>​        <strong>exec：传入一个字符串，把字符串里面的内容当成语句来执行，这个是没有返回值，或者说返回值是None。</strong>    </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exec</span>(<span class="string">&quot;a = 1&quot;</span>)  <span class="comment"># 等价于把a = 1这个字符串里面的内容当成语句来执行</span></span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># 1</span></span><br><span class="line"></span><br><span class="line">statement = <span class="string">&quot;&quot;&quot;a = 123</span></span><br><span class="line"><span class="string">if a == 123:</span></span><br><span class="line"><span class="string">    print(&quot;a等于123&quot;)</span></span><br><span class="line"><span class="string">else:</span></span><br><span class="line"><span class="string">    print(&quot;a不等于123&quot;)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">exec</span>(statement)  <span class="comment"># a等于123</span></span><br><span class="line"><span class="comment"># 注意：&#x27;a等于123&#x27;并不是exec返回的，而是把上面那坨字符串当成普通代码执行的时候print出来的</span></span><br><span class="line"><span class="comment"># 这便是exec的作用。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 那么它和eval的区别就显而易见的，eval是要求字符串里面的内容能够当成一个值来打印，返回值就是里面的值</span></span><br><span class="line"><span class="comment"># 而exec则是直接执行里面的内容</span></span><br><span class="line"><span class="comment"># 举个例子</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">eval</span>(<span class="string">&quot;1 + 1&quot;</span>))  <span class="comment"># 2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">exec</span>(<span class="string">&quot;1 + 1&quot;</span>))  <span class="comment"># None</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exec</span>(<span class="string">&quot;a = 1 + 1&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">eval</span>(<span class="string">&quot;a = 1 + 1&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> SyntaxError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># invalid syntax (&lt;string&gt;, line 1)</span></span><br></pre></td></tr></table></figure>

<p>​        <strong>compile：关键来了，它执行后返回的就是一个code对象</strong>    </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">statement = <span class="string">&quot;a, b = 1, 2&quot;</span></span><br><span class="line"><span class="comment"># 参数一：代码</span></span><br><span class="line"><span class="comment"># 参数二：可以为这些代码起一个文件名</span></span><br><span class="line"><span class="comment"># 参数三：执行方式,可以选择三种方式。exec: 将源码当做一个模块来编译;single: 用于编译一个单独d的Python语句(交互式下);eval:用于编译一个eval表达式</span></span><br><span class="line"><span class="comment"># 这里显然是exec</span></span><br><span class="line">co = <span class="built_in">compile</span>(statement, <span class="string">&quot;夏色祭&quot;</span>, <span class="string">&quot;exec&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(co.co_firstlineno)  <span class="comment"># 1</span></span><br><span class="line"><span class="built_in">print</span>(co.co_filename)  <span class="comment"># 夏色祭</span></span><br><span class="line"><span class="built_in">print</span>(co.co_argcount)  <span class="comment"># 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里是一个元组，因为我们是a, b = 1, 2这种方式赋值的，所以加载的是一个元组</span></span><br><span class="line"><span class="built_in">print</span>(co.co_consts)  <span class="comment"># ((1, 2), None)</span></span><br><span class="line"></span><br><span class="line">statement = <span class="string">&quot;a = 1;b = 2&quot;</span></span><br><span class="line">co = <span class="built_in">compile</span>(statement, <span class="string">&quot;夏色祭&quot;</span>, <span class="string">&quot;exec&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(co.co_consts)  <span class="comment"># (1, 2, None)</span></span><br><span class="line"><span class="built_in">print</span>(co.co_names)  <span class="comment"># (&#x27;a&#x27;, &#x27;b&#x27;)</span></span><br></pre></td></tr></table></figure>

<p><strong>我们后面在分析PyCodeObject的时候，会经常使用compile的方式。</strong></p>
<h3 id="pyc文件的生成"><a href="#pyc文件的生成" class="headerlink" title="pyc文件的生成"></a>pyc文件的生成</h3><h4 id="创建pyc文件的具体过程"><a href="#创建pyc文件的具体过程" class="headerlink" title="创建pyc文件的具体过程"></a>创建pyc文件的具体过程</h4><p><strong>前面我们提到，Python通过import  module进行加载时，如果没有找到相应的pyc或者dll文件，就会在py文件的基础上自动创建pyc文件。所以想要了解pyc文件是怎么创建的，只需要了解PyCodeObject是如何写入的即可。关于写入pyc文件，主要写入三个内容：</strong></p>
<p>​        <strong>1. magic number</strong>    </p>
<p><strong>这是Python定义的一个整数值，不同版本的Python会定义不同的magic  number，这个值是为了保证Python能够加载正确的pyc。比如Python3.7不会加载3.6版本的pyc，因为Python在加载这个pyc文件的时候会首先检测该pyc的magic number，如果和自身的magic number不一致，则拒绝加载。</strong></p>
<p>​        <strong>2. pyc的创建时间</strong>    </p>
<p><strong>这个很好理解，因为编译完之后要是把源代码修改了怎么办呢？因此会判断源代码的最后修改时间和pyc文件的创建时间，如果pyc文件的创建时间比源代码修改时间要早，说明在生成pyc之后，源代码被修改了，那么会重新编译新的pyc，而反之则会直接加载pyc。</strong></p>
<p>​        <strong>3.PyCodeObject对象</strong>    </p>
<p><strong>这个不用说了，肯定是要存储的。当然还有字节码，不过PyCodeObject里面的co_code指向了这个字节码，所以我们就直接说PyCodeObject对象了。</strong></p>
<h4 id="文件的写入"><a href="#文件的写入" class="headerlink" title="文件的写入"></a>文件的写入</h4><p><strong>既然要写入，那么肯定要有文件句柄，我们来看看：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//位置：Python/marshal.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//FILE是一个文件句柄，可以把WFILE看成是FILE的包装</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    FILE *fp;  <span class="comment">//文件句柄</span></span><br><span class="line">    <span class="comment">//下面的字段在写入信息的时候会看到</span></span><br><span class="line">    <span class="type">int</span> error;  </span><br><span class="line">    <span class="type">int</span> depth;</span><br><span class="line">    PyObject *str;</span><br><span class="line">    <span class="type">char</span> *ptr;</span><br><span class="line">    <span class="type">char</span> *end;</span><br><span class="line">    <span class="type">char</span> *buf;</span><br><span class="line">    _Py_hashtable_t *hashtable;</span><br><span class="line">    <span class="type">int</span> version;</span><br><span class="line">&#125; WFILE;</span><br></pre></td></tr></table></figure>

<p><strong>写入magic number和时间：</strong></p>
<p><strong>写入magic number和时间都是调用了<code>PyMarshal_WriteLongToFile</code>，我们来看看长什么样子。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">PyMarshal_WriteLongToFile</span><span class="params">(<span class="type">long</span> x, FILE *fp, <span class="type">int</span> version)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//声明char型的数组，元素个数为4个</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">4</span>];</span><br><span class="line">    <span class="comment">//声明一个WFILE类型变量wf</span></span><br><span class="line">    WFILE wf;</span><br><span class="line">    <span class="comment">//内存初始化</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;wf, <span class="number">0</span>, <span class="keyword">sizeof</span>(wf));</span><br><span class="line">    <span class="comment">//设置fp，文件句柄</span></span><br><span class="line">    wf.fp = fp;</span><br><span class="line">    <span class="comment">//将buf数组的指针赋值给wf.ptr和wf.buf</span></span><br><span class="line">    wf.ptr = wf.buf = buf;</span><br><span class="line">    <span class="comment">//相当于buf的最后一个元素的指针</span></span><br><span class="line">    wf.end = wf.ptr + <span class="keyword">sizeof</span>(buf);</span><br><span class="line">    <span class="comment">//写错误</span></span><br><span class="line">    wf.error = WFERR_OK;</span><br><span class="line">    <span class="comment">//写入版本信息</span></span><br><span class="line">    wf.version = version;</span><br><span class="line">    <span class="comment">//调用w_long将x也就是版本信息或者时间写到wf里面去</span></span><br><span class="line">    w_long(x, &amp;wf);</span><br><span class="line">    <span class="comment">//刷到磁盘上</span></span><br><span class="line">    w_flush(&amp;wf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//所以我们看到这一步只是初始化一个WFILE对象，真正写入则是调用w_long</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">w_long</span><span class="params">(<span class="type">long</span> x, WFILE *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    w_byte((<span class="type">char</span>)( x      &amp; <span class="number">0xff</span>), p);</span><br><span class="line">    w_byte((<span class="type">char</span>)((x&gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>), p);</span><br><span class="line">    w_byte((<span class="type">char</span>)((x&gt;&gt;<span class="number">16</span>) &amp; <span class="number">0xff</span>), p);</span><br><span class="line">    w_byte((<span class="type">char</span>)((x&gt;&gt;<span class="number">24</span>) &amp; <span class="number">0xff</span>), p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//w_long则是将要写入的x一个字节一个字节写到文件里面去。</span></span><br></pre></td></tr></table></figure>

<p><strong>写入PyCodeObject对象：</strong></p>
<p><strong>写入PyCodeObject对象则是调用了<code>PyMarshal_WriteObjectToFile</code>，我们也来看看长什么样子。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">PyMarshal_WriteObjectToFile</span><span class="params">(PyObject *x, FILE *fp, <span class="type">int</span> version)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[BUFSIZ];</span><br><span class="line">    WFILE wf;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;wf, <span class="number">0</span>, <span class="keyword">sizeof</span>(wf));</span><br><span class="line">    wf.fp = fp;</span><br><span class="line">    wf.ptr = wf.buf = buf;</span><br><span class="line">    wf.end = wf.ptr + <span class="keyword">sizeof</span>(buf);</span><br><span class="line">    wf.error = WFERR_OK;</span><br><span class="line">    wf.version = version;</span><br><span class="line">    <span class="keyword">if</span> (w_init_refs(&amp;wf, version))</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">/* caller mush check PyErr_Occurred() */</span></span><br><span class="line">    w_object(x, &amp;wf);</span><br><span class="line">    w_clear_refs(&amp;wf);</span><br><span class="line">    w_flush(&amp;wf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可以看到，和PyMarshal_WriteLongToFile基本是类似的</span></span><br><span class="line"><span class="comment">//只不过PyMarshal_WriteLongToFile调用的是w_long，而PyMarshal_WriteObjectToFile调用的是w_object</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">w_object</span><span class="params">(PyObject *v, WFILE *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> flag = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    p-&gt;depth++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p-&gt;depth &gt; MAX_MARSHAL_STACK_DEPTH) &#123;</span><br><span class="line">        p-&gt;error = WFERR_NESTEDTOODEEP;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (v == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        w_byte(TYPE_NULL, p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (v == Py_None) &#123;</span><br><span class="line">        w_byte(TYPE_NONE, p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (v == PyExc_StopIteration) &#123;</span><br><span class="line">        w_byte(TYPE_STOPITER, p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (v == Py_Ellipsis) &#123;</span><br><span class="line">        w_byte(TYPE_ELLIPSIS, p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (v == Py_False) &#123;</span><br><span class="line">        w_byte(TYPE_FALSE, p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (v == Py_True) &#123;</span><br><span class="line">        w_byte(TYPE_TRUE, p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!w_ref(v, &amp;flag, p))</span><br><span class="line">        w_complex_object(v, flag, p);</span><br><span class="line"></span><br><span class="line">    p-&gt;depth--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>可以看到本质上还是调用了w_byte，但是在这里面我们并没有看到诸如：列表、元组之类的数据的存储过程，注意最后的w_complex_object，关键来了。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//源代码很长, 具体逻辑就不贴了</span></span><br><span class="line"><span class="comment">//我们后面会单独截取一部分	进行分析</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">w_complex_object</span><span class="params">(PyObject *v, <span class="type">char</span> flag, WFILE *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    Py_ssize_t i, n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PyLong_CheckExact(v)) &#123;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (PyFloat_CheckExact(v)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;version &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//......</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//......</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (PyComplex_CheckExact(v)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;version &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//......</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//......</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (PyBytes_CheckExact(v)) &#123;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (PyUnicode_CheckExact(v)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;version &gt;= <span class="number">4</span> &amp;&amp; PyUnicode_IS_ASCII(v)) &#123;</span><br><span class="line">            	<span class="comment">//......</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//......</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//......</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (PyTuple_CheckExact(v)) &#123;</span><br><span class="line">       <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (PyList_CheckExact(v)) &#123;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (PyDict_CheckExact(v)) &#123;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (PyAnySet_CheckExact(v)) &#123;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (PyCode_Check(v)) &#123;</span><br><span class="line">        PyCodeObject *co = (PyCodeObject *)v;</span><br><span class="line">        W_TYPE(TYPE_CODE, p);</span><br><span class="line">        w_long(co-&gt;co_argcount, p);</span><br><span class="line">        w_long(co-&gt;co_kwonlyargcount, p);</span><br><span class="line">        w_long(co-&gt;co_nlocals, p);</span><br><span class="line">        w_long(co-&gt;co_stacksize, p);</span><br><span class="line">        w_long(co-&gt;co_flags, p);</span><br><span class="line">        w_object(co-&gt;co_code, p);</span><br><span class="line">        w_object(co-&gt;co_consts, p);</span><br><span class="line">        w_object(co-&gt;co_names, p);</span><br><span class="line">        w_object(co-&gt;co_varnames, p);</span><br><span class="line">        w_object(co-&gt;co_freevars, p);</span><br><span class="line">        w_object(co-&gt;co_cellvars, p);</span><br><span class="line">        w_object(co-&gt;co_filename, p);</span><br><span class="line">        w_object(co-&gt;co_name, p);</span><br><span class="line">        w_long(co-&gt;co_firstlineno, p);</span><br><span class="line">        w_object(co-&gt;co_lnotab, p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (PyObject_CheckBuffer(v)) &#123;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        W_TYPE(TYPE_UNKNOWN, p);</span><br><span class="line">        p-&gt;error = WFERR_UNMARSHALLABLE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><font color="red"><strong>源代码很长，这里就不一一分析了，可以自行查看。不过虽然长，但是逻辑很简单，就是对不同的对象、执行不同的写动作。然而其最终目的都是通过w_byte写到pyc文件中。换句话说，Python在往pyc写入list对象时，只是将list中包含的数值或者字符串等对象写到了pyc文件中。同时这也意味着，Python在加载pyc文件时，必须基于这些数值或字符串重新构造出list对象。</strong></font></p>
<p><strong>对于PyCodeObject对象，很显然，w_object会遍历PyCodeObject中的所有域，将这些域依次写入。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">PyCodeObject *co = (PyCodeObject *)v;</span><br><span class="line">        W_TYPE(TYPE_CODE, p);</span><br><span class="line">        w_long(co-&gt;co_argcount, p);</span><br><span class="line">        w_long(co-&gt;co_kwonlyargcount, p);</span><br><span class="line">        w_long(co-&gt;co_nlocals, p);</span><br><span class="line">        w_long(co-&gt;co_stacksize, p);</span><br><span class="line">        w_long(co-&gt;co_flags, p);</span><br><span class="line">        w_object(co-&gt;co_code, p);</span><br><span class="line">        w_object(co-&gt;co_consts, p);</span><br><span class="line">        w_object(co-&gt;co_names, p);</span><br><span class="line">        w_object(co-&gt;co_varnames, p);</span><br><span class="line">        w_object(co-&gt;co_freevars, p);</span><br><span class="line">        w_object(co-&gt;co_cellvars, p);</span><br><span class="line">        w_object(co-&gt;co_filename, p);</span><br><span class="line">        w_object(co-&gt;co_name, p);</span><br><span class="line">        w_long(co-&gt;co_firstlineno, p);</span><br><span class="line">        w_object(co-&gt;co_lnotab, p);</span><br></pre></td></tr></table></figure>

<p><strong>但是当面对一个PyListObject对象时，会有什么变化呢？没错，会和PyCodeObject一样，w_object还是会遍历，然后将PyListObject对象中的每一个元素依次写入到pyc文件中。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以看到PyTupleObject、PyListObject、PyDictObject都是采用了相同的姿势</span></span><br><span class="line"><span class="comment">//注意里面的W_TYPE</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (PyTuple_CheckExact(v)) &#123;</span><br><span class="line">        n = PyTuple_Size(v);</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;version &gt;= <span class="number">4</span> &amp;&amp; n &lt; <span class="number">256</span>) &#123;</span><br><span class="line">            W_TYPE(TYPE_SMALL_TUPLE, p);</span><br><span class="line">            w_byte((<span class="type">unsigned</span> <span class="type">char</span>)n, p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            W_TYPE(TYPE_TUPLE, p);</span><br><span class="line">            W_SIZE(n, p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            w_object(PyTuple_GET_ITEM(v, i), p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (PyList_CheckExact(v)) &#123;</span><br><span class="line">        W_TYPE(TYPE_LIST, p);</span><br><span class="line">        n = PyList_GET_SIZE(v);</span><br><span class="line">        W_SIZE(n, p);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            w_object(PyList_GET_ITEM(v, i), p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (PyDict_CheckExact(v)) &#123;</span><br><span class="line">        Py_ssize_t pos;</span><br><span class="line">        PyObject *key, *value;</span><br><span class="line">        W_TYPE(TYPE_DICT, p);</span><br><span class="line">        <span class="comment">/* This one is NULL object terminated! */</span></span><br><span class="line">        pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (PyDict_Next(v, &amp;pos, &amp;key, &amp;value)) &#123;</span><br><span class="line">            w_object(key, p);</span><br><span class="line">            w_object(value, p);</span><br><span class="line">        &#125;</span><br><span class="line">        w_object((PyObject *)<span class="literal">NULL</span>, p);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们看到无论对于哪一个对象，在写入之前，都会先调用W_TYPE写一个类似于类型的东西，是的，诸如TYPE_LIST、TYPE_TUPLE、TYPE_DICT这样的标识，对于pyc文件的加载起着至关重要的作用。</strong></p>
<p><strong>之前说过，Python仅仅将容器里面的数值和字符串写入到pyc文件。当PyCodeObject写入到pyc之后，所有的数据就变成了字节流，类型信息就丢失了。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从当前来看，常量池中没有任何关于列表的信息</span></span><br><span class="line"><span class="built_in">print</span>(func.__code__.co_consts)  <span class="comment"># (None, 1, 2, 3)</span></span><br></pre></td></tr></table></figure>

<p><strong>然鹅如果没有类型信息，那么当python再次加载pyc文件的时候，就没办法知道字节流中隐藏的结构和蕴含的信息，所以Python必须往pyc文件写入一个标识，这些标识正是Python定义的类型信息。如果Python在pyc中发现了这样的标识，则预示着上一个对象结束，新的对象开始，并且也知道新对象是什么样的对象，从而也知道该执行什么样的加载动作，这些标识也是可以看到的。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//marshal.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_NULL               <span class="string">&#x27;0&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_NONE               <span class="string">&#x27;N&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_FALSE              <span class="string">&#x27;F&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_TRUE               <span class="string">&#x27;T&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_STOPITER           <span class="string">&#x27;S&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_ELLIPSIS           <span class="string">&#x27;.&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_INT                <span class="string">&#x27;i&#x27;</span></span></span><br><span class="line"><span class="comment">/* TYPE_INT64 is not generated anymore.</span></span><br><span class="line"><span class="comment">   Supported for backward compatibility only. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_INT64              <span class="string">&#x27;I&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_FLOAT              <span class="string">&#x27;f&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_BINARY_FLOAT       <span class="string">&#x27;g&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_COMPLEX            <span class="string">&#x27;x&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_BINARY_COMPLEX     <span class="string">&#x27;y&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_LONG               <span class="string">&#x27;l&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_STRING             <span class="string">&#x27;s&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_INTERNED           <span class="string">&#x27;t&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_REF                <span class="string">&#x27;r&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_TUPLE              <span class="string">&#x27;(&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_LIST               <span class="string">&#x27;[&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_DICT               <span class="string">&#x27;&#123;&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_CODE               <span class="string">&#x27;c&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_UNICODE            <span class="string">&#x27;u&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_UNKNOWN            <span class="string">&#x27;?&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_SET                <span class="string">&#x27;&lt;&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_FROZENSET          <span class="string">&#x27;&gt;&#x27;</span></span></span><br></pre></td></tr></table></figure>

<p><strong>到了这里可以看到，其实Python对于PyCodeObject对象的导出实际上是不复杂的，因为不管什么对象，最后都为归结为两种简单的形式，一种是数值写入，一种是字符串写入。上面都是对数值的写入，比较简单，仅仅需要按照字节一次写入pyc即可。然而在写入字符串的时候，Python设计了一种比较复杂的机制，有兴趣可以自己阅读源码，这里不再介绍。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># a.py</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p><strong>我们之前说对于这样的一个py文件，会创建三个PyCodeObject对象，但是写到pyc文件里面的只有一个PyCodeObject对象，这难道不就意味着有两个PyCodeObject丢失了吗？其实很明显，有两个PyCodeObject对象是位于另一个PyCodeObject对象当中的。因此foo和A对应的PyCodeObject对象位于a.py这个PyCodeObject对象当中，准确的说是位于co_consts指向的常量池当中。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f2</span>():</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(f1.__code__.co_consts)</span><br><span class="line"><span class="comment"># (None, &lt;code object f2 at 0x000001BC5DF3D450, file &quot;D:/satori/1.py&quot;, line 2&gt;, &#x27;f1.&lt;locals&gt;.f2&#x27;)</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看到f2对应的PyCodeObject确实位于f1的常量池当中，但其实说白了不过f1的常量池当中有一个指针在指向f2对应PyCodeObject罢了。只不过在写入的时候，也会把指针的内容一块写进去，所以也可以理解就是写了3个PyCodeObject对象。不过这都不是重点，重点是PyCodeObject对象是可以嵌套的，当在一个作用域内部发现了一个新的作用域，那么新的作用域对应的PyCodeObject对象会位于外层作用域的PyCodeObject对象的常量池中，或者说被常量池中的一个指针指向。</strong></p>
<p><strong>而在写入pyc的时候会从最外层、也就是模块的PyCodeObject对象开始写入，如果碰到了包含的另一个PyCodeObject对象，那么就会递归地执行写入新的PyCodeObject对象的操作。如此下去，最终所有的PyCodeObject对象都会写入到pyc文件当中，因此pyc文件当中的PyCodeObject对象也是以一种嵌套的关系联系在一起的。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bar</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bar</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p><strong>这里问一下，上面那段代码中创建了几个PyCodeObject对象呢？</strong></p>
<blockquote>
<p><strong>答案是6个，首先全局是一个，foo函数一个，bar函数一个，类A一个，类A里面的foo函数一个，类A里面的bar函数一个，所以一共是6个。</strong></p>
<p><strong>而且这里的PyCodeObject对象是层层嵌套的，一开始是对整个全局创建PyCodeObject对象，然后遇到了函数foo，那么再为函数foo创建一个PyCodeObject对象，依次往下。所以如果是常量值、字符串等等，则相当于是静态信息，直接存储起来便可；可如果是函数、类，那么会为其创建新的PyCodeObject对象，然后收集起来，所以A里面的foo函数对应的PyCodeObject对象是存在A对应PyCodeObject对象里面的；而A对应的PyCodeObject对象则是存在全局对应的PyCodeObject对象里面，当然此时还有外层的foo、bar函数。。</strong></p>
</blockquote>
<h3 id="Python的字节码与反编译"><a href="#Python的字节码与反编译" class="headerlink" title="Python的字节码与反编译"></a>Python的字节码与反编译</h3><p><strong>关于Python的字节码，是后面章节剖析虚拟机的重点，现在先来看一下。我们知道Python执行源代码之前会对其进行编译得到PyCodeObject对象，里面的co_code指向了字节码序列，Python虚拟机会根据这些字节码序列来进行一系列的操作<code>(当然也依赖其它的静态信息)</code>，从而完成对程序的执行。</strong></p>
<p><strong>当然每一个操作在python中都对应一个操作指令、或者操作数，总共一共定义了121个。其实说白了每个指令不过是一个整数罢了。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> POP_TOP                   1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ROT_TWO                   2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ROT_THREE                 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DUP_TOP                   4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DUP_TOP_TWO               5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NOP                       9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNARY_POSITIVE           10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNARY_NEGATIVE           11</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNARY_NOT                12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNARY_INVERT             15</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BINARY_MATRIX_MULTIPLY   16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INPLACE_MATRIX_MULTIPLY  17</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BINARY_POWER             19</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BINARY_MULTIPLY          20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BINARY_MODULO            22</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BINARY_ADD               23</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BINARY_SUBTRACT          24</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BINARY_SUBSCR            25</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BINARY_FLOOR_DIVIDE      26</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BINARY_TRUE_DIVIDE       27</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INPLACE_FLOOR_DIVIDE     28</span></span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><strong>然后我们可以通过反编译的方式查看一下：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python中的dis模块是专门干这件事情</span></span><br><span class="line"><span class="keyword">import</span> dis</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">a, b</span>):</span><br><span class="line">    c = a + b</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 里面可以接收一个字节码对象, 当然函数也是可以的, 会自动获取co_code</span></span><br><span class="line">dis.dis(foo)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">  5           0 LOAD_FAST                0 (a)</span></span><br><span class="line"><span class="string">              2 LOAD_FAST                1 (b)</span></span><br><span class="line"><span class="string">              4 BINARY_ADD</span></span><br><span class="line"><span class="string">              6 STORE_FAST               2 (c)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  6           8 LOAD_FAST                2 (c)</span></span><br><span class="line"><span class="string">             10 RETURN_VALUE</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>字节码反编译后的结果多么像汇编语言！其中，第一列是源代码行号，第二列是字节码偏移量，第三列是操作数。</strong></p>
<p><strong>关于反编译的内容，我们会在剖析函数的时候，深入介绍。</strong></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Lin Li</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/03/29/10-PyCodeObject%E5%AF%B9%E8%B1%A1%E5%92%8Cpyc%E6%96%87%E4%BB%B6/">http://example.com/2023/03/29/10-PyCodeObject%E5%AF%B9%E8%B1%A1%E5%92%8Cpyc%E6%96%87%E4%BB%B6/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">LinLi's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/CPython/">CPython</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/03/29/11-%E6%8E%A2%E7%B4%A2Python%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%92%8C%E5%AD%97%E8%8A%82%E7%A0%81%E7%9A%84%E5%A5%A5%E7%A7%98/" title="11-探索Python虚拟机和字节码的奥秘"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">11-探索Python虚拟机和字节码的奥秘</div></div></a></div><div class="next-post pull-right"><a href="/2023/03/29/09-%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/" title="09-字典和集合的底层实现"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">09-字典和集合的底层实现</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/03/29/01-%E7%BC%96%E8%AF%91Cpython/" title="01-编译Cpython"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">01-编译Cpython</div></div></a></div><div><a href="/2023/03/29/02-%E4%B8%80%E5%88%87%E5%AF%B9%E8%B1%A1%E7%9A%86PyObject/" title="02-一切对象皆PyObject"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">02-一切对象皆PyObject</div></div></a></div><div><a href="/2023/03/29/04-%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/" title="04-浮点数的底层实现"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">04-浮点数的底层实现</div></div></a></div><div><a href="/2023/03/29/06-Bytes%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BA%95%E5%B1%82%E6%93%8D%E4%BD%9C/" title="06-Bytes对象的底层操作"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">06-Bytes对象的底层操作</div></div></a></div><div><a href="/2023/03/29/03-Python%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E5%99%A8%E5%92%8C%E5%BA%95%E5%B1%82%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86/" title="03-Python引用计数器和底层对象管理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">03-Python引用计数器和底层对象管理</div></div></a></div><div><a href="/2023/03/29/05-Python%E6%95%B4%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/" title="05-Python整数的底层实现"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">05-Python整数的底层实现</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Lin Li</div><div class="author-info__description">今日事，今日毕</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">75</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#10-Python%E4%B8%AD%E7%9A%84PyCodeObject%E5%AF%B9%E8%B1%A1%E4%B8%8Epyc%E6%96%87%E4%BB%B6"><span class="toc-number">1.</span> <span class="toc-text">10-Python中的PyCodeObject对象与pyc文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A5%94%E5%AD%90"><span class="toc-number">1.1.</span> <span class="toc-text">楔子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Python%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E7%BC%96%E8%AF%91%E7%BB%93%E6%9E%9C%E2%80%93PyCodeObject%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.2.</span> <span class="toc-text">Python编译器的编译结果–PyCodeObject对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#PyCodeObject%E5%AF%B9%E8%B1%A1%E5%92%8Cpyc%E6%96%87%E4%BB%B6"><span class="toc-number">1.2.1.</span> <span class="toc-text">PyCodeObject对象和pyc文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#python%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84PyCodeObject%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.2.2.</span> <span class="toc-text">python源码中的PyCodeObject对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%9C%A8Python%E4%B8%AD%E8%AE%BF%E9%97%AEPyCodeObject%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.2.3.</span> <span class="toc-text">如何在Python中访问PyCodeObject对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pyc%E6%96%87%E4%BB%B6"><span class="toc-number">1.2.4.</span> <span class="toc-text">pyc文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87compile%E8%8E%B7%E5%8F%96PyCodeObject%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.2.5.</span> <span class="toc-text">通过compile获取PyCodeObject对象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pyc%E6%96%87%E4%BB%B6%E7%9A%84%E7%94%9F%E6%88%90"><span class="toc-number">1.3.</span> <span class="toc-text">pyc文件的生成</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BApyc%E6%96%87%E4%BB%B6%E7%9A%84%E5%85%B7%E4%BD%93%E8%BF%87%E7%A8%8B"><span class="toc-number">1.3.1.</span> <span class="toc-text">创建pyc文件的具体过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E5%86%99%E5%85%A5"><span class="toc-number">1.3.2.</span> <span class="toc-text">文件的写入</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Python%E7%9A%84%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E5%8F%8D%E7%BC%96%E8%AF%91"><span class="toc-number">1.4.</span> <span class="toc-text">Python的字节码与反编译</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/01/22/Testing-Database-Systems-via-Differential-Query-Execution/" title="Testing Database Systems via Differential Query Execution">Testing Database Systems via Differential Query Execution</a><time datetime="2024-01-22T13:12:54.000Z" title="发表于 2024-01-22 21:12:54">2024-01-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/01/15/DynSQL-Stateful-Fuzzing-for-Database-Management-Systems-with-Complex-and-Valid-SQL-Query-Generation/" title="DynSQL: Stateful Fuzzing for Database Management Systems with Complex and Valid SQL Query Generation">DynSQL: Stateful Fuzzing for Database Management Systems with Complex and Valid SQL Query Generation</a><time datetime="2024-01-15T12:34:42.000Z" title="发表于 2024-01-15 20:34:42">2024-01-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/10/21/Detecting-Logical-Bugs-of-DBMS-with-Coverage-based-Guidance/" title="Detecting Logical Bugs of DBMS with Coverage-based Guidance">Detecting Logical Bugs of DBMS with Coverage-based Guidance</a><time datetime="2023-10-21T11:38:31.000Z" title="发表于 2023-10-21 19:38:31">2023-10-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/10/21/Squirrel-Testing-Database-Management-Systems-withLanguage-Validity-and-Coverage-Feedback-%E5%AF%B9%E4%BA%8EDBMS%E7%9A%84%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95%E6%8A%80%E6%9C%AF%E4%BB%8B%E7%BB%8D/" title="Squirrel Testing Database Management Systems withLanguage Validity and Coverage Feedback--对于DBMS的模糊测试技术介绍">Squirrel Testing Database Management Systems withLanguage Validity and Coverage Feedback--对于DBMS的模糊测试技术介绍</a><time datetime="2023-10-21T11:00:32.000Z" title="发表于 2023-10-21 19:00:32">2023-10-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/09/27/LearnedSQLGen-Constraint-aware-SQL-Generation-using-Reinforcement-Learning/" title="LearnedSQLGen Constraint-aware SQL Generation using Reinforcement Learning">LearnedSQLGen Constraint-aware SQL Generation using Reinforcement Learning</a><time datetime="2023-09-27T07:05:56.000Z" title="发表于 2023-09-27 15:05:56">2023-09-27</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Lin Li</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>