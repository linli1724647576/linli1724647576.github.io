<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>09-字典和集合的底层实现 | LinLi's Blog</title><meta name="author" content="Lin Li"><meta name="copyright" content="Lin Li"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="09-解密Python中字典和集合的底层实现，深度分析哈希表楔子Python的字典是一种映射型容器对象，保存了键(key)到值(value)的映射关系。通过字典，我们可以快速的实现值的查找，json这种数据结构也是借鉴了Python中的字典。而且字典在Python中是经过高度优化的，因为Python底层也在大量的使用字典这种数据结构。 那么这次我们就来全面分析一下Python中的字典。 基本使用我">
<meta property="og:type" content="article">
<meta property="og:title" content="09-字典和集合的底层实现">
<meta property="og:url" content="http://example.com/2023/03/29/09-%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/index.html">
<meta property="og:site_name" content="LinLi&#39;s Blog">
<meta property="og:description" content="09-解密Python中字典和集合的底层实现，深度分析哈希表楔子Python的字典是一种映射型容器对象，保存了键(key)到值(value)的映射关系。通过字典，我们可以快速的实现值的查找，json这种数据结构也是借鉴了Python中的字典。而且字典在Python中是经过高度优化的，因为Python底层也在大量的使用字典这种数据结构。 那么这次我们就来全面分析一下Python中的字典。 基本使用我">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2023-03-29T14:40:43.000Z">
<meta property="article:modified_time" content="2023-04-12T02:37:47.961Z">
<meta property="article:author" content="Lin Li">
<meta property="article:tag" content="CPython">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/03/29/09-%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '09-字典和集合的底层实现',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-04-12 10:37:47'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">86</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="LinLi's Blog"><span class="site-name">LinLi's Blog</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">09-字典和集合的底层实现</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-29T14:40:43.000Z" title="发表于 2023-03-29 22:40:43">2023-03-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-04-12T02:37:47.961Z" title="更新于 2023-04-12 10:37:47">2023-04-12</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="09-字典和集合的底层实现"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="09-解密Python中字典和集合的底层实现，深度分析哈希表"><a href="#09-解密Python中字典和集合的底层实现，深度分析哈希表" class="headerlink" title="09-解密Python中字典和集合的底层实现，深度分析哈希表"></a>09-解密Python中字典和集合的底层实现，深度分析哈希表</h2><h3 id="楔子"><a href="#楔子" class="headerlink" title="楔子"></a>楔子</h3><p><strong>Python的字典是一种映射型容器对象，保存了键(key)到值(value)的映射关系。通过字典，我们可以快速的实现值的查找，json这种数据结构也是借鉴了Python中的字典。而且字典在Python中是经过高度优化的，因为Python底层也在大量的使用字典这种数据结构。</strong></p>
<p><strong>那么这次我们就来全面分析一下Python中的字典。</strong></p>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p><strong>我们先来回顾一下字典的基本使用，然后再来分析它的一些特性以及底层实现。</strong></p>
<p><strong>创建一个字典：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个字典</span></span><br><span class="line">d = &#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>, <span class="string">&quot;b&quot;</span>: <span class="number">2</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(d)  <span class="comment"># &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者我们还可以通过dict, 传入关键字参数即可</span></span><br><span class="line">d = <span class="built_in">dict</span>(a=<span class="number">1</span>, b=<span class="number">2</span>, c=<span class="number">3</span>, d=<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(d)  <span class="comment"># &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3, &#x27;d&#x27;: 4&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当然dict里面还可以接收位置参数, 但是最多接收一个</span></span><br><span class="line">d1 = <span class="built_in">dict</span>(&#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>, <span class="string">&quot;b&quot;</span>: <span class="number">2</span>&#125;, c=<span class="number">3</span>, d=<span class="number">4</span>)</span><br><span class="line">d2 = <span class="built_in">dict</span>([(<span class="string">&quot;a&quot;</span>, <span class="number">1</span>), (<span class="string">&quot;b&quot;</span>, <span class="number">2</span>)], c=<span class="number">3</span>, d=<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(d1)  <span class="comment"># &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3, &#x27;d&#x27;: 4&#125;</span></span><br><span class="line"><span class="built_in">print</span>(d2)  <span class="comment"># &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3, &#x27;d&#x27;: 4&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 还可以根据已有字典创建新的字典</span></span><br><span class="line">d = &#123;**&#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>, <span class="string">&quot;b&quot;</span>: <span class="number">2</span>&#125;, <span class="string">&quot;c&quot;</span>: <span class="number">3</span>, **&#123;<span class="string">&quot;d&quot;</span>: <span class="number">4</span>&#125;&#125;</span><br><span class="line"><span class="built_in">print</span>(d)  <span class="comment"># &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3, &#x27;d&#x27;: 4&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当然通过dict也是可以的, 但是注意: 通过**这种方式本质上是把字典变成多个关键字参数</span></span><br><span class="line"><span class="comment"># 所以里面的key一定要符合Python的变量规范</span></span><br><span class="line">d = <span class="built_in">dict</span>(**&#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>, <span class="string">&quot;b&quot;</span>: <span class="number">2</span>&#125;, c=<span class="number">3</span>, **&#123;<span class="string">&quot;d&quot;</span>: <span class="number">4</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(d)  <span class="comment"># &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3, &#x27;d&#x27;: 4&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 这种是不合法的, 因为**&#123;1: 1&#125;等价于1=1</span></span><br><span class="line">    d = <span class="built_in">dict</span>(**&#123;<span class="number">1</span>: <span class="number">1</span>&#125;)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># keywords must be strings</span></span><br><span class="line"><span class="comment"># 但是这种是合法的</span></span><br><span class="line">d = &#123;**&#123;<span class="number">1</span>: <span class="number">1</span>, <span class="number">2</span>: <span class="number">2</span>&#125;, **&#123;(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>): <span class="string">&quot;嘿嘿&quot;</span>&#125;&#125;</span><br><span class="line"><span class="built_in">print</span>(d)  <span class="comment"># &#123;1: 1, 2: 2, (1, 2, 3): &#x27;嘿嘿&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>字典支持的操作：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个空字典</span></span><br><span class="line">d = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以设置键值对</span></span><br><span class="line">d[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;古明地觉&quot;</span></span><br><span class="line">d[<span class="string">&quot;where&quot;</span>] = <span class="string">&quot;东方地灵殿&quot;</span></span><br><span class="line"><span class="built_in">print</span>(d)  <span class="comment"># &#123;&#x27;name&#x27;: &#x27;古明地觉&#x27;, &#x27;where&#x27;: &#x27;东方地灵殿&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取值</span></span><br><span class="line"><span class="built_in">print</span>(d[<span class="string">&quot;name&quot;</span>])  <span class="comment"># 古明地觉</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新值, 字典里面的key是不重复的, 所以不会出现一个字典中有多个key的情况出现</span></span><br><span class="line">d[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;古明地恋&quot;</span></span><br><span class="line"><span class="built_in">print</span>(d)  <span class="comment"># &#123;&#x27;name&#x27;: &#x27;古明地恋&#x27;, &#x27;where&#x27;: &#x27;东方地灵殿&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除一个值, 可以使用del或者pop</span></span><br><span class="line"><span class="keyword">del</span> d[<span class="string">&quot;name&quot;</span>]</span><br><span class="line">d.pop(<span class="string">&quot;where&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(d)  <span class="comment"># &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>当然字典支持的操作远不止上面那些，但是这些Python层面上的东西想必所有人都了如指掌了，因为字典支持的操作，仅仅相当于是一些API的调用罢了，对着文档查一遍、操作一波就完事了。我们重点是要分析字典这种数据结构在底层的实现方式，以及它背后的一些原理，这才是我们需要关注的。</strong></p>
<p><strong>首先字典的底层是借助哈希表实现的，什么是哈希表我们后面会详细说，总之字典的添加元素、删除元素、查找元素等操作的平均时间复杂度是O(1)。当然了，在哈希不均匀的情况下，最坏时间复杂度是O(n)，但是这种情况很少发生。</strong></p>
<p>​        <strong>我们来测试一下字典的执行效率，看看它和列表之间的区别。一个有1千万个键值对的字典。然后对两者使用in来查询某个元素是否存在,</strong>     </p>
<p>​        <strong>我们测试的方式是，使用if … in …来查询一个元素是否存在，看看它们的耗时如何。</strong>    </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">count: <span class="built_in">int</span>, value: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :param count: 循环次数</span></span><br><span class="line"><span class="string">    :param value: 查询的元素</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 有一千万个随机数的列表</span></span><br><span class="line">    lst = <span class="built_in">list</span>(np.random.randint(<span class="number">0</span>, <span class="number">2</span> ** <span class="number">30</span>, size=<span class="number">1000</span>))</span><br><span class="line">    <span class="comment"># 根据这个列表构造出含有一千万个键值对的字典</span></span><br><span class="line">    d = <span class="built_in">dict</span>.fromkeys(lst)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 查询元素value是否在列表中, 循环count次, 并统计时间</span></span><br><span class="line">    t1 = time.perf_counter()</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(count):</span><br><span class="line">        value <span class="keyword">in</span> lst</span><br><span class="line">    t2 = time.perf_counter()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;列表查询耗时:&quot;</span>, <span class="built_in">round</span>(t2 - t1, <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 查询元素value是否在字典中, 循环count次, 并统计时间</span></span><br><span class="line">    t1 = time.perf_counter()</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(count):</span><br><span class="line">        value <span class="keyword">in</span> d</span><br><span class="line">    t2 = time.perf_counter()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;字典查询耗时:&quot;</span>, <span class="built_in">round</span>(t2 - t1, <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分别查询一千次、一万次、十万次、二十万次</span></span><br><span class="line">test(<span class="number">10</span> ** <span class="number">3</span>, <span class="number">22333</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">列表查询耗时: 0.13</span></span><br><span class="line"><span class="string">字典查询耗时: 0.0</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">test(<span class="number">10</span> ** <span class="number">4</span>, <span class="number">22333</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">列表查询耗时: 1.22</span></span><br><span class="line"><span class="string">字典查询耗时: 0.0</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">test(<span class="number">10</span> ** <span class="number">5</span>, <span class="number">22333</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">列表查询耗时: 12.68</span></span><br><span class="line"><span class="string">字典查询耗时: 0.01</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">test(<span class="number">10</span> ** <span class="number">5</span> * <span class="number">2</span>, <span class="number">22333</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">列表查询耗时: 25.72</span></span><br><span class="line"><span class="string">字典查询耗时: 0.01</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>我们看到字典的查询速度非常快，从测试中我们看到，随着循环次数越来越多，列表所花费的总时间越来越长。但是字典由于查询所花费的时间极少，查询速度非常快，所以即便循环50万次，花费的总时间也不过才0.01秒左右。</strong></p>
<p><strong>此外字典还有一个特点，就是它的”快”不会受到数据量的影响，你从含有一万个键值对的字典中查找，和你从含有一千万个键值对的字典中查找，两者花费的时间几乎是没有区别的。</strong></p>
<p><strong>那么字典到底是使用了什么黑科技，才能达到这么快的效果呢？想要知道答案的话，那就从字典在底层的内部结构中寻找吧。</strong></p>
<h3 id="初识哈希表"><a href="#初识哈希表" class="headerlink" title="初识哈希表"></a>初识哈希表</h3><p>**由于映射型容器的使用场景非常广泛，几乎所有现代语言都支持映射型容器，而且特别关注”键”的搜索效率。例如：C++标准模板库中的 *map* 就是一种关联式容器，内部基于红黑树实现。红黑树是一种平衡二叉树，能够提供良好的操作效率，插入、删除、搜索等关键操作的时间复杂度均为*O*(*l*<em>o*<em>g*2*n*)</em></em></p>
<p><strong>，Linux的epoll也是使用了红黑树。</strong></p>
<p><img src="/2023/03/29/09-%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/image-20230329155658577-1680101009722.png" alt="image-20230329155658577"></p>
<p>**而对于Python来讲，映射型容器指的就是字典，我们说字典在Python内部是被高度优化的。因为不光我们在用，Python虚拟机在运行时也重度依赖字典，比如：自定义类、以及其实例对象都有自己的属性字典，还有名字空间本质上也是一个字典，因此Python对字典的要求会更加苛刻。所以Python在实现字典时采用的数据结构肯定是要优于红黑树的<code>(至少在添加、删除、查询元素等方面)</code>，也就是说它的时间复杂度是优于红黑树的。时间复杂度优于*O*(*l*<em>o*<em>g*2*n*)</em></em></p>
<p><strong>的数据结构有哪些呢？没错，你应该已经猜到了，就是散列表、又称哈希表。</strong></p>
<p>​        <strong>所以在介绍字典之前，我们需要介绍一下哈希表。当然这里只是先大致介绍一下，能够一个宏观的认识，为了在理解字典时能够方便一些。至于更详细的内容，我们会在本文的后面介绍。</strong>    </p>
<p><strong>我们在介绍元组的时候，说元组可以作为字典的key，但是列表不可以，就是因为列表是不可哈希的。哈希表的原理是将key通过哈希函数进行运算转换为一个数值，用这个数值来充当索引，因此这就有一个前提，就是你的值不可以变。而列表是个可变对象，因此它不可以作为字典的key。</strong></p>
<p><strong>直接这么说的话，可能会感到很迷，我们画一张图。</strong></p>
<p><img src="/2023/03/29/09-%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200814164717645-250695028-1680101009725.png" alt="img"></p>
<p><strong>我们发现除了key、value之外，还有一个index。其实哈希表本质上也是使用了索引的思想，我们知道虽然列表在遍历的时候是个时间复杂度为O(n)的操作，但是通过索引定位元素则是一个时间复杂度为O(1)的操作，不管你列表有多长，通过索引总是能瞬间定位到指定元素。所以哈希表实际上也是使用了数组<code>(列表)</code>的思想，会把这个key通过哈希函数映射成一个数值，作为索引。至于它是怎么映射的，我们后面再谈，现在我们就假设是按照我们接下来说的方法映射的。</strong></p>
<p><strong>比如我们这里有一个能容纳10个元素的字典<code>(这里假设容量为10其实是不准确的,容量应该是2的n次方,但是这里只是介绍哈希表,所以不管了)</code>，我们先设置d[“satori”]&#x3D;82，那么会对”satori”这个字符串进行一个哈希运算，然后再对10、也就是和当前的总容量进行取模，这样的话是不是能够得到一个小于10的数呢？假设是5，那么就存在索引为5地方。然后又进行d[“koishi”]&#x3D;83，那么按照同样的规则运算得到8，那么就存在索引为8的位置，同理第三次设置d[“mashiro”]&#x3D;80，对mashiro进行哈希、取模，得到2，那么存储在索引为2的地方。</strong></p>
<p><strong>同理当我们根据键来获取值的时候，比如：d[“satori”]，那么同样会对字符串”satori”进行哈希、取模，得到索引发现是5，直接把索引为5的value给取出来。</strong></p>
<p><strong>当然这种方式肯定存在缺陷，比如：</strong></p>
<ul>
<li><code>不同的值进行哈希、取模运算之后得到的结果一定是不同的吗？</code></li>
<li><code>在运算之后得到索引的时候，发现这个位置已经有人占了怎么办？</code></li>
<li><code>取值的时候，索引为5，可如果索引为5对应的key和我们指定获取的key不一致怎么办？</code></li>
</ul>
<blockquote>
<p><strong>所以哈希值是有冲突的，如果一旦冲突，那么Python底层会改变策略重新映射，直到映射出来的索引没有人用。比如我们设置一个新的key、value，d[“tomoyo”]&#x3D;88，可是我们对”tomoyo”这个key进行映射之后得到的结果也是5，而索引为5的地方已经被key为”satori”的键给占了，那么Python就会改变规则来对”tomoyo”重新进行运算，找到一个空位置进行添加。但如果我们再次设置d[“satori”]&#x3D;100，那么对satori进行映射得到的结果也是5，而key是一致的，那么就会把对应的值进行修改。</strong></p>
<p><strong>同理，当我们获取值的时候，d[“tomoyo”]，对key进行映射，得到索引。但是发现key不是”tomoyo”而是”satori”，于是改变规则<code>(这个规则跟设置key冲突时，采用的规则是一样的)</code>，重新映射，得到索引，然后发现key是一致的，于是将值取出来。</strong></p>
<p><strong>但如果我们指定了一个不存在的key，那么哈希映射，找到对应索引，发现没有key，证明我们指定的key是不存在的。但如果有的话，发现key和我们指定的key不相等，说明哈希运算得到索引只是碰巧一样，但由于key不一样，因此会改变规则重新运算，得到新的索引。然而发现没有对应的key，于是报错：指定的key不存在。</strong></p>
</blockquote>
<p><strong>所以从这里就已经能说明问题了，就是把key转换成类似列表的索引。可能有人问，这些值貌似不是连续的啊，对的，肯定不是连续的。并不是说你先存，你的索引就小、就在前面，这是由key进行哈希运算之后的结果决定的。而且容量有10个，目前我们只存了4个元素，那么哈希表、或者说字典会不会扩容呢？当然，既然是可变对象，当然会扩容。并且它还不是像列表那样，容量不够才扩容，而当元素个数达到容量的三分之二的时候就会扩容。</strong></p>
<p><strong>我们可以认为字典底层还是使用了索引的思想，字典不可能会像列表那样，元素之间是连续的，一个一个挨在一起的。既然是哈希运算，得到的值肯定是随机的。容量为10，尽管有6个是空着的，但是没关系，我们只要保证设置的元素整体上是有序的即可。就好比有10张桌椅，小红坐在第3张，小明坐在第8张，尽管有空着的，但是没关系，就让它空着。只要我到第3张桌椅能够找到小红、第8张可以找到小明即可。这些桌椅的位置就可以看成是索引，只要我通过索引能够找到对应的元素即可。但是容量为10，为什么不能全部占满之后再扩容呢？试想一下，既然是随机的，那么肯定会出现哈希值碰撞，并且当元素个数到达三分之二之后，这种碰撞的概率非常大。因此当容量到达三分之二的时候，就会申请一份更大的空间，以便来容纳新的元素。</strong></p>
<p><strong>所以我们发现哈希表实际上就是一种空间换时间的方法，如果容量为100，那么就相当于有100个位置，每个元素都进行哈希映射，找到自己的位置。各自的位置都是不固定的，也许会空出来很多元素，但是无所谓，只要保证这些元素在100个位置上是相对有序、通过哈希运算得到索引之后，可以在相应的位置找到它即可。</strong></p>
<p><strong>所以相信应该所有人都能明白为什么哈希表的时间复杂度是O(1)了，就是因为使用了索引的思想，每一个索引都是连续的，只不过一部分索引没有相应的key、value罢了。但这无所谓，因为索引和key、value是一一对应的，通过索引我们能瞬间定位到指定的key，再来检测key是否存在以及和我们指定的key是否一致。如果不存在，那么不好意思，证明这个地方根本没有key、value，说明我们指定了一个不存在的key。而且由于元素个数达到容量的三分之二的时候，碰撞的概率非常大，因此几乎不可能出现容量正好都排满的情况，否则那要改变规则、重复映射多少次啊。</strong></p>
<p>​        <strong>一句话总结：哈希表就是一种空间换时间的方法</strong>    </p>
<p><strong>设置键值对如下图所示：</strong></p>
<p><img src="/2023/03/29/09-%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200814164728024-1124533030-1680101009725.png" alt="img"></p>
<p><strong>根据键获取值，如下图所示：</strong></p>
<p><img src="/2023/03/29/09-%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200814164734209-960036321-1680101009725.png" alt="img"></p>
<h3 id="字典的底层结构–PyDictObject"><a href="#字典的底层结构–PyDictObject" class="headerlink" title="字典的底层结构–PyDictObject"></a>字典的底层结构–PyDictObject</h3><p><strong>下面我们来看看字典在底层对应的结构体PyDictObject，位于Include&#x2F;dictobject.h中，它的实现还是很复杂的。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="comment">//注意这里是PyObject_HEAD,不是PyObject_VAR_HEAD</span></span><br><span class="line">    <span class="comment">//PyObject_HEAD只有引用计数和类型，没有ob_size</span></span><br><span class="line">    <span class="comment">//但字典显然是一个变长对象，因此肯定有别的成员来维护字典的长度, 当然字典也有容量</span></span><br><span class="line">    PyObject_HEAD</span><br><span class="line"></span><br><span class="line">    <span class="comment">//字典里面键值对的个数</span></span><br><span class="line">    Py_ssize_t ma_used;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//字典版本：全局唯一，每一次value的变动，都会导致其改变</span></span><br><span class="line">    <span class="type">uint64_t</span> ma_version_tag;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//ma_keys从定义上来看，它是一个指针, 指向了一个PyDictKeysObject对象</span></span><br><span class="line">    <span class="comment">//事实上在底层哈希表分为两种，分别是：combined table(结合表)和split table(分离表)</span></span><br><span class="line">    <span class="comment">//如果是结合表，那么键值对存在ma_keys里面，此时下面的ma_values为NULL</span></span><br><span class="line">    PyDictKeysObject *ma_keys;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果是分离表，那么&quot;键&quot;存在ma_keys里，&quot;value&quot;存在ma_values里</span></span><br><span class="line">    PyObject **ma_values;</span><br><span class="line">&#125; PyDictObject;</span><br><span class="line"></span><br><span class="line"><span class="comment">//我们下面介绍的是常用的结合表</span></span><br></pre></td></tr></table></figure>

<p><strong>所以名字起得很形象，结合表的话，键和值就存在一起；分离表的话，键和值就存在不同的地方。至于为什么这么做，后面会解释。</strong></p>
<p><strong>整个结构体实际上是看不出来啥的，主要的原因就在那个PyDictKeysObject，我们需要再来看看它长什么样子。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我们看到这是给struct _dictkeysobject起了一个别名，所以真正要看的是_dictkeysobject</span></span><br><span class="line"><span class="comment">//它位于Objects/dict-common.h中</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">dictkeysobject</span> <span class="title">PyDictKeysObject</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">dictkeysobject</span> &#123;</span></span><br><span class="line">    <span class="comment">//引用计数，跟映射视图的实现有关，类似于对象的引用计数</span></span><br><span class="line">    Py_ssize_t dk_refcnt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//哈希表大小，比如是2的n次方，这样可将模运算优化成按位与运算</span></span><br><span class="line">    <span class="comment">//所以我们在上面介绍哈希表的时候，假设字典能容纳10个元素，这个假设是不准确的，不过无所谓啦</span></span><br><span class="line">    Py_ssize_t dk_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Function to lookup in the hash table (dk_indices):</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       - lookdict(): general-purpose, and may return DKIX_ERROR if (and</span></span><br><span class="line"><span class="comment">         only if) a comparison raises an exception.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       - lookdict_unicode(): specialized to Unicode string keys, comparison of</span></span><br><span class="line"><span class="comment">         which can never raise an exception; that function can never return</span></span><br><span class="line"><span class="comment">         DKIX_ERROR.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       - lookdict_unicode_nodummy(): similar to lookdict_unicode() but further</span></span><br><span class="line"><span class="comment">         specialized for Unicode string keys that cannot be the &lt;dummy&gt; value.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       - lookdict_split(): Version of lookdict() for split tables. */</span></span><br><span class="line">    <span class="comment">//哈希查找函数的指针，从注释上我们看到有好几种，会根据字典的当前状态选用最优的版本</span></span><br><span class="line">    dict_lookup_func dk_lookup;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//哈希表中可用的entry数量，这个entry你可以理解为键值对，一个entry就是一个键值对</span></span><br><span class="line">    <span class="comment">//哈希表是有容量的，所以这个dk_usable就表示当前的容量还能容纳多个entry</span></span><br><span class="line">    Py_ssize_t dk_usable;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//哈希表中已经使用的entry数量</span></span><br><span class="line">    Py_ssize_t dk_nentries;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Actual hash table of dk_size entries. It holds indices in dk_entries,</span></span><br><span class="line"><span class="comment">       or DKIX_EMPTY(-1) or DKIX_DUMMY(-2).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       Indices must be: 0 &lt;= indice &lt; USABLE_FRACTION(dk_size).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       The size in bytes of an indice depends on dk_size:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       - 1 byte if dk_size &lt;= 0xff (char*)</span></span><br><span class="line"><span class="comment">       - 2 bytes if dk_size &lt;= 0xffff (int16_t*)</span></span><br><span class="line"><span class="comment">       - 4 bytes if dk_size &lt;= 0xffffffff (int32_t*)</span></span><br><span class="line"><span class="comment">       - 8 bytes otherwise (int64_t*)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       Dynamically sized, SIZEOF_VOID_P is minimum. */</span></span><br><span class="line">    <span class="comment">//哈希表 起始地址 ，哈希表后紧接着 键值对数组 dk_entries 。</span></span><br><span class="line">    <span class="type">char</span> dk_indices[];  <span class="comment">/* char is required to avoid strict aliasing. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* &quot;PyDictKeyEntry dk_entries[dk_usable];&quot; array follows:</span></span><br><span class="line"><span class="comment">       see the DK_ENTRIES() macro */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>而我们说一个键值对在底层对应一个entry，而这个entry指的就是PyDictKeyEntry对象，我们看看这个结构体长什么样子。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="comment">/* Cached hash code of me_key. */</span></span><br><span class="line">    Py_hash_t me_hash;</span><br><span class="line">    PyObject *me_key;</span><br><span class="line">    PyObject *me_value; <span class="comment">/* This field is only meaningful for combined tables */</span></span><br><span class="line">&#125; PyDictKeyEntry;</span><br></pre></td></tr></table></figure>

<p><strong>显然ma_key和ma_value就是键和值，我们之前说Python中变量、以及容器内部的元素都是泛型指针PyObject  *，其中也包括字典，这里也得到了证明。但是我们看到entry除了有键和值之外，还有一个me_hash，它表示键对应的哈希值，这样可以避免重复计算。</strong></p>
<p><strong>至此，字典的整个底层结构就非常清晰了。</strong></p>
<p><img src="/2023/03/29/09-%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200814180611353-1782148743-1680101009725.png" alt="img"></p>
<p><strong>字典的真正实现藏在PyDictKeysObject中，它的内部包含两个关键数组：一个是<strong><strong>哈希索引数组dk_indices</strong></strong>，另一个是<strong><strong>键值对数组dk_entries</strong></strong>。字典所维护的键值对<code>(entry)</code>按照先来后到的顺序保存在键值对数组中，而哈希索引数组则保存”键值对”在”键值对数组”中的索引。另外，哈希索引数组中的一个位置我们称之为一个”槽”，比如图中的哈希索引数组便有8个槽，它字典的数量是相等的。</strong></p>
<p><strong>比如我们往空字典<code>(但是容量已经有了, 初始是8个, 不过可用的数量为5个)</code>中插入键值对<code>&quot;夏色祭&quot;: &quot;お娘&quot;</code>的时候，Python会执行以下步骤：</strong></p>
<ul>
<li><code>1. 将键值对保存在dk_entries中，由于初始字典是空的，所以会保存在dk_entries数组中索引为0的位置</code></li>
<li><code>2. 通过哈希函数将键&quot;夏色祭&quot;映射成一个数值，作为索引，假设是5</code></li>
<li><code>3. 将插入的键值对在数组中的索引0，保存在哈希索引数组中索引为5的槽中</code></li>
</ul>
<p><strong>然后当我们在查找键”夏色祭”对应的值的时候，便可瞬间定位。过程如下：</strong></p>
<ul>
<li><code>1. 通过哈希函数将键&quot;夏色祭&quot;映射成数值，也就是索引。因为在设置的时候索引是5，所以在获取的时候映射出来的索引肯定也是5</code></li>
<li><code>2. 找到哈希索引数组中索引为5的槽，得到其保存的0，这里的0对应键值对数组的索引</code></li>
<li><code>3. 找到键值对数组中索引为0的位置，取出PyDictKeyEntry中的me_value，也就是值(当然肯定要先比较key、也就是me_key是否一致, 不一致则重新映射。当然如果该位置为NULL, 那么直接报出KeyError)</code></li>
</ul>
<p><strong>由于<strong><strong>哈希值计算</strong></strong>以及<strong><strong>数组定位</strong></strong>均是O(1)的时间复杂度，所以字典的查询速度才会这么快。当然我们上面没有涉及到哈希冲突，关于哈希冲突我们会在后面详细说，但是就字典在存储和获取的时候就是上面那个流程。</strong></p>
<blockquote>
<p><strong>当然我们在上面的”初识哈希表”这一部分，为了避免牵扯太多，所以说的相对简化了。比如：”mashiro”:  80，我们说”mashiro”映射出来的索引是2，那么键值对就直接存在索引为2的地方。这实际上是简化了，因为这相当于把”哈希索引数组”和”键值对数组”合在一块了。而在早期的Python中，它也确实是这么做的。</strong></p>
<p><strong>但是从上面字典的结构图中我们看到，实际上是先将”键值对”按照先来后到的顺序存在一个数组<code>(键值对数组)</code>中，然后再把其索引存放在另一个数组<code>(哈希索引数组)</code>中索引为2<code>(&quot;mashiro&quot;映射出来的索引是2)</code>的地方。所以在查找的时候，映射出来的索引2其实是哈希索引数组对应的索引。然后对应的槽也存储了一个索引，这个索引是键值对数组对应的索引，假设是4，所以会再根据索引4从键值对数组中获取指定的PyDictKeyEntry对象，再根据该对象获取指定的value。</strong></p>
<p><strong>所以可以看出两者整体思想是基本类似的，理解起来没有什么区别，甚至第一种方式实现起来还会更简单一些。但为什么采用后者这种实现方式，以及这两者之间的区别，我们在后面还会专门分析，之所以采用后者主要是基于内存的考量。</strong></p>
</blockquote>
<h4 id="容量策略"><a href="#容量策略" class="headerlink" title="容量策略"></a>容量策略</h4><p><strong>根据字典的行为我们断定，字典肯定和列表一样有着”预分配机制”。因为可以扩容，那么为了避免频繁申请内存，所以在扩容的是时候会将容量申请的比键值对个数要多一些。那么字典的容量策略是怎么样的呢？</strong></p>
<p><strong>在Object&#x2F;dictobject.c源文件中我们可以看到一个宏定义：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PyDict_MINSIZE 8</span></span><br></pre></td></tr></table></figure>

<p><strong>从这个宏定义中我们可以得知，一个字典的最小容量是8，或者说内部哈希表的长度最小是8。</strong></p>
<p>​        <strong>哈希表越密集，哈希冲突则越频繁，性能也就越差。因此，哈希表必须是一种 稀疏 的表结构，越稀疏则性能越好。但由于  “内存开销”  的制约，哈希表不可能无限地稀疏，所以需要在时间和空间上进行权衡。实践经验表明，一个1&#x2F;2到2&#x2F;3满的哈希表，性能较为理想——以相对合理的  “内存” 换取相对高效的 “执行性能”。</strong>    </p>
<p>​        <strong>为保证哈希表的稀疏程度，进而控制哈希冲突频率， Python 通过 宏USABLE_FRACTION  将哈希表内元素控制在2&#x2F;3以内。宏USABLE_FRACTION 根据哈希表规模n，计算哈希表可存储元素的个数，也就是 键值对数组  的长度。以长度为 8 的哈希表为例，最多可以保持 5 个键值对，超出则需要扩容。</strong>    </p>
<p><strong>而USABLE_FRACTION 是一个非常重要的宏定义，位于源文件 *Objects&#x2F;dictobject.c* 中：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> USABLE_FRACTION(n) (((n) &lt;&lt; 1)/3)</span></span><br></pre></td></tr></table></figure>

<p><strong>哈希表规模一定是2的n次方，也就是说 *Python* 采用”翻倍扩容”的策略。例如，长度为 *8* 的哈希表扩容后，长度变为 *16* 。</strong></p>
<p><strong>最后，我们来考察一个空字典所占用的内存空间。*Python* 为空字典分配了一个长度为 *8* 的哈希表，因而也要占用相当多的内存，主要有以下几个部分组成：</strong></p>
<ul>
<li><code>PyDictObject中有6个成员，一个8字节，加起来共48字节</code></li>
<li><code>PyDictKeysObject中有7个成员，除了两个数组之外，剩余的每个成员也是一个8字节，所以加起来40字节</code></li>
<li><code>而剩余的两个数组，一个是char类型的数组dk_indices，里面1个元素占1字节；还有一个PyDictKeyEntry类型的数组dk_entries，里面一个元素占24字节，因为PyDictKeyEntry里面有三个成员，一个8字节。但是注意：字典容量为8，说明哈希索引数组长度为8，但是键值对数组dk_entries长度是5，至于原因我们上面分析的很透彻了。因此这两个数组加起来总共是 8 + 24 * 5 = 128字节</code></li>
</ul>
<p><strong>所以一个空字典占用的内存是：48 + 40 + 128 &#x3D; 216字节，我们来测试一下：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = <span class="built_in">dict</span>()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.__sizeof__()</span><br><span class="line"><span class="number">216</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>但是注意：我们说空字典容量为8，但前提它不是通过Python&#x2F;C API创建的，如果是d &#x3D; {}这种方式，那么初始容量就是0，显然此时只有48字节，因为ma_keys此时是NULL。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.__sizeof__()</span><br><span class="line"><span class="number">48</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>另外，我们看到在计算内存的时候使用的不是sys.getsizeof，而是对象的__sizeof__方法，这两者有什么区别呢？答案是使用sys.getsizeof计算出来内存大小会比调用对象的__sizeof__方法计算出来的内存大小多出16个字节。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.getsizeof(<span class="built_in">dict</span>()), <span class="built_in">dict</span>().__sizeof__()</span><br><span class="line">(<span class="number">232</span>, <span class="number">216</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.getsizeof(&#123;&#125;), &#123;&#125;.__sizeof__()</span><br><span class="line">(<span class="number">64</span>, <span class="number">48</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>之所以会出现这种情况，是因为sys.getsizeof将垃圾回收器的开销也考虑进去了。</strong></p>
<blockquote>
<p><strong>我们说Python底层是通过引用计数来判断对象是否被回收，但是引用计数有一个致命缺陷就是它无法解决循环引用的问题，所以Python内部的gc就是专门用来解决循环引用的。如果创建了一个可能会发生循环引用的对象，那么Python会将该对象挂在链表上，当然链表总共有三条，分别是零代链表、一代链表、二代链表。</strong></p>
<p><strong>先将对象挂在零代链表上，Python的gc一旦发动，那么会采用三色标记模型来对零代链表上的对象进行标记–清除，将那些发生了循环引用的对象的引用计数减一。</strong></p>
<p><strong>而这样的链表为什么有三条呢？试想一下，gc发动的成本也是很高的，如果在gc的洗礼下还能活下来的对象，说明其暂时是较稳的，没有必要每次都对其进行检测。所以会将零代链表中比较稳定的对象移动到一代链表中，同理二代链表也是同理。当清理零代链表达到10次的时候，会清理一次一代链表，清理一代链表达到10次的时候会清理一次二代链表。这样的技术在Python中也被成为分代技术。</strong></p>
</blockquote>
<p><strong>而移动到链表中的对象，除了 PyObject 之外还会有一个额外的 PyGC_Head，所以 sys.getsizeof 计算结果多出的16字节，就是这个 PyGC_Head 所占的大小（在后续介绍GC的时候会说）。</strong></p>
<p><strong>但是整型、浮点型、字符串等等，它们使用sys.getsizeof和调用__sizeof__计算出来的结果是一样的。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.getsizeof(<span class="number">123</span>), (<span class="number">123</span>).__sizeof__()</span><br><span class="line">(<span class="number">28</span>, <span class="number">28</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.getsizeof(<span class="string">&quot;matsuri&quot;</span>), <span class="string">&quot;matsuri&quot;</span>.__sizeof__()</span><br><span class="line">(<span class="number">56</span>, <span class="number">56</span>)</span><br></pre></td></tr></table></figure>

<p><strong>至于为什么一样，想必你已经猜到了，因为整型、字符串这种对象是不可能发生循环引用的，只有容器对象才会有可能发生循环引用。我们说Python中的gc是专门针对可能发生循环引用的对象的，对于不会发生循环引用的对象来说，不会参与gc，一个引用计数足够了，所以它们使用两种方式计算出的结果是一样的。</strong></p>
<blockquote>
<p><strong>关于垃圾回收，是一门很复杂的学问，我们这里简单提一下。在该系列的后续，我们会详细的探讨Python中的垃圾回收。</strong></p>
</blockquote>
<h4 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h4><p><strong>我们说在Python早期，哈希表并没有分成两个数组实现，而是由一个键值对数组实现，这个数组也承担哈希索引的角色：</strong></p>
<p><img src="/2023/03/29/09-%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200814164757642-1115745631-1680101009725.png" alt="img"></p>
<p><strong>我们看到这种结构不正是我们在介绍哈希表的时候说的吗？一个键值对数组既用来存储，又用来充当索引，无需分成两个步骤，而且这种方式也似乎更简单、更直观。而我们说Python在早期确实是通过这种方式实现的哈希表，只是这种实现方式有一个弊端，就是太耗费内存了。</strong></p>
<p><strong>我们说哈希表必须保持一定程度的稀疏，最多只有2&#x2F;3满，这意味着至少要浪费1&#x2F;3的空间。</strong></p>
<p><em><em>所以Python为了尽量节省内存，将键值对数组压缩到原来的2&#x2F;3，只用来存储，而对key进行映射得到的索引由另一个数组<code>(哈希索引数组)</code>来存储。因为键值对数组里面一个元素要占用24字节，而哈希索引数组在容量不超过256的时候，里面一个元素只占一个字节；容量不超过65536的时候，里面一个元素只占两个字节，其它以此类推。由于哈希索引数组里面的元素大小比键值对数组里面的元素大小要小很多，所以将哈希表分成两个数组<code>(避免键值对数组的浪费)</code>来实现会更加的节省内存。我们可以举个栗子计算一下，假设我们容量是2 *</em> 16 &#x3D; 65536的哈希表。</em>*</p>
<p><strong>如果是通过第一种方式，只用一个数组来存储的话：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span> ** <span class="number">16</span> * <span class="number">24</span></span><br><span class="line"><span class="number">1572864</span>  <span class="comment"># 总共需要这么多字节来存储</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span> ** <span class="number">16</span> * <span class="number">24</span> // <span class="number">3</span></span><br><span class="line"><span class="number">524288</span>  <span class="comment"># 除以3, 会浪费这么多字节</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>如果是通过第二种方式，使用两个数组来存储的话：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span> ** <span class="number">16</span> * <span class="number">24</span> * <span class="number">2</span> / <span class="number">3</span> + <span class="number">2</span> ** <span class="number">16</span> * <span class="number">2</span></span><br><span class="line"><span class="number">1179648</span>  <span class="comment"># 容量虽然是2 ** 16次方, 但是键值对数组是容量的2 / 3, 然后加上哈希索引数组的大小</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>所以一个数组存储比两个数组存储要多用393216字节的内存，因此Python选择使用两个数组来进行存储。</strong></p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p><strong>我们通过考察字典的搜索效率，并深入源码研究其内部哈希表的实现，得到以下结论：</strong></p>
<ul>
<li><code>字典是一种高效的映射式容器，每秒完成高达 *200* 多万次搜索操作；</code></li>
<li><code>字典内部由哈希表实现，哈希表的稀疏特性意味着昂贵的内存开销；</code></li>
<li><code>为优化内存使用，Python将哈希表分为 哈希索引数组 和 键值对数组，也就是通过两个数组来实现；</code></li>
<li><code>哈希表在 1/2 到 2/3 满时，性能较为理想，较好地平衡了 内存开销 与 搜索效率；</code></li>
</ul>
<h3 id="深入哈希表"><a href="#深入哈希表" class="headerlink" title="深入哈希表"></a>深入哈希表</h3><p><strong>通过字典的底层实现，我们找到字典快速、高效的秘密–哈希表。对于映射式容器，一般是通过平衡搜索树或哈希表实现。而Python的字典选用了哈希表，主要是考虑到在搜索方面哈希表的效率更高。因为我们说Python底层重度依赖字典，所以对字典在搜索、设置元素方面的性能，要求的更加苛刻。</strong></p>
<p><strong>但是由于哈希表的稀疏特性，导致其会有巨大的内存牺牲，而为了优化，Python别出心裁的将哈希表分成两部分来实现，分别是：哈希索引数组和键值对数组。</strong></p>
<p><strong>但是显然这当中还有很多细节我们没有说，比如：哈希函数到底是怎么将一个键映射成索引的？哈希冲突了怎么办？哈希攻击又是什么？以及删除操作<code>(没有表面想的那么简单)</code>如何实现？而下面我们就来攻破这些难题，深入理解哈希表。</strong></p>
<h4 id="哈希值"><a href="#哈希值" class="headerlink" title="哈希值"></a>哈希值</h4><p><strong>Python内置函数hash会返回对象的哈希值，哈希表依赖于哈希值。</strong></p>
<p><strong>而根据哈希表的性质，我们知道键对象必须满足以下两个条件，否则哈希表便无法正常工作。</strong></p>
<ul>
<li><code>1. 哈希值在对象的整个生命周期内不可以改变</code></li>
<li><code>2. 可比较，如果两个对象相等(使用==操作符结果为True)，那么它们的哈希值一定相同</code></li>
</ul>
<p><strong>满足这两个条件的对象便是”可哈希(hashable)”对象，只有可哈希对象才可以作为哈希表的键<code>(key)</code>。因此像字典、集合等底层由哈希表实现的对象，其元素必须是可哈希对象。</strong></p>
<p><strong>Python中内置的不可变对象都是可哈希对象，比如：整数、浮点数、字符串、元组<code>(元组里面也要是不可变对象)</code>等等，而像可变对象，比如列表、字典等等便不可作为哈希表的键。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;<span class="number">1</span>: <span class="number">1</span>, <span class="string">&quot;xxx&quot;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">3.14</span>: <span class="number">333</span>&#125;  <span class="comment"># 键是可哈希的就行，值是否可哈希则没有要求</span></span><br><span class="line">&#123;<span class="number">1</span>: <span class="number">1</span>, <span class="string">&#x27;xxx&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">3.14</span>: <span class="number">333</span>&#125;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;[]: <span class="number">123</span>&#125;  <span class="comment"># 列表是可变对象，因为无法哈希</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: unhashable <span class="built_in">type</span>: <span class="string">&#x27;list&#x27;</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>): <span class="number">123</span>&#125;  <span class="comment"># 元组也是可哈希的</span></span><br><span class="line">&#123;(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>): <span class="number">123</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, []): <span class="number">123</span>&#125;  <span class="comment"># 但如果元组里面包含了不可哈希的对象，那么整体也会变成不可哈希对象</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: unhashable <span class="built_in">type</span>: <span class="string">&#x27;list&#x27;</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>而我们自定义的类的实例对象也是可哈希的，且哈希值是通过对象的地址计算得到的。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a1 = A()</span><br><span class="line">a2 = A()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hash</span>(a1), <span class="built_in">hash</span>(a2))  <span class="comment"># 141215868971 141215869022</span></span><br></pre></td></tr></table></figure>

<p><strong>而且Python也支持我们重写哈希函数，比如：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__hash__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a1 = A()</span><br><span class="line">a2 = A()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hash</span>(a1), <span class="built_in">hash</span>(a2))  <span class="comment"># 123 123</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(&#123;a1: <span class="number">1</span>, a2: <span class="number">2</span>&#125;)</span><br><span class="line"><span class="comment"># &#123;&lt;__main__.A object at 0x000002A2842282B0&gt;: 1, &lt;__main__.A object at 0x000002A2842285E0&gt;: 2&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>并且我们看到虽然哈希值一样，但是在作为字典的键的时候，如果发生了冲突，会改变规则。注意：我们自定义的类的实例对象默认都是可哈希的，但如果类里面重写了__eq__方法，且没有重写__hash__方法的话，那么这个类的实例对象就不可哈希了。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__eq__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a1 = A()</span><br><span class="line">a2 = A()</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hash</span>(a1), <span class="built_in">hash</span>(a2))</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># unhashable type: &#x27;A&#x27;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>为什么会有这种现象呢？首先我们说在没有重写__hash__方法的时候，哈希值默认是根据对象的地址计算得到的。而且对象如果相等<code>(使用==操作符会得到True)</code>，那么哈希值一定是一样的。但是我们重写了__eq__，相当于控制了&#x3D;&#x3D;操作符的比较结果，两个对象是否相等就是由我们来控制了，可哈希值却还是根据地址计算得到的。两个对象地址不同，哈希值不同，但是对象却可以相等、又可以不相等，这就导致了矛盾。因此在重写了__eq__、但是没有重写__hash__的情况下，其实例对象便不可哈希了。</strong></p>
<p><strong>但如果重写了__hash__，那么哈希值计算方式就不再通过地址计算了，因此此时是可以哈希的。</strong></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__eq__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__hash__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a1 = A()</span><br><span class="line">a2 = A()</span><br><span class="line"><span class="built_in">print</span>(&#123;a1: <span class="number">1</span>, a2: <span class="number">2</span>&#125;)  <span class="comment"># &#123;&lt;__main__.A object at 0x000001CEC8D682B0&gt;: 2&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">此时我们看到字典里面只有一个元素了，因为我们说重写了__hash__方法之后，计算得到哈希值都是一样的</span></span><br><span class="line"><span class="string">但是在没有重写__eq__的情况下，默认都是不相等的。如果哈希值一样，但是对象不相等，所以会重新映射。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">而我们重写了__eq__，返回的结果是True，所以Python认为对象是相等的，由于key的不重复性，保留了后面的键值对</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>​        <strong>同样的，我们再来看一个Python中字典的例子</strong>    </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="number">1</span>: <span class="number">123</span>&#125;</span><br><span class="line"></span><br><span class="line">d[<span class="number">1.0</span>] = <span class="number">234</span></span><br><span class="line"><span class="built_in">print</span>(d)  <span class="comment"># &#123;1: 234&#125;</span></span><br><span class="line"></span><br><span class="line">d[<span class="literal">True</span>] = <span class="number">345</span></span><br><span class="line"><span class="built_in">print</span>(d)  <span class="comment"># &#123;1: 345&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>天哪，这是咋回事？因为整数在计算哈希的时候，得到结果就是其本身；而浮点数显然不是，但如果浮点数的小数点后面只有一个0，那么它和整数是等价的。因此两者的哈希值一样，而3和3.0在Python中也是相等的，因此它们视为同一个key，所以相当于是替换。同理True也是一样，我们说它bool继承自int，所以它等价于1，比如：9 + True &#x3D; 10，因为True的哈希值和1也是一样的，而且也是相等的，索引d[True] &#x3D; 345也是更新。</strong></p>
<blockquote>
<p><strong>但是问题来了，值更新了我们可以理解，字典里面只有一个元素也可以理解，但是为什么key一直是1呢？理论上最终结果应该是True才对啊。</strong></p>
<p><strong>其实这算是Python偷了个懒吧<code>(开个玩笑)</code>，因为key的哈希值是一样的，并且也相等，所以Python不会对key进行替换。从字典在设置元素的时候我们也知道，如果对key映射成索引之后发现哈希索引数组的此位置没有人用，那么就按照先来后到的顺序将”键值对”存在键值对数组中，再将其索引存在哈希索引数组的指定的槽中；如果有人用了，但是对应的key不想等，则重新映射找一个新位置；如果有人用了、并且相等，则说明是同一个key，那么把value换掉即可。所以在替换元素的整个过程中，根本没有涉及到对键的修改，因此上面那个例子的最终结果，value会变、但键依旧是1，而不是True。</strong></p>
</blockquote>
<p><strong>理想的哈希函数必须保证哈希值尽量均匀地分布于整个哈希空间中，越是相近的值，其哈希值差别应该越大。</strong></p>
<blockquote>
<p><strong>所以一个好的哈希函数对实现哈希表起到至关重要的作用。</strong></p>
</blockquote>
<h4 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h4><p><strong>一方面，不同的对象，哈希值有可能相同，另一方面，与哈希值空间相比，哈希表的槽位是非常有限的。因此，存在多个键被映射到哈希索引的同一槽位的可能性，这便是<strong><strong>索引冲突</strong></strong>。</strong></p>
<p><img src="/2023/03/29/09-%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200814164807998-1827451738-1680101009725.png" alt="img"></p>
<p><strong>解决哈希冲突的常用方法有两种：</strong></p>
<ul>
<li><code>分离链接法(separate chaining)</code></li>
<li><code>开放寻址法(open addressing)</code></li>
</ul>
<p><strong>Python采用的便是开放寻址法。</strong></p>
<h5 id="分离链接法"><a href="#分离链接法" class="headerlink" title="分离链接法"></a>分离链接法</h5><p><strong>“分离链接法”为每个哈希槽维护一个链表，所有哈希到同一槽位的键保存到对应的链表中：</strong></p>
<p><img src="/2023/03/29/09-%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200814164818019-995843865-1680101009725.png" alt="img"></p>
<p><strong>如上图所示，哈希索引数组的每一个槽都连接着一个链表，初始状态为空，哈希表某个槽位对应的”键”则保存在对应的链表中。例如：key1和key3都哈希到下标为3的槽位，依次保存在对应的链表中；key2被哈希到下标为1的槽位。</strong></p>
<h5 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h5><p><strong>Python依旧是将key映射成索引存在哈希索引数组的槽中，如果发现槽被占了，那么就尝试另一个。</strong></p>
<p><img src="/2023/03/29/09-%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200814164825466-1426145061-1680101009725.png" alt="img"></p>
<p>*<em>key3被哈希到槽位为3的时候，发现这个坑被key1给占了，所以只能重新找个坑了。但是为什么找到5呢？显然在解决哈希冲突的时候是有策略的，一般而言，如果是第i次尝试，那么会在首槽的基础上加上一个偏移量*d*<em>i*</em></em></p>
<p>**。比如哈希之后索引是n，那么首槽就是n，然而n这个槽被占了，于是重新映射，重新映射之后的索引就是n + *d**i****<em>，所以可以看出探测方式因函数*d*<em>i*</em></em></p>
<p><strong>而异。</strong></p>
<p><strong>而常见的探测函数有两种：</strong></p>
<ul>
<li><code>线性探测(linear probing)</code></li>
<li><code>平方探测(quadratic probing)</code></li>
</ul>
<p>*<em>线性探测很好理解，*d*<em>i*</em></em></p>
<p>*<em>是一个线性函数，例如：*d*<em>i*</em></em></p>
<p> <strong>&#x3D; 2 * i</strong></p>
<p><img src="/2023/03/29/09-%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200814164833564-723416397-1680101009725.png" alt="img"></p>
<p>*<em>哈希之后对应的槽是1，但是被占了，这个时候会在首槽的基础上加一个偏移量*d*<em>i*</em></em></p>
<p><strong>。第1次尝试，偏移量是2；第2次尝试，偏移量是4；第3次尝试，偏移量是6。然后再加上首槽的1，所以尝试之后的位置分别是3、5、7。</strong></p>
<p>*<em>平方探测也很好理解，*d*<em>i*</em></em></p>
<p>*<em>是一个平方函数，例如：*d*<em>i*</em></em> <strong>&#x3D; *i*2</strong></p>
<p><strong>。同理如果是平方探测，首槽还是1，那么冲突之后重试的槽就是1 + 1、1 + 4、 1+ 9。</strong></p>
<p><img src="/2023/03/29/09-%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200814164841296-1736851838-1680101009725.png" alt="img"></p>
<blockquote>
<p><strong>线性探测和平方探测很简单，平方探测似乎更胜一筹。因为如果哈希表存在局部热点，探测很难快速跳过热点区域，而平方探测则可以解决这一点。但是这两种方法其实都不够好–因为固定的探测序列加大了冲突的概率。</strong></p>
</blockquote>
<p><img src="/2023/03/29/09-%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200814164847932-1766657391-1680101009725.png" alt="img"></p>
<p><strong>key1和key2都哈希到槽1，而由于探测序列是相同的，因此冲突概率很高。所以Python对此进行了优化，探测函数参考对象哈希值，生成不同的探测序列，进一步降低哈希冲突的可能性：</strong></p>
<p><img src="/2023/03/29/09-%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200814164855563-1413795961-1680101009726.png" alt="img"></p>
<h5 id="探测函数"><a href="#探测函数" class="headerlink" title="探测函数"></a>探测函数</h5><p><strong>Python为哈希表搜索提供了多种探测函数，lookdict、lookdict_unicode、lookdict_index，一般通用的是lookdict。lookdict_unicode是专门针对key为字符串的entry，lookdict_index针对key为整数的entry，可以把lookdict_unicode、lookdict_index看成lookdict的特殊实现，只不过key是整数和字符串的场景非常常见，因此为其单独实现了一个函数。</strong></p>
<blockquote>
<p><strong>注意: 我们对字典无论是设置值还是获取值，都需要进行搜索。</strong></p>
</blockquote>
<p><strong>我们这里重点看一下lookdict的函数实现，它位于 *Objects&#x2F;dictobject.c* 源文件内。关键代码如下：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> Py_ssize_t _Py_HOT_FUNCTION</span><br><span class="line"><span class="title function_">lookdict</span><span class="params">(PyDictObject *mp, PyObject *key,</span></span><br><span class="line"><span class="params">         Py_hash_t hash, PyObject **value_addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> i, mask, perturb;</span><br><span class="line">    <span class="comment">//keys数组的首地址</span></span><br><span class="line">    PyDictKeysObject *dk;</span><br><span class="line">    <span class="comment">//entries数组的首地址</span></span><br><span class="line">    PyDictKeyEntry *ep0;</span><br><span class="line"></span><br><span class="line">top:</span><br><span class="line">    dk = mp-&gt;ma_keys;</span><br><span class="line">    ep0 = DK_ENTRIES(dk);</span><br><span class="line">    mask = DK_MASK(dk);</span><br><span class="line">    perturb = hash;</span><br><span class="line">    <span class="comment">//哈希，定位探测链冲突的第一个entry的索引</span></span><br><span class="line">    i = (<span class="type">size_t</span>)hash &amp; mask;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// dk-&gt;indecs[i]</span></span><br><span class="line">        Py_ssize_t ix = dk_get_index(dk, i);</span><br><span class="line">        <span class="comment">//如果ix == DKIX_EMPTY，说明没有存储值</span></span><br><span class="line">        <span class="comment">//理论上是报错的，但是在底层是将值的指针设置为NULL</span></span><br><span class="line">        <span class="keyword">if</span> (ix == DKIX_EMPTY) &#123;</span><br><span class="line">            *value_addr = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">return</span> ix;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ix &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//拿到指定的entry的指针</span></span><br><span class="line">            PyDictKeyEntry *ep = &amp;ep0[ix];</span><br><span class="line">            assert(ep-&gt;me_key != <span class="literal">NULL</span>);</span><br><span class="line">            <span class="comment">//如果两个key一样，那么直接将值的地址设置为ep-&gt;me_value</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            但是注意：我们说Python中的变量是一个指针</span></span><br><span class="line"><span class="comment">            所以这里的一样，表示的两个指针是一样的, 或者地址是一样的, 所以在Python中指向的是同一个对象</span></span><br><span class="line"><span class="comment">            也就是说这一步等价于Python中的: if a is b</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">if</span> (ep-&gt;me_key == key) &#123;</span><br><span class="line">                *value_addr = ep-&gt;me_value;</span><br><span class="line">                <span class="keyword">return</span> ix;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果两个对象不一样，那么就比较它们的哈希值是否相同</span></span><br><span class="line">            <span class="comment">//比如33和33是一个对象,都是小整数对象池里面整数，但是3333和3333却不是，但是它们的值是一样的</span></span><br><span class="line">            <span class="comment">//因此先判断id是否一致，如果不一致再比较哈希值是否一样</span></span><br><span class="line">            <span class="keyword">if</span> (ep-&gt;me_hash == hash) &#123;</span><br><span class="line">                <span class="comment">//哈希值一样的话, 那么获取me_key</span></span><br><span class="line">                PyObject *startkey = ep-&gt;me_key;</span><br><span class="line">                Py_INCREF(startkey);  <span class="comment">//inc ref</span></span><br><span class="line">                <span class="comment">//比较key是否一致</span></span><br><span class="line">                <span class="type">int</span> cmp = PyObject_RichCompareBool(startkey, key, Py_EQ);</span><br><span class="line">                Py_DECREF(startkey);  <span class="comment">//dec ref</span></span><br><span class="line">                <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    *value_addr = <span class="literal">NULL</span>;</span><br><span class="line">                    <span class="keyword">return</span> DKIX_ERROR;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (dk == mp-&gt;ma_keys &amp;&amp; ep-&gt;me_key == startkey) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        *value_addr = ep-&gt;me_value;</span><br><span class="line">                        <span class="keyword">return</span> ix;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">/* The dict was mutated, restart */</span></span><br><span class="line">                    <span class="keyword">goto</span> top;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果条件均不满足，调整姿势，进行下一次探索</span></span><br><span class="line">        <span class="comment">//由于参考了对象哈希值，探测序列因哈希值而异</span></span><br><span class="line">        perturb &gt;&gt;= PERTURB_SHIFT;</span><br><span class="line">        i = (i*<span class="number">5</span> + perturb + <span class="number">1</span>) &amp; mask;</span><br><span class="line">    &#125;</span><br><span class="line">    Py_UNREACHABLE();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="哈希攻击"><a href="#哈希攻击" class="headerlink" title="哈希攻击"></a>哈希攻击</h4><p>*<strong>Python* 在 *3.3* 以前， 哈希算法只根据对象本身计算哈希值。因此，只要 *Python* 解释器相同，对象哈希值也肯定相同。</strong></p>
<p><strong>如果一些别有用心的人构造出大量哈希值相同的 *key* ，并提交给服务器，会发生什么事情呢？例如，向一台 *Python 2 Web* 服务器 *post* 一个 *json* 数据，数据包含大量的 *key* ，所有 *key* 的哈希值相同。这意味着哈希表将频繁发生哈希冲突，性能由 O(1)急剧下降为 O(N)，这便是哈希攻击。</strong></p>
<p><strong>问题虽然很严重，但是好在应对方法比较简单–直接往对象身上撒把盐(salt)即可。具体做法如下：</strong></p>
<ul>
<li><code>1. Python解释器进程启动后，产生一个随机数作为盐</code></li>
<li><code>2. 哈希函数同时参考对象本身以及随机数计算哈希值</code></li>
</ul>
<p><strong>这样一来，攻击者无法获悉解释器内部的随机数，也就无法构造出哈希值相同的对象了！*Python* 自 *3.3* 以后，哈希函数均采用加盐模式，杜绝了哈希攻击的可能性。*Python* 哈希算法在 *Python&#x2F;pyhash.c* 源文件中实现，有兴趣的可以自己去了解一下。</strong></p>
<p><strong>以我当前使用的Python3.8为例，在执行<code>hash(&quot;夏色祭&quot;)</code>的时候，每次执行得到的结果都是不一样的。</strong></p>
<h4 id="元素删除"><a href="#元素删除" class="headerlink" title="元素删除"></a>元素删除</h4><p><strong>通过前面的学习，我们现在已经知道哈希表就是通过相应的函数将需要搜索的键映射为一个索引，最终通过索引去访问连续的内存区域。而对于哈希表这种数据结构，最终目的就是加速键的搜索过程。用于映射的函数就是哈希函数，映射之后的值就是哈希值，再由哈希值得到索引<code>(不过为了方便,我们有时会将哈希函数映射的结果直接称为索引)</code>。因此在哈希表的实现中，哈希函数的优劣将直接决定哈希表搜索效率的高低。</strong></p>
<p><strong>并且我们知道，当键值对数量越多，在映射成索引之后就越容易出现冲突。而我们之前说如果冲突了，就改变规则重新映射。事实上，Python也确实是这么做的，这种方法叫做开放寻址法。当发生冲突时，Python会通过一个二次探测函数f，计算下一个候选位置addr，如果可用就插入进去。如果不可用，会继续使用探测函数，直到找到一个可用的位置。通过多次使用探测函数f，从一个位置可以到达多个位置，我们认为这些位置就形成了一个”冲突探测链(探测序列)”。比如当我们插入一个key&#x3D;”satori”的键值对，在a位置发现不行，又走b位置，发现也被人占了，于是到达c位置，发现没有key，于是就占了c这个位置。那么a -&gt; b -&gt; c便形成了一条冲突探测链，同理我们查找的时候也会按照这个顺序进行查找。</strong></p>
<blockquote>
<p><strong>显然上面这些东西，现在理解起来已经没什么难度了，但是问题来了。</strong></p>
<p><strong>如果我此时把上面b位置的entry给删掉的话，会引发什么后果？首先我们知道，b位置上的key和我们指定的”satori”这个key的哈希值是一样的，不然它们也不会映射到同一个槽。当我们直接获取d[“satori”]，肯定会先走a位置，发现有人但key又不是”satori”，于是重新映射；然后走到b，发现还不对，再走到c位置，发现key是”satori”，于是就把值取出来了。显然这符合我们的预期，但是，我要说但是了。</strong></p>
<p><strong>如果我们把b位置上的entry删掉呢？那么老规矩，映射成索引，先走到a位置发现坑被占；于是又走到b位置，结果发现居然没有内容，那么直接就报出了一个KeyError。所以继续寻找的前提是，这个地方要存储了entry，并且存在的<code>entry -&gt; me_key</code>和指定的key不相同，但如果没有的话，就说明根本没有这个key，直接KeyError。然而”satori”这个key确实是存在的，因此发生这种情况我们就说<code>探测链断裂</code>。本来应该走到c的，但是由于b没有元素，因此探测函数在b处就停止了。</strong></p>
</blockquote>
<p><strong>因此我们发现，当一个元素只要位于任何一条探测链当中，在删除元素时都不能真正意义上的删除，而是一种”伪删除”操作。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个键值对就是一个entry, 在底层就是一个 PyDictKeyEntry 对象</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Py_hash_t me_hash;</span><br><span class="line">    PyObject *me_key;</span><br><span class="line">    PyObject *me_value;</span><br><span class="line">&#125; PyDictKeyEntry;</span><br></pre></td></tr></table></figure>

<p><strong>在Python中，当一个PyDictObject对象发生变化时，其中的entry会在三种不同的状态之间进行切换：unused态、active态、dummy态。</strong></p>
<ul>
<li><code>当一个entry的me_key和me_value都是NULL的时候，entry处于unused态。unused态表明该entry中并没有存储key、value，并且在此之前也没有存储过它们，每一个entry在初始化的时候都会处于这个状态。不过me_value的话，即使不是unused态也可能为NULL，更准确的说不管何时它都可能会NULL，这取决于到底是combined table、还是split  table。我们说如果是分离表的话，value是不存在这里的，只有key存在这里，因此me_value永远是NULL。而如果是结合表，那么key和value都存在这里面。所以对于me_key，只可能在unused的时候才可能会NULL。</code></li>
<li><code>当entry存储了key时，那么此时entry便从unused态变成了active态。</code></li>
<li><code>当entry中的key(value)被删除后，状态便从active态变成dummy态。注意：这里是dummy，删除了并不代表就能够回到unused态，来存储其他key了。我们也说了，unused态是指当前没有、并且之前也没有存储过。key被删除后，会变成dummy，否则就会发生我们之前说的探测链断裂。至于这个dummy到底是啥，我们后面说。总是entry进入dummy态，就是我们刚才提到的伪删除技术。当Python沿着某条探测链搜索时，如果发现一个entry处于dummy态，就会明白虽然当前的entry是无效的，但是后面的entry可能是有效的，所以不会直接就停止搜索、报错，而是会继续搜索，这样就保证了探测链的连续性。至于报错，是在找到了unused状态的entry时才会报错，因为这里确实一直都没有存储过key，但是索引确实是这个位置，这说明当前指定的key就真的不存在哈希表中，此时才会报错。</code></li>
</ul>
<p><img src="/2023/03/29/09-%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200814164910070-2009596752-1680101009726.png" alt="img"></p>
<blockquote>
<p><strong>unused态只能转换为active态；active态只能转换为dummy态；dummy态只能转化为active态。</strong></p>
</blockquote>
<p><strong>哈希槽位状态常量在 *Objects&#x2F;dict-common.h* 头文件中定义：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DKIX_EMPTY (-1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DKIX_DUMMY (-2)  <span class="comment">/* Used internally */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DKIX_ERROR (-3)</span></span><br></pre></td></tr></table></figure>

<p><strong>但是问题来了，如果一个entry被删除了，那么它就变成了dummy态。而我们说dummy态是可以转为active态的，要如何转化呢？如果新来了一个entry，这个entry在存储的时候发生冲突，那么会沿着冲突探测链查找，在查找的时候要是遇到了处于dummy态entry，那么原来处于dummy态的entry就会变成active态。</strong></p>
<p><strong>换句话说，对于处理dummy态的entry，Python压根不会主动理会，只是说这个元素被标记为删除了，但是内存还会继续占用。如果新来的entry，没有发生冲突，一上来就有位置可以存储，那么是不会理会dummy态entry的。只有当发生冲突的时候，正好撞上了dummy态的entry，才会将dummy态的entry给替换掉。此时entry就变成了active态，然后内部维护的就是新的键值对。</strong></p>
<p><strong>如果哈希表满了，那么就申请新的存储单元，然后将所有的active态的entry都搬过去，而处于dummy态的entry则直接丢弃。之所以可以丢弃，是因为dummy状态的entry存在是为了保证探测链不断裂，但是现在所有的active都拷贝到新的内存当中了，它们会形成一条新的探测链，因此也就不需要这些dummy态的entry了。至于到底是扩容、缩容、还是容量不变，取决于当前哈希表的entry个数。但是无论怎么样，当新的哈希表创建之后，便又有新的存储单元可用了。</strong></p>
<h3 id="PyDictObject的创建与维护"><a href="#PyDictObject的创建与维护" class="headerlink" title="PyDictObject的创建与维护"></a>PyDictObject的创建与维护</h3><h4 id="PyDictObject的创建"><a href="#PyDictObject的创建" class="headerlink" title="PyDictObject的创建"></a>PyDictObject的创建</h4><p><strong>Python内部通过PyDict_New来创建一个新的dict对象。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyDict_New</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//new_keys_object表示创建PyDictKeysObject*对象</span></span><br><span class="line">    <span class="comment">//里面传一个数值，表示entry的容量</span></span><br><span class="line">    <span class="comment">//#define PyDict_MINSIZE 8，从宏定义我们能看出来为8</span></span><br><span class="line">    <span class="comment">//表示默认初始化能容纳8个entry的PyDictKeysObject</span></span><br><span class="line">    <span class="comment">//为什么是8，这是通过大量的经验得来的。</span></span><br><span class="line">    PyDictKeysObject *keys = new_keys_object(PyDict_MINSIZE);</span><br><span class="line">    <span class="keyword">if</span> (keys == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//这一步则是根据PyDictKeysObject *创建一个新字典</span></span><br><span class="line">    <span class="keyword">return</span> new_dict(keys, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyDictKeysObject *<span class="title function_">new_keys_object</span><span class="params">(Py_ssize_t size)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyDictKeysObject *dk;</span><br><span class="line">    Py_ssize_t es, usable;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//检测，size是否&gt;=PyDict_MINSIZE</span></span><br><span class="line">    assert(size &gt;= PyDict_MINSIZE);</span><br><span class="line">    assert(IS_POWER_OF_2(size));</span><br><span class="line"></span><br><span class="line">    usable = USABLE_FRACTION(size);</span><br><span class="line">    <span class="comment">//es：哈希表中的每个索引占多少字节</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">0xff</span>) &#123;</span><br><span class="line">        es = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (size &lt;= <span class="number">0xffff</span>) &#123;</span><br><span class="line">        es = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SIZEOF_VOID_P &gt; 4</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (size &lt;= <span class="number">0xffffffff</span>) &#123;</span><br><span class="line">        es = <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        es = <span class="keyword">sizeof</span>(Py_ssize_t);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//注意到，字典里面也有缓冲池，当然这里指定是字典的key</span></span><br><span class="line">    <span class="comment">//如果有的话，直接从里面取</span></span><br><span class="line">    <span class="keyword">if</span> (size == PyDict_MINSIZE &amp;&amp; numfreekeys &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        dk = keys_free_list[--numfreekeys];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//否则malloc重新申请</span></span><br><span class="line">        dk = PyObject_MALLOC(<span class="keyword">sizeof</span>(PyDictKeysObject)</span><br><span class="line">                             + es * size</span><br><span class="line">                             + <span class="keyword">sizeof</span>(PyDictKeyEntry) * usable);</span><br><span class="line">        <span class="keyword">if</span> (dk == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            PyErr_NoMemory();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置引用计数、可用的entry个数等信息</span></span><br><span class="line">    DK_DEBUG_INCREF dk-&gt;dk_refcnt = <span class="number">1</span>;</span><br><span class="line">    dk-&gt;dk_size = size;</span><br><span class="line">    dk-&gt;dk_usable = usable;</span><br><span class="line">    <span class="comment">//dk_lookup很关键，里面包括了哈希函数和冲突时的二次探测函数的实现</span></span><br><span class="line">    dk-&gt;dk_lookup = lookdict_unicode_nodummy;</span><br><span class="line">    dk-&gt;dk_nentries = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//哈希表的初始化</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;dk-&gt;dk_indices[<span class="number">0</span>], <span class="number">0xff</span>, es * size);</span><br><span class="line">    <span class="built_in">memset</span>(DK_ENTRIES(dk), <span class="number">0</span>, <span class="keyword">sizeof</span>(PyDictKeyEntry) * usable);</span><br><span class="line">    <span class="keyword">return</span> dk;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">new_dict</span><span class="params">(PyDictKeysObject *keys, PyObject **values)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyDictObject *mp;</span><br><span class="line">    assert(keys != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//这是一个字典的缓冲池</span></span><br><span class="line">    <span class="keyword">if</span> (numfree) &#123;</span><br><span class="line">        mp = free_list[--numfree];</span><br><span class="line">        assert (mp != <span class="literal">NULL</span>);</span><br><span class="line">        assert (Py_TYPE(mp) == &amp;PyDict_Type);</span><br><span class="line">        _Py_NewReference((PyObject *)mp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//系统堆中申请内存</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        mp = PyObject_GC_New(PyDictObject, &amp;PyDict_Type);</span><br><span class="line">        <span class="keyword">if</span> (mp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            DK_DECREF(keys);</span><br><span class="line">            free_values(values);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置key、value等等</span></span><br><span class="line">    mp-&gt;ma_keys = keys;</span><br><span class="line">    mp-&gt;ma_values = values;</span><br><span class="line">    mp-&gt;ma_used = <span class="number">0</span>;</span><br><span class="line">    mp-&gt;ma_version_tag = DICT_NEXT_VERSION();</span><br><span class="line">    assert(_PyDict_CheckConsistency(mp));</span><br><span class="line">    <span class="keyword">return</span> (PyObject *)mp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h4><p><strong>我们对PyDictObject对象的操作都是建立在搜索的基础之上的，插入和删除也不例外。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">insertdict</span><span class="params">(PyDictObject *mp, PyObject *key, Py_hash_t hash, PyObject *value)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyObject *old_value;</span><br><span class="line">    PyDictKeyEntry *ep;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//增加对key和value的引用计数</span></span><br><span class="line">    Py_INCREF(key);</span><br><span class="line">    Py_INCREF(value);</span><br><span class="line">    <span class="comment">//类型检查</span></span><br><span class="line">    <span class="keyword">if</span> (mp-&gt;ma_values != <span class="literal">NULL</span> &amp;&amp; !PyUnicode_CheckExact(key)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (insertion_resize(mp) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> Fail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Py_ssize_t ix = mp-&gt;ma_keys-&gt;dk_lookup(mp, key, hash, &amp;old_value);</span><br><span class="line">    <span class="keyword">if</span> (ix == DKIX_ERROR)</span><br><span class="line">        <span class="keyword">goto</span> Fail;</span><br><span class="line"></span><br><span class="line">    assert(PyUnicode_CheckExact(key) || mp-&gt;ma_keys-&gt;dk_lookup == lookdict);</span><br><span class="line">    MAINTAIN_TRACKING(mp, key, value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 检查共享key，可能扩容哈希表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (_PyDict_HasSplitTable(mp) &amp;&amp;</span><br><span class="line">        ((ix &gt;= <span class="number">0</span> &amp;&amp; old_value == <span class="literal">NULL</span> &amp;&amp; mp-&gt;ma_used != ix) ||</span><br><span class="line">         (ix == DKIX_EMPTY &amp;&amp; mp-&gt;ma_used != mp-&gt;ma_keys-&gt;dk_nentries))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (insertion_resize(mp) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> Fail;</span><br><span class="line">        ix = DKIX_EMPTY;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//搜索成功</span></span><br><span class="line">    <span class="keyword">if</span> (ix == DKIX_EMPTY) &#123;</span><br><span class="line">        <span class="comment">/* 插入一个新的slot，这个slot可以直接看成是entry */</span></span><br><span class="line">        assert(old_value == <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (mp-&gt;ma_keys-&gt;dk_usable &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/* 需要resize */</span></span><br><span class="line">            <span class="keyword">if</span> (insertion_resize(mp) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">goto</span> Fail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//寻找值的插入位置，就是我们之前说的将key这个值通过哈希函数映射为索引</span></span><br><span class="line">        Py_ssize_t hashpos = find_empty_slot(mp-&gt;ma_keys, hash);</span><br><span class="line">        <span class="comment">//拿到PyDictKeyEntry *指针</span></span><br><span class="line">        ep = &amp;DK_ENTRIES(mp-&gt;ma_keys)[mp-&gt;ma_keys-&gt;dk_nentries];</span><br><span class="line">        <span class="comment">//设置</span></span><br><span class="line">        dk_set_index(mp-&gt;ma_keys, hashpos, mp-&gt;ma_keys-&gt;dk_nentries);</span><br><span class="line">        ep-&gt;me_key = key; <span class="comment">//设置key</span></span><br><span class="line">        ep-&gt;me_hash = hash;<span class="comment">//设置哈希</span></span><br><span class="line">        <span class="comment">//如果ma_values数组不为空</span></span><br><span class="line">        <span class="keyword">if</span> (mp-&gt;ma_values) &#123;</span><br><span class="line">            assert (mp-&gt;ma_values[mp-&gt;ma_keys-&gt;dk_nentries] == <span class="literal">NULL</span>);</span><br><span class="line">            <span class="comment">//设置进去，还记得这是什么表吗？对，这是一张split table</span></span><br><span class="line">            mp-&gt;ma_values[mp-&gt;ma_keys-&gt;dk_nentries] = value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//ma_values数据为空的话，那么value就设置在PyDictKeyEntry对象的me_value里面</span></span><br><span class="line">            ep-&gt;me_value = value;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        mp-&gt;ma_used++;<span class="comment">//使用个数+1</span></span><br><span class="line">        mp-&gt;ma_version_tag = DICT_NEXT_VERSION();<span class="comment">//版本数+1</span></span><br><span class="line">        mp-&gt;ma_keys-&gt;dk_usable--;<span class="comment">//可用数-1</span></span><br><span class="line">        mp-&gt;ma_keys-&gt;dk_nentries++;<span class="comment">//里面entry数量+1</span></span><br><span class="line">        assert(mp-&gt;ma_keys-&gt;dk_usable &gt;= <span class="number">0</span>);</span><br><span class="line">        assert(_PyDict_CheckConsistency(mp));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//判断key是否存在，存在即替换</span></span><br><span class="line">    <span class="keyword">if</span> (_PyDict_HasSplitTable(mp)) &#123;</span><br><span class="line">        mp-&gt;ma_values[ix] = value;</span><br><span class="line">        <span class="keyword">if</span> (old_value == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">/* pending state */</span></span><br><span class="line">            assert(ix == mp-&gt;ma_used);</span><br><span class="line">            mp-&gt;ma_used++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        assert(old_value != <span class="literal">NULL</span>);</span><br><span class="line">        DK_ENTRIES(mp-&gt;ma_keys)[ix].me_value = value;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    mp-&gt;ma_version_tag = DICT_NEXT_VERSION();</span><br><span class="line">    Py_XDECREF(old_value); <span class="comment">/* which **CAN** re-enter (see issue #22653) */</span></span><br><span class="line">    assert(_PyDict_CheckConsistency(mp));</span><br><span class="line">    Py_DECREF(key);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">Fail:</span><br><span class="line">    Py_DECREF(value);</span><br><span class="line">    Py_DECREF(key);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>以上是插入元素，但我们看到无论是插入元素、还是设置元素，insertdict都是可以胜任。但是请注意一下参数，有一个hash参数，这个hash是从什么地方获取的呢？答案是，在调用这个insertdict之前其实会首先调用<code>PyDict_SetItem</code></strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">PyDict_SetItem</span><span class="params">(PyObject *op, PyObject *key, PyObject *value)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyDictObject *mp;</span><br><span class="line">    Py_hash_t hash;</span><br><span class="line">    <span class="keyword">if</span> (!PyDict_Check(op)) &#123;</span><br><span class="line">        PyErr_BadInternalCall();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    assert(key);</span><br><span class="line">    assert(value);</span><br><span class="line">    mp = (PyDictObject *)op;</span><br><span class="line">    <span class="comment">//计算hash值</span></span><br><span class="line">    <span class="keyword">if</span> (!PyUnicode_CheckExact(key) ||</span><br><span class="line">        (hash = ((PyASCIIObject *) key)-&gt;hash) == <span class="number">-1</span>)</span><br><span class="line">    &#123;	</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        hash = PyObject_Hash(key);</span><br><span class="line">        <span class="keyword">if</span> (hash == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 调用insertdict，必要时调整元素 */</span></span><br><span class="line">    <span class="keyword">return</span> insertdict(mp, key, hash, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们说如果entry个数达到容量的三分之二，那么会调整容量，如何调整呢？</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//增长率</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GROWTH_RATE(d) ((d)-&gt;ma_used*3)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">insertion_resize</span><span class="params">(PyDictObject *mp)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//本质上调用了dictresize，传入PyDictObject * 和增长率</span></span><br><span class="line">    <span class="keyword">return</span> dictresize(mp, GROWTH_RATE(mp));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">dictresize</span><span class="params">(PyDictObject *mp, Py_ssize_t minsize)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//新的容量，entry的个数</span></span><br><span class="line">    Py_ssize_t newsize, numentries;</span><br><span class="line">    <span class="comment">//老的keys</span></span><br><span class="line">    PyDictKeysObject *oldkeys;</span><br><span class="line">    <span class="comment">//老的values</span></span><br><span class="line">    PyObject **oldvalues;</span><br><span class="line">    <span class="comment">//老的entries，新的entries</span></span><br><span class="line">    PyDictKeyEntry *oldentries, *newentries;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 确定table的大小*/</span></span><br><span class="line">    <span class="keyword">for</span> (newsize = PyDict_MINSIZE;</span><br><span class="line">         newsize &lt; minsize &amp;&amp; newsize &gt; <span class="number">0</span>;</span><br><span class="line">         newsize &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">        ;</span><br><span class="line">    <span class="keyword">if</span> (newsize &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        PyErr_NoMemory();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//获取原来的所有keys</span></span><br><span class="line">    oldkeys = mp-&gt;ma_keys;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建能够容纳newsize个entry的内存空间 */</span></span><br><span class="line">    mp-&gt;ma_keys = new_keys_object(newsize);</span><br><span class="line">    <span class="keyword">if</span> (mp-&gt;ma_keys == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//把以前的key拷贝过去。</span></span><br><span class="line">        mp-&gt;ma_keys = oldkeys;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//必须满足 可用 &gt;= 已用</span></span><br><span class="line">    assert(mp-&gt;ma_keys-&gt;dk_usable &gt;= mp-&gt;ma_used);</span><br><span class="line">    <span class="keyword">if</span> (oldkeys-&gt;dk_lookup == lookdict)</span><br><span class="line">        mp-&gt;ma_keys-&gt;dk_lookup = lookdict;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//获取已用entries</span></span><br><span class="line">    numentries = mp-&gt;ma_used;</span><br><span class="line">    <span class="comment">//获取旧信息</span></span><br><span class="line">    oldentries = DK_ENTRIES(oldkeys);</span><br><span class="line">    newentries = DK_ENTRIES(mp-&gt;ma_keys);</span><br><span class="line">    oldvalues = mp-&gt;ma_values;</span><br><span class="line">    <span class="comment">//如果oldvalues不为NULL，这应该是一个 split table</span></span><br><span class="line">    <span class="comment">//split table的特点是key是能是unicode、</span></span><br><span class="line">    <span class="comment">//那么需要把split table转换成combined table</span></span><br><span class="line">    <span class="keyword">if</span> (oldvalues != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Py_ssize_t i = <span class="number">0</span>; i &lt; numentries; i++) &#123;</span><br><span class="line">            </span><br><span class="line">            assert(oldvalues[i] != <span class="literal">NULL</span>);</span><br><span class="line">            <span class="comment">//将ma_values数组里面的元素统统都设置到PyDictKeyEntry对象里面去</span></span><br><span class="line">            PyDictKeyEntry *ep = &amp;oldentries[i];</span><br><span class="line">            PyObject *key = ep-&gt;me_key;</span><br><span class="line">            Py_INCREF(key);</span><br><span class="line">            newentries[i].me_key = key;</span><br><span class="line">            newentries[i].me_hash = ep-&gt;me_hash;</span><br><span class="line">            newentries[i].me_value = oldvalues[i];</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//减少原来对oldkeys的引用计数</span></span><br><span class="line">        DK_DECREF(oldkeys);</span><br><span class="line">        <span class="comment">//将ma_values设置为NULL，因为所有的value都存在了PyDictKeyEntry对象的me_value里面</span></span><br><span class="line">        mp-&gt;ma_values = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (oldvalues != empty_values) &#123;</span><br><span class="line">            free_values(oldvalues);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;  <span class="comment">// 否则的话说明这本身就是一个combined table</span></span><br><span class="line">        <span class="keyword">if</span> (oldkeys-&gt;dk_nentries == numentries) &#123;</span><br><span class="line">            <span class="comment">//将就得entries拷贝到新的entries里面去</span></span><br><span class="line">            <span class="built_in">memcpy</span>(newentries, oldentries, numentries * <span class="keyword">sizeof</span>(PyDictKeyEntry));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//处理旧的entries</span></span><br><span class="line">            <span class="comment">//active态的entry搬到新table中</span></span><br><span class="line">            <span class="comment">//dummy态的entry，调整key的引用计数，丢弃该entry</span></span><br><span class="line">            PyDictKeyEntry *ep = oldentries;</span><br><span class="line">            <span class="keyword">for</span> (Py_ssize_t i = <span class="number">0</span>; i &lt; numentries; i++) &#123;</span><br><span class="line">                <span class="keyword">while</span> (ep-&gt;me_value == <span class="literal">NULL</span>)</span><br><span class="line">                    ep++;</span><br><span class="line">                newentries[i] = *ep++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//字典缓冲池的操作，后面介绍</span></span><br><span class="line">        assert(oldkeys-&gt;dk_lookup != lookdict_split);</span><br><span class="line">        assert(oldkeys-&gt;dk_refcnt == <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (oldkeys-&gt;dk_size == PyDict_MINSIZE &amp;&amp;</span><br><span class="line">            numfreekeys &lt; PyDict_MAXFREELIST) &#123;</span><br><span class="line">            DK_DEBUG_DECREF keys_free_list[numfreekeys++] = oldkeys;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            DK_DEBUG_DECREF PyObject_FREE(oldkeys);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//建立哈希表索引</span></span><br><span class="line">    build_indices(mp-&gt;ma_keys, newentries, numentries);</span><br><span class="line">    mp-&gt;ma_keys-&gt;dk_usable -= numentries;</span><br><span class="line">    mp-&gt;ma_keys-&gt;dk_nentries = numentries;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们再来看一下改变dict内存空间的一些动作：</strong></p>
<ul>
<li><code>首先要确定table的大小，很显然这个大小一定要大于minsize，这个minsize通过我们已经看到了，是通过宏定义的，是已用entry的3倍</code></li>
<li><code>根据新的table，重新申请内存</code></li>
<li><code>将原来的处于active状态的entry拷贝到新的内存当中，而对于处于dummy状态的entry则直接丢弃。可以丢弃的原因我们上面也说过了。主要是因为哈希表扩容了，会申请的一个新的数组，直接将原来的active态的entry组成一条新的探测链即可，因此也就不需要这些dummy态的entry了</code></li>
</ul>
<h4 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h4><p><strong>插入元素(设置元素)如果明白了，删除元素我觉得都可以不需要说了。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">PyDict_DelItem</span><span class="params">(PyObject *op, PyObject *key)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//这显然和dictresize一样，是先获取hash值</span></span><br><span class="line">    Py_hash_t hash;</span><br><span class="line">    assert(key);</span><br><span class="line">    <span class="keyword">if</span> (!PyUnicode_CheckExact(key) ||</span><br><span class="line">        (hash = ((PyASCIIObject *) key)-&gt;hash) == <span class="number">-1</span>) &#123;</span><br><span class="line">        hash = PyObject_Hash(key);</span><br><span class="line">        <span class="keyword">if</span> (hash == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//真正来删除是下面这个函数</span></span><br><span class="line">    <span class="keyword">return</span> _PyDict_DelItem_KnownHash(op, key, hash);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line">_PyDict_DelItem_KnownHash(PyObject *op, PyObject *key, Py_hash_t hash)</span><br><span class="line">&#123;</span><br><span class="line">    Py_ssize_t ix;</span><br><span class="line">    PyDictObject *mp;</span><br><span class="line">    PyObject *old_value;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//类型检测</span></span><br><span class="line">    <span class="keyword">if</span> (!PyDict_Check(op)) &#123;</span><br><span class="line">        PyErr_BadInternalCall();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    assert(key);</span><br><span class="line">    assert(hash != <span class="number">-1</span>);</span><br><span class="line">    mp = (PyDictObject *)op;</span><br><span class="line">    <span class="comment">//获取对应entry的index</span></span><br><span class="line">    ix = (mp-&gt;ma_keys-&gt;dk_lookup)(mp, key, hash, &amp;old_value);</span><br><span class="line">    <span class="keyword">if</span> (ix == DKIX_ERROR)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (ix == DKIX_EMPTY || old_value == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        _PyErr_SetKeyError(key);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// split table不支持删除操作，如果是split table，需要转换成combined table</span></span><br><span class="line">    <span class="keyword">if</span> (_PyDict_HasSplitTable(mp)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dictresize(mp, DK_SIZE(mp-&gt;ma_keys))) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ix = (mp-&gt;ma_keys-&gt;dk_lookup)(mp, key, hash, &amp;old_value);</span><br><span class="line">        assert(ix &gt;= <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//传入hash和ix，又调用了delitem_common</span></span><br><span class="line">    <span class="keyword">return</span> delitem_common(mp, hash, ix, old_value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">delitem_common</span><span class="params">(PyDictObject *mp, Py_hash_t hash, Py_ssize_t ix,</span></span><br><span class="line"><span class="params">               PyObject *old_value)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyObject *old_key;</span><br><span class="line">    PyDictKeyEntry *ep;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//找到对应的hash索引</span></span><br><span class="line">    Py_ssize_t hashpos = lookdict_index(mp-&gt;ma_keys, hash, ix);</span><br><span class="line">    assert(hashpos &gt;= <span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//已经entries个数-1</span></span><br><span class="line">    mp-&gt;ma_used--;</span><br><span class="line">    <span class="comment">//版本-1</span></span><br><span class="line">    mp-&gt;ma_version_tag = DICT_NEXT_VERSION();</span><br><span class="line">    <span class="comment">//拿到entry的指针</span></span><br><span class="line">    ep = &amp;DK_ENTRIES(mp-&gt;ma_keys)[ix];</span><br><span class="line">    <span class="comment">//将其设置为dummy状态</span></span><br><span class="line">    dk_set_index(mp-&gt;ma_keys, hashpos, DKIX_DUMMY);</span><br><span class="line">    ENSURE_ALLOWS_DELETIONS(mp);</span><br><span class="line">    old_key = ep-&gt;me_key;</span><br><span class="line">    <span class="comment">//将其key、value都设置为NULL</span></span><br><span class="line">    ep-&gt;me_key = <span class="literal">NULL</span>;</span><br><span class="line">    ep-&gt;me_value = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//减少引用计数</span></span><br><span class="line">    Py_DECREF(old_key);</span><br><span class="line">    Py_DECREF(old_value);</span><br><span class="line"></span><br><span class="line">    assert(_PyDict_CheckConsistency(mp));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>流程非常清晰，也很简单。先使用PyDict_DelItem计算hash值，再使用_PyDict_DelItem_KnownHash计算出索引，最后使用delitem_common获取相应的entry，删除维护的元素，并将entry从active态设置为dummy态，同时还会调整ma_used(已用entry)的数量</strong></p>
<h3 id="PyDictObject缓存池"><a href="#PyDictObject缓存池" class="headerlink" title="PyDictObject缓存池"></a>PyDictObject缓存池</h3><p><strong>从介绍PyLongObject的小整数对象池的时候，我们就说过，不同的对象都有自己的缓存池，比如列表，当然字典也不例外。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PyDict_MAXFREELIST</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PyDict_MAXFREELIST 80</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">static</span> PyDictObject *free_list[PyDict_MAXFREELIST];</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> numfree = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p><strong>PyDictObject的缓存池机制其实和PyListObject的缓存池是类似的，开始时，这个缓存池什么也没有，直到第一个PyDictObject对象被销毁时，这个PyDictObject缓冲池里面才开始接纳被缓冲的PyDictObject对象。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">dict_dealloc</span><span class="params">(PyDictObject *mp)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//获取ma_values指针</span></span><br><span class="line">    PyObject **values = mp-&gt;ma_values;</span><br><span class="line">    <span class="comment">//获取所有的ma_keys指针</span></span><br><span class="line">    PyDictKeysObject *keys = mp-&gt;ma_keys;</span><br><span class="line">    <span class="comment">//两个整型</span></span><br><span class="line">    Py_ssize_t i, n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//追踪、调试</span></span><br><span class="line">    PyObject_GC_UnTrack(mp);</span><br><span class="line">    Py_TRASHCAN_SAFE_BEGIN(mp)</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//调整引用计数    </span></span><br><span class="line">    <span class="keyword">if</span> (values != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (values != empty_values) &#123;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>, n = mp-&gt;ma_keys-&gt;dk_nentries; i &lt; n; i++) &#123;</span><br><span class="line">                Py_XDECREF(values[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            free_values(values);</span><br><span class="line">        &#125;</span><br><span class="line">        DK_DECREF(keys);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (keys != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        assert(keys-&gt;dk_refcnt == <span class="number">1</span>);</span><br><span class="line">        DK_DECREF(keys);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将被销毁的对象放到缓冲池当中</span></span><br><span class="line">    <span class="keyword">if</span> (numfree &lt; PyDict_MAXFREELIST &amp;&amp; Py_TYPE(mp) == &amp;PyDict_Type)</span><br><span class="line">        free_list[numfree++] = mp;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        Py_TYPE(mp)-&gt;tp_free((PyObject *)mp);</span><br><span class="line">    Py_TRASHCAN_SAFE_END(mp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>和PyListObject对象的缓冲池机制一样，缓冲池中只保留了PyDictObject对象。如果维护的是从系统堆中申请的内存空间，那么Python将释放这份内存空间，归还给系统堆。如果不是，那么仅仅只需要调整维护的对象的引用计数即可。</strong></p>
<p><strong>其实在创建一个PyDictObject对象时，如果缓冲池中有可用的对象，也会直接从缓冲池中取，而不需要再重新创建。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">new_dict</span><span class="params">(PyDictKeysObject *keys, PyObject **values)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyDictObject *mp;</span><br><span class="line">    assert(keys != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (numfree) &#123;</span><br><span class="line">        mp = free_list[--numfree];</span><br><span class="line">        assert (mp != <span class="literal">NULL</span>);</span><br><span class="line">        assert (Py_TYPE(mp) == &amp;PyDict_Type);</span><br><span class="line">        _Py_NewReference((PyObject *)mp);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>​        <strong>关于字典的剖析我们就说到这里，其实内容还是很多的，尤其是哈希表背后的一些原理，值得好好体会一下。</strong>    </p>
<h3 id="PySetObject"><a href="#PySetObject" class="headerlink" title="PySetObject"></a>PySetObject</h3><p><strong>由于集合和字典在底层使用的都是哈希表，所以我们放在一起说吧。</strong></p>
<p><strong>既然集合也使用了哈希表，那么它的查询性能也是很高的。由于哈希表我们已经说了很多了，所以我们下面就直接来看集合的底层结构吧。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//python中的集合的每一个元素，是通过setentry这个结构体来存储的</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject *key; <span class="comment">// 元素的指针</span></span><br><span class="line">    Py_hash_t hash; <span class="comment">// 元素的哈希值</span></span><br><span class="line">&#125; setentry;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_HEAD</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//我们发现在set中，每一个元素依然叫做entry</span></span><br><span class="line">    Py_ssize_t fill;            <span class="comment">/* active态以及dummy态的entry总数量*/</span></span><br><span class="line">    Py_ssize_t used;            <span class="comment">/* active态的entry数量 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 该table包含mask+1个slot，mask+1是2的幂次方</span></span><br><span class="line"><span class="comment">    我们存储的是mask，而不是size，因为更常需要mask</span></span><br><span class="line"><span class="comment">    这个mask是用来和哈希值进行运算的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Py_ssize_t mask;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 对于小表，该table指向固定大小的small table，对于bigger table则指向额外的malloc内存</span></span><br><span class="line"><span class="comment">    该table的指针永远不会为NULL。</span></span><br><span class="line"><span class="comment">    所以它是指向setentry数组的一个指针</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    setentry *table;</span><br><span class="line">    Py_hash_t hash;             <span class="comment">/* 该PySetObject的哈希值，只适用于frozenset */</span></span><br><span class="line">    Py_ssize_t finger;          </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    用于pop元素的，search finger就是我们从包含某个元素的节点开始，找到我们希望的元素</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">//smalltable就是显然就是一个保存了setentry类型的数组</span></span><br><span class="line">    <span class="comment">//PySet_MINSIZE是一个宏定义，默认是8。如果元素比较少的话，存在smalltable里面</span></span><br><span class="line">    <span class="comment">//当smalltable存不下的时候(仮)，就会使用malloc申请。存不下，指的是超过8个的时候吗？</span></span><br><span class="line">    <span class="comment">//由于哈希表的特性，需要预留一定的空间，因此还没存到8个的时候，就会扩容了</span></span><br><span class="line">    setentry smalltable[PySet_MINSIZE];</span><br><span class="line">    PyObject *weakreflist;      <span class="comment">/* 弱引用列表 */</span></span><br><span class="line">&#125; PySetObject;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/03/29/09-%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1229382-20200814164928460-76799035-1680101009726.png" alt="img"></p>
<h4 id="PySetObject对象的创建"><a href="#PySetObject对象的创建" class="headerlink" title="PySetObject对象的创建"></a>PySetObject对象的创建</h4><p><strong>创建一个PySetObject对象可以使用PySet_New方法：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PySet_New</span><span class="params">(PyObject *iterable)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//底层调用了make_new_set</span></span><br><span class="line">    <span class="keyword">return</span> make_new_set(&amp;PySet_Type, iterable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">make_new_set</span><span class="params">(PyTypeObject *type, PyObject *iterable)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//申明一个PySetObject *指针</span></span><br><span class="line">    PySetObject *so;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//申请该元素所需要的内存</span></span><br><span class="line">    so = (PySetObject *)type-&gt;tp_alloc(type, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//申请失败，返回NULL</span></span><br><span class="line">    <span class="keyword">if</span> (so == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//初始化都为0</span></span><br><span class="line">    so-&gt;fill = <span class="number">0</span>;</span><br><span class="line">    so-&gt;used = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//PySet_MINSIZE默认为8，mask初始化为7</span></span><br><span class="line">    so-&gt;mask = PySet_MINSIZE - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//将table指向保存数据的smalltable的头指针</span></span><br><span class="line">    so-&gt;table = so-&gt;smalltable;</span><br><span class="line">    <span class="comment">//初始化hash值为-1</span></span><br><span class="line">    so-&gt;hash = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//finger为0</span></span><br><span class="line">    so-&gt;finger = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//弱引用列表为NULL</span></span><br><span class="line">    so-&gt;weakreflist = <span class="literal">NULL</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//如果迭代器不为NULL，那么把元素依次更新的so这个PySetObject中</span></span><br><span class="line">    <span class="keyword">if</span> (iterable != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (set_update_internal(so, iterable)) &#123;</span><br><span class="line">            Py_DECREF(so);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//返回初始化完成的set</span></span><br><span class="line">    <span class="keyword">return</span> (PyObject *)so;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>从以上步骤可以看出，初始化一个PySetObject对象主要初始化其内部的数据结构。</strong></p>
<h4 id="插入元素-1"><a href="#插入元素-1" class="headerlink" title="插入元素"></a>插入元素</h4><p><strong>插入元素，会调用PySet_Add：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">PySet_Add</span><span class="params">(PyObject *anyset, PyObject *key)</span></span><br><span class="line">&#123;	<span class="comment">//参数是两个指针</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//类型检测</span></span><br><span class="line">    <span class="keyword">if</span> (!PySet_Check(anyset) &amp;&amp;</span><br><span class="line">        (!PyFrozenSet_Check(anyset) || Py_REFCNT(anyset) != <span class="number">1</span>)) &#123;</span><br><span class="line">        PyErr_BadInternalCall();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//本质上调用了set_add_key</span></span><br><span class="line">    <span class="keyword">return</span> set_add_key((PySetObject *)anyset, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">set_add_key</span><span class="params">(PySetObject *so, PyObject *key)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//声明一个变量，显然是存储哈希值的</span></span><br><span class="line">    Py_hash_t hash;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//类型检测</span></span><br><span class="line">    <span class="keyword">if</span> (!PyUnicode_CheckExact(key) ||</span><br><span class="line">        (hash = ((PyASCIIObject *) key)-&gt;hash) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">//计算哈希值</span></span><br><span class="line">        hash = PyObject_Hash(key);</span><br><span class="line">        <span class="comment">//如果传入的元素不能被hash，那么直接返回-1</span></span><br><span class="line">        <span class="comment">//在python层面显然会报错</span></span><br><span class="line">        <span class="keyword">if</span> (hash == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//底层又调用了set_add_entry，并把hash也作为参数传了进去</span></span><br><span class="line">    <span class="keyword">return</span> set_add_entry(so, key, hash);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">set_add_entry</span><span class="params">(PySetObject *so, PyObject *key, Py_hash_t hash)</span></span><br><span class="line">&#123;</span><br><span class="line">    setentry *table;  <span class="comment">//指向setentry数组的指针，当然数组里面也是指针</span></span><br><span class="line">    setentry *freeslot;<span class="comment">//存放不可hash的entry</span></span><br><span class="line">    setentry *entry;<span class="comment">//entry指针</span></span><br><span class="line">    <span class="type">size_t</span> perturb;</span><br><span class="line">    <span class="type">size_t</span> mask;<span class="comment">//和hash运算</span></span><br><span class="line">    <span class="type">size_t</span> i; <span class="comment">//一个整型变量，后面的索引值</span></span><br><span class="line">    <span class="type">size_t</span> j;<span class="comment">//遍历用的</span></span><br><span class="line">    <span class="type">int</span> cmp;<span class="comment">//比较的结果</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Pre-increment is necessary to prevent arbitrary code in the rich</span></span><br><span class="line"><span class="comment">       comparison from deallocating the key just before the insertion. */</span></span><br><span class="line">    Py_INCREF(key);  <span class="comment">//增加key的引用计数</span></span><br><span class="line"></span><br><span class="line">  restart:</span><br><span class="line"></span><br><span class="line">    mask = so-&gt;mask;  <span class="comment">//获取mask</span></span><br><span class="line">    i = (<span class="type">size_t</span>)hash &amp; mask;<span class="comment">//mask和hash进行与运算，得到一个索引</span></span><br><span class="line"></span><br><span class="line">    entry = &amp;so-&gt;table[i];<span class="comment">//获取对应的entry指针</span></span><br><span class="line">    <span class="keyword">if</span> (entry-&gt;key == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="comment">//如果entry-&gt;key == NULL，表示当前位置没有被使用</span></span><br><span class="line">        <span class="comment">//直接跳到found_unused标签</span></span><br><span class="line">        <span class="keyword">goto</span> found_unused;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//否则说明有人用了</span></span><br><span class="line">    freeslot = <span class="literal">NULL</span>;</span><br><span class="line">    perturb = hash; <span class="comment">// 将perturb设置为hash</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        找到entry-&gt;hash，之前说了，entry结构体由两部分组成</span></span><br><span class="line"><span class="comment">        一个*key，也就是指向真正元素的指针，另一个是hash值</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//如果和我们当前的hash值一样的话</span></span><br><span class="line">        <span class="keyword">if</span> (entry-&gt;hash == hash) &#123;</span><br><span class="line">            <span class="comment">//拿到当前的key</span></span><br><span class="line">            PyObject *startkey = entry-&gt;key;</span><br><span class="line">            <span class="comment">/* startkey cannot be a dummy because the dummy hash field is -1 */</span></span><br><span class="line">            <span class="comment">//entry里面的key不可以为dummy态，因为这相当于删除(伪删除)了，hash为-1</span></span><br><span class="line">            assert(startkey != dummy);</span><br><span class="line">            <span class="comment">//如果已经存在的key和我们添加的key是一样，说明重复了</span></span><br><span class="line">            <span class="comment">//而集合内的元素不允许重复</span></span><br><span class="line">            <span class="keyword">if</span> (startkey == key)</span><br><span class="line">                <span class="comment">//直接跳转到found_active标签</span></span><br><span class="line">                <span class="keyword">goto</span> found_active;</span><br><span class="line">            <span class="comment">//如果是unicode，那么先转化，然后再比较两个key是否一样</span></span><br><span class="line">            <span class="keyword">if</span> (PyUnicode_CheckExact(startkey)</span><br><span class="line">                &amp;&amp; PyUnicode_CheckExact(key)</span><br><span class="line">                &amp;&amp; _PyUnicode_EQ(startkey, key))</span><br><span class="line">                <span class="comment">//如果一样，跳转到found_active标签</span></span><br><span class="line">                <span class="keyword">goto</span> found_active;</span><br><span class="line">            <span class="comment">//那么获取头部指针</span></span><br><span class="line">            table = so-&gt;table;</span><br><span class="line">            <span class="comment">//增加startkey的引用计数</span></span><br><span class="line">            Py_INCREF(startkey);</span><br><span class="line">            <span class="comment">//不一样的话，通过富比较，去比较两个对象维护的值是否一致</span></span><br><span class="line">            cmp = PyObject_RichCompareBool(startkey, key, Py_EQ);</span><br><span class="line">            <span class="comment">//介绍startkey的引用计数</span></span><br><span class="line">            Py_DECREF(startkey);</span><br><span class="line">            <span class="comment">//如果cmp大于0，比较成功</span></span><br><span class="line">            <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)          </span><br><span class="line">                <span class="comment">//说明索引被人占了</span></span><br><span class="line">                <span class="keyword">goto</span> found_active;</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="comment">//小于0说明比较失败</span></span><br><span class="line">                <span class="keyword">goto</span> comparison_error;</span><br><span class="line">            <span class="comment">/* 如果table或者entry改变了，我们必须从头开始 */</span></span><br><span class="line">            <span class="keyword">if</span> (table != so-&gt;table || entry-&gt;key != startkey)</span><br><span class="line">                <span class="comment">//跳转到restart标签</span></span><br><span class="line">                <span class="keyword">goto</span> restart;</span><br><span class="line">            <span class="comment">//拿到当前的mask</span></span><br><span class="line">            mask = so-&gt;mask;                 <span class="comment">/* help avoid a register spill */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果不能hash</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (entry-&gt;hash == <span class="number">-1</span>)</span><br><span class="line">            <span class="comment">//则设置为freeslot</span></span><br><span class="line">            freeslot = entry;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//如果当前索引值加上9小于当前的mask</span></span><br><span class="line">        <span class="comment">//#define LINEAR_PROBES 9</span></span><br><span class="line">        <span class="keyword">if</span> (i + LINEAR_PROBES &lt;= mask) &#123;</span><br><span class="line">            <span class="comment">//循环9次</span></span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt; LINEAR_PROBES ; j++) &#123;</span><br><span class="line">                <span class="comment">//每次得到下一个entry</span></span><br><span class="line">                entry++;</span><br><span class="line">                <span class="comment">//如果hash=0，并且对应的key为NULL</span></span><br><span class="line">                <span class="keyword">if</span> (entry-&gt;hash == <span class="number">0</span> &amp;&amp; entry-&gt;key == <span class="literal">NULL</span>)</span><br><span class="line">                    <span class="comment">//跳转到found_unused_or_dummy标签</span></span><br><span class="line">                    <span class="keyword">goto</span> found_unused_or_dummy;</span><br><span class="line">                <span class="keyword">if</span> (entry-&gt;hash == hash) &#123;</span><br><span class="line">                    <span class="comment">//如果hash值相同，获取对应的key</span></span><br><span class="line">                    PyObject *startkey = entry-&gt;key;</span><br><span class="line">                    <span class="comment">//key必须不为dummy态</span></span><br><span class="line">                    assert(startkey != dummy);</span><br><span class="line">                    <span class="comment">//如果两个key相同，跳转到found_active标签</span></span><br><span class="line">                    <span class="keyword">if</span> (startkey == key)</span><br><span class="line">                        <span class="keyword">goto</span> found_active;</span><br><span class="line">                    <span class="comment">//如果为unicode，还是转化后比较</span></span><br><span class="line">                    <span class="keyword">if</span> (PyUnicode_CheckExact(startkey)</span><br><span class="line">                        &amp;&amp; PyUnicode_CheckExact(key)</span><br><span class="line">                        &amp;&amp; _PyUnicode_EQ(startkey, key))</span><br><span class="line">                        <span class="keyword">goto</span> found_active;</span><br><span class="line">                    <span class="comment">//下面的跟if (i + LINEAR_PROBES &lt;= mask) &#123;上面的是一样的</span></span><br><span class="line">                    table = so-&gt;table;</span><br><span class="line">                    Py_INCREF(startkey);</span><br><span class="line">                    cmp = PyObject_RichCompareBool(startkey, key, Py_EQ);</span><br><span class="line">                    Py_DECREF(startkey);</span><br><span class="line">                    <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">goto</span> found_active;</span><br><span class="line">                    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">goto</span> comparison_error;</span><br><span class="line">                    <span class="keyword">if</span> (table != so-&gt;table || entry-&gt;key != startkey)</span><br><span class="line">                        <span class="keyword">goto</span> restart;</span><br><span class="line">                    mask = so-&gt;mask;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (entry-&gt;hash == <span class="number">-1</span>)</span><br><span class="line">                    freeslot = entry;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 如果没有找到，说明哈希值冲突，改变规则，重新计算索引值</span></span><br><span class="line">        perturb &gt;&gt;= PERTURB_SHIFT;</span><br><span class="line">        <span class="comment">//按照(i * 5 + 1 + perturb) &amp; mask重新计算</span></span><br><span class="line">        i = (i * <span class="number">5</span> + <span class="number">1</span> + perturb) &amp; mask;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//获取新索引对应的entry</span></span><br><span class="line">        entry = &amp;so-&gt;table[i];</span><br><span class="line">        <span class="comment">//如果对应的key为NULL，说明重新计算索引之后找到了可以存储的地方</span></span><br><span class="line">        <span class="keyword">if</span> (entry-&gt;key == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="comment">//跳转到found_unused_or_dummy</span></span><br><span class="line">            <span class="keyword">goto</span> found_unused_or_dummy;</span><br><span class="line">        <span class="comment">//否则说明比较倒霉，改变规则重新映射索引依旧冲突</span></span><br><span class="line">        <span class="comment">//那么继续循环，比较key是否一致等等</span></span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">  <span class="comment">//未使用或者dummy，dummy我们是不可以使用的</span></span><br><span class="line">  found_unused_or_dummy:</span><br><span class="line">    <span class="comment">//如果这个freeslot为NULL，说明是可用的</span></span><br><span class="line">    <span class="keyword">if</span> (freeslot == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="comment">//跳转</span></span><br><span class="line">        <span class="keyword">goto</span> found_unused;</span><br><span class="line">    <span class="comment">//否则，说明为dummy态，那么我们依旧可以使用，正好废物利用</span></span><br><span class="line">    <span class="comment">//将used数量加一</span></span><br><span class="line">    so-&gt;used++;</span><br><span class="line">    <span class="comment">//设置key和hash值</span></span><br><span class="line">    freeslot-&gt;key = key;</span><br><span class="line">    freeslot-&gt;hash = hash;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">  <span class="comment">//发现未使用的</span></span><br><span class="line">  found_unused:</span><br><span class="line">    <span class="comment">//将fill和used个数+1</span></span><br><span class="line">    so-&gt;fill++;</span><br><span class="line">    so-&gt;used++;</span><br><span class="line">    <span class="comment">//设置key和hash值</span></span><br><span class="line">    entry-&gt;key = key;</span><br><span class="line">    entry-&gt;hash = hash;</span><br><span class="line">    <span class="comment">//检查active态+dummy的entry个数是否小于mask的3/5</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">size_t</span>)so-&gt;fill*<span class="number">5</span> &lt; mask*<span class="number">3</span>)</span><br><span class="line">        <span class="comment">//是的话，表示无需扩容</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//否则要进行扩容</span></span><br><span class="line">    <span class="comment">//扩容的规则就是如果active态的entry各式各样如果大于50000，那么两倍扩容，否则四倍扩容</span></span><br><span class="line">    <span class="keyword">return</span> set_table_resize(so, so-&gt;used&gt;<span class="number">50000</span> ? so-&gt;used*<span class="number">2</span> : so-&gt;used*<span class="number">4</span>);</span><br><span class="line">	</span><br><span class="line">  <span class="comment">//如果是found_active，表示key重复了</span></span><br><span class="line">  <span class="comment">//直接减少一个引用计数即可</span></span><br><span class="line">  found_active:</span><br><span class="line">    Py_DECREF(key);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//比较失败，同样减少引用计数，返回-1</span></span><br><span class="line">  comparison_error:</span><br><span class="line">    Py_DECREF(key);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结一下流程就是：</strong></p>
<ul>
<li><code>传入hash值，计算出索引值，通过索引值找到对应的entry</code></li>
<li><code>如果entry-&gt;key=NULL，那么将hash和key存到对应的entry</code></li>
<li><code>如果有key，但是值相同，则不插入，直接减少引入计数。因为不是字典，不存在更新一说</code></li>
<li><code>如果有key，但是值不相同。那么从该索引往后的9个entry(i + 9 &lt;= mask)，如果存在key为NULL的entry，那么设置进去。</code></li>
<li><code>如果以上条件都不满足，那么改变策略重新计算索引值，直到找到一个满足key为NULL的entry</code></li>
<li><code>判断容量问题，如果active态+dummy态的entry个数不小于3/5 * mask，那么扩容，扩容的规则是active态的entry个数是否大于50000，是的话就二倍扩容，否则4倍扩容。</code></li>
</ul>
<h4 id="PySetObject扩容"><a href="#PySetObject扩容" class="headerlink" title="PySetObject扩容"></a>PySetObject扩容</h4><p><strong>我们之前说PySetObject会改变容量，那么它是如何改变的呢？</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">set_table_resize</span><span class="params">(PySetObject *so, Py_ssize_t minused)</span></span><br><span class="line">&#123;	<span class="comment">//显然参数是：PySetObject *指针以及容量大小</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//三个setentry *指针</span></span><br><span class="line">    setentry *oldtable, *newtable, *entry;</span><br><span class="line">    <span class="comment">//oldmask</span></span><br><span class="line">    Py_ssize_t oldmask = so-&gt;mask;</span><br><span class="line">    <span class="comment">//newmask</span></span><br><span class="line">    <span class="type">size_t</span> newmask;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//是否为其申请过内存</span></span><br><span class="line">    <span class="type">int</span> is_oldtable_malloced;</span><br><span class="line">    <span class="comment">//将PySet_MINSIZE个entry直接copy过来</span></span><br><span class="line">    <span class="comment">//因为你既然要扩容的话，那么肯定是这里面存不下了</span></span><br><span class="line">    setentry small_copy[PySet_MINSIZE];</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//minused必须大于等于0</span></span><br><span class="line">    assert(minused &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Find the smallest table size &gt; minused. */</span></span><br><span class="line">    <span class="comment">/* XXX speed-up with intrinsics */</span></span><br><span class="line">    <span class="comment">//newsize扩大二倍，直到大于minused</span></span><br><span class="line">    <span class="comment">//所以我们刚才说的大于50000，二倍扩容，否则四倍扩容</span></span><br><span class="line">    <span class="comment">//实际上是最终的newsize是比二倍或者四倍扩容的结果要大的</span></span><br><span class="line">    <span class="type">size_t</span> newsize = PySet_MINSIZE;</span><br><span class="line">    <span class="keyword">while</span> (newsize &lt;= (<span class="type">size_t</span>)minused) &#123;</span><br><span class="line">        <span class="comment">//newsize最大顶多也就是PY_SSIZE_T_MAX + 1，但是基本不可能存储这么多元素</span></span><br><span class="line">        newsize &lt;&lt;= <span class="number">1</span>; <span class="comment">// The largest possible value is PY_SSIZE_T_MAX + 1.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Get space for a new table. */</span></span><br><span class="line">    <span class="comment">//为新的table申请空间</span></span><br><span class="line">    oldtable = so-&gt;table;</span><br><span class="line">    assert(oldtable != <span class="literal">NULL</span>);</span><br><span class="line">    is_oldtable_malloced = oldtable != so-&gt;smalltable;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//如果newsize和PySet_MINSIZE(这里的8)相等</span></span><br><span class="line">    <span class="keyword">if</span> (newsize == PySet_MINSIZE) &#123;</span><br><span class="line">        <span class="comment">/* A large table is shrinking, or we can&#x27;t get any smaller. */</span></span><br><span class="line">        <span class="comment">//拿到smalltable，就是默认初始化8个entry数组的那哥们</span></span><br><span class="line">        newtable = so-&gt;smalltable;</span><br><span class="line">        <span class="comment">//如果oldtable和newtable一样</span></span><br><span class="line">        <span class="keyword">if</span> (newtable == oldtable) &#123;</span><br><span class="line">            <span class="comment">//并且没有dummy态的entry</span></span><br><span class="line">            <span class="keyword">if</span> (so-&gt;fill == so-&gt;used) &#123;</span><br><span class="line">                <span class="comment">/* No dummies, so no point doing anything. */</span></span><br><span class="line">                <span class="comment">//那么无需做任何事情</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* We&#x27;re not going to resize it, but rebuild the</span></span><br><span class="line"><span class="comment">               table anyway to purge old dummy entries.</span></span><br><span class="line"><span class="comment">               Subtle:  This is *necessary* if fill==size,</span></span><br><span class="line"><span class="comment">               as set_lookkey needs at least one virgin slot to</span></span><br><span class="line"><span class="comment">               terminate failing searches.  If fill &lt; size, it&#x27;s</span></span><br><span class="line"><span class="comment">               merely desirable, as dummies slow searches. */</span></span><br><span class="line">            <span class="comment">//否则的话，dummy的个数一定大于0</span></span><br><span class="line">            assert(so-&gt;fill &gt; so-&gt;used);</span><br><span class="line">            <span class="comment">//扔掉dummy态，只把oldtable中active态的拷贝过来</span></span><br><span class="line">            <span class="built_in">memcpy</span>(small_copy, oldtable, <span class="keyword">sizeof</span>(small_copy));</span><br><span class="line">            <span class="comment">//将small_copy重新设置为oldtable</span></span><br><span class="line">            oldtable = small_copy;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//否则的话，肯定大于8，申请newsize个setentry所需要的空间</span></span><br><span class="line">        newtable = PyMem_NEW(setentry, newsize);</span><br><span class="line">        <span class="comment">//如果newtable为NULL，那么申请内存失败，返回-1</span></span><br><span class="line">        <span class="keyword">if</span> (newtable == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            PyErr_NoMemory();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make the set empty, using the new table. */</span></span><br><span class="line">    <span class="comment">//newtable肯定不等于oldtable</span></span><br><span class="line">    assert(newtable != oldtable);</span><br><span class="line">    <span class="comment">//创建一个能融安newsize个entry的空set</span></span><br><span class="line">    <span class="built_in">memset</span>(newtable, <span class="number">0</span>, <span class="keyword">sizeof</span>(setentry) * newsize);</span><br><span class="line">    <span class="comment">//将mask设置为newsize-1</span></span><br><span class="line">    <span class="comment">//将table设置为newtable</span></span><br><span class="line">    so-&gt;mask = newsize - <span class="number">1</span>;</span><br><span class="line">    so-&gt;table = newtable;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Copy the data over; this is refcount-neutral for active entries;</span></span><br><span class="line"><span class="comment">       dummy entries aren&#x27;t copied over, of course */</span></span><br><span class="line">    <span class="comment">//获取newmask</span></span><br><span class="line">    newmask = (<span class="type">size_t</span>)so-&gt;mask;</span><br><span class="line">    <span class="comment">//将原来旧table的setentry数组里面所有setentry的key和hash值全部设置到新的table里面</span></span><br><span class="line">    <span class="keyword">if</span> (so-&gt;fill == so-&gt;used) &#123;</span><br><span class="line">        <span class="keyword">for</span> (entry = oldtable; entry &lt;= oldtable + oldmask; entry++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry-&gt;key != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                set_insert_clean(newtable, newmask, entry-&gt;key, entry-&gt;hash);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        so-&gt;fill = so-&gt;used;</span><br><span class="line">        <span class="keyword">for</span> (entry = oldtable; entry &lt;= oldtable + oldmask; entry++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry-&gt;key != <span class="literal">NULL</span> &amp;&amp; entry-&gt;key != dummy) &#123;</span><br><span class="line">                set_insert_clean(newtable, newmask, entry-&gt;key, entry-&gt;hash);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//如果已经为其申请了内存，那么要将其归还给系统堆</span></span><br><span class="line">    <span class="keyword">if</span> (is_oldtable_malloced)</span><br><span class="line">        PyMem_DEL(oldtable);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置元素是通过set_insert_clean设置的</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">set_insert_clean</span><span class="params">(setentry *table, <span class="type">size_t</span> mask, PyObject *key, Py_hash_t hash)</span></span><br><span class="line">&#123;</span><br><span class="line">    setentry *entry;</span><br><span class="line">    <span class="type">size_t</span> perturb = hash;</span><br><span class="line">    <span class="type">size_t</span> i = (<span class="type">size_t</span>)hash &amp; mask; <span class="comment">//计算索引</span></span><br><span class="line">    <span class="type">size_t</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        entry = &amp;table[i];  <span class="comment">//获取当前entry</span></span><br><span class="line">        <span class="keyword">if</span> (entry-&gt;key == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">goto</span> found_null; <span class="comment">//如果为空则跳转found_null设置key与hash</span></span><br><span class="line">        <span class="keyword">if</span> (i + LINEAR_PROBES &lt;= mask) &#123;</span><br><span class="line">            <span class="comment">//如果没有还是老规矩，遍历之后的9个entry</span></span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; LINEAR_PROBES; j++) &#123;</span><br><span class="line">                entry++;</span><br><span class="line">                <span class="comment">//找到空的entry，那么跳转到found_null设置key与hash</span></span><br><span class="line">                <span class="keyword">if</span> (entry-&gt;key == <span class="literal">NULL</span>)</span><br><span class="line">                    <span class="keyword">goto</span> found_null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没有找到，那么改变规则，重新计算索引</span></span><br><span class="line">        perturb &gt;&gt;= PERTURB_SHIFT;</span><br><span class="line">        i = (i * <span class="number">5</span> + <span class="number">1</span> + perturb) &amp; mask;</span><br><span class="line">    &#125;</span><br><span class="line">  found_null:</span><br><span class="line">    <span class="comment">//设置key与hash</span></span><br><span class="line">    entry-&gt;key = key;</span><br><span class="line">    entry-&gt;hash = hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="删除元素-1"><a href="#删除元素-1" class="headerlink" title="删除元素"></a>删除元素</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">set_remove</span><span class="params">(PySetObject *so, PyObject *key)</span></span><br><span class="line">&#123;	</span><br><span class="line">    PyObject *tmpkey;</span><br><span class="line">    <span class="type">int</span> rv;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//将该值设置为dummy态</span></span><br><span class="line">    rv = set_discard_key(so, key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rv &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//类型检测</span></span><br><span class="line">        <span class="keyword">if</span> (!PySet_Check(key) || !PyErr_ExceptionMatches(PyExc_TypeError))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        PyErr_Clear();</span><br><span class="line">        <span class="comment">//对该值重新初始化为frozenset</span></span><br><span class="line">        tmpkey = make_new_set(&amp;PyFrozenSet_Type, key);</span><br><span class="line">        <span class="keyword">if</span> (tmpkey == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">//将该key设置为空</span></span><br><span class="line">        rv = set_discard_key(so, tmpkey);</span><br><span class="line">        Py_DECREF(tmpkey);</span><br><span class="line">        <span class="keyword">if</span> (rv &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//如果没有找到则报错</span></span><br><span class="line">    <span class="keyword">if</span> (rv == DISCARD_NOTFOUND) &#123;</span><br><span class="line">        _PyErr_SetKeyError(key);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Py_RETURN_NONE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//里面调用了set_discard_key方法</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">set_discard_key</span><span class="params">(PySetObject *so, PyObject *key)</span></span><br><span class="line">&#123;</span><br><span class="line">    Py_hash_t hash;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//老套路，先计算hash值</span></span><br><span class="line">    <span class="keyword">if</span> (!PyUnicode_CheckExact(key) ||</span><br><span class="line">        (hash = ((PyASCIIObject *) key)-&gt;hash) == <span class="number">-1</span>) &#123;</span><br><span class="line">        hash = PyObject_Hash(key);</span><br><span class="line">        <span class="keyword">if</span> (hash == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将hash值也船进入</span></span><br><span class="line">    <span class="keyword">return</span> set_discard_entry(so, key, hash);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">set_discard_entry</span><span class="params">(PySetObject *so, PyObject *key, Py_hash_t hash)</span></span><br><span class="line">&#123;</span><br><span class="line">    setentry *entry;</span><br><span class="line">    PyObject *old_key;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">////通过传入的key和hash找到该entry</span></span><br><span class="line">    <span class="comment">//并且hash对应的key要和传入的key是一样的</span></span><br><span class="line">    entry = set_lookkey(so, key, hash);  </span><br><span class="line">    <span class="comment">//如果entry为NULL，直接返回-1</span></span><br><span class="line">    <span class="keyword">if</span> (entry == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//如果entry不为NULL，但是对应的key为NULL</span></span><br><span class="line">    <span class="comment">//返回DISCARD_NOTFOUND</span></span><br><span class="line">    <span class="keyword">if</span> (entry-&gt;key == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> DISCARD_NOTFOUND;</span><br><span class="line">    <span class="comment">//获取要删除的key</span></span><br><span class="line">    old_key = entry-&gt;key;</span><br><span class="line">    <span class="comment">//并将entry的key设置为dummy</span></span><br><span class="line">    entry-&gt;key = dummy;</span><br><span class="line">    <span class="comment">//hash值设置为-1</span></span><br><span class="line">    entry-&gt;hash = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//减少使用数量</span></span><br><span class="line">    so-&gt;used--;</span><br><span class="line">    <span class="comment">//减少引用计数</span></span><br><span class="line">    Py_DECREF(old_key);</span><br><span class="line">    <span class="comment">//返回DISCARD_FOUND</span></span><br><span class="line">    <span class="keyword">return</span> DISCARD_FOUND;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>可以看到集合添加、删除元素和字典是有些相似的，毕竟底层都是使用了hash表嘛。</strong></p>
<h4 id="集合的运算-交集"><a href="#集合的运算-交集" class="headerlink" title="集合的运算(交集)"></a>集合的运算(交集)</h4><p><strong>在python中使用集合的时候，可以取两个集合的交集、并集、差集、对称差集等等，这里介绍一下交集，其余的可以自行看源码研究<code>(Objects/setobject.c)</code>。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">set_intersection</span><span class="params">(PySetObject *so, PyObject *other)</span></span><br><span class="line">&#123;	    </span><br><span class="line">    <span class="comment">//result，显然是用来存储两者交集运算的结果的</span></span><br><span class="line">    PySetObject *result;</span><br><span class="line">    <span class="comment">//不看下面代码的话，很难知道这几个PyObject * 是用来干啥的</span></span><br><span class="line">    <span class="comment">//我们下面代码再看看这是干啥的</span></span><br><span class="line">    PyObject *key, *it, *tmp;</span><br><span class="line">    <span class="comment">//这个肯定是hash值</span></span><br><span class="line">    Py_hash_t hash;</span><br><span class="line">    <span class="type">int</span> rv;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//如果两个对象一样</span></span><br><span class="line">    <span class="keyword">if</span> ((PyObject *)so == other)</span><br><span class="line">        <span class="comment">//直接返回其中一个的拷贝即可</span></span><br><span class="line">        <span class="keyword">return</span> set_copy(so);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//这行代码表示创建一个空的PySetObject *</span></span><br><span class="line">    result = (PySetObject *)make_new_set_basetype(Py_TYPE(so), <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//如果result == NULL，说明创建失败</span></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//检测other是不是PySetObject *</span></span><br><span class="line">    <span class="keyword">if</span> (PyAnySet_Check(other)) &#123;</span><br><span class="line">        <span class="comment">//初始索引为0</span></span><br><span class="line">        Py_ssize_t pos = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//setentry *</span></span><br><span class="line">        setentry *entry;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//如果other元素的个数大于so</span></span><br><span class="line">        <span class="keyword">if</span> (PySet_GET_SIZE(other) &gt; PySet_GET_SIZE(so)) &#123;</span><br><span class="line">            <span class="comment">//就把so和other进行交换</span></span><br><span class="line">            tmp = (PyObject *)so;</span><br><span class="line">            so = (PySetObject *)other;</span><br><span class="line">            other = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//从少的那一方的开头开始便利</span></span><br><span class="line">        <span class="keyword">while</span> (set_next((PySetObject *)other, &amp;pos, &amp;entry)) &#123;</span><br><span class="line">            <span class="comment">//拿到key和hash</span></span><br><span class="line">            key = entry-&gt;key;</span><br><span class="line">            hash = entry-&gt;hash;</span><br><span class="line">            <span class="comment">//传入other的key和hash，在so中去找</span></span><br><span class="line">            rv = set_contains_entry(so, key, hash);</span><br><span class="line">            <span class="keyword">if</span> (rv &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//如果对应的rv不存在，那么显然就没有</span></span><br><span class="line">                Py_DECREF(result);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (rv) &#123;</span><br><span class="line">                <span class="comment">//存在的话设置进result里面</span></span><br><span class="line">                <span class="keyword">if</span> (set_add_entry(result, key, hash)) &#123;</span><br><span class="line">                    Py_DECREF(result);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//直接返回</span></span><br><span class="line">        <span class="keyword">return</span> (PyObject *)result;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//如果不是PyObject *</span></span><br><span class="line">    <span class="comment">//那么获取其对应的迭代器，相当于python中的__iter__</span></span><br><span class="line">    it = PyObject_GetIter(other);</span><br><span class="line">    <span class="comment">//如果是NULL，降低其引用计数</span></span><br><span class="line">    <span class="keyword">if</span> (it == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Py_DECREF(result);</span><br><span class="line">        <span class="comment">//返回NULL</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//下面的没必要分析了，在python中，只能set和set(或者frozenset)之间才可以取交集</span></span><br><span class="line">    <span class="keyword">while</span> ((key = PyIter_Next(it)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        hash = PyObject_Hash(key);</span><br><span class="line">        <span class="keyword">if</span> (hash == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">        rv = set_contains_entry(so, key, hash);</span><br><span class="line">        <span class="keyword">if</span> (rv &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">        <span class="keyword">if</span> (rv) &#123;</span><br><span class="line">            <span class="keyword">if</span> (set_add_entry(result, key, hash))</span><br><span class="line">                <span class="keyword">goto</span> error;</span><br><span class="line">        &#125;</span><br><span class="line">        Py_DECREF(key);</span><br><span class="line">    &#125;</span><br><span class="line">    Py_DECREF(it);</span><br><span class="line">    <span class="keyword">if</span> (PyErr_Occurred()) &#123;</span><br><span class="line">        Py_DECREF(result);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (PyObject *)result;</span><br><span class="line">  error:</span><br><span class="line">    Py_DECREF(it);</span><br><span class="line">    Py_DECREF(result);</span><br><span class="line">    Py_DECREF(key);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="集合小结"><a href="#集合小结" class="headerlink" title="集合小结"></a>集合小结</h4><p><strong>可以看到，剖析集合的时候话很少。主要是有了剖析字典的经验，因此再剖析集合的时候就很简单了。并且在Python中还有一个frozenset，就是不可变的集合。但是不像列表和元组，元组还是有很多特殊的，并不单单只是不可变的列表，从具有自己独自的结构体就能看出来。而frozenset对象和set对象都是一个结构体，只有一个PySetObject，没有PyFrozenSetObject。我们在看PySetObject的时候，发现里面有一个hash成员，如果是frozenset的话，那么hash值是不为-1的，因为它不可以添加、删除元素，是不可变对象。由于比较相似，因此frozenset就不再说了，可以自己源码中研究，位置还是<code>Object/setobject.c</code>。</strong></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Lin Li</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/03/29/09-%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/">http://example.com/2023/03/29/09-%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">LinLi's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/CPython/">CPython</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/03/29/10-PyCodeObject%E5%AF%B9%E8%B1%A1%E5%92%8Cpyc%E6%96%87%E4%BB%B6/" title="10-PyCodeObject对象和pyc文件"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">10-PyCodeObject对象和pyc文件</div></div></a></div><div class="next-post pull-right"><a href="/2023/03/29/08-%E8%A7%A3%E5%AF%86Python%E4%B8%AD%E5%88%97%E8%A1%A8%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/" title="08-解密Python中列表的底层实现"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">08-解密Python中列表的底层实现</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/03/29/01-%E7%BC%96%E8%AF%91Cpython/" title="01-编译Cpython"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">01-编译Cpython</div></div></a></div><div><a href="/2023/03/29/02-%E4%B8%80%E5%88%87%E5%AF%B9%E8%B1%A1%E7%9A%86PyObject/" title="02-一切对象皆PyObject"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">02-一切对象皆PyObject</div></div></a></div><div><a href="/2023/03/29/04-%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/" title="04-浮点数的底层实现"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">04-浮点数的底层实现</div></div></a></div><div><a href="/2023/03/29/06-Bytes%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BA%95%E5%B1%82%E6%93%8D%E4%BD%9C/" title="06-Bytes对象的底层操作"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">06-Bytes对象的底层操作</div></div></a></div><div><a href="/2023/03/29/03-Python%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E5%99%A8%E5%92%8C%E5%BA%95%E5%B1%82%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86/" title="03-Python引用计数器和底层对象管理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">03-Python引用计数器和底层对象管理</div></div></a></div><div><a href="/2023/03/29/05-Python%E6%95%B4%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/" title="05-Python整数的底层实现"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">05-Python整数的底层实现</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Lin Li</div><div class="author-info__description">今日事，今日毕</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">86</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#09-%E8%A7%A3%E5%AF%86Python%E4%B8%AD%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%EF%BC%8C%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">1.</span> <span class="toc-text">09-解密Python中字典和集合的底层实现，深度分析哈希表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A5%94%E5%AD%90"><span class="toc-number">1.1.</span> <span class="toc-text">楔子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">1.2.</span> <span class="toc-text">基本使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E8%AF%86%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">1.3.</span> <span class="toc-text">初识哈希表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E5%85%B8%E7%9A%84%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E2%80%93PyDictObject"><span class="toc-number">1.4.</span> <span class="toc-text">字典的底层结构–PyDictObject</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E9%87%8F%E7%AD%96%E7%95%A5"><span class="toc-number">1.4.1.</span> <span class="toc-text">容量策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96"><span class="toc-number">1.4.2.</span> <span class="toc-text">内存优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">1.4.3.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">1.5.</span> <span class="toc-text">深入哈希表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E5%80%BC"><span class="toc-number">1.5.1.</span> <span class="toc-text">哈希值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81"><span class="toc-number">1.5.2.</span> <span class="toc-text">哈希冲突</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E7%A6%BB%E9%93%BE%E6%8E%A5%E6%B3%95"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">分离链接法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%80%E6%94%BE%E5%AF%BB%E5%9D%80%E6%B3%95"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">开放寻址法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%A2%E6%B5%8B%E5%87%BD%E6%95%B0"><span class="toc-number">1.5.2.3.</span> <span class="toc-text">探测函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E6%94%BB%E5%87%BB"><span class="toc-number">1.5.3.</span> <span class="toc-text">哈希攻击</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%83%E7%B4%A0%E5%88%A0%E9%99%A4"><span class="toc-number">1.5.4.</span> <span class="toc-text">元素删除</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PyDictObject%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E7%BB%B4%E6%8A%A4"><span class="toc-number">1.6.</span> <span class="toc-text">PyDictObject的创建与维护</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#PyDictObject%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">1.6.1.</span> <span class="toc-text">PyDictObject的创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A0"><span class="toc-number">1.6.2.</span> <span class="toc-text">插入元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-number">1.6.3.</span> <span class="toc-text">删除元素</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PyDictObject%E7%BC%93%E5%AD%98%E6%B1%A0"><span class="toc-number">1.7.</span> <span class="toc-text">PyDictObject缓存池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PySetObject"><span class="toc-number">1.8.</span> <span class="toc-text">PySetObject</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#PySetObject%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">1.8.1.</span> <span class="toc-text">PySetObject对象的创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A0-1"><span class="toc-number">1.8.2.</span> <span class="toc-text">插入元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PySetObject%E6%89%A9%E5%AE%B9"><span class="toc-number">1.8.3.</span> <span class="toc-text">PySetObject扩容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0-1"><span class="toc-number">1.8.4.</span> <span class="toc-text">删除元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E7%9A%84%E8%BF%90%E7%AE%97-%E4%BA%A4%E9%9B%86"><span class="toc-number">1.8.5.</span> <span class="toc-text">集合的运算(交集)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E5%B0%8F%E7%BB%93"><span class="toc-number">1.8.6.</span> <span class="toc-text">集合小结</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/06/18/Detecting-Logic-Bugs-in-Database-Engines-via-Equivalent-Expression-Transformation/" title="Detecting Logic Bugs in Database Engines via Equivalent Expression Transformation">Detecting Logic Bugs in Database Engines via Equivalent Expression Transformation</a><time datetime="2024-06-18T07:48:17.000Z" title="发表于 2024-06-18 15:48:17">2024-06-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/24/Mozi-Discovering-DBMS-Bugs-via-Configuration-Based-Equivalent-Transformation/" title="Mozi: Discovering DBMS Bugs via Configuration-Based Equivalent Transformation">Mozi: Discovering DBMS Bugs via Configuration-Based Equivalent Transformation</a><time datetime="2024-05-24T09:07:56.000Z" title="发表于 2024-05-24 17:07:56">2024-05-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/24/Testing-Graph-Database-Systems-via-Equivalent-Query-Rewriting/" title="Testing Graph Database Systems via Equivalent Query Rewriting">Testing Graph Database Systems via Equivalent Query Rewriting</a><time datetime="2024-05-24T02:53:06.000Z" title="发表于 2024-05-24 10:53:06">2024-05-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/23/Towards-Generic-Database-Management-System-Fuzzing/" title="Towards Generic Database Management System Fuzzing">Towards Generic Database Management System Fuzzing</a><time datetime="2024-05-23T09:51:00.000Z" title="发表于 2024-05-23 17:51:00">2024-05-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/23/When-Fuzzing-Meets-LLMs-Challenges-and-Opportunities/" title="When Fuzzing Meets LLMs: Challenges and Opportunities">When Fuzzing Meets LLMs: Challenges and Opportunities</a><time datetime="2024-05-23T05:04:34.000Z" title="发表于 2024-05-23 13:04:34">2024-05-23</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Lin Li</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>