<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>Testing Database Systems via Differential Query Execution | LinLi's Blog</title><meta name="author" content="Lin Li"><meta name="copyright" content="Lin Li"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Testing Database Systems via Differential Query ExecutionBasic Information: Title: Testing Database Systems via Differential Query Execution (通过差异查询执行测试数据库系统) Authors: Jiansen Song, Wensheng Dou, Ziyu">
<meta property="og:type" content="article">
<meta property="og:title" content="Testing Database Systems via Differential Query Execution">
<meta property="og:url" content="http://example.com/2024/01/22/Testing-Database-Systems-via-Differential-Query-Execution/index.html">
<meta property="og:site_name" content="LinLi&#39;s Blog">
<meta property="og:description" content="Testing Database Systems via Differential Query ExecutionBasic Information: Title: Testing Database Systems via Differential Query Execution (通过差异查询执行测试数据库系统) Authors: Jiansen Song, Wensheng Dou, Ziyu">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2024-01-22T13:12:54.000Z">
<meta property="article:modified_time" content="2024-01-22T13:13:50.950Z">
<meta property="article:author" content="Lin Li">
<meta property="article:tag" content="论文阅读">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/01/22/Testing-Database-Systems-via-Differential-Query-Execution/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Testing Database Systems via Differential Query Execution',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-01-22 21:13:50'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">107</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="LinLi's Blog"><span class="site-name">LinLi's Blog</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Testing Database Systems via Differential Query Execution</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-01-22T13:12:54.000Z" title="发表于 2024-01-22 21:12:54">2024-01-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-01-22T13:13:50.950Z" title="更新于 2024-01-22 21:13:50">2024-01-22</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Testing Database Systems via Differential Query Execution"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="Testing-Database-Systems-via-Differential-Query-Execution"><a href="#Testing-Database-Systems-via-Differential-Query-Execution" class="headerlink" title="Testing Database Systems via Differential Query Execution"></a>Testing Database Systems via Differential Query Execution</h2><h3 id="Basic-Information"><a href="#Basic-Information" class="headerlink" title="Basic Information:"></a>Basic Information:</h3><ul>
<li>Title: Testing Database Systems via Differential Query Execution (通过差异查询执行测试数据库系统)</li>
<li>Authors: Jiansen Song, Wensheng Dou, Ziyu Cui, Qianwang Dai, Wei Wang, Jun Wei, Hua Zhong, Tao Huang</li>
<li>Affiliation: State Key Laboratory of Computer Science, Institute of Software,  Chinese Academy of Sciences; University of Chinese Academy of Sciences;  Nanjing College; Nanjing Institute of Software Technology</li>
<li>Keywords: Database system, DBMS testing, logic bug</li>
<li>URLs: <a target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/document/9514812">Paper</a>, <a target="_blank" rel="noopener" href="https://github.com/tcse-iscas/dqetool">GitHub</a></li>
</ul>
<h3 id="论文简要"><a href="#论文简要" class="headerlink" title="论文简要 :"></a>论文简要 :</h3><ul>
<li>本文提出了一种名为差异查询执行（Differential Query  Execution，DQE）的新颖通用方法，用于检测数据库管理系统（DBMS）中SELECT、UPDATE和DELETE查询中的逻辑错误。通过在五个生产级DBMS上的实验，发现了50个独特的逻辑错误，并成功修复了其中的11个。</li>
</ul>
<h3 id="背景信息"><a href="#背景信息" class="headerlink" title="背景信息:"></a>背景信息:</h3><ul>
<li>论文背景:  数据库管理系统（DBMS）通过结构化查询语言（SQL）提供高效的数据检索和操作。然而，DBMS的错误实现可能导致逻辑错误，从而导致SELECT查询返回错误结果，或者UPDATE和DELETE查询生成错误的数据库状态。现有方法主要集中在检测SELECT查询中的逻辑错误，而UPDATE和DELETE查询中的逻辑错误尚未得到解决。</li>
<li>过去方案: 过去的方法主要集中在检测SELECT查询中的逻辑错误，如RAGS、PQS、NoREC和TLP等。然而，这些方法无法检测UPDATE和DELETE查询中的逻辑错误，尽管这些错误可能导致更严重的后果。</li>
<li>论文的Motivation:  鉴于现有方法无法解决UPDATE和DELETE查询中的逻辑错误，本文提出了一种新颖的通用方法DQE，通过执行具有相同谓词的SELECT、UPDATE和DELETE查询，并观察它们的执行结果之间的不一致性，来检测这些查询中的逻辑错误。通过在五个生产级DBMS上的实验，验证了DQE的有效性和通用性，并发现了多个未知的逻辑错误。</li>
</ul>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法:"></a>方法:</h3><ul>
<li>a. 理论背景:<ul>
<li>本文提出了一种名为差异查询执行（Differential Query  Execution，DQE）的新方法，用于检测数据库管理系统（DBMS）中SELECT、UPDATE和DELETE查询中的逻辑错误。DQE的核心思想是使用相同的谓词执行不同的SQL查询，并观察它们执行结果的不一致性。该方法旨在自动识别DBMS中的逻辑错误，特别是在UPDATE和DELETE查询中，这些错误在现有方法中尚未得到有效解决。DQE通过执行具有相同谓词的查询并比较它们的结果来解决构建有效的测试预言的挑战。作者实现了DQE并在五个广泛使用的DBMS上评估了其有效性，发现了41个以前未知的错误，其中20个出现在UPDATE和DELETE查询中。</li>
</ul>
</li>
<li>b. 技术路线:<ul>
<li>生成数据库和查询三元组的过程：首先通过创建表格和使用INDEX命令和随机选项对其进行修改来生成初始数据库。然后为每个表格添加两个新列rowId和updated，以唯一标识行并跟踪修改。使用基于SQL的抽象语法树（ASTs）的算法随机生成谓词来进行谓词生成。基于生成的谓词生成包含SELECT查询（Qsel）、UPDATE查询（Qup）和DELETE查询（Qdel）的查询三元组。使用谓词中引用的表格来生成Qsel的选择字段和Qup的更新字段。还可以为查询三元组生成可选的子句，如ORDER  BY。使用目标DBMS提供的诊断命令获取查询引发的错误。通过将选择字段与rowId列连接并执行修改后的查询来获取SELECT查询访问的行。通过将更新字段与更新列的赋值连接并执行修改后的查询来获取UPDATE查询访问的行。</li>
</ul>
</li>
</ul>
<h3 id="结果"><a href="#结果" class="headerlink" title="结果:"></a>结果:</h3><ul>
<li>a. 详细的实验设置:  <ul>
<li>作者在五个广泛使用且生产级别的DBMS上实现和评估了DQE，包括MySQL、MariaDB、TiDB、CockroachDB和SQLite。他们在这些DBMS中检测到了41个以前未知的错误，其中20个出现在UPDATE和DELETE查询中。实验结果表明，DQE在检测DBMS中SELECT、UPDATE和DELETE查询的逻辑错误方面具有有效性。作者已经公开提供了DQE供使用。</li>
</ul>
</li>
</ul>
<h3 id="ABSTRACT："><a href="#ABSTRACT：" class="headerlink" title="ABSTRACT："></a>ABSTRACT：</h3><p>这篇论文提出了一种名为差分查询执行（DQE）的新方法，用于检测数据库管理系统（DBMS）中SELECT、UPDATE和DELETE查询的逻辑错误。DQE的核心思想是：具有相同谓词的不同SQL查询通常会访问数据库中的相同行。比如，使用谓词φ的UPDATE查询更新的行，也应该被具有相同谓词φ的SELECT查询获取。如果不是这样，就暴露了目标DBMS中的逻辑错误。研究者在五个生产级别的DBMS上应用了DQE，包括MySQL、MariaDB、TiDB、CockroachDB和SQLite，共检测到50个独特的错误，其中41个已被确认，11个已被修复。这表明DQE的简单性和通用性可以大大提高DBMS的可靠性。</p>
<h3 id="INTRODUCTION："><a href="#INTRODUCTION：" class="headerlink" title="INTRODUCTION："></a>INTRODUCTION：</h3><p><strong>背景：</strong></p>
<p>DBMS（例如MySQL、MariaDB、TiDB、CockroachDB和SQLite）使用结构化查询语言（SQL）来高效检索和操作数据库中的数据，并在许多业务关键应用中发挥着不可或缺的作用。DBMS可能遇到的不同类型的错误，特别是逻辑错误，这些错误可能导致SELECT查询返回错误结果，或者UPDATE和DELETE查询产生错误的数据库状态。这些逻辑错误通常不会导致DBMS崩溃，因此开发者可能不容易注意到它们。本研究的重点是检测DBMS中的这类逻辑错误。</p>
<p><strong>相关工作以及局限性：</strong></p>
<p>数据库管理系统（DBMS）中检测逻辑错误的几种方法，特别是针对 SELECT 查询的方法。提到的方法包括  RAGS（通过在多个DBMS上运行相同的SELECT查询来检测结果差异），PQS（生成特定行的SELECT查询来检测DBMS是否能正确检索这行），NoREC（通过重写SELECT查询为一个DBMS无法优化的等效查询来检测结果差异），以及TLP（将SELECT查询分解为三个部分查询，然后将这些部分的结果合并，预期与原始查询结果相同）。</p>
<p>然而，这些方法主要关注于SELECT查询中的逻辑错误，而对于可能导致更严重后果的UPDATE和DELETE查询中的逻辑错误，尚未有有效的检测方法。自动检测这些错误是一个挑战，因为需要构建一个有效的测试预言机（test oracle）来判断给定查询的DBMS行为是否正确。</p>
<p>文章还讨论了SELECT、UPDATE和DELETE查询中的谓词（WHERE子句）使用问题。理想情况下，DBMS应该对这三种查询中的谓词评估采用相同的实现方式。但由于优化选择的多样性，DBMS通常采用不同的实现方式来评估这些查询中的谓词，导致使用相同谓词的SELECT、UPDATE和DELETE查询可能会访问不同的行。1<a target="_blank" rel="noopener" href="https://bugs.mysql.com/bug.php?id=106420">https://bugs.mysql.com/bug.php?id=106420</a></p>
<p><font color="green">(这里使用bug report的引用来说明SELECT UPDATE和DELETE的实现逻辑不同，是不是有点牵强?）</font></p>
<p><strong>Key insight以及面临的挑战：</strong></p>
<p>本文提出了一种差异查询执行（Differential Query Execution, DQE）的新方法，用于检测SELECT、UPDATE和DELETE查询中的逻辑错误。DQE通过执行具有相同谓词φ的SELECT、UPDATE和DELETE查询，并观察它们执行结果之间的不一致性来解决测试预言机问题。例如，如果一个UPDATE查询更新的行在具有相同谓词φ的SELECT查询结果中没有出现，这表明目标数据库管理系统（DBMS）存在逻辑错误。</p>
<p>DQE面临的主要挑战是如何自动获取给定SELECT、UPDATE或DELETE查询所访问的行。为了解决这个挑战，DQE方法在数据库中的每个表格中添加两个额外的列，一个用于唯一标识每一行，另一个用于跟踪行是否被修改。此外，DQE还重新编写SELECT和UPDATE查询，以便识别它们所访问的行。</p>
<p><strong>Motivation example:</strong></p>
<p><img src="/2024/01/22/Testing-Database-Systems-via-Differential-Query-Execution/image-20240122175708890.png" alt="image-20240122175708890"></p>
<p>这个错误涉及UPDATE和DELETE查询，它们意外地改变了数据库状态。具体来说，有一个表t1，包含一个INT类型的行，其值为1。使用的谓词φ是一个空字符串。在处理这三种查询时（SELECT、UPDATE和DELETE），TiDB尝试将φ转换为布尔值。</p>
<p>对于SELECT查询，TiDB首先将φ截断为DOUBLE类型的值0，然后将其转换为布尔值FALSE。因此，SELECT查询得到一个空的查询结果，并引发一个警告。而对于UPDATE和DELETE查询，TiDB错误地将φ评估为TRUE，导致数据库状态发生了意外的变化。这个错误在报告给TiDB开发者后得到了确认和修复。现有的检测方法无法发现这个错误，因为它仅发生在UPDATE和DELETE查询中。</p>
<p><strong>评估：</strong></p>
<p>为了评估差异查询执行（DQE）的有效性和通用性，研究者们实施了DQE，并在五个广泛使用的、生产级别的数据库管理系统（DBMS）上进行了实验。这些系统包括MySQL、MariaDB、TiDB、CockroachDB和SQLite。通过这些实验，共检测到了50个独特的错误，在这些DBMS中，其中41个被确认为新的错误，并且已有11个错误得到修复。在这41个确认的错误中，20个发生在UPDATE和DELETE查询中。他们检测到的错误无法被现有的方法（如PQS、NoREC和TLP）检测到。实验结果表明，DQE在检测DBMS中的SELECT、UPDATE和DELETE查询的逻辑错误方面是有效的。DQE的代码已经在GitHub上公开。</p>
<p><font color="green">(是指20个发生在UPDATE和DELETE的错误没法被现有工具检测到还是全部？)</font></p>
<p><strong>limitations:</strong></p>
<p>DQE虽然在目标数据库管理系统（DBMS）的SELECT、UPDATE和DELETE查询中检测到了许多错误，但仍存在一些限制。首先，DQE受到与差异测试相同的问题的影响，即当相同的错误同时出现在SELECT、UPDATE和DELETE查询中时，DQE无法检测到这个错误。其次，DQE只支持SELECT、UPDATE和DELETE查询中的常见操作和函数，如JOIN、ORDER  BY和LIMIT。它不支持只在一种查询中使用的操作和函数，例如只在SELECT查询中使用的DISTINCT、子查询、基于聚合的函数、窗口函数和GROUP  BY。对于这些特性，DQE无法比较它们在SELECT、UPDATE和DELETE查询中的执行结果。第三，DQE不支持非确定性函数，例如RAND函数，这种函数在不同查询中返回不同的值。</p>
<p><strong>贡献：</strong></p>
<ol>
<li><strong>提出DQE方法</strong>：这是一种新颖且通用的方法，用于检测数据库管理系统（DBMS）中SELECT、UPDATE和DELETE查询的逻辑错误。据作者所知，DQE是首个能够检测出UPDATE和DELETE查询中逻辑错误的方法。</li>
<li><strong>在五个广泛使用的DBMS上实施和评估DQE</strong>：通过在这些DBMS上的实现和评估，DQE检测到了41个以前未知的错误，其中20个错误发生在UPDATE和DELETE查询中。这表明DQE在检测这类错误方面具有有效性。</li>
</ol>
<h3 id="PRELIMINARIES"><a href="#PRELIMINARIES" class="headerlink" title="PRELIMINARIES"></a>PRELIMINARIES</h3><p><em>A. Database Management Systems and SQL</em></p>
<ol>
<li><strong>数据库管理系统（DBMS）的广泛应用</strong>：DBMS在许多应用程序中被广泛使用，以实现有效的数据检索和操作。主流的DBMS（例如MySQL、MariaDB、TiDB、CockroachDB和SQLite）采用关系数据模型，这种模型将数据组织成关系表，因此这些系统被称为关系型数据库管理系统。</li>
<li><strong>结构化查询语言（SQL）</strong>：关系型DBMS通常采用SQL作为查询语言。在SQL中，SELECT、UPDATE和DELETE查询通过谓词（即WHERE子句）来确定要检索、更新或删除的行。DBMS通常采用复杂的优化技术来提高查询评估的性能。</li>
<li><strong>优化过程的差异</strong>：尽管对于相同的谓词，DBMS可以在SELECT、UPDATE和DELETE查询中应用不同的优化，但无论应用何种优化，具有相同谓词φ的SELECT、UPDATE和DELETE查询理应访问相同的行。例如，MySQL开发人员指出，虽然所有的数据操纵语言（DML）语句都必须经过优化阶段，但SELECT和UPDATE查询不会经过相同的优化过程。</li>
</ol>
<p><em>B. Target DBMSs</em></p>
<p>这段文字讨论了研究所关注的五个生产级别且广泛使用的数据库管理系统（DBMS）：MySQL、MariaDB、TiDB、CockroachDB和SQLite。选择这些DBMS的依据是它们的流行度和数据库类型。</p>
<ol>
<li><strong>流行度和排名</strong>：根据DB-Engines Ranking，MySQL、SQLite和MariaDB是最受欢迎的DBMS之一，在全球排名分别为第2、第9和第13位。</li>
<li><strong>DBMS的类型和特点</strong>：<ul>
<li>MySQL和MariaDB是传统的DBMS，已经开发了数十年。</li>
<li>SQLite是一个嵌入式DBMS，是最广泛部署的DBMS。</li>
<li>根据GitHub Database Topic，TiDB和CockroachDB是最受欢迎的关系型DBMS（分别拥有33.3K和26.5K星）。</li>
<li>CockroachDB和TiDB是具有高可扩展性的分布式NewSQL DBMS。</li>
</ul>
</li>
</ol>
<p><img src="/2024/01/22/Testing-Database-Systems-via-Differential-Query-Execution/image-20240122180720559.png" alt="image-20240122180720559"></p>
<p><em>C. Query Execution Strategy</em></p>
<p>不同数据库管理系统（DBMS）在SELECT、UPDATE和DELETE查询中的SQL查询执行策略，尤其关注它们如何处理语法和语义错误，这对于DQE（差异查询执行）分析查询执行情况至关重要。</p>
<ol>
<li><p><strong>MySQL、MariaDB和TiDB的策略</strong>：这三个DBMS采用相同的查询执行策略。当查询评估中出现语法或语义错误时，这些系统会根据错误的严重性引发警告或错误。例如，使用无效值时会引发警告，而语法上无效的谓词会引发错误。如果评估查询时出现警告，DBMS可以继续执行查询；但如果出现错误，则会中止并回滚查询。这三个DBMS在不同的SQL模式下执行查询，影响查询执行策略。在严格模式下，对于UPDATE和DELETE查询会采用严格的验证检查。如果SELECT查询中的谓词引发警告，在UPDATE和DELETE查询中会将其视为错误。</p>
<blockquote>
<p><code>STRICT_ALL_TABLES</code>和<code>STRICT_TRANS_TABLES</code>是两种SQL模式设置，它们用于定义如何处理数据验证和错误。</p>
<ol>
<li><strong>STRICT_ALL_TABLES</strong>：当这个模式被激活时，DBMS对所有表执行严格的数据验证。这意味着如果插入或更新的数据行违反了列定义（例如，超出指定的长度或类型），DBMS将拒绝这个操作并显示错误。这个模式有助于确保数据的完整性和一致性，因为它阻止了无效数据的输入。</li>
<li><strong>STRICT_TRANS_TABLES</strong>：这个模式与<code>STRICT_ALL_TABLES</code>相似，但它主要适用于具有事务支持的表。在这个模式下，如果在事务处理过程中的任何点上违反数据完整性，则整个事务都会被回滚，确保数据库状态的一致性。</li>
</ol>
<p>假设我们有一个名为<code>users</code>的表，其中有一个名为<code>age</code>的列，其数据类型为整数（INT），并且这个列不允许为空（NOT NULL）。</p>
<ol>
<li><strong>STRICT_ALL_TABLES模式</strong>：<ul>
<li>在这种模式下，如果你尝试插入一条新的记录到<code>users</code>表中，但没有提供<code>age</code>字段的值，数据库将拒绝这个插入操作并显示一个错误。这是因为<code>age</code>字段被定义为NOT NULL，而在STRICT模式下，任何违反列定义的操作都会被阻止。</li>
<li>示例命令：<code>INSERT INTO users (name) VALUES (&#39;Alice&#39;);</code></li>
<li>结果：由于<code>age</code>字段缺失，操作将失败并显示错误。</li>
</ul>
</li>
<li><strong>STRICT_TRANS_TABLES模式</strong>：<ul>
<li>假设<code>users</code>表是一个事务支持的表（例如，在InnoDB引擎中）。在STRICT_TRANS_TABLES模式下，如果你在一个事务中执行多个操作，其中一个操作违反了数据完整性，那么整个事务都会被回滚。</li>
<li>示例：<ul>
<li>开始一个事务：<code>START TRANSACTION;</code></li>
<li>正确插入：<code>INSERT INTO users (name, age) VALUES (&#39;Bob&#39;, 25);</code></li>
<li>错误插入：<code>INSERT INTO users (name) VALUES (&#39;Charlie&#39;);</code>（由于缺少<code>age</code>，这将失败）</li>
<li>提交事务：<code>COMMIT;</code></li>
</ul>
</li>
<li>结果：第二个插入操作将失败，并且由于是在STRICT_TRANS_TABLES模式下，整个事务（包括第一个成功的插入）都会被回滚，数据库中不会添加任何新记录。</li>
</ul>
</li>
</ol>
<p>这两种模式通过增加严格性来提高数据的完整性，确保只有符合定义的数据才能被存储到数据库中。</p>
</blockquote>
</li>
<li><p><strong>CockroachDB和SQLite的策略</strong>：这两个DBMS采用较为简单的查询执行策略。在这两个系统中，SELECT、UPDATE和DELETE查询在评估谓词时出现语法或语义错误只会引发错误，不会引发警告。如果UPDATE或DELETE查询引发错误，将会被回滚，并撤销所有由该查询所做的更改。然而，如果SELECT查询引发错误，它将返回在错误发生之前匹配其谓词的所有行，这意味着SELECT查询即使在引发错误时也可能返回非空的查询结果。</p>
</li>
</ol>
<p><img src="/2024/01/22/Testing-Database-Systems-via-Differential-Query-Execution/image-20240122182011380.png" alt="image-20240122182011380"></p>
<p>这个例子描述了SQL查询在不同SQL模式下如何处理针对特定谓词φ的警告和错误。</p>
<ol>
<li><strong>严格模式（Strict Mode）</strong>：在严格模式下，DBMS对UPDATE和DELETE查询采用严格的验证检查。特别是，如果一个带有谓词φ的SELECT查询引发了一个警告，在相同谓词φ的UPDATE和DELETE查询中，这个警告会被当作错误处理（并带有相同的错误消息）。</li>
<li><strong>非严格模式（Non-Strict Mode）</strong>：在非严格模式下，如果一个带有谓词φ的SELECT查询引发了警告，带有相同谓词φ的UPDATE和DELETE查询也会引发相同的警告。值得注意的是，如果带有谓词φ的SELECT查询引发了错误，在严格模式和非严格模式下，相同谓词φ的UPDATE和DELETE查询也会引发相同的错误。</li>
</ol>
<p>这个例子说明了在不同的SQL模式下，DBMS如何根据SELECT查询的警告或错误来调整UPDATE和DELETE查询的行为。在严格模式下，警告被升级为错误，而在非严格模式下，相同的警告被保留。在任何模式下，如果SELECT查询引发错误，UPDATE和DELETE查询也会引发同样的错误。</p>
<h3 id="APPROACH"><a href="#APPROACH" class="headerlink" title="APPROACH"></a>APPROACH</h3><h4 id="A-DQE-Overview"><a href="#A-DQE-Overview" class="headerlink" title="A. DQE Overview"></a><em>A. DQE Overview</em></h4><p><img src="/2024/01/22/Testing-Database-Systems-via-Differential-Query-Execution/image-20240122182316296.png" alt="image-20240122182316296"></p>
<p>它的工作流程如下：</p>
<ol>
<li><strong>生成随机数据库（步骤1）</strong>：创建包含一个或多个表（如t1、t2）的数据库，每个表包含一些随机列和数据（例如，表t1有一个值为’a’和’b’的列c1）。</li>
<li><strong>生成随机谓词φ（步骤2）</strong>：随机生成一个谓词，例如NOT c1。</li>
<li><strong>生成查询三元组&lt; Qsel, Qup, Qdel &gt;（步骤3）</strong>：基于谓词φ生成一组查询，包括SELECT查询（Qsel）、UPDATE查询（Qup）和DELETE查询（Qdel）。这三个查询都使用相同的谓词φ。</li>
<li><strong>执行查询三元组（步骤4）</strong>：在相同的数据库状态下执行Qsel、Qup和Qdel，并分析它们的执行结果。</li>
<li><strong>分析执行结果（步骤5）</strong>：分析SELECT查询的结果集rs、执行UPDATE查询后修改的表tu以及执行DELETE查询后修改的表td。特别关注这些查询访问的行和引发的错误。</li>
<li><strong>检测逻辑错误（步骤6）</strong>：如果查询三元组中的三个查询的执行结果不一致（例如，访问了不同的行），则表明目标DBMS中可能存在潜在的逻辑错误。</li>
</ol>
<p>接下来的部分分别描述了数据库生成（第III-B节）、SQL查询生成策略（第III-C节）、获取查询三元组执行结果的方法（第III-D节）以及如何通过比较三个查询的执行结果来检测逻辑错误（第III-E节）。</p>
<h4 id="B-Database-Generation"><a href="#B-Database-Generation" class="headerlink" title="B. Database Generation"></a><em>B. Database Generation</em></h4><p>数据库生成的过程，主要采用了SQLancer的方法，用于实验中的数据库准备。这个过程不是研究的主要贡献，但为了完整性而被提及。</p>
<ol>
<li><strong>创建表格</strong>：使用<code>CREATE TABLE</code>命令创建最多<code>maxTable</code>个表格。每个表格包含最多<code>maxCol</code>个列。为每个列随机分配一个列类型（如INT或TEXT）和一些列约束（如PRIMARY KEY和UNIQUE）。</li>
<li><strong>填充数据</strong>：通过执行<code>INSERT</code>命令向每个表中填充随机数据。每个表包含最多<code>maxInsert</code>行数据。</li>
<li><strong>修改表格结构</strong>：执行最多<code>maxAlter</code>个<code>ALTER TABLE</code>和<code>CREATE INDEX</code>命令来修改每个初始表格，例如添加新列或在现有列上建立索引。还配置每个表格的随机选项，比如设置自增列的起始编号（例如<code>AUTO_INCREMENT=5</code>）。</li>
<li><strong>参数配置</strong>：<code>maxTable</code>、<code>maxCol</code>、<code>maxInsert</code>、<code>maxAlter</code>都是可配置的参数。在实验中，默认设置分别为5、3、10、3。</li>
<li><strong>增加特殊列</strong>：在生成的数据库中，每个表格被修改以添加<code>rowId</code>和<code>updated</code>列。<code>rowId</code>列用于唯一标识每行，通常为TEXT类型，填充唯一值（如UUID）。<code>updated</code>列用于跟踪每行的修改情况，通常为INT类型，默认值为0。这两个新增加的列用于后续部分中获取查询访问的行，但不用于查询三元组生成。</li>
<li><strong>针对不同DBMS的特定生成</strong>：数据库生成过程针对不同的DBMS进行了特定的调整。不同的DBMS支持不同的列类型、列约束和表选项。例如，CockroachDB支持INTERVAL列类型，而MySQL则不支持。</li>
</ol>
<h4 id="C-Query-Triple-Generation"><a href="#C-Query-Triple-Generation" class="headerlink" title="C. Query Triple Generation"></a><em>C. Query Triple Generation</em></h4><p>这段文字描述了查询三元组&lt; Qsel, Qup, Qdel &gt;的生成过程，其中Qsel、Qup和Qdel使用相同的谓词φ。整个过程包括谓词的生成和基于谓词生成三种查询（SELECT、UPDATE、DELETE）。</p>
<ol>
<li><strong>谓词生成</strong>：使用一种算法，基于SQL的抽象语法树（AST）随机生成谓词。随机选择节点类型（CONST、COLUMN或操作符），如果是CONST，则生成一个常量值；如果是COLUMN，则随机返回数据库中表的列引用；如果是操作符，则迭代生成其操作数。当AST达到最大深度（maxDepth，实验中默认设为3）时，只生成常量或列引用，不再扩展AST。</li>
<li><strong>查询三元组生成</strong>：基于谓词φ，随机生成Qsel、Qup和Qdel。首先提取谓词φ中引用的表，这些表将用于Qsel、Qup和Qdel。然后为Qsel生成选择字段，为Qup生成更新字段。Qsel的选择字段是列引用列表，Qup的更新字段是赋值列表。最后，生成通用支持的可选子句（如ORDER BY）。</li>
<li><strong>查询生成的支持和限制</strong>：DQE支持SELECT、UPDATE和DELETE查询中的常见操作和函数，但不支持仅在一种查询中使用的操作和函数，如仅在SELECT查询中使用的DISTINCT、基于聚合的函数、窗口函数和GROUP BY。DQE也不支持非确定性函数，如返回随机值的RAND函数。查询生成过程针对不同DBMS进行了特定的调整。</li>
</ol>
<p>举例，可以生成如下查询三元组：</p>
<ul>
<li><img src="/2024/01/22/Testing-Database-Systems-via-Differential-Query-Execution/image-20240122184303565.png" alt="image-20240122184303565"></li>
</ul>
<blockquote>
<ol>
<li><p><strong>聚合函数</strong>：聚合函数对一组值进行计算，并返回单个值。它们通常用于统计分析，例如计算总和、平均值、最大值、最小值等。聚合函数对整个数据集或分组的数据集进行操作。常见的聚合函数包括：</p>
<ul>
<li><code>SUM()</code>：计算数值列的总和。</li>
<li><code>AVG()</code>：计算数值列的平均值。</li>
<li><code>COUNT()</code>：计算数据集中的项数。</li>
<li><code>MAX()</code>：找出列中的最大值。</li>
<li><code>MIN()</code>：找出列中的最小值。</li>
</ul>
<p>使用聚合函数时，通常会结合<code>GROUP BY</code>子句来对数据进行分组，然后对每个组应用聚合函数。</p>
</li>
<li><p><strong>窗口函数</strong>：窗口函数对数据集的一部分（称为“窗口”）执行计算，这部分数据与查询结果中的当前行相关。与聚合函数不同，窗口函数不会将行组合成单个输出行 — 它们会为每个输入行返回一个值。因此，窗口函数可以用来执行更复杂的计算，如累积总和、移动平均等。常见的窗口函数包括：</p>
<ul>
<li><code>ROW_NUMBER()</code>：为每个窗口内的行分配一个唯一的序号。</li>
<li><code>RANK()</code> 和 <code>DENSE_RANK()</code>：为窗口内的行提供排名。</li>
<li><code>LEAD()</code> 和 <code>LAG()</code>：访问窗口内的后续行或前置行的数据。</li>
<li><code>SUM()</code>、<code>AVG()</code> 等聚合函数也可以用作窗口函数。</li>
</ul>
<p>窗口函数通常与<code>OVER</code>子句一起使用，以定义窗口的范围和排序。</p>
</li>
</ol>
</blockquote>
<p><img src="/2024/01/22/Testing-Database-Systems-via-Differential-Query-Execution/image-20240122183945041.png" alt="image-20240122183945041"></p>
<p><font color="green">（和PINOLO的生成方式很像啊）</font></p>
<h4 id="D-Obtaining-Execution-Results"><a href="#D-Obtaining-Execution-Results" class="headerlink" title="D. Obtaining Execution Results"></a><em>D. Obtaining Execution Results</em></h4><p>这段文字描述了如何获取生成的查询三元组&lt; Qsel, Qup, Qdel &gt;的执行结果。这个过程包括两个主要部分：获取由查询引发的错误和自动获取查询访问的行。</p>
<ol>
<li><strong>获取查询引发的错误</strong>：<ul>
<li>当SELECT、UPDATE和DELETE查询评估时出现语法或语义错误，它们可能引发错误（在MySQL、MariaDB和TiDB中有时是警告）。</li>
<li>特别是，UPDATE查询（Qup）可能违反表约束（如NOT NULL和UNIQUE）并在更新引用表时引发特定于UPDATE的错误。类似地，DELETE查询（Qdel）可能违反表约束（如FOREIGN KEY）并在删除引用表中的数据时引发特定于DELETE的错误。</li>
<li>为了获取查询引发的错误，使用目标DBMS提供的诊断命令，如MySQL、MariaDB和TiDB中的<code>SHOW WARNINGS</code>命令。CockroachDB和SQLite没有这样的诊断命令，因此在这两个DBMS中使用Java中的SQLException来获取引发的错误。</li>
<li><img src="/2024/01/22/Testing-Database-Systems-via-Differential-Query-Execution/image-20240122193147591.png" alt="image-20240122193147591"></li>
</ul>
</li>
<li><strong>获取SELECT查询（Qsel）访问的行</strong>：<ul>
<li>为了获取SELECT查询返回的行，将Qsel的选择字段与其引用表的rowId列一起附加，形成一个新的SELECT查询Q’ sel。</li>
<li>执行Q’ sel后，从其结果集中提取rowId列的值。</li>
<li><img src="/2024/01/22/Testing-Database-Systems-via-Differential-Query-Execution/image-20240122193832830.png" alt="image-20240122193832830"></li>
</ul>
</li>
<li><strong>获取UPDATE查询（Qup）访问的行</strong>：<ul>
<li>为了获取UPDATE查询更新的行，将Qup的更新字段与其引用表的updated列的赋值列表一起附加，形成一个新的UPDATE查询Q’ up。</li>
<li>执行Q’ up后，从每个引用表中提取updated列值等于1的rowId列的值。</li>
<li><img src="/2024/01/22/Testing-Database-Systems-via-Differential-Query-Execution/image-20240122194001174.png" alt="image-20240122194001174"></li>
</ul>
</li>
<li><strong>获取DELETE查询（Qdel）访问的行</strong>：<ul>
<li>为了获取DELETE查询删除的行，比较执行Qdel之前后每个引用表中rowId列的值。</li>
<li>执行Qdel后，查看被删除的rowId列的值。</li>
<li><img src="/2024/01/22/Testing-Database-Systems-via-Differential-Query-Execution/image-20240122194220844.png" alt="image-20240122194220844"></li>
</ul>
</li>
</ol>
<h4 id="E-Comparing-Execution-Results"><a href="#E-Comparing-Execution-Results" class="headerlink" title="E. Comparing Execution Results"></a><em>E. Comparing Execution Results</em></h4><p>这段文字讲述了如何比较和分析在不同数据库管理系统（DBMS）中SELECT、UPDATE和DELETE查询（即Qsel、Qup和Qdel）的执行结果，以检测目标DBMS中是否存在逻辑错误。这一过程涉及到对查询访问的行集合（分别标记为rowsel、rowup和rowdel）的比较。</p>
<ol>
<li><strong>针对MySQL、MariaDB和TiDB的比较规则</strong>：这些系统中，如果Qup和Qdel分别引发了特定于UPDATE和DELETE的错误，则不会与Qsel的执行结果进行比较。在不违反以下规则的情况下，如果任何规则被违反，DQE将报告一个错误：<ul>
<li>如果Qsel引发错误，则Qup和Qdel也应引发相同的错误，此时rowsel、rowup和rowdel应为空。</li>
<li>在严格模式下，如果Qsel引发警告，则Qup和Qdel应引发错误，且警告和错误应具有相同的错误代码和消息（除了错误级别不同）。此时rowup和rowdel应为空。</li>
<li>在非严格模式下，如果Qsel引发警告，则Qup和Qdel也应引发相同的警告，此时rowsel、rowup和rowdel应相同。</li>
<li>如果Qsel没有引发警告或错误，则Qup和Qdel也不应引发警告或错误，此时rowsel、rowup和rowdel应相同。</li>
</ul>
</li>
<li><strong>针对CockroachDB和SQLite的比较规则</strong>：在这些系统中，规则略有不同：<ul>
<li>如果Qsel引发错误，则Qup和Qdel也应引发相同的错误。但与MySQL、MariaDB和TiDB不同，此时rowsel可能不为空，而rowup和rowdel应为空。</li>
<li>如果Qsel没有引发警告或错误，则Qup和Qdel也不应引发警告或错误，此时rowsel、rowup和rowdel应相同。</li>
</ul>
</li>
</ol>
<h3 id="EVALUATION"><a href="#EVALUATION" class="headerlink" title="EVALUATION"></a>EVALUATION</h3><p>DQE是基于SQLancer（一个用Java实现的工具）开发的，并对其进行了以下改进：</p>
<ol>
<li><strong>改进点</strong>：<ul>
<li>首先，为目标数据库管理系统（DBMS）添加了UPDATE和DELETE查询的生成能力，例如MySQL、TiDB和SQLite。</li>
<li>其次，为了确保在相同的数据库状态下执行查询三元组（Qsel, Qup, Qdel），在MySQL、MariaDB和TiDB中使用ROLLBACK事务来回滚由UPDATE和DELETE查询所做的所有更改。在CockroachDB和SQLite中，则通过记录查询执行前的表内容并在查询执行后用相同的内容填充表来维护数据库状态。</li>
<li>为了在五个目标DBMS上实现DQE，编写了大约2600行代码。</li>
</ul>
</li>
<li><strong>评估效果</strong>：<ul>
<li>研究团队通过回答两个研究问题来评估DQE的有效性：<ul>
<li>RQ1: DQE可以检测到现实世界DBMS中的哪些逻辑错误？</li>
<li>RQ2: DQE检测到的错误中有多少是现有方法可以发现的？</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="A-Experimental-Methodology"><a href="#A-Experimental-Methodology" class="headerlink" title="A. Experimental Methodology"></a><em>A. Experimental Methodology</em></h4><ol>
<li><strong>实验设置</strong>：<ul>
<li>DQE在五个广泛使用的数据库管理系统（DBMS）上进行评估：MySQL、MariaDB、TiDB、CockroachDB和SQLite。这些DBMS的详细信息在文中的第II-B节中介绍。</li>
<li>实验使用的是这些DBMS的最新发布版本：MySQL 8.0.28、MariaDB 10.8.2、TiDB 5.2.0、CockroachDB 21.2.6和SQLite 3.39.2。对于TiDB，实验还包括在其5.3.0和5.4.0版本发布后的测试。</li>
<li>实验在一台配有8个CPU核心和32GB RAM的CentOS机器上进行。每个DBMS根据其自身部署要求进行部署。</li>
</ul>
</li>
<li><strong>实验过程</strong>：<ul>
<li>DQE运行以在目标DBMS中找到错误。实验没有设置超时，直到DQE找到错误为止。整个实验持续了大约一个月。</li>
<li>当DQE报告潜在错误时，通过目标DBMS的交互式终端手动执行以确认是否能复现这个错误。</li>
<li>成功复现报告的错误后，手动将测试用例减少到更小的规模，包括移除未使用的列、可选的列约束、数据表中的数据，并随机移除部分谓词子句。</li>
<li>在报告错误之前，检查目标DBMS的错误跟踪系统以避免提交重复的错误。报告错误后，等待开发者的反馈。</li>
<li><font color="green">手动精简，至于怎么去重的没细说</font></li>
</ul>
</li>
<li><strong>实验重点</strong>：<ul>
<li>开发者的响应时间决定了在测试一个DBMS上花费的努力。TiDB的开发者提供了更快速的确认，这极大地增强了继续测试的信心。因此，实验主要集中在TiDB上，并保持其最新状态。</li>
</ul>
</li>
</ol>
<h4 id="B-Overall-Detection-Results"><a href="#B-Overall-Detection-Results" class="headerlink" title="B. Overall Detection Results"></a><em>B. Overall Detection Results</em></h4><ol>
<li><p><strong>检测结果概况</strong>：</p>
<ul>
<li><p>DQE报告了122个错误，经过手动复现和最小化测试用例，最终确认了50个独特的错误。</p>
</li>
<li><p>怎么去重？精简后的结果是相同的，则说明是重复的bug。</p>
<p>We manually reproduce and minimize the test cases of these 122 reported bugs. If the minimized test cases of some bugs are the same, we only keep one, and consider others as duplicate bugs.</p>
</li>
<li><p>这些错误被提交给相应的DBMS开发者：MySQL（7个）、MariaDB（4个）、TiDB（37个）、CockroachDB（1个）和SQLite（1个）。</p>
</li>
<li><p>其中，41个错误被确认为新的错误，11个已被修复。</p>
</li>
<li><p><img src="/2024/01/22/Testing-Database-Systems-via-Differential-Query-Execution/image-20240122204158557.png" alt="image-20240122204158557"></p>
</li>
</ul>
</li>
<li><p><strong>错误的状态和分类</strong>：</p>
<ul>
<li>在这41个确认的错误中，22个被评定为重大或中等严重级别。</li>
<li>触发错误的查询类型包括SELECT（21个）、UPDATE（18个）和DELETE（20个）查询。一个错误可以由多个类型的查询触发，因此触发查询的总数超过已确认的错误总数。</li>
</ul>
</li>
<li><p><strong>错误的后果</strong>：</p>
<ul>
<li>大多数SELECT查询导致了不正确的警告，例如重复警告、意外警告和错误的警告信息。</li>
<li>所有UPDATE查询和大多数DELETE查询导致了不正确的数据库状态。</li>
<li>其他错误包括意外的警告、不正确的警告信息和导致SHOW WARNINGS命令执行失败的错误。</li>
<li><img src="/2024/01/22/Testing-Database-Systems-via-Differential-Query-Execution/image-20240122204412625.png" alt="image-20240122204412625"></li>
</ul>
</li>
<li><p><strong>错误分布</strong>：</p>
<ul>
<li><p>大部分导致不正确数据库状态的错误发生在TiDB（34个）和MySQL（2个）。（逻辑错误，查询结果不符合）</p>
</li>
<li><p>导致重复警告和意外警告的错误主要出现在TiDB和MariaDB。</p>
<blockquote>
<ul>
<li><strong>重复警告（Duplicate Warnings）</strong>：这类警告发生在系统对同一问题或条件生成多次警告的情况下。例如，如果数据库在处理单个查询时针对相同的问题重复生成警告，那么这些警告就被视为重复警告。这种情况可能是由于数据库内部逻辑的问题，导致它在处理特定情况时过度反应。</li>
<li><strong>意外警告（Unexpected Warnings）</strong>：意外警告是指在执行数据库操作时出现的不预期或不适当的警告消息。这种警告通常表明数据库以某种方式对操作作出了反应，但这种反应与操作的性质或上下文不相符。例如，如果一个简单且正确的查询操作触发了性能相关的警告，尽管查询本身并没有表现出任何性能问题，这样的警告就可以被认为是意外的。（比如向一个表中插入一行新数据。这个操作相对简单，不应该触发任何警告。）</li>
</ul>
</blockquote>
</li>
<li><p>导致不正确警告信息和SHOW WARNINGS命令执行失败的错误仅出现在TiDB。</p>
</li>
<li><p>发生在SQLite的一个错误导致了意外的错误。</p>
</li>
</ul>
</li>
</ol>
<h4 id="C-Comparing-with-Existing-Approaches"><a href="#C-Comparing-with-Existing-Approaches" class="headerlink" title="C. Comparing with Existing Approaches"></a><em>C. Comparing with Existing Approaches</em></h4><p>这段文字讨论了为回答研究问题RQ2所进行的与现有方法的比较。目的是评估DQE在检测数据库管理系统（DBMS）中逻辑错误方面的相对效果。</p>
<ol>
<li><strong>与现有方法的比较</strong>：<ul>
<li>现有的方法（PQS、NoREC和TLP）主要构建预言机（oracles）来检测单个SELECT查询中的逻辑错误。</li>
<li>这些方法无法检测在UPDATE和DELETE查询中的20个逻辑错误。</li>
<li>它们也不考虑SELECT查询可能意外引发的正常错误（如警告）作为逻辑错误。</li>
<li>因此，这些方法不能检测与这类错误相关的SELECT查询中的18个逻辑错误。</li>
</ul>
</li>
<li><strong>现有方法的局限性</strong>：<ul>
<li>分析剩余的3个SELECT查询中的逻辑错误，发现这些错误也不能被现有方法的预言机捕获或触发。</li>
<li>理论上，所有报告的错误都无法被这些方法检测到。</li>
</ul>
</li>
<li><strong>与其他DBMS测试方法的比较</strong>：<ul>
<li>其他DBMS测试方法（如SQLsmith、APOLLO、AMOEBA、RAGS和SparkFuzz）无法构建预言机来检测逻辑错误，或者由于差异测试需要多个DBMS，所以无法在单个DBMS中检测逻辑错误。</li>
<li>因此，DQE没有与这些方法进行比较。</li>
</ul>
</li>
</ol>
<h4 id="D-Other-Experimental-Statistics"><a href="#D-Other-Experimental-Statistics" class="headerlink" title="D. Other Experimental Statistics"></a><em>D. Other Experimental Statistics</em></h4><ol>
<li><strong>测试效率</strong>：<ul>
<li>DQE报告了122个错误，但经过过滤重复错误后，最终确认了50个独特的错误，重复率为41%。</li>
<li>在发现这50个独特错误的过程中，DQE生成了约17.76亿个查询三元组。</li>
</ul>
</li>
<li><strong>查询生成效率</strong>：<ul>
<li>DQE在不同DBMS上的查询生成效率不同。例如，在MySQL中，每秒生成2,885个查询，成功率为88%；而在SQLite中，每秒生成12,313个查询，成功率为97%。</li>
<li>DQE生成的查询可能由于语义约束而在不同的DBMS中变得无效，例如插入重复值到唯一列中。</li>
</ul>
</li>
<li><strong>代码覆盖率</strong>：<ul>
<li>与现有工作（PQS、NoREC和TLP）比较，DQE在MySQL和MariaDB中的代码覆盖率与这些工作相似，分别为15%和21%。</li>
<li>这一覆盖率较低，是因为DQE主要关注于DBMS的查询处理，而不包括其他功能，如用户管理、配置和容错。</li>
</ul>
</li>
<li><strong>参数选择</strong>：<ul>
<li>实验使用了一些默认参数（如maxTable&#x3D;5、maxCol&#x3D;10、maxDept&#x3D;3）来生成数据库和查询。</li>
<li>这些参数可能影响错误检测的有效性，但由于DBMS中的逻辑错误通常符合小范围假设，影响可能较低。例如，所有50个提交的错误都可以在单表上检测到，其中47个错误可以通过一行数据检测到。</li>
</ul>
</li>
</ol>
<h4 id="E-Selected-Bugs"><a href="#E-Selected-Bugs" class="headerlink" title="E. Selected Bugs"></a><em>E. Selected Bugs</em></h4><p><strong>Incorrect database state</strong>.</p>
<p><img src="/2024/01/22/Testing-Database-Systems-via-Differential-Query-Execution/image-20240122210241424.png" alt="image-20240122210241424"></p>
<p><strong>Duplicate warning</strong>.</p>
<p><img src="/2024/01/22/Testing-Database-Systems-via-Differential-Query-Execution/image-20240122210324576.png" alt="image-20240122210324576"></p>
<p><strong>Unexpected warning</strong>.</p>
<p><img src="/2024/01/22/Testing-Database-Systems-via-Differential-Query-Execution/image-20240122210341626.png" alt="image-20240122210341626"></p>
<p><strong>Unexpected error</strong>.</p>
<p><img src="/2024/01/22/Testing-Database-Systems-via-Differential-Query-Execution/image-20240122210356874.png" alt="image-20240122210356874"></p>
<p><strong>Incorrect warning message</strong>.</p>
<p><img src="/2024/01/22/Testing-Database-Systems-via-Differential-Query-Execution/image-20240122210417738.png" alt="image-20240122210417738"></p>
<p><strong>Others</strong>. </p>
<p><img src="/2024/01/22/Testing-Database-Systems-via-Differential-Query-Execution/image-20240122210430638.png" alt="image-20240122210430638"></p>
<h4 id="F-Not-A-Bug"><a href="#F-Not-A-Bug" class="headerlink" title="F. Not A Bug"></a><em>F. Not A Bug</em></h4><p>这段文字描述了MySQL中的一个错误（编号MySQL#10640712），涉及在索引列r1上多次出现相同的警告或错误的情况。错误的具体情况如下：</p>
<ol>
<li><strong>数据库和查询设置</strong>：<ul>
<li>数据库表<code>t1</code>包含一个FLOAT类型的行，其值为0，且在列<code>c1</code>上建立了索引。</li>
<li>使用的谓词φ是(<code>&#39;a&#39; | 1) BETWEEN 0 AND c1</code>。在SELECT查询中，MySQL将<code>&#39;a&#39;</code>转换为INT值0，然后执行与1的按位或操作，结果为1，最后检查这个结果是否在0和列<code>c1</code>的值之间的范围内。</li>
<li>由于列<code>c1</code>的值为1，谓词φ被评估为TRUE，因此SELECT查询返回行r1，但同时引发了三个相同的警告。</li>
</ul>
</li>
<li><strong>错误表现</strong>：<ul>
<li>UPDATE和DELETE查询分别引发一个警告和一个错误（警告代码和消息相同）。</li>
<li>由于只有一行数据，作者认为不应该出现重复的警告或错误。</li>
</ul>
</li>
<li><strong>开发者的回应</strong>：<ul>
<li>当向MySQL开发者报告这个问题时，他们确认了这个问题的存在，但解释说“重复的警告，即使完全相同，也不构成一个错误”。</li>
</ul>
</li>
</ol>
<p><img src="/2024/01/22/Testing-Database-Systems-via-Differential-Query-Execution/image-20240122210533393.png" alt="image-20240122210533393"></p>
<h3 id="RELATED-WORK"><a href="#RELATED-WORK" class="headerlink" title="RELATED WORK"></a>RELATED WORK</h3><p>相关的工作主要集中在三个方面：DBMS的差异测试、数据库和SQL查询生成、以及DBMS的测试预言机。</p>
<ol>
<li><strong>DBMS的差异测试</strong>：<ul>
<li>差异测试是测试DBMS的有效方法，它通过将相同的输入提供给多个功能上相似的系统并比较它们的输出来检测错误。</li>
<li>例如，RAGS在不同的DBMS上执行相同的SELECT查询并观察查询结果的差异；APOLLO在同一DBMS的不同版本上执行SELECT查询以检测性能错误；SparkFuzz通过参考DBMS（如PostgreSQL）或不同版本的Spark来验证查询结果。</li>
<li>本文提出了一种新的差异测试方法，即在一个DBMS中执行带有相同谓词的SELECT、UPDATE和DELETE查询来检测逻辑错误。</li>
</ul>
</li>
<li><strong>数据库和SQL查询生成</strong>：<ul>
<li>自动输入生成是自动测试的关键组成部分，数据库和SQL查询生成已被广泛研究。</li>
<li>如SQLsmith是一个开源的随机SQL查询生成器；Go-randgen可以基于输入的SQL语法生成各种SQL查询；SQLRight是一个基于变异的SQL查询生成器。</li>
</ul>
</li>
<li><strong>DBMS的测试预言机</strong>：<ul>
<li>测试预言机是揭示DBMS错误的关键。</li>
<li>例如，ADUSA使用Alloy语言和分析器来分析给定SELECT查询的预期查询结果；PQS合成一个SELECT查询来获取随机选择的支点行，并检查这行是否包含在其查询结果中；NoREC重写SELECT查询为DBMS无法优化的等效查询，并比较它们的结果。</li>
<li>本文提出了一种新的测试预言机方法，对DBMS测试提供了补充。</li>
</ul>
</li>
</ol>
<h3 id="CONCLUSION"><a href="#CONCLUSION" class="headerlink" title="CONCLUSION"></a>CONCLUSION</h3><p>在UPDATE和DELETE查询中的逻辑错误可能导致更严重的后果，例如不正确的数据库状态，并且现有方法尚未解决这些问题。在本文中，我们提出了一种新颖且通用的方法DQE，用于有效检测SELECT、UPDATE和DELETE查询中的逻辑错误。我们在五个广泛使用的数据库管理系统上评估了DQE，即MySQL、MariaDB、TiDB、CockroachDB和SQLite。总共，我们在这些DBMS中检测到了41个以前未知的逻辑错误。我们期望DQE的通用性能够帮助提高数据库管理系统的可靠性。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Lin Li</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/01/22/Testing-Database-Systems-via-Differential-Query-Execution/">http://example.com/2024/01/22/Testing-Database-Systems-via-Differential-Query-Execution/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">LinLi's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/">论文阅读</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/01/28/Detecting-Logic-Bugs-of-Join-Optimizations-in-DBMS/" title="Detecting Logic Bugs of Join Optimizations in DBMS"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Detecting Logic Bugs of Join Optimizations in DBMS</div></div></a></div><div class="next-post pull-right"><a href="/2024/01/15/DynSQL-Stateful-Fuzzing-for-Database-Management-Systems-with-Complex-and-Valid-SQL-Query-Generation/" title="DynSQL: Stateful Fuzzing for Database Management Systems with Complex and Valid SQL Query Generation"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">DynSQL: Stateful Fuzzing for Database Management Systems with Complex and Valid SQL Query Generation</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/03/04/PLUMBER/" title="PLUMBER"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-04</div><div class="title">PLUMBER</div></div></a></div><div><a href="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/" title="通过NPM生态系统的依赖树揭开脆弱性传播及其演化的神秘面纱"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-08</div><div class="title">通过NPM生态系统的依赖树揭开脆弱性传播及其演化的神秘面纱</div></div></a></div><div><a href="/2023/04/03/Flexible-and-Optimal-Dependency-Management-via-Max-SMT/" title="Flexible and Optimal Dependency Management via Max-SMT"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-03</div><div class="title">Flexible and Optimal Dependency Management via Max-SMT</div></div></a></div><div><a href="/2023/04/11/What-the-Fork-Finding-Hidden-Code-Clones-in-npm/" title="What the Fork Finding Hidden Code Clones in npm"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-11</div><div class="title">What the Fork Finding Hidden Code Clones in npm</div></div></a></div><div><a href="/2023/04/12/Static-Type-Inference-for-Foreign-Functions-of-Python/" title="Static Type Inference for Foreign Functions of Python"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-12</div><div class="title">Static Type Inference for Foreign Functions of Python</div></div></a></div><div><a href="/2023/04/13/Where-to-Start-Studying-Type-Annotation-Practices-in-Python/" title="Where to Start Studying Type Annotation Practices in Python"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-13</div><div class="title">Where to Start Studying Type Annotation Practices in Python</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Lin Li</div><div class="author-info__description">今日事，今日毕</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">107</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-Database-Systems-via-Differential-Query-Execution"><span class="toc-number">1.</span> <span class="toc-text">Testing Database Systems via Differential Query Execution</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Basic-Information"><span class="toc-number">1.1.</span> <span class="toc-text">Basic Information:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BA%E6%96%87%E7%AE%80%E8%A6%81"><span class="toc-number">1.2.</span> <span class="toc-text">论文简要 :</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%83%8C%E6%99%AF%E4%BF%A1%E6%81%AF"><span class="toc-number">1.3.</span> <span class="toc-text">背景信息:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.</span> <span class="toc-text">方法:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%9C"><span class="toc-number">1.5.</span> <span class="toc-text">结果:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ABSTRACT%EF%BC%9A"><span class="toc-number">1.6.</span> <span class="toc-text">ABSTRACT：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#INTRODUCTION%EF%BC%9A"><span class="toc-number">1.7.</span> <span class="toc-text">INTRODUCTION：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PRELIMINARIES"><span class="toc-number">1.8.</span> <span class="toc-text">PRELIMINARIES</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#APPROACH"><span class="toc-number">1.9.</span> <span class="toc-text">APPROACH</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#A-DQE-Overview"><span class="toc-number">1.9.1.</span> <span class="toc-text">A. DQE Overview</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-Database-Generation"><span class="toc-number">1.9.2.</span> <span class="toc-text">B. Database Generation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-Query-Triple-Generation"><span class="toc-number">1.9.3.</span> <span class="toc-text">C. Query Triple Generation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#D-Obtaining-Execution-Results"><span class="toc-number">1.9.4.</span> <span class="toc-text">D. Obtaining Execution Results</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#E-Comparing-Execution-Results"><span class="toc-number">1.9.5.</span> <span class="toc-text">E. Comparing Execution Results</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EVALUATION"><span class="toc-number">1.10.</span> <span class="toc-text">EVALUATION</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#A-Experimental-Methodology"><span class="toc-number">1.10.1.</span> <span class="toc-text">A. Experimental Methodology</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-Overall-Detection-Results"><span class="toc-number">1.10.2.</span> <span class="toc-text">B. Overall Detection Results</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-Comparing-with-Existing-Approaches"><span class="toc-number">1.10.3.</span> <span class="toc-text">C. Comparing with Existing Approaches</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#D-Other-Experimental-Statistics"><span class="toc-number">1.10.4.</span> <span class="toc-text">D. Other Experimental Statistics</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#E-Selected-Bugs"><span class="toc-number">1.10.5.</span> <span class="toc-text">E. Selected Bugs</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#F-Not-A-Bug"><span class="toc-number">1.10.6.</span> <span class="toc-text">F. Not A Bug</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RELATED-WORK"><span class="toc-number">1.11.</span> <span class="toc-text">RELATED WORK</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CONCLUSION"><span class="toc-number">1.12.</span> <span class="toc-text">CONCLUSION</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/24/Validating-LLM-Generated-Programs-with-Metamorphic-Prompt-Testing/" title="Validating LLM-Generated Programs with Metamorphic Prompt Testing">Validating LLM-Generated Programs with Metamorphic Prompt Testing</a><time datetime="2024-11-24T12:19:15.000Z" title="发表于 2024-11-24 20:19:15">2024-11-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/22/MASTERKEY-Automated-Jailbreaking-of-Large-Language-Model-Chatbots/" title="MASTERKEY: Automated Jailbreaking of Large Language Model Chatbots">MASTERKEY: Automated Jailbreaking of Large Language Model Chatbots</a><time datetime="2024-11-22T13:32:36.000Z" title="发表于 2024-11-22 21:32:36">2024-11-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/19/How-Effective-Are-They-Exploring-Large-Language-Model-Based-Fuzz-Driver-Generation/" title="How Effective Are They? Exploring Large Language Model Based Fuzz Driver Generation">How Effective Are They? Exploring Large Language Model Based Fuzz Driver Generation</a><time datetime="2024-11-19T09:24:19.000Z" title="发表于 2024-11-19 17:24:19">2024-11-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/19/METAL-Metamorphic-Testing-Framework-for-Analyzing-Large-Language-Model-Qualities/" title="METAL Metamorphic Testing Framework for Analyzing Large-Language Model Qualities">METAL Metamorphic Testing Framework for Analyzing Large-Language Model Qualities</a><time datetime="2024-11-19T02:47:44.000Z" title="发表于 2024-11-19 10:47:44">2024-11-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/19/SMT-Solver-Validation-Empowered-by-Large-Pre-trained-Language-Models/" title="SMT Solver Validation Empowered by Large Pre-trained Language Models">SMT Solver Validation Empowered by Large Pre-trained Language Models</a><time datetime="2024-10-19T12:57:20.000Z" title="发表于 2024-10-19 20:57:20">2024-10-19</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Lin Li</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>