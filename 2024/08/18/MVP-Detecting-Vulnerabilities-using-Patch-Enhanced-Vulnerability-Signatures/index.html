<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>MVP: Detecting Vulnerabilities using Patch-Enhanced Vulnerability Signatures | LinLi's Blog</title><meta name="author" content="Lin Li"><meta name="copyright" content="Lin Li"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="MVP: Detecting Vulnerabilities using Patch-Enhanced Vulnerability SignaturesABSTRACT复现漏洞在现实世界的系统中广泛存在并且通常未被检测到，这通常是由于重用代码库或共享代码逻辑所导致的。然而，脆弱函数与其修补函数之间潜在的小差异以及脆弱函数与目标检测函数之间可能存在的大差异，给基于克隆和函数匹配的检测方法带来了挑战，">
<meta property="og:type" content="article">
<meta property="og:title" content="MVP: Detecting Vulnerabilities using Patch-Enhanced Vulnerability Signatures">
<meta property="og:url" content="http://example.com/2024/08/18/MVP-Detecting-Vulnerabilities-using-Patch-Enhanced-Vulnerability-Signatures/index.html">
<meta property="og:site_name" content="LinLi&#39;s Blog">
<meta property="og:description" content="MVP: Detecting Vulnerabilities using Patch-Enhanced Vulnerability SignaturesABSTRACT复现漏洞在现实世界的系统中广泛存在并且通常未被检测到，这通常是由于重用代码库或共享代码逻辑所导致的。然而，脆弱函数与其修补函数之间潜在的小差异以及脆弱函数与目标检测函数之间可能存在的大差异，给基于克隆和函数匹配的检测方法带来了挑战，">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2024-08-18T09:26:02.000Z">
<meta property="article:modified_time" content="2024-08-18T09:28:48.523Z">
<meta property="article:author" content="Lin Li">
<meta property="article:tag" content="论文阅读">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/08/18/MVP-Detecting-Vulnerabilities-using-Patch-Enhanced-Vulnerability-Signatures/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'MVP: Detecting Vulnerabilities using Patch-Enhanced Vulnerability Signatures',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-08-18 17:28:48'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">103</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="LinLi's Blog"><span class="site-name">LinLi's Blog</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">MVP: Detecting Vulnerabilities using Patch-Enhanced Vulnerability Signatures</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-08-18T09:26:02.000Z" title="发表于 2024-08-18 17:26:02">2024-08-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-08-18T09:28:48.523Z" title="更新于 2024-08-18 17:28:48">2024-08-18</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="MVP: Detecting Vulnerabilities using Patch-Enhanced Vulnerability Signatures"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="MVP-Detecting-Vulnerabilities-using-Patch-Enhanced-Vulnerability-Signatures"><a href="#MVP-Detecting-Vulnerabilities-using-Patch-Enhanced-Vulnerability-Signatures" class="headerlink" title="MVP: Detecting Vulnerabilities using Patch-Enhanced Vulnerability Signatures"></a><strong>MVP: Detecting Vulnerabilities using Patch-Enhanced Vulnerability Signatures</strong></h1><h2 id="ABSTRACT"><a href="#ABSTRACT" class="headerlink" title="ABSTRACT"></a>ABSTRACT</h2><p>复现漏洞在现实世界的系统中广泛存在并且通常未被检测到，这通常是由于重用代码库或共享代码逻辑所导致的。然而，脆弱函数与其修补函数之间潜在的小差异以及脆弱函数与目标检测函数之间可能存在的大差异，给基于克隆和函数匹配的检测方法带来了挑战，导致高误报率和漏报率。</p>
<p>在本文中，我们提出了一种新颖的方法来检测复现漏洞，具有低误报率和低漏报率。我们首先使用我们新颖的<strong>程序切片技术</strong>，从脆弱函数及其修补函数中<strong>提取漏洞和补丁签名</strong>，在语法和语义层面上进行分析。然后，如果目标函数匹配漏洞签名但不匹配补丁签名，则将其识别为潜在的脆弱函数。我们将该方法实现于一个名为MVP的工具中。我们在十个开源系统上的评估结果表明，i) MVP显著优于当前最先进的基于克隆和函数匹配的复现漏洞检测方法；ii) MVP检测到了一般漏洞检测方法无法检测到的复现漏洞，即两个基于学习的方法和两款商业工具；iii) MVP检测到97个新的漏洞，并已分配了23个CVE标识符。</p>
<h2 id="INTRODUCTION"><a href="#INTRODUCTION" class="headerlink" title="INTRODUCTION"></a>INTRODUCTION</h2><p><font color="red">background</font></p>
<p>漏洞可以被利用来攻击软件系统，威胁系统安全。因此，尽早检测和修补软件系统中的漏洞非常重要。为了检测漏洞，已经开发了多种技术，如静态分析、模糊测试、符号执行和人工审计等。此外，还出现了一些技术用于自动修补漏洞，以减少补丁部署的延迟。</p>
<p>由于重用代码库或共享代码逻辑，具有相似特征的复现漏洞在软件系统中广泛存在，但在现实世界的程序中往往未被检测到。因此，复现漏洞的检测得到了广泛关注，尤其是在漏洞数量不断增加的情况下。本文的目标是检测复现漏洞，即在一个程序中表现出特定行为的漏洞，是否会在其他程序中也表现出这种特定行为。与此不同的是，通用漏洞检测技术倾向于利用大量漏洞的总体行为来发现这些行为的特定实例。</p>
<p><font color="red">related work</font></p>
<p>总体思路：</p>
<ul>
<li>通过匹配目标系统的源代码与已知漏洞的源代码来检测复现漏洞。</li>
<li>现有方法可以分为基于克隆和基于函数匹配的两类。</li>
</ul>
<p>基于<strong>克隆的方法</strong>：</p>
<ul>
<li>将复现漏洞检测问题视为代码克隆检测问题。</li>
<li>提取已知漏洞的标记或语法级别签名，识别与这些签名匹配的代码克隆并标记为潜在漏洞。</li>
</ul>
<p>基于<strong>函数匹配的方法</strong>：</p>
<ul>
<li>使用已知漏洞中的脆弱函数作为签名，检测与这些脆弱函数匹配的代码克隆。</li>
<li>不考虑漏洞特性，因为这些方法并非特别为复现漏洞检测设计的。</li>
</ul>
<p>局限性：</p>
<ul>
<li>由于克隆检测的性质，未考虑漏洞修复的方式，导致无法区分脆弱函数和修补函数之间的微小差异，造成高误报率。</li>
<li>对于与已知漏洞代码差异较大的复现漏洞，这些方法无法检测，导致高漏报率。</li>
</ul>
<p><font color="red">challenges</font></p>
<p>检测复现漏洞的主要挑战概括如下：</p>
<ol>
<li><strong>区分已修补的漏洞</strong>：如何区分已经修补过的漏洞以减少误报率。</li>
<li><strong>生成精确的漏洞签名</strong>：如何精确生成已知漏洞的签名，以同时减少误报率和漏报率。</li>
</ol>
<p>这两个挑战都涉及如何在复现漏洞检测中实现低误报率和低漏报率。</p>
<p><font color="red">approach</font></p>
<p>为了解决两个主要挑战，提出了一种新颖的复现漏洞检测方法，名为MVP（Matching Vulnerabilities with Patches）。具体包括：</p>
<ol>
<li><strong>生成漏洞和补丁签名</strong>：不仅生成漏洞签名，还生成补丁签名，以捕捉漏洞的产生和修复过程。这有助于区分潜在脆弱函数是否已被修补。</li>
<li><strong>使用新颖的切片方法</strong>：提出了一种新的切片方法，仅提取与漏洞和补丁相关的语句，在语法和语义层面生成签名。</li>
<li><strong>应用语句抽象和基于熵的语句选择</strong>：进一步提高MVP的检测精度。</li>
</ol>
<p>这些方法共同解决了区分已修补漏洞和生成精确漏洞签名的挑战。</p>
<p><font color="red">evaluation and contributions</font></p>
<p><strong>评估</strong>：</p>
<ul>
<li>MVP在包含25,377个安全补丁的十个开源系统上进行了评估。</li>
<li>与两个最先进的基于克隆的方法（ReDeBug和VUUDY）相比，MVP提高了74.5%和75.6%的精度，以及42.4%和65.8%的召回率。</li>
<li>MVP检测出97个新漏洞，并分配了23个CVE标识符。</li>
<li>与基于函数匹配的方法（SourcererCC和CCAligner）相比，MVP提高了83.1%和83.3%的精度，以及22.5%和30.6%的召回率。</li>
<li>与基于学习的方法（VulDeePecker和Devign）和商业工具（Coverity和Checkmarx）相比，MVP展示了其在检测复现漏洞方面的优势。</li>
</ul>
<p><strong>贡献</strong>：</p>
<ol>
<li>提出了利用漏洞和补丁签名的新颖切片技术，开发并实现了一种新的复现漏洞检测方法。</li>
<li>进行了深入的评估，将MVP与四类最先进的方法进行了比较，MVP在精度上显著优于它们。</li>
<li>在十个开源系统中发现了97个新漏洞，并分配了23个CVE标识符。</li>
</ol>
<h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a><strong>Motivation</strong></h2><h3 id="Problems"><a href="#Problems" class="headerlink" title="Problems"></a><strong>Problems</strong></h3><ol>
<li><strong>漏洞函数与修补函数的相似性问题</strong>：<ul>
<li>大部分漏洞函数和修补函数之间的代码差异较小。由于此相似性，基于克隆的方法可能会错误地将修补函数识别为漏洞函数，从而引发高误报率。</li>
</ul>
</li>
<li><strong>漏洞函数与目标函数的相似性问题</strong>：<ul>
<li>如果漏洞函数和目标函数的相似性较低，现有方法可能无法检测到目标函数中的漏洞。在评估中，35.1%的实际漏洞函数与目标函数的相似性低于70%，导致现有方法无法检测到这些漏洞函数，从而引发高漏报率。</li>
</ul>
</li>
</ol>
<p>总结来说，现有方法在处理漏洞函数与修补函数或目标函数的相似性时容易产生误报和漏报的问题。</p>
<h3 id="A-Motivating-Example"><a href="#A-Motivating-Example" class="headerlink" title="A Motivating Example"></a><strong>A Motivating Example</strong></h3><p>为说明现有方法的局限性并引出MVP的概念，本文使用Qcacld-2.0中的一个漏洞作为示例。Qcacld-2.0是Qualcomm WLAN的开源驱动程序，广泛用于Android手机中。示例展示了一个越界访问漏洞，以及相应的补丁修复措施。</p>
<ol>
<li><strong>基于克隆的方法</strong>（如ReDeBug）：通过纯语法级匹配来检测复现漏洞。ReDeBug在漏洞补丁前后提取几行代码生成漏洞签名。然而，由于修补函数中的语法与漏洞签名相同，ReDeBug错误地将修补函数识别为漏洞函数，导致误报。</li>
<li><strong>MVP方法</strong>：MVP识别漏洞的根本原因，即缺少对局部变量<code>vdev_id</code>的检查，该变量在后续用作数组访问的索引。MVP通过构建<code>vdev_id</code>的语义数据流签名来检测语义等效的漏洞，即使这些漏洞的语法有所变化。</li>
</ol>
<p>这一概念说明了MVP在处理语法略有变化的语义等效漏洞时的优势。</p>
<p><img src="/2024/08/18/MVP-Detecting-Vulnerabilities-using-Patch-Enhanced-Vulnerability-Signatures/image-20240818161025220.png" alt="image-20240818161025220"></p>
<blockquote>
<p>这个motivation example展示了在Qcacld-2.0中修复的一个越界访问漏洞，并用来说明现有方法的局限性及MVP方法的优势。</p>
<ul>
<li><strong>漏洞类型</strong>：越界访问漏洞。</li>
<li><strong>漏洞位置</strong>：函数<code>WDA_TxPacket</code>中。</li>
<li><strong>修复措施</strong>：补丁在第18-22行添加了对局部变量<code>vdev_id</code>的检查，确保其值不超过<code>wma_handle-&gt;max_bssid</code>。这个检查防止了在第28行中使用<code>vdev_id</code>作为数组<code>wma_handle-&gt;interfaces</code>的索引时发生越界访问。</li>
</ul>
<p><strong>现有方法的局限性：</strong></p>
<ul>
<li><strong>ReDeBug方法</strong>：ReDeBug通过语法级别的匹配来检测漏洞，它从补丁前后的几行代码生成漏洞签名，并在目标函数中寻找匹配的签名。</li>
<li><strong>问题</strong>：由于修补函数中的某些代码行（如第20-22行和第23-25行）与漏洞签名语法相同，ReDeBug误将修补函数识别为漏洞函数，导致误报。</li>
</ul>
<p><strong>MVP方法的优势：</strong></p>
<ul>
<li><strong>识别漏洞根源</strong>：MVP识别出漏洞的根本原因是缺少对局部变量<code>vdev_id</code>的检查，该变量用于后续的数组访问。</li>
<li><strong>语义检测</strong>：MVP通过构建<code>vdev_id</code>的语义数据流签名，可以检测出语法稍有不同但语义等效的漏洞，避免了ReDeBug中的误报问题。</li>
</ul>
<p>这个例子展示了MVP如何通过更深入的语义分析克服现有方法在处理语法相似但语义不同的修补函数时的局限性。</p>
</blockquote>
<h2 id="Methodology"><a href="#Methodology" class="headerlink" title="Methodology"></a><strong>Methodology</strong></h2><p><img src="/2024/08/18/MVP-Detecting-Vulnerabilities-using-Patch-Enhanced-Vulnerability-Signatures/image-20240818162126542.png" alt="image-20240818162126542"></p>
<p>图2展示了MVP的概览，包含三个步骤。</p>
<ul>
<li><strong>提取函数签名步骤</strong>（§ 3.2）接收一个目标系统作为输入，并为目标系统中的每个函数生成一个签名。</li>
<li><strong>提取漏洞和补丁签名步骤</strong>（§ 3.3）接收一个安全补丁作为输入，并生成一个漏洞签名和一个补丁签名，以反映漏洞是如何产生和修复的。</li>
<li>最后一步<strong>检测漏洞步骤</strong>（§ 3.4）通过将目标系统中每个函数的签名与漏洞和补丁签名进行匹配，来确定该函数是否可能存在漏洞。</li>
</ul>
<h3 id="3-1-Definition"><a href="#3-1-Definition" class="headerlink" title="3.1 Definition"></a><strong>3.1 Definition</strong></h3><p><strong>1. 函数签名定义：</strong></p>
<ul>
<li><p>函数签名由语法签名（</p>
<p>fsynf_{syn}fsyn</p>
<p>）和语义签名（</p>
<p>fsemf_{sem}fsem</p>
<p>）组成。</p>
<ul>
<li><strong>fsynf_{syn}fsyn</strong>：函数中所有语句的哈希值集合，表示目标函数的语法特征。</li>
<li><strong>fsemf_{sem}fsem</strong>：包含数据和控制依赖关系的三元组集合，描述语句之间的依赖关系，表示函数的语义特征。</li>
</ul>
</li>
<li><p>这些签名提供了函数的互补信息，有助于提高匹配精度。</p>
</li>
</ul>
<p><strong>2. 函数补丁定义：</strong></p>
<ul>
<li>函数补丁由一个或多个hunk组成，hunk包括上下文行、删除行和添加行。<ul>
<li><strong>删除行</strong>：在脆弱函数中存在但在修补函数中缺失的行。</li>
<li><strong>添加行</strong>：在修补函数中存在但在脆弱函数中缺失的行。</li>
</ul>
</li>
<li>进一步定义了：<ul>
<li><strong>Sdel</strong>：脆弱函数中存在但在修补函数中缺失的语句集合。</li>
<li>**Sadd：修补函数中存在但在脆弱函数中缺失的语句集合。</li>
<li><strong>Svul</strong>：脆弱函数中的所有语句。</li>
<li><strong>Spat</strong>：修补函数中的所有语句。</li>
</ul>
</li>
</ul>
<p>这些定义为后续分析漏洞和修补函数之间的关系奠定了基础。</p>
<h3 id="3-2-Extracting-Function-Signature"><a href="#3-2-Extracting-Function-Signature" class="headerlink" title="3.2 Extracting Function Signature"></a><strong>3.2 Extracting Function Signature</strong></h3><p>3.2节描述了提取函数签名的过程，分为三个步骤：</p>
<ol>
<li><strong>解析和分析函数</strong>（3.2.1）：<ul>
<li>使用解析工具解析目标系统的源代码，生成抽象语法树（AST）和程序依赖图（PDG）。</li>
<li>通过这些图提取出目标系统中每个函数的语句及其依赖关系。</li>
</ul>
</li>
<li><strong>抽象和规范化函数</strong>（3.2.2）：<ul>
<li>识别并替换函数中的形式参数、本地变量和字符串字面量，使用标准化符号（如<code>PARAM</code>、<code>VARIABLE</code>、<code>STRING</code>）替换变量和字符串，以减少命名不同带来的干扰。</li>
<li>对格式字符串相关漏洞进行了特殊处理，将格式字符串抽象为通用的符号，以避免格式字符串引发的漏洞检测问题。</li>
<li>通过规范化，去除了函数体中的注释、括号和空格，提升对代码格式的容忍度。</li>
</ul>
</li>
<li><strong>生成函数签名</strong>（3.2.3）：<ul>
<li>通过对抽象后的语句进行哈希运算，生成语法签名（fsyn），并提取数据和控制依赖关系生成语义签名（fsem）。</li>
<li>语法签名表示函数的语句特征，而语义签名则表示函数内部语句间的依赖关系，两者共同构成函数签名。</li>
</ul>
</li>
</ol>
<p>通过这些步骤，MVP能够更准确地匹配和检测潜在的漏洞。</p>
<h3 id="3-3-Extracting-Vulnerability-and-Patch-Signatures"><a href="#3-3-Extracting-Vulnerability-and-Patch-Signatures" class="headerlink" title="3.3 Extracting Vulnerability and Patch Signatures"></a><strong>3.3 Extracting Vulnerability and Patch Signatures</strong></h3><p>3.3节描述了提取漏洞和补丁签名的过程，分为三个主要步骤：</p>
<ol>
<li><strong>识别代码更改</strong>（3.3.1）：<ul>
<li>通过解析安全补丁的头文件，确定代码中已删除和已添加的语句。</li>
<li>使用这些信息提取脆弱函数和修补函数中的更改语句集（Sdel 和 Sadd）以及所有相关语句集（Svul 和 Spat）。</li>
</ul>
</li>
<li><strong>计算代码切片</strong>（3.3.2）：<ul>
<li>利用切片技术提取与更改语句相关的数据和控制依赖语句，通过正向和逆向切片方法减少噪声。</li>
<li>对不同类型的语句（如赋值语句、条件语句、返回语句等）采用特定的切片策略，确保涵盖与漏洞相关的所有关键语句。</li>
</ul>
</li>
<li><strong>生成漏洞和补丁签名</strong>（3.3.3）：<ul>
<li>生成漏洞签名（Vsyn 和 Vsem）和补丁签名（Psyn 和 Psem），分别表示在语法和语义层面的漏洞特征和补丁特征。</li>
<li>通过信息熵的方式对提取的语句集进行优化，以减少噪声和错误匹配。</li>
</ul>
</li>
</ol>
<p>这一节详细阐述了如何通过解析补丁和利用代码切片技术生成准确的漏洞和补丁签名，以提高检测的精度并减少误报和漏报。</p>
<img src="/2024/08/18/MVP-Detecting-Vulnerabilities-using-Patch-Enhanced-Vulnerability-Signatures/image-20240818164114920.png" alt="image-20240818164114920" style="zoom:67%;">

<h3 id="3-4-Detecting-Vulnerability-through-Matching"><a href="#3-4-Detecting-Vulnerability-through-Matching" class="headerlink" title="3.4 Detecting Vulnerability through Matching"></a><strong>3.4 Detecting Vulnerability through Matching</strong></h3><p>3.4节描述了通过匹配检测漏洞的方法，提出了确定目标函数是否可能存在漏洞的五个条件（C1到C5）：</p>
<ol>
<li><strong>C1</strong>：目标函数必须包含所有已删除的语句，确保这些与漏洞相关的语句被保留。</li>
<li><strong>C2</strong>：目标函数的语法签名与漏洞签名匹配的程度必须超过阈值 t1。</li>
<li><strong>C3</strong>：目标函数的语法签名与补丁签名的匹配程度不能超过阈值 t2，以确保修补后的特征不会被错误匹配。</li>
<li><strong>C4</strong>：目标函数的语义签名与漏洞签名匹配的程度必须超过阈值 t3。</li>
<li><strong>C5</strong>：目标函数的语义签名与补丁签名的匹配程度不能超过阈值 t4，以避免误报修补后的特征。</li>
</ol>
<p>这些条件通过比较目标函数与漏洞函数和修补函数的签名，在语法和语义层面检测潜在的漏洞。根据敏感性分析，推荐的阈值为 t1和 t3 为0.8，t2 和 t4 为0.2，但用户可以根据需要进行配置。</p>
<p>总结来说，这部分定义了匹配规则，以减少误报和漏报，并提供了可调节的阈值设置以优化检测效果。</p>
<h2 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a><strong>Evaluation</strong></h2><h3 id="4-1-Evaluation-Setup"><a href="#4-1-Evaluation-Setup" class="headerlink" title="4.1 Evaluation Setup"></a><strong>4.1 Evaluation Setup</strong></h3><p>4.1节描述了评估MVP方法的设置，包括以下几个方面：</p>
<ol>
<li><strong>研究问题</strong>：<ul>
<li>RQ1: MVP在检测复现漏洞方面的准确性如何？</li>
<li>RQ2: MVP在检测复现漏洞方面的可扩展性如何？</li>
<li>RQ3: MVP中可配置的阈值在匹配组件中的敏感性如何？</li>
<li>RQ4: 抽象语句和语句选择方法的采用如何提高MVP的准确性？</li>
<li>RQ5: 通用漏洞检测方法在检测复现漏洞方面的表现如何？</li>
</ul>
</li>
<li><strong>数据集</strong>：<ul>
<li>选择了十个开源项目作为评估数据集，这些项目包含大量的C&#x2F;C++代码，并涵盖了广泛的应用领域，如操作系统内核、图像处理、压缩、通信工具包和WLAN驱动程序。</li>
<li>收集了这些项目的安全补丁及其在国家漏洞数据库（NVD）中的漏洞标识符，并记录了与漏洞相关的代码更改。</li>
</ul>
</li>
<li><strong>比较方法</strong>：<ul>
<li>评估了与MVP相比的四种最先进的方法，包括基于克隆的ReDeBug和VUUDY，基于函数匹配的SourcererCC和CCAligner，以及基于学习的VulDeePecker和Devign。</li>
<li>还包括两个广泛使用的商业静态分析工具Coverity和Checkmarx，尽管它们主要用于通用漏洞检测，但用于展示MVP的优势。</li>
</ul>
</li>
<li><strong>评估配置</strong>：<ul>
<li>MVP在6500个文件和500万行代码中进行了实现和评估，所有比较的方法在实验中都使用了其原始论文中报告的设置。</li>
</ul>
</li>
</ol>
<p>这一节为后续的评估实验奠定了基础，通过提出研究问题和选择合适的数据集与比较方法，旨在全面评估MVP在检测复现漏洞方面的性能。</p>
<h3 id="4-2-Accuracy-Evaluation-RQ1"><a href="#4-2-Accuracy-Evaluation-RQ1" class="headerlink" title="4.2 Accuracy Evaluation (RQ1)"></a><strong>4.2 Accuracy Evaluation (RQ1)</strong></h3><p>4.2节主要探讨了MVP的准确性评估（RQ1），通过与现有的先进方法进行比较，展示了MVP在检测复现漏洞方面的表现。以下是主要内容的概括：</p>
<ol>
<li><strong>准确性评估</strong>：<ul>
<li>使用精度（Precision）和召回率（Recall）作为衡量指标，比较了MVP与ReDeBug、VUUDY这两种基于克隆的方法的表现。</li>
<li>MVP在检测潜在漏洞函数时，达到了83.6%的精度和81.4%的召回率，而ReDeBug和VUUDY的精度和召回率分别较低。</li>
<li>MVP的误报率（False Positive）显著低于ReDeBug和VUUDY，尤其在两个项目中没有出现误报。</li>
</ul>
</li>
<li><strong>误报分析</strong>：<ul>
<li>通过对MVP的误报进行分析，发现主要原因包括缺少过程间分析和语义等效性的问题，这导致了9次误报。</li>
<li>另外，ReDeBug和VUUDY的误报也进行了详细分析，揭示了它们在处理补丁时引入的误报问题。</li>
</ul>
</li>
<li><strong>与SourcererCC和CCAligner的比较</strong>：<ul>
<li>比较表明MVP显著提高了精度，分别达到83.1%和83.3%，召回率也提升了22.5%和30.6%。</li>
</ul>
</li>
<li><strong>漏洞函数与目标函数的相似性分析</strong>：<ul>
<li>对于不同方法，MVP能够更好地检测与漏洞函数相似性低的目标函数。</li>
</ul>
</li>
</ol>
<h3 id="4-3-Scalability-Evaluation-RQ2"><a href="#4-3-Scalability-Evaluation-RQ2" class="headerlink" title="4.3 Scalability Evaluation (RQ2)"></a><strong>4.3 Scalability Evaluation (RQ2)</strong></h3><p>4.3节讨论了MVP的可扩展性评估（RQ2），并与基于克隆的漏洞检测方法ReDeBug和VUUDY进行了比较。以下是主要内容的概括：</p>
<ol>
<li><strong>基本组件</strong>：MVP、ReDeBug和VUUDY都包含三个基本组件：<ul>
<li><strong>系统分析</strong>：提取目标系统中每个目标函数的信息。</li>
<li><strong>补丁分析</strong>：生成漏洞的签名。</li>
<li><strong>匹配</strong>：搜索目标函数中的漏洞。</li>
</ul>
</li>
<li><strong>性能开销</strong>：<ul>
<li><strong>系统分析</strong>：MVP由于进行语义分析，花费了比VUUDY多3.2倍的时间，但仍能扩展到大型系统。例如，MVP在Linux内核上的分析时间为10.4小时。</li>
<li><strong>补丁分析</strong>：MVP花费的时间是VUUDY的3.3倍，平均耗时17,272.82毫秒从安全补丁中提取签名。</li>
<li><strong>匹配过程</strong>：所有三个方法在匹配上的表现都很快。</li>
</ul>
</li>
<li><strong>总结</strong>：虽然MVP在分析时间上比ReDeBug和VUUDY慢，但它具有更高的精度，这显著减少了手动验证潜在漏洞函数所需的时间。MVP仍然能够扩展到大型系统，并且由于减少了误报，它可能会节省更多的时间。</li>
</ol>
<p>这个部分强调了MVP的可扩展性，即使在处理大型项目时，MVP的时间开销仍在可接受范围内，特别是考虑到其更高的精度。</p>
<h3 id="4-4-Threshold-Sensitivity-Analysis-RQ3"><a href="#4-4-Threshold-Sensitivity-Analysis-RQ3" class="headerlink" title="4.4 Threshold Sensitivity Analysis (RQ3)"></a><strong>4.4 Threshold Sensitivity Analysis (RQ3)</strong></h3><p>4.4节讨论了MVP方法中阈值的敏感性分析（RQ3）。以下是主要内容的概括：</p>
<ol>
<li><strong>默认配置</strong>：在MVP的匹配步骤中，四个可配置的阈值（t1,t2,t3,t4t_1, t_2, t_3, t_4t1,t2,t3,t4）的默认配置为0.8、0.2、0.8和0.2。通过调整这些阈值，评估了它们对MVP准确性的影响。</li>
<li><strong>调整阈值</strong>：<ul>
<li>t1t_1t1 和 t3t_3t3 控制函数签名是否与漏洞签名匹配的阈值，分别从0.1到1.0进行调整。</li>
<li>t2t_2t2 和 t4t_4t4 控制函数签名是否不与补丁签名匹配的阈值，分别从0.0到0.9进行调整。</li>
<li>共执行了35种不同的配置，并分析了检测结果，发现了8个在默认配置下未检测到的漏洞。</li>
</ul>
</li>
<li><strong>结果分析</strong>：<ul>
<li>当 t3t_3t3 增加到0.7之前，精度和召回率在大多数系统中保持稳定；当 t3t_3t3 进一步增加到1.0时，精度增加而召回率下降。</li>
<li>t1t_1t1 从0.1增加到0.8时，精度显著提高。较严格的匹配条件导致了更少的误报，但召回率有所下降。</li>
<li>对于 t2t_2t2 和 t4t_4t4，将其从0.0到0.2时，精度略有提高，因此0.2被认为是这些阈值的最佳值。</li>
</ul>
</li>
<li><strong>总结</strong>：表5显示了不同阈值配置对精度和召回率的影响，最佳配置为 t1t_1t1 和 t3t_3t3 为0.8，t2t_2t2 和 t4t_4t4 为0.2。通过适当配置阈值，MVP在精度和召回率之间取得了良好的平衡。</li>
</ol>
<p>这一部分的分析帮助优化了MVP的匹配参数，使得在保持较高检测精度的同时减少漏报和误报。</p>
<h3 id="4-5-Contribution-of-Statement-Abstraction-and-Statement-Information-RQ4"><a href="#4-5-Contribution-of-Statement-Abstraction-and-Statement-Information-RQ4" class="headerlink" title="4.5 Contribution of Statement Abstraction and Statement Information (RQ4)"></a><strong>4.5 Contribution of Statement Abstraction and Statement Information (RQ4)</strong></h3><p>4.5节讨论了语句抽象和语句信息对MVP的贡献（RQ4）。</p>
<ol>
<li><strong>语句抽象的贡献</strong>：<ul>
<li>MVP在生成函数签名时使用了语句抽象。通过去除语句抽象来运行MVP，并分析潜在的漏洞函数，发现仅有11个更多的漏报（即Linux内核中的3个，ImageMagick中的5个，以及Qcacld-2.0中的3个）。</li>
<li>结果表明，语句抽象能够提高MVP的表现，使其多检测到12.8%的漏洞。</li>
</ul>
</li>
<li><strong>语句信息的贡献</strong>：<ul>
<li>MVP在提取漏洞签名时采用了语句信息。为了评估这一点，配置MVP在禁用和启用语句信息的情况下运行，调整了阈值 tImaxt_{I}^{max}tImax 从4到8。</li>
<li>通过对比分析，表5的结果表明，采用语句信息显著提高了MVP的准确性，并且阈值5被验证为tImaxt_{I}^{max}tImax的最佳值。</li>
</ul>
</li>
</ol>
<p>总结来说，语句抽象和语句信息的应用分别提高了MVP的漏洞检测能力和准确性。</p>
<h3 id="4-6-Performance-of-General-Purpose-Vulnerability-Detection-RQ5"><a href="#4-6-Performance-of-General-Purpose-Vulnerability-Detection-RQ5" class="headerlink" title="4.6 Performance of General-Purpose Vulnerability Detection (RQ5)"></a><strong>4.6 Performance of General-Purpose Vulnerability Detection (RQ5)</strong></h3><p>4.6节讨论了通用漏洞检测工具的性能评估（RQ5）。</p>
<ol>
<li><strong>VulDeePecker和Devign的表现</strong>：<ul>
<li>VulDeePecker只检测到111个复现漏洞中的8个，召回率为7.2%；Devign检测到40个，召回率为36.0%。</li>
<li>VulDeePecker的高漏报率主要是因为它只能处理调用特定库函数或API的函数，而Devign只能处理节点少于500的函数。</li>
<li>特别是在Linux内核中，VulDeePecker未能检测到任何复现漏洞，而Devign检测到了其中的19个，召回率为59.3%。</li>
<li>结果表明，基于学习的方法可能不适合发现复现漏洞，而MVP在这方面具有优势。</li>
</ul>
</li>
<li><strong>与Coverity和Checkmarx的比较</strong>：<ul>
<li>Coverity在十个项目中只检测到4个复现漏洞，而Checkmarx未能检测到任何复现漏洞。</li>
<li>这些结果表明，静态扫描工具在发现复现漏洞方面效果不佳，MVP是一个值得考虑的方法。</li>
</ul>
</li>
</ol>
<p>总结来说，通用漏洞检测工具在处理复现漏洞方面表现不理想，进一步强调了MVP方法的有效性和价值。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Lin Li</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/08/18/MVP-Detecting-Vulnerabilities-using-Patch-Enhanced-Vulnerability-Signatures/">http://example.com/2024/08/18/MVP-Detecting-Vulnerabilities-using-Patch-Enhanced-Vulnerability-Signatures/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">LinLi's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/">论文阅读</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/09/28/SQLaser-Detecting-DBMS-Logic-Bugs-with-Clause-Guided-Fuzzing/" title="SQLaser: Detecting DBMS Logic Bugs with Clause-Guided Fuzzing"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">SQLaser: Detecting DBMS Logic Bugs with Clause-Guided Fuzzing</div></div></a></div><div class="next-post pull-right"><a href="/2024/08/17/Movery-A-Precise-Approach-for-Modified-Vulnerable-Code-Clone-Discovery-from-Modified-Open-Source-Software-Components/" title="Movery A Precise Approach for Modified Vulnerable Code Clone Discovery from Modified Open-Source Software Components"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Movery A Precise Approach for Modified Vulnerable Code Clone Discovery from Modified Open-Source Software Components</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/03/04/PLUMBER/" title="PLUMBER"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-04</div><div class="title">PLUMBER</div></div></a></div><div><a href="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/" title="通过NPM生态系统的依赖树揭开脆弱性传播及其演化的神秘面纱"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-08</div><div class="title">通过NPM生态系统的依赖树揭开脆弱性传播及其演化的神秘面纱</div></div></a></div><div><a href="/2023/04/03/Flexible-and-Optimal-Dependency-Management-via-Max-SMT/" title="Flexible and Optimal Dependency Management via Max-SMT"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-03</div><div class="title">Flexible and Optimal Dependency Management via Max-SMT</div></div></a></div><div><a href="/2023/04/11/What-the-Fork-Finding-Hidden-Code-Clones-in-npm/" title="What the Fork Finding Hidden Code Clones in npm"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-11</div><div class="title">What the Fork Finding Hidden Code Clones in npm</div></div></a></div><div><a href="/2023/04/12/Static-Type-Inference-for-Foreign-Functions-of-Python/" title="Static Type Inference for Foreign Functions of Python"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-12</div><div class="title">Static Type Inference for Foreign Functions of Python</div></div></a></div><div><a href="/2023/04/13/Where-to-Start-Studying-Type-Annotation-Practices-in-Python/" title="Where to Start Studying Type Annotation Practices in Python"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-13</div><div class="title">Where to Start Studying Type Annotation Practices in Python</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Lin Li</div><div class="author-info__description">今日事，今日毕</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">103</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#MVP-Detecting-Vulnerabilities-using-Patch-Enhanced-Vulnerability-Signatures"><span class="toc-number">1.</span> <span class="toc-text">MVP: Detecting Vulnerabilities using Patch-Enhanced Vulnerability Signatures</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ABSTRACT"><span class="toc-number">1.1.</span> <span class="toc-text">ABSTRACT</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#INTRODUCTION"><span class="toc-number">1.2.</span> <span class="toc-text">INTRODUCTION</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Motivation"><span class="toc-number">1.3.</span> <span class="toc-text">Motivation</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Problems"><span class="toc-number">1.3.1.</span> <span class="toc-text">Problems</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#A-Motivating-Example"><span class="toc-number">1.3.2.</span> <span class="toc-text">A Motivating Example</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Methodology"><span class="toc-number">1.4.</span> <span class="toc-text">Methodology</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-Definition"><span class="toc-number">1.4.1.</span> <span class="toc-text">3.1 Definition</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-Extracting-Function-Signature"><span class="toc-number">1.4.2.</span> <span class="toc-text">3.2 Extracting Function Signature</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-Extracting-Vulnerability-and-Patch-Signatures"><span class="toc-number">1.4.3.</span> <span class="toc-text">3.3 Extracting Vulnerability and Patch Signatures</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-Detecting-Vulnerability-through-Matching"><span class="toc-number">1.4.4.</span> <span class="toc-text">3.4 Detecting Vulnerability through Matching</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Evaluation"><span class="toc-number">1.5.</span> <span class="toc-text">Evaluation</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-Evaluation-Setup"><span class="toc-number">1.5.1.</span> <span class="toc-text">4.1 Evaluation Setup</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-Accuracy-Evaluation-RQ1"><span class="toc-number">1.5.2.</span> <span class="toc-text">4.2 Accuracy Evaluation (RQ1)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-Scalability-Evaluation-RQ2"><span class="toc-number">1.5.3.</span> <span class="toc-text">4.3 Scalability Evaluation (RQ2)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-Threshold-Sensitivity-Analysis-RQ3"><span class="toc-number">1.5.4.</span> <span class="toc-text">4.4 Threshold Sensitivity Analysis (RQ3)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-Contribution-of-Statement-Abstraction-and-Statement-Information-RQ4"><span class="toc-number">1.5.5.</span> <span class="toc-text">4.5 Contribution of Statement Abstraction and Statement Information (RQ4)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-Performance-of-General-Purpose-Vulnerability-Detection-RQ5"><span class="toc-number">1.5.6.</span> <span class="toc-text">4.6 Performance of General-Purpose Vulnerability Detection (RQ5)</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/19/SMT-Solver-Validation-Empowered-by-Large-Pre-trained-Language-Models/" title="SMT Solver Validation Empowered by Large Pre-trained Language Models">SMT Solver Validation Empowered by Large Pre-trained Language Models</a><time datetime="2024-10-19T12:57:20.000Z" title="发表于 2024-10-19 20:57:20">2024-10-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/13/MR-Adopt-Automatic-Deduction-of-Input-Transformation-Function-for-Metamorphic-Testing/" title="MR-Adopt: Automatic Deduction of Input Transformation Function for Metamorphic Testing">MR-Adopt: Automatic Deduction of Input Transformation Function for Metamorphic Testing</a><time datetime="2024-10-13T03:09:01.000Z" title="发表于 2024-10-13 11:09:01">2024-10-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/12/Domain-Adaptation-for-Code-Model-Based-Unit-Test-Case-Generation/" title="Domain Adaptation for Code Model-Based Unit Test Case Generation">Domain Adaptation for Code Model-Based Unit Test Case Generation</a><time datetime="2024-10-12T10:59:24.000Z" title="发表于 2024-10-12 18:59:24">2024-10-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/10/LPR-Large-Language-Models-Aided-Program-Reduction/" title="LPR: Large Language Models-Aided Program Reduction">LPR: Large Language Models-Aided Program Reduction</a><time datetime="2024-10-10T12:56:10.000Z" title="发表于 2024-10-10 20:56:10">2024-10-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/04/Understanding-and-Detecting-SQL-Function-Bugs/" title="Understanding and Detecting SQL Function Bugs">Understanding and Detecting SQL Function Bugs</a><time datetime="2024-10-04T04:01:00.000Z" title="发表于 2024-10-04 12:01:00">2024-10-04</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Lin Li</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>