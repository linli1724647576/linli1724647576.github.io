<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>Vision: Identifying Affected Library Versions for Open Source Software Vulnerabilities | LinLi's Blog</title><meta name="author" content="Lin Li"><meta name="copyright" content="Lin Li"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Vision: Identifying Affected Library Versions for Open Source Software VulnerabilitiesABSTRACT漏洞报告在减少开源软件风险中起着至关重要的作用。通常，漏洞报告包含受影响的软件版本。然而，尽管安全专家已经验证了漏洞并且厂商也进行了审查，但受影响的版本并不总是准确的。特别是在处理多个版本及其差异时，保持版本的准">
<meta property="og:type" content="article">
<meta property="og:title" content="Vision: Identifying Affected Library Versions for Open Source Software Vulnerabilities">
<meta property="og:url" content="http://example.com/2024/11/29/Vision-Identifying-Affected-Library-Versions-for-Open-Source-Software-Vulnerabilities/index.html">
<meta property="og:site_name" content="LinLi&#39;s Blog">
<meta property="og:description" content="Vision: Identifying Affected Library Versions for Open Source Software VulnerabilitiesABSTRACT漏洞报告在减少开源软件风险中起着至关重要的作用。通常，漏洞报告包含受影响的软件版本。然而，尽管安全专家已经验证了漏洞并且厂商也进行了审查，但受影响的版本并不总是准确的。特别是在处理多个版本及其差异时，保持版本的准">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2024-11-29T12:34:04.000Z">
<meta property="article:modified_time" content="2024-11-29T12:35:26.914Z">
<meta property="article:author" content="Lin Li">
<meta property="article:tag" content="论文阅读">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/11/29/Vision-Identifying-Affected-Library-Versions-for-Open-Source-Software-Vulnerabilities/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Vision: Identifying Affected Library Versions for Open Source Software Vulnerabilities',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-11-29 20:35:26'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">121</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="LinLi's Blog"><span class="site-name">LinLi's Blog</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Vision: Identifying Affected Library Versions for Open Source Software Vulnerabilities</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-11-29T12:34:04.000Z" title="发表于 2024-11-29 20:34:04">2024-11-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-11-29T12:35:26.914Z" title="更新于 2024-11-29 20:35:26">2024-11-29</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Vision: Identifying Affected Library Versions for Open Source Software Vulnerabilities"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Vision-Identifying-Affected-Library-Versions-for-Open-Source-Software-Vulnerabilities"><a href="#Vision-Identifying-Affected-Library-Versions-for-Open-Source-Software-Vulnerabilities" class="headerlink" title="Vision: Identifying Affected Library Versions for Open Source Software Vulnerabilities"></a>Vision: Identifying Affected Library Versions for Open Source Software Vulnerabilities</h1><h2 id="ABSTRACT"><a href="#ABSTRACT" class="headerlink" title="ABSTRACT"></a>ABSTRACT</h2><p>漏洞报告在减少开源软件风险中起着至关重要的作用。通常，漏洞报告包含受影响的软件版本。然而，尽管安全专家已经验证了漏洞并且厂商也进行了审查，但受影响的版本并不总是准确的。特别是在处理多个版本及其差异时，保持版本的准确性变得更加复杂。虽然已经有一些方法用来识别受影响的版本，但它们仍然面临一些限制。首先，某些现有的方法是基于代码托管平台（如 GitHub）来识别受影响的版本，但这些版本与包注册表中的版本（如 Maven）并不总是保持一致。其次，现有的方法未能区分多个方法和变更块中漏洞方法与修补语句的重要性。</p>
<p>为了解决这些问题，本文提出了一种新的方法——Vision，旨在准确识别漏洞的受影响库版本（ALVs）。Vision使用来自包注册表的库版本作为输入。为了区分漏洞方法和修补语句的重要性，Vision通过关键方法选择和关键语句选择来优先考虑重要的变更及其上下文。此外，漏洞签名通过加权的跨过程程序依赖图（IPDG）来表示，这些图结合了关键方法和语句。Vision根据这些加权图之间的相似性来确定受影响的库版本。我们的评估表明，Vision优于现有的方法，精度达到 0.91，召回率为 0.94。此外，评估还显示了Vision在修正现有漏洞数据库中的受影响版本方面的实际有效性。</p>
<h2 id="NTRODUCTION"><a href="#NTRODUCTION" class="headerlink" title="NTRODUCTION"></a><strong>NTRODUCTION</strong></h2><p><font color="red">Background</font></p>
<ol>
<li>开源软件的重要性：<ul>
<li>开源软件（OsS）促进了创新的分享。</li>
<li>开源软件加速了软件开发。</li>
<li>开源软件已成为现代行业的关键基础设施。</li>
</ul>
</li>
<li>开源软件带来的风险：<ul>
<li>开源软件存在安全风险。</li>
<li>开源软件中的漏洞可以被攻击者利用来发起攻击，降低下游软件的安全性。</li>
</ul>
</li>
<li>开源软件漏洞问题：<ul>
<li>根据Sonatype的一项研究，大约有12.5%的开源软件下载中含有已知漏洞。</li>
<li>检测开源软件中的漏洞对于确保软件安全至关重要。</li>
</ul>
</li>
<li>开源软件漏洞数据库：<ul>
<li>存在开源软件漏洞数据库，这些数据库包含由安全专家提供的漏洞报告。</li>
<li>这些数据库帮助下游客户确定他们的应用程序是否受到漏洞的影响，通过匹配数据库中的漏洞版本与应用程序中使用的版本。</li>
</ul>
</li>
</ol>
<p><font color="red">Problem</font></p>
<ol>
<li>问题概述：<ul>
<li>手动编译的漏洞报告存在不准确性的问题。</li>
</ul>
</li>
<li>不准确性的具体领域：<ul>
<li>受影响版本字段（指示漏洞的脆弱版本和安全版本）特别容易出现不准确。</li>
</ul>
</li>
<li>原因分析：<ul>
<li>安全专家能够积极识别和确认漏洞。</li>
<li>但跨多个版本进行检查既耗时又费力，不符合他们的主要目标。</li>
</ul>
</li>
<li>影响：<ul>
<li>这些不准确性对漏洞报告的消费者（如OSS漏洞管理应用程序）产生显著影响。</li>
</ul>
</li>
</ol>
<p><font color="red">Existing Approaches.</font></p>
<p>关于识别受影响库版本（ALV）的现有方法：</p>
<ol>
<li>Dong等人[14]的研究提出了使用命名实体识别技术从漏洞描述中提取ALV的方法，但这种方法受限于漏洞描述的质量。</li>
<li>Dai等人[13]利用跟踪指导的模糊测试（trace-guided fuzzing）来检测和验证ALV，虽然这种方法能提供令人信服的验证，但计算密集且耗时。</li>
<li>Shi等人[48]通过污点分析（taint analysis）来识别ALV，但这种方法需要手动筛选危险函数，因此仅适用于某些类型的漏洞。</li>
<li>研究人员正越来越多地关注通过匹配漏洞补丁或脆弱克隆来静态分析源代码的方法。特别是，基于补丁的方法[2, 27, 38, 55]通过追踪版本历史中的代码变化来识别ALV；而基于克隆的方法[31, 65-67, 70]则从漏洞中修改的方法生成基于克隆的指纹，如果ALV中存在匹配的指纹，则报告ALV。</li>
</ol>
<p>[55] VERJava: Vulnerable Version Identification for Java OSS with a Two-Stage Analysis.</p>
<p><strong>[31] Vuddy     [66] Movery     [70]MVP</strong>  </p>
<p>[65] V1SCAN: Discovering 1-day Vulnerabilities in Reused C&#x2F;C++ Open-source Software Components Using Code Classification Techniques</p>
<p>[67] V0Finder: Discovering the Correct Origin of Publicly Reported Software Vulnerabilities.</p>
<p><font color="red">Limitations</font></p>
<ol>
<li>现有方法的局限性：<ul>
<li>现有方法在识别仓库托管平台（如GitHub）上的库版本时存在问题。</li>
</ul>
</li>
<li>具体问题：<ul>
<li>(a) 忽略平台间库版本差异：<ul>
<li>现有方法未能考虑仓库托管平台与包注册表（如Maven仓库）之间库版本的差异。</li>
<li>导致包注册表中库版本的漏检。</li>
<li>由于大量下游消费者从这些注册表中获取库，因此对漏洞检测工具的有效性产生显著影响。</li>
</ul>
</li>
<li>(b) 基于补丁的方法的局限性：<ul>
<li>依赖于补丁中的变化类型（添加或删除的行），当补丁不包含删除的行时无法报告受影响库版本（ALVs）。</li>
<li>不包含漏洞的上下文（依赖和被依赖的语句），容易导致误报。</li>
</ul>
</li>
<li>(c) 基于克隆的方法的局限性：<ul>
<li>通过结合程序切片添加了漏洞上下文。</li>
<li>但对所有修复方法（用于修补漏洞的方法）赋予相同的重要性。</li>
<li><strong>不区分修复方法的重要性，也不对修复方法内变化的语句分配不同的优先级。</strong></li>
</ul>
</li>
</ul>
</li>
</ol>
<p><font color="red">Our Approach.</font></p>
<ol>
<li>新方法提出：<ul>
<li>我们提出了一种名为Vision的新方法，用于识别开源软件（OSS）漏洞的受影响库版本。</li>
</ul>
</li>
<li>分析来源：<ul>
<li>Vision从包注册表（如Maven）分析库版本，克服现有方法的局限性。  <strong>(a)</strong></li>
</ul>
</li>
<li>Maven仓库的重要性：<ul>
<li>Maven仓库是Maven包管理器的默认仓库，提供全面的库版本列表。</li>
</ul>
</li>
<li>核心见解：<ul>
<li>Vision认为不同的方法或语句包含关于漏洞的不等量的语义知识。</li>
</ul>
</li>
<li>签名生成：<ul>
<li>Vision为每个漏洞生成漏洞签名和补丁签名。</li>
<li>使用删除的行生成漏洞库版本的漏洞签名和候选库版本的漏洞潜力签名。</li>
<li>使用添加的行生成修补库版本的补丁签名和候选库版本的补丁潜力签名。</li>
</ul>
</li>
<li>加权IPDGs：<ul>
<li>Vision生成加权的程序间程序依赖图（IPDGs），将方法和语句的关键性编码到图表示中。</li>
</ul>
</li>
<li>版本检测：<ul>
<li>Vision通过比较IPDGs之间的相似性来检测受影响的库版本。</li>
<li>比较候选库版本与漏洞代码的相似性，同时确保其与修补代码的不相似性。</li>
</ul>
</li>
<li>处理无删除行情况：<ul>
<li>Vision能在无删除行的情况下利用原始上下文生成漏洞签名，解决现有方法的局限性。  <strong>(b)</strong></li>
</ul>
</li>
<li>克服另一局限性：<ul>
<li>Vision采用Hyperlink-Induced Topic Search算法（HITS）在方法引用图（MRGs）上选择关键方法，克服另一局限性。  <strong>(c)</strong></li>
</ul>
</li>
<li>关键语句和路径识别：<ul>
<li>Vision通过从补丁中识别关键变量，在加权的IPDGs中高亮显示关键语句和路径。</li>
</ul>
</li>
</ol>
<p><font color="red">Evaluation</font></p>
<ol>
<li>评估方法：<ul>
<li>我们通过对比Vision与两种最先进的基于补丁的方法和三种高级的基于克隆的方法，在涉及79个库和12,073个版本对的102个CVE上评估了其有效性。</li>
</ul>
</li>
<li>评估结果：<ul>
<li>Vision的精确度为0.91，召回率为0.94，分别比最先进的方法高出至少12.3%和154.1%。</li>
</ul>
</li>
<li>错误报告：<ul>
<li>在重叠库版本中，Vision报告了357个假正例和184个假反例；在完整的真实数据中，报告了418个假正例和258个假反例。</li>
<li>相比之下，基于补丁的方法在重叠库版本中平均报告了1,031个假正例和1,654个假反例，在完整的真实数据中平均报告了1,720个假正例和2,961个假反例。</li>
<li>基于克隆的方法在完整的真实数据中平均报告了286个假正例和3,826个假反例。</li>
</ul>
</li>
<li>消融研究和阈值敏感性分析：<ul>
<li>这些分析证实了Vision中各组件对其整体有效性的贡献。</li>
</ul>
</li>
<li>泛化能力：<ul>
<li>我们将Vision应用于V-SZZ和VerJava的原始数据集，并取得了可比的有效性（精确度为0.90，召回率为0.92），证明了其泛化能力。</li>
</ul>
</li>
<li>实际应用：<ul>
<li>我们使用Vision分析了五个漏洞数据库中标记有错误受影响库版本的漏洞，并向五个供应商报告了这些漏洞。</li>
<li>三个供应商已回复并分别修复了39、42和8个漏洞，证明了Vision的实际实用性。</li>
</ul>
</li>
</ol>
<p><font color="red">Contributions：</font></p>
<ol>
<li><strong>提出Vision方法</strong>：我们提出了Vision方法，用于识别开源软件（OSS）漏洞中受影响的库版本。该方法接受来自Maven的库版本，并将漏洞中方法和语句的关键性编码为加权IPDGs，以实现准确识别。</li>
<li><strong>实验验证</strong>：通过实验，我们证明了Vision方法的有效性和实用性。在精确度和召回率方面，Vision方法分别比最先进的方法高出至少12.3%和154.1%。</li>
</ol>
<h2 id="MOTIVATION"><a href="#MOTIVATION" class="headerlink" title="MOTIVATION"></a><strong>MOTIVATION</strong></h2><h3 id="2-1-Inaccurate-Affected-Library-Versions-in-Vulnerability-Databases"><a href="#2-1-Inaccurate-Affected-Library-Versions-in-Vulnerability-Databases" class="headerlink" title="2.1 Inaccurate Affected Library Versions in Vulnerability Databases"></a><strong>2.1 Inaccurate Affected Library Versions in Vulnerability Databases</strong></h3><p>这段话讨论了漏洞数据库中“不准确的受影响库版本”（Inaccurate Affected Library  Versions，ALVs）问题。具体来说，这些数据库中的受影响库版本信息可能包含错误的版本或缺失的版本。这一问题已被广泛认知，并且依然是一个重要的挑战。文中通过一个实例（Armeria和CVE-2021-43795）来说明这一点，展示了不同漏洞数据库在报告受影响库版本时的差异。通过对源代码的手动检查，得出了“真实”版本信息，其中只有两个数据库提供了正确的受影响版本范围。此种差异强调了仅依赖漏洞数据库来获得准确的受影响库版本的困难。</p>
<img src="/2024/11/29/Vision-Identifying-Affected-Library-Versions-for-Open-Source-Software-Vulnerabilities/image-20241129163039054.png" alt="image-20241129163039054" style="zoom:67%;">

<h3 id="2-2-Limitations-of-Existing-Works"><a href="#2-2-Limitations-of-Existing-Works" class="headerlink" title="2.2 Limitations of Existing Works"></a><strong>2.2 Limitations of Existing Works</strong></h3><h4 id="Library-Versions-from-Repository-Hosting-Platforms"><a href="#Library-Versions-from-Repository-Hosting-Platforms" class="headerlink" title="Library Versions from Repository-Hosting Platforms."></a><strong>Library Versions from Repository-Hosting Platforms.</strong></h4><ol>
<li><p><strong>问题概述</strong>：</p>
<ul>
<li><p>存储库托管平台（如Maven和GitHub）上的库版本存在差异。</p>
</li>
<li><p>例如，</p>
<p>spring-boot-actuator-logview 和 spring-integration-zip</p>
<p>两个库在Maven和GitHub上的版本数量不同，且版本没有重叠：</p>
<ul>
<li>spring-boot-actuator-logview：<ul>
<li>Maven 上发布了 15 个版本，GitHub 上仅有 7 个版本。</li>
</ul>
</li>
<li>spring-integration-zip：<ul>
<li>Maven 上发布了 21 个版本，GitHub 上发布了 47 个版本。</li>
</ul>
</li>
<li>两者的版本重叠为零。</li>
<li><img src="/2024/11/29/Vision-Identifying-Affected-Library-Versions-for-Open-Source-Software-Vulnerabilities/image-20241129163401411.png" alt="image-20241129163401411" style="zoom:67%;"></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>实证分析</strong>：</p>
<ul>
<li>研究者选择了539个Maven库，并找到了对应的434个GitHub仓库，分析了1,083个与Java库相关的CVE。</li>
<li>重点分析了 <strong>Maven</strong> 和 <strong>GitHub</strong> 上的库版本，并进行了版本对比。</li>
</ul>
</li>
<li><p><strong>版本差异的发现</strong>：</p>
<ul>
<li>版本差异情况：<ul>
<li><strong>94.8%</strong> 的 Maven 库和 <strong>93.8%</strong> 的 GitHub 仓库存在版本差异。</li>
<li>这些版本差异占所有版本的 **28.0%**（15,341&#x2F;54,713）。</li>
</ul>
</li>
<li>差异的持续性：<ul>
<li>特别是在过去三年（2021年7月至2024年7月）发布的版本中，差异仍然普遍存在。</li>
<li>在新版本中，<strong>87.4%</strong> 的 Maven 库和 <strong>86.4%</strong> 的 GitHub 仓库存在版本差异。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>结论</strong>：</p>
<ul>
<li>该研究揭示了在不同的存储库托管平台和包注册中心之间，库版本的差异性依然是一个普遍且持续存在的问题，影响了准确获取版本信息的难度。</li>
</ul>
</li>
</ol>
<h4 id="Equal-Importance-to-Changed-Methods"><a href="#Equal-Importance-to-Changed-Methods" class="headerlink" title="Equal Importance to Changed Methods."></a><strong>Equal Importance to Changed Methods.</strong></h4><p>这段话主要比较了两种基于补丁的方法（V-SZZ 和 VER-Java）与三种基于克隆的方法（VOFINDER、Vuppy 和 MVP）在识别受影响库版本（ALVs）时的效果，并探讨了它们的不同表现及其原因。</p>
<p>关键点总结：</p>
<ol>
<li><strong>实验设置</strong>：<ul>
<li>比较了两种补丁方法（V-SZZ 和 VER-Java）与三种克隆方法（VOFINDER、Vuppy 和 MVP），所有方法使用相同的漏洞数据（来自 2.1 节）。  <strong>（只有一个CVE-2021-43796）</strong></li>
<li>对补丁方法，库版本信息来自 GitHub 仓库；对克隆方法，库版本信息来自 Maven。</li>
</ul>
</li>
<li><strong>结果比较</strong>：<ul>
<li>补丁方法：<ul>
<li>V-SZZ：报告 49 个受影响版本</li>
<li>VER-Java：报告 68 个受影响版本</li>
</ul>
</li>
<li>克隆方法：<ul>
<li>VOFINDER：报告 69 个受影响版本</li>
<li>Vuppy 和 MVP 没有报告任何受影响版本。</li>
</ul>
</li>
<li>其中，错误标识的库版本被标记为红色。</li>
</ul>
</li>
<li><strong>根本原因分析</strong>：<ul>
<li>漏洞根源存在于 Armeria 的 commit a38@cf，并在 commit e2697a 中修复。</li>
<li>在 commit e2697a 中有多个方法发生了变化，但如果所有变化的方法都被同等对待，检测工具可能会错误地追溯到早期的提交，从而导致错误的版本标识。<ul>
<li>例如，V-SZZ 错误地将 <code>appendHexNibble()</code> 方法中的删除语句标记为漏洞，并追溯到 commit bf1ee5，导致版本 0.69.0 到 1.12.0 被错误标记为受影响版本。</li>
<li>VER-Java 和 VOFINDER 也因为将不重要的方法错误地标识为漏洞而报告了错误的版本。</li>
<li>Vuppy 和 MVP 没有报告任何受影响版本，因为它们未能识别出任何方法。</li>
</ul>
</li>
</ul>
</li>
<li><strong>重要结论</strong>：<ul>
<li>强调了在检测受影响版本时，需要关注重要的、关键的方法。实验结果表明，选择关键方法对于避免错误标识至关重要。</li>
</ul>
</li>
</ol>
<p><img src="/2024/11/29/Vision-Identifying-Affected-Library-Versions-for-Open-Source-Software-Vulnerabilities/image-20241129164353714.png" alt="image-20241129164353714"></p>
<p>[43] NVD. 2024. <em>CVE-2021-43795</em>. Retrieved May 25, 2024 from <a target="_blank" rel="noopener" href="https://github.com/line/armeria/pull/3855/files/a380cf982f665459b79909555b5d4b024d7daf1a">https://github.com/line/armeria/pull/3855/files/a380cf982f665459b79909555b5d4b024d7daf1a</a></p>
<p>[44] NVD. 2024. <em>CVE-2021-43795</em>. Retrieved May 25, 2024 from <a target="_blank" rel="noopener" href="https://github.com/line/armeria/commit/e2697a575e9df6692b423e02d731f293c1313284z">https://github.com/line/armeria/commit/e2697a575e9df6692b423e02d731f293c1313284z</a></p>
<h4 id="Equal-Importance-to-Changed-Statements"><a href="#Equal-Importance-to-Changed-Statements" class="headerlink" title="Equal Importance to Changed Statements"></a><strong>Equal Importance to Changed Statements</strong></h4><p> <strong>CVE-2022-22976</strong> 漏洞修复中的方法修改，特别是 <strong>spring-security</strong> 项目中的 <code>crypt_raw</code> 方法的补丁。具体概括如下：</p>
<ol>
<li><p><strong>背景介绍</strong>：</p>
<ul>
<li>漏洞修复涉及 <strong>spring-security</strong> 中的 <strong><code>crypt_raw</code></strong> 方法。通过对该方法进行修改，修复了 CVE-2022-22976 漏洞。</li>
<li>在该方法的修复补丁中，修改的部分被明确标出，帮助理解漏洞的根本原因以及修复方法。</li>
</ul>
</li>
<li><p><strong>补丁分析</strong>：</p>
<ul>
<li>补丁的具体内容通过图3呈现，其中包括：<ul>
<li><strong>(a)</strong> 表示 <strong><code>crypt_raw</code> 方法修改前</strong> 的代码。</li>
<li><strong>(b)</strong> 表示 **<code>crypt_raw</code> 方法修改后的代码。</li>
<li><strong>红色背景</strong> 表示删除的代码行，<strong>绿色背景</strong> 表示新增的代码行。</li>
</ul>
</li>
</ul>
<p>图3展示了在 <strong>commit a40f735</strong> 中对 <code>crypt_raw</code> 方法进行的具体修改。通过标记删除和添加的代码行，可以看到方法中的逻辑和结构发生了调整，这有助于修复漏洞。</p>
</li>
<li><p><strong>方法修复过程</strong>：</p>
<ul>
<li>修复过程中，重要的代码行进行了修改，以避免漏洞被利用。通过图3中对比修改前后的代码，可以看到在安全性方面的增强。</li>
<li>例如，修改了代码中的一些逻辑判断和加密相关的操作，确保在运行时不会导致潜在的安全漏洞。</li>
</ul>
</li>
<li><p><strong>总结</strong>：</p>
<ul>
<li>图3帮助理解了如何通过补丁修复漏洞，强调了代码修改的细节，包括哪些部分被删除（红色背景）以及哪些部分被新增（绿色背景）。</li>
<li>这种修复方式不仅改进了代码的安全性，还展示了如何通过精确的代码变更来解决漏洞问题。</li>
</ul>
</li>
</ol>
<p><img src="/2024/11/29/Vision-Identifying-Affected-Library-Versions-for-Open-Source-Software-Vulnerabilities/image-20241129171354177.png" alt="image-20241129171354177"></p>
<p>这段话主要探讨了五种不同方法（V-SZZ、VERJAVA、VOFINDER、Vuppy 和 MVP）如何选择代码中的语句，以生成其漏洞签名，并比较了它们在漏洞检测中的表现。以下是详细概括：</p>
<ol>
<li><strong>漏洞签名的类型</strong>：<ul>
<li>**Vulnerable signature (“vul.”)**：用于匹配漏洞。</li>
<li>**Patch signature (“pat.”)**：用于验证漏洞是否已经被修复。</li>
</ul>
</li>
<li><strong>表格与图示</strong>：<ul>
<li>使用 <strong>图3</strong> 中的行号表示生成漏洞签名的元素。</li>
<li><strong>“vul.” 签名</strong> 来自图3(a)（即修复前的方法代码），<strong>“pat.” 签名</strong> 来自图3(b)（即修复后的方法代码）。</li>
</ul>
</li>
<li><strong>不同方法的选择差异</strong>：<ul>
<li>V-SZZ、Vuppy 和 VOFINDER：<ul>
<li>这些方法通过分析 <strong>修复前的代码</strong> 来生成漏洞签名。</li>
<li>具体来说：<ul>
<li><strong>V-SZZ</strong> 专注于删除的行。</li>
<li><strong>Vuppy 和 VOFINDER</strong> 则处理修复前的整个方法。</li>
</ul>
</li>
</ul>
</li>
<li>VERJAVA 和 MVP：<ul>
<li>这两种方法同时利用 <strong>vul. 和 pat. 签名</strong> 来检测漏洞并确认是否修复。</li>
<li><strong>VERJAVA</strong> 使用修改过的语句来生成签名。</li>
<li><strong>MVP</strong> 使用程序切片技术，通过识别修改的上下文（例如：在 “pat.” 签名中的第3行、第5行和第7行）来生成签名。</li>
</ul>
</li>
</ul>
</li>
<li><strong>漏洞签名的语义对齐</strong>：<ul>
<li>要实现精确的受影响库版本（ALVs）检测，漏洞签名需要与其语义意义对齐。这意味着，签名不仅要标识漏洞代码的变化，还需理解这些变化的上下文，以确保漏洞的准确检测和修复验证。</li>
</ul>
</li>
</ol>
<h2 id="APPROACH"><a href="#APPROACH" class="headerlink" title="APPROACH"></a><strong>APPROACH</strong></h2><p><strong>Vision 方法概述</strong>：</p>
<ul>
<li>核心思想：<ul>
<li><strong>Vision</strong> 通过区分不同方法和语句的重要性，来生成更精确的漏洞签名。与现有方法将所有方法和语句看作同等重要不同，Vision 根据语句和方法的重要性为它们加权，形成加权的跨过程程序依赖图（IPDGs）。</li>
<li>通过比较 IPDG 之间的相似性，Vision 能够有效检测受影响的库版本。</li>
</ul>
</li>
</ul>
<p><strong>主要模块</strong>：</p>
<ol>
<li><strong>漏洞和修复签名生成</strong>：<ul>
<li>给定一个 GitHub 仓库中的漏洞修复提交，首先识别漏洞版本（𝑅𝑃pre）和修复版本（𝑅𝑃pos）。</li>
<li>使用漏洞版本（𝑅𝑃pre）生成漏洞签名（𝑆𝑖𝑔vul），使用修复版本（𝑅𝑃pos）生成修复签名（𝑆𝑖𝑔pat）。</li>
<li>漏洞描述帮助选择关键方法，进一步生成漏洞签名。</li>
</ul>
</li>
<li><strong>漏洞潜力和修复潜力版本签名生成</strong>：<ul>
<li>给定候选库版本，生成漏洞潜力签名（𝑆𝑖𝑔vul ）和修复潜力签名（𝑆𝑖𝑔pat ）。</li>
<li>根据具体漏洞，Vision 精确选择要匹配的特征（如方法和语句）。这种签名定制化的策略，确保漏洞潜力签名与漏洞匹配，修复潜力签名与修复匹配。</li>
</ul>
</li>
<li><strong>受影响库版本检测</strong>：<ul>
<li>Vision 计算漏洞签名（𝑆𝑖𝑔vul）与候选库版本的漏洞潜力签名（𝑆𝑖𝑔vul ）之间的相似性，以及修复签名（𝑆𝑖𝑔pat）与修复潜力签名（𝑆𝑖𝑔pat ）之间的相似性。</li>
<li>如果候选库版本的漏洞潜力签名与漏洞签名（𝑆𝑖𝑔vul）更相似，则判定该版本受漏洞影响；如果与修复签名（𝑆𝑖𝑔pat）更相似，则认为该版本未受影响。</li>
</ul>
</li>
</ol>
<p><strong>总结</strong>：</p>
<p>Vision 方法通过精细化的签名生成过程和基于语义的相似性比较，能够准确检测受影响的库版本，并区别于传统方法的一视同仁的方式。</p>
<p><img src="/2024/11/29/Vision-Identifying-Affected-Library-Versions-for-Open-Source-Software-Vulnerabilities/image-20241129173431989.png" alt="image-20241129173431989"></p>
<h3 id="3-1-Vulnerability-and-Patch-Signature-Generation"><a href="#3-1-Vulnerability-and-Patch-Signature-Generation" class="headerlink" title="3.1 Vulnerability and Patch Signature Generation"></a><strong>3.1 Vulnerability and Patch Signature Generation</strong></h3><h4 id="3-1-1-Critical-Method-Selection"><a href="#3-1-1-Critical-Method-Selection" class="headerlink" title="3.1.1  Critical Method Selection"></a><em>3.1.1</em>  Critical Method Selection</h4><p><strong>1. 关键方法选择</strong></p>
<p>Vision 通过两步过程来识别 <strong>𝑅𝑃pre</strong> 和 <strong>𝑅𝑃pos</strong> 中的关键方法：</p>
<ul>
<li><strong>第一步</strong>：生成方法引用图（MRGs）。</li>
<li><strong>第二步</strong>：在这些图中识别关键方法。</li>
</ul>
<p>在此过程中，关键方法分为：</p>
<ul>
<li><strong>关键变动方法（𝑀𝑐vul, 𝑀𝑐pat）</strong>：在漏洞和修复版本中发生变化的关键方法。</li>
<li><strong>关键未变方法（𝑀𝑢vul, 𝑀𝑢pat）</strong>：在漏洞和修复版本中未发生变化的关键方法。</li>
</ul>
<p><strong>2. 方法引用图（MRGs）生成</strong></p>
<ul>
<li><strong>MRGs</strong> 用于捕捉与漏洞相关的上下文，结合了 <strong>方法调用图</strong> 和 <strong>漏洞描述中的类&#x2F;方法名</strong>。</li>
<li>这有助于更好地理解漏洞，并选择相关的关键方法：<ul>
<li><strong>构建调用图</strong>：使用 <strong>Joern</strong> 构建程序的调用图，选取与漏洞相关的变动方法及其调用方法。</li>
<li><strong>提取漏洞描述中的类和方法</strong>：从 <strong>CVE</strong> 描述和 <strong>提交描述</strong> 中提取方法和类名，并将其与调用图进行匹配。如果描述中提到的方法是专家引用的，那么在 MRG 中会创建一个 <strong>“虚拟方法调用者”</strong>，从而建立与方法之间的引用关系。</li>
</ul>
</li>
</ul>
<p><strong>3. 关键方法选择（基于MRGs）</strong></p>
<ul>
<li>使用 HITS 算法来评估方法的权威性（authority） 和 枢纽性（hub），进而识别关键方法：<ul>
<li><strong>权威方法</strong> 是最终会被恶意触发（或清理器）到达的方法。</li>
<li><strong>枢纽方法</strong> 是触发（或清理器）方法，通常会被遍历。</li>
<li>算法通过迭代计算方法的 <strong>权威值</strong> 和 <strong>枢纽值</strong>，直到收敛。</li>
<li>如果一个方法的 <strong>权威值</strong> 和 <strong>枢纽值</strong> 的总和超过一个预定阈值，则认为该方法为关键方法。</li>
</ul>
</li>
</ul>
<p><strong>4. 关键方法的调用关系</strong></p>
<p>在识别出关键方法后，Vision 会获取这些方法的调用关系和相应的调用语句，具体为：</p>
<ul>
<li><strong>在𝑅𝑃pre中的调用关系</strong>：𝑬𝑐𝑎𝑙𝑙vul 和 𝑆𝑐𝑎𝑙𝑙vul。</li>
<li><strong>在𝑅𝑃pos中的调用关系</strong>：𝑬𝑐𝑎𝑙𝑙𝑝𝑎𝑡 和 𝑆𝑐𝑎𝑙𝑙𝑝𝑎𝑡。</li>
</ul>
<p><strong>总结</strong>：</p>
<p>通过生成方法引用图并结合 HITS 算法，Vision 能够有效地识别和选择漏洞修复中的关键方法，为进一步的漏洞检测和修复分析提供支持。</p>
<blockquote>
<p>我们假设一个简单的漏洞修复场景，其中涉及一个小型的库 <code>LibraryX</code>，该库有两个版本：漏洞版本 <code>RPpre</code> 和修复版本 <code>RPpos</code>。其中的漏洞涉及一个 <strong>SQL 注入漏洞</strong>，而修复版本通过修改一个方法的实现来修复该漏洞。</p>
<h4 id="步骤1：生成方法引用图（MRGs）"><a href="#步骤1：生成方法引用图（MRGs）" class="headerlink" title="步骤1：生成方法引用图（MRGs）"></a>步骤1：生成方法引用图（MRGs）</h4><ol>
<li><p><strong>构建调用图</strong>： 假设在 <code>RPpre</code>（漏洞版本）中，有两个方法：</p>
<ul>
<li><code>methodA</code>：这个方法执行了一个数据库查询，但没有对输入进行充分的检查，导致 SQL 注入漏洞。</li>
<li><code>methodB</code>：这个方法调用了 <code>methodA</code>。</li>
</ul>
<p>在 <code>RPpos</code>（修复版本）中：</p>
<ul>
<li><code>methodA</code> 被修复，增加了对用户输入的检查，防止 SQL 注入。</li>
<li><code>methodB</code> 仍然存在，并且依然调用了 <code>methodA</code>。</li>
</ul>
<p>Vision 使用 <strong>Joern</strong> 工具生成调用图，并从中选择与漏洞相关的变动方法（<code>methodA</code>）以及其调用方法（<code>methodB</code>）。这些方法及其调用关系被添加到 <strong>MRG</strong> 中。</p>
</li>
<li><p><strong>提取漏洞描述中的类和方法</strong>： 假设漏洞描述中提到 <code>methodA</code> 是导致 SQL 注入的关键方法。因此，在生成 MRG 时，除了实际的调用关系，还会从漏洞描述中提取出 <code>methodA</code> 和相关的类名，并在 MRG 中创建一个 <strong>“虚拟方法调用者”</strong>，将描述中提到的类和方法添加到图中。</p>
<p>在 <code>RPpre</code> 中，<code>methodA</code> 被视为关键方法，因为它是 SQL 注入的根源。而在 <code>RPpos</code> 中，<code>methodA</code> 被修复，因此它不再是漏洞的一部分。</p>
</li>
</ol>
<h4 id="步骤2：使用-HITS-算法选择关键方法"><a href="#步骤2：使用-HITS-算法选择关键方法" class="headerlink" title="步骤2：使用 HITS 算法选择关键方法"></a>步骤2：使用 HITS 算法选择关键方法</h4><ol>
<li><p><strong>计算权威性和枢纽性</strong>： Vision 使用 <strong>HITS 算法</strong> 来计算每个方法的 <strong>权威性（authority）</strong> 和 <strong>枢纽性（hub）</strong>：</p>
<ul>
<li><code>methodA</code> 作为一个受影响的方法，属于 <strong>权威方法</strong>，因为它是 SQL 注入的目标。</li>
<li><code>methodB</code> 作为触发方法，属于 <strong>枢纽方法</strong>，因为它调用了 <code>methodA</code>。</li>
</ul>
<p>HITS 算法会迭代计算每个方法的 <strong>权威值</strong> 和 <strong>枢纽值</strong>。具体来说：</p>
<ul>
<li>在第一轮迭代中，<code>methodB</code> 的 <strong>枢纽值</strong> 可能会影响 <code>methodA</code> 的 <strong>权威值</strong>，因为 <code>methodB</code> 调用了 <code>methodA</code>。</li>
<li><code>methodA</code> 的 <strong>权威值</strong> 反过来也会影响 <code>methodB</code> 的 <strong>枢纽值</strong>，因为 <code>methodB</code> 依赖于 <code>methodA</code> 的执行。</li>
</ul>
</li>
<li><p><strong>迭代过程</strong>： 计算的过程会进行多轮迭代，直到所有方法的权威值和枢纽值收敛。最终，<code>methodA</code> 和 <code>methodB</code> 都会得到权威值和枢纽值，这些值可以帮助我们判断它们是否为关键方法。</p>
</li>
</ol>
<h4 id="步骤3：判断关键方法"><a href="#步骤3：判断关键方法" class="headerlink" title="步骤3：判断关键方法"></a>步骤3：判断关键方法</h4><ol>
<li><strong>判断关键方法</strong>： 如果 <code>methodA</code> 的 <strong>权威值</strong> 和 <strong>枢纽值</strong> 的总和超过了一个全局阈值（<code>t_thits</code>），则它被认为是 <strong>关键方法</strong>。在这个例子中，<code>methodA</code> 是 SQL 注入漏洞的核心，因而它被认为是关键方法。<ul>
<li>在 <code>RPpre</code> 中，<code>methodA</code> 是漏洞的一部分，具有较高的 <strong>权威值</strong>，因此被标记为 <strong>关键变动方法（𝑀𝑐vul）</strong>。</li>
<li>在 <code>RPpos</code> 中，<code>methodA</code> 已经被修复，其 <strong>权威值</strong> 降低，因此它不再是关键方法。此时，<code>methodB</code> 可能依然是 <strong>关键未变方法（𝑀𝑢pat）</strong>，因为它依赖于 <code>methodA</code>。</li>
</ul>
</li>
</ol>
<h4 id="步骤4：提取调用关系"><a href="#步骤4：提取调用关系" class="headerlink" title="步骤4：提取调用关系"></a>步骤4：提取调用关系</h4><ol>
<li><p>提取调用关系和调用语句</p>
<p>： 在识别出关键方法后，Vision 会进一步提取这些方法的调用关系和相关的调用语句。例如：</p>
<ul>
<li>在 <code>RPpre</code> 中，<code>methodA</code> 被认为是漏洞的根源，<code>methodB</code> 作为触发方法与 <code>methodA</code> 相关联，因此它们的调用关系和调用语句（<code>Ecall_vul</code> 和 <code>Scall_vul</code>）会被提取。</li>
<li>在 <code>RPpos</code> 中，修复后的 <code>methodA</code> 被认为不再是漏洞的一部分，而 <code>methodB</code> 可能会作为修复后方法的调用者之一被提取（<code>Ecall_pat</code> 和 <code>Scall_pat</code>）。</li>
</ul>
</li>
</ol>
</blockquote>
<h4 id="3-1-2-Change-Statement-Slicing"><a href="#3-1-2-Change-Statement-Slicing" class="headerlink" title="3.1.2  Change Statement Slicing"></a><em>3.1.2</em>  Change Statement Slicing</h4><p><strong>Change Statement Slicing</strong> 主要描述了 Vision 方法中如何通过 <strong>程序依赖图（PDG）</strong> 和 <strong>程序切片（program slicing）</strong> 技术，来识别和提取与关键变动方法相关的关键语句。</p>
<p>具体过程如下：</p>
<ol>
<li><strong>关键方法选择</strong>：首先，Vision 识别出关键变动方法 <code>𝑀𝑐vul</code> 和 <code>𝑀𝑐pat</code>，分别位于漏洞版本 <code>𝑅𝑃pre</code> 和修复版本 <code>𝑅𝑃pos</code> 的 <strong>方法引用图（MRG）</strong> 中。</li>
<li><strong>生成程序依赖图（PDG）</strong>：Vision 使用工具 <strong>Joern</strong> 生成 <strong>程序依赖图（PDG）</strong>，该图是一个二元组 <code>𝑆</code> 和 <code>𝐸</code>，其中：<ul>
<li><code>𝑆</code> 是图中的语句集合。</li>
<li><code>𝐸</code> 是语句间的依赖关系，表示语句之间的控制或数据依赖。</li>
</ul>
</li>
<li><strong>程序切片</strong>：<ul>
<li>Vision 在 PDG 上执行 <strong>前向切片</strong> 和 <strong>后向切片</strong> 操作，目标是提取与变动方法相关的语句。</li>
<li>变动语句（改变了的语句）通过数据依赖或控制依赖与其他语句相连，所有与这些变动语句有依赖关系的语句都会被切入到部分 PDG 中。</li>
</ul>
</li>
<li><strong>切片结果</strong>：最终，Vision 得到一个部分的 PDG，包含所有与关键变动方法相关的语句及其依赖关系。</li>
</ol>
<p>简而言之，<strong>Change Statement Slicing</strong> 通过分析关键方法所在的程序依赖图，提取与变动语句相关的语句及其依赖关系，从而帮助确定与漏洞相关的具体代码片段。</p>
<h4 id="3-1-3-Critical-Statement-Identification"><a href="#3-1-3-Critical-Statement-Identification" class="headerlink" title="3.1.3  Critical Statement Identification"></a><em>3.1.3</em>  Critical Statement Identification</h4><p><strong>Critical Statement Identification</strong> 旨在通过识别关键变量并进行 <strong>污染分析（taint analysis）</strong>，进一步确定与漏洞相关的关键语句。具体步骤包括两个主要部分：<strong>关键变量识别</strong> 和 <strong>污染分析</strong>。</p>
<ol>
<li><strong>关键变量识别</strong>：</li>
</ol>
<p>Vision 通过处理代码更改块（change hunks）来识别关键变量，具体分为以下三种情况：</p>
<ul>
<li><strong>新增变量（Added Hunks）</strong>：当一个块中只包含新增语句时，Vision 识别新增的变量，这些变量通常与漏洞修复相关。通过分析新增语句的子 <strong>抽象语法树（AST）</strong> 来提取新引入的变量。</li>
<li><strong>删除变量（Deleted Hunks）</strong>：当块中只包含删除的语句时，Vision 识别在旧版本（<code>𝑅𝑃pre</code>）中存在但在新版本（<code>𝑅𝑃pos</code>）中被移除的变量，这些变量可能与漏洞代码相关。通过分析删除语句的子 <strong>AST</strong> 来识别这些变量。</li>
<li><strong>修改变量（Modified Hunks）</strong>：当块中既有新增语句也有删除语句时，Vision 识别因代码变动而修改的变量，如方法参数或条件语句的改变。通过对比两个版本中的变量集合，识别出那些有变化的关键变量。</li>
</ul>
<ol start="2">
<li><strong>污染分析（Taint Analysis）</strong>：</li>
</ol>
<p>识别出关键变量后，Vision 进一步应用污染分析，追踪这些变量从方法的入口点到出口点的流动，并确定在流动过程中涉及的关键语句。</p>
<ul>
<li><strong>回溯污染分析（Backward Taint Analysis）</strong>：从每个关键变量开始，向方法入口点回溯，找到影响关键变量值的语句，并将这些语句标记为关键语句。</li>
<li><strong>前向污染分析（Forward Taint Analysis）</strong>：从关键变量开始，向方法的出口点（如 return、throw、assert 等语句）追踪，分析这些变量如何影响其他语句。</li>
</ul>
<p>最终，Vision 记录关键语句及其依赖关系，分别表示为：</p>
<ul>
<li>在漏洞版本（<code>𝑅𝑃pre</code>）中的关键语句：<code>𝑆taintvul</code> 和 <code>𝐸vultaint</code>。</li>
<li>在修复版本（<code>𝑅𝑃pos</code>）中的关键语句：<code>𝑆pattaint</code> 和 <code>𝐸pattaint</code>。</li>
</ul>
<p>通过以上过程，Vision 精确识别了与漏洞相关的关键语句，帮助发现漏洞的根本原因。</p>
<h4 id="3-1-4-Signature-Generation"><a href="#3-1-4-Signature-Generation" class="headerlink" title="3.1.4  Signature Generation"></a><em>3.1.4</em>  Signature Generation</h4><p><strong>Signature Generation</strong> 过程的目标是生成一个加权的跨过程程序依赖图（IPDG），用于表示漏洞和修复签名。这个签名由一个三元组组成：<code>(𝑆, 𝐸, 𝑊)</code>，其中：</p>
<ul>
<li><code>𝑆</code> 是语句集合，</li>
<li><code>𝐸</code> 是语句之间的依赖关系集合，</li>
<li><code>𝑊</code> 是每个语句及其依赖关系的权重。</li>
</ul>
<p>生成漏洞签名 (<code>𝑆𝑖𝑔vul</code>) 或修复签名 (<code>𝑆𝑖𝑔pat</code>) 的过程包括以下几个步骤：</p>
<ol>
<li><strong>连接 PDG 成为 IPDG</strong>：</li>
</ol>
<ul>
<li>Vision 为每个关键方法生成程序依赖图（PDG）。对于有更改的关键方法，使用在 <strong>change statement slicing</strong> 中生成的部分 PDG。</li>
<li>对于没有变化的关键方法，Vision 将其 PDG 压缩成一个单一的函数节点，忽略内部的程序依赖关系。</li>
<li>然后，通过从 <strong>关键方法选择</strong> 中获得的函数调用关系，将这些部分 PDG 和单一方法节点连接起来，形成跨过程程序依赖图（IPDG）。在这些连接中，跨过程调用关系从调用方法中的调用语句开始，到被调用方法中的 PDG 入口。</li>
</ul>
<ol start="2">
<li><strong>为 IPDG 分配权重</strong>：</li>
</ol>
<ul>
<li>默认情况下，IPDG 中的每个顶点和边的权重都为 1。</li>
<li>接下来，Vision 通过关键方法和关键语句来赋予更高的权重：<ul>
<li>为关键方法中的调用语句和调用关系分配权重（<code>𝑤𝑐𝑟𝑖_𝑚</code>）。</li>
<li>为关键语句及其依赖关系分配权重（<code>𝑤𝑐𝑟𝑖_𝑠</code>）。</li>
</ul>
</li>
<li>最终，通过这种加权过程生成漏洞签名 (<code>𝑆𝑖𝑔vul</code>) 和修复签名 (<code>𝑆𝑖𝑔pat</code>)，它们都表现为加权的 IPDG。</li>
</ul>
<h3 id="3-2-Vulnerability-potential-and-Patch-potential-Version-Signature-Generation"><a href="#3-2-Vulnerability-potential-and-Patch-potential-Version-Signature-Generation" class="headerlink" title="3.2 Vulnerability-potential and Patch-potential Version Signature Generation"></a><strong>3.2 Vulnerability-potential and Patch-potential Version Signature Generation</strong></h3><h4 id="3-2-1-Critical-Method-Mapping"><a href="#3-2-1-Critical-Method-Mapping" class="headerlink" title="3.2.1  Critical Method Mapping"></a><em>3.2.1</em>  Critical Method Mapping</h4><p><strong>Critical Method Mapping</strong> 过程的目标是通过与候选库版本中的相似方法匹配，帮助识别潜在的漏洞。具体步骤如下：</p>
<ol>
<li><strong>反编译库版本</strong>：首先，Vision 使用 Java Decompiler 对候选库版本进行反编译。</li>
<li><strong>使用代码克隆检测工具</strong>：然后，Vision 利用 NiCad（一个流行的代码克隆检测工具）来识别候选库版本中与 <code>𝑅𝑃pre</code> 和 <code>𝑅𝑃pos</code> 中的方法相似的方法。</li>
<li><strong>通过克隆检测匹配相似方法</strong>：不同于直接比较方法签名，Vision 使用代码克隆检测来处理更复杂的重构情况。这种方法可以识别出在重构过程中可能发生的变化，从而更全面地匹配相似方法。</li>
</ol>
<p>通过这种方法，Vision 能够发现与漏洞相关的相似方法，从而为漏洞识别提供证据。</p>
<h4 id="3-2-2-Change-Statement-Mapping-amp-Slicing"><a href="#3-2-2-Change-Statement-Mapping-amp-Slicing" class="headerlink" title="3.2.2  Change Statement Mapping &amp; Slicing"></a><em>3.2.2</em>  Change Statement Mapping &amp; Slicing</h4><p><strong>Change Statement Mapping &amp; Slicing</strong> 过程旨在通过计算原始方法和映射的关键方法之间语句的相似性来识别和处理变化的语句。具体步骤如下：</p>
<ol>
<li><strong>语法差异归一化</strong>：为了处理反编译可能引起的语法差异，Vision 对原始方法和映射方法的语句进行归一化处理，包括重新排序操作数、将条件语句（如 IfStatement）中的操作符进行标准化（例如将  “&gt;” 转换为 “&lt;”），以及统一 ForStatement 中的条件表达式。</li>
<li><strong>计算语法相似性</strong>：使用 <strong>Levenshtein 距离</strong> 来计算语句之间的语法相似性。如果相似度超过预设的阈值（默认阈值为 0.55），则 Vision 会将两者的语句匹配成一对。</li>
<li><strong>构建删除和添加语句的映射集</strong>：一旦找到了匹配的语句，Vision 会构建删除语句和添加语句的映射集。</li>
<li><strong>执行程序切片</strong>：随后，Vision 对这些映射的语句集合进行前向和后向的程序切片操作，进一步分析关键语句的依赖关系。</li>
</ol>
<p>通过这些步骤，Vision 可以有效地处理变化的语句，识别出关键的修改语句，并对其进行依赖分析。</p>
<h4 id="3-2-3-Critical-Statement-Mapping"><a href="#3-2-3-Critical-Statement-Mapping" class="headerlink" title="3.2.3 Critical Statement Mapping"></a><em>3.2.3</em> Critical Statement Mapping</h4><p><strong>Critical Statement Mapping</strong> 过程通过以下步骤识别原始方法中的关键语句：</p>
<ol>
<li><strong>识别关键变量</strong>：Vision 首先识别原始方法中包含关键变量的语句。</li>
<li><strong>构建程序依赖图（PDG）</strong>：基于识别的关键语句，Vision 构建相应的程序依赖图（PDG）。</li>
<li><strong>执行污点分析</strong>：对映射的变量进行污点分析，追踪关键变量的流向。</li>
<li><strong>形成关键语句集合</strong>：通过污点分析，Vision 确定哪些语句对关键变量有影响，从而构成原始方法中的关键语句集合。</li>
</ol>
<p>这一过程帮助 Vision 精确地识别出原始方法中与关键变量相关的关键语句。</p>
<h4 id="3-2-4-Signature-Generation"><a href="#3-2-4-Signature-Generation" class="headerlink" title="3.2.4  Signature Generation"></a><em>3.2.4</em>  Signature Generation</h4><p><strong>Signature Generation</strong> 过程与漏洞和修复签名生成过程相似，具体步骤如下：</p>
<ol>
<li><strong>使用映射的关键方法和关键语句</strong>：Vision 利用映射后的关键方法（来自 3.2.2 节）和关键语句（来自 3.2.3 节）进行签名生成。</li>
<li><strong>连接 PDGs 到 IPDGs</strong>：将程序依赖图（PDGs）连接成跨过程依赖图（IPDGs）。</li>
<li><strong>赋予权重</strong>：为每个语句及其依赖关系分配权重。</li>
</ol>
<p>最终，生成漏洞潜在签名（𝑆𝑖𝑔vul）和修复潜在签名（𝑆𝑖𝑔pat）。</p>
<h3 id="3-3-Affected-Library-Versions-Detection"><a href="#3-3-Affected-Library-Versions-Detection" class="headerlink" title="3.3 Affected Library Versions Detection"></a><strong>3.3 Affected Library Versions Detection</strong></h3><h4 id="3-3-1-Similarity-Calculation"><a href="#3-3-1-Similarity-Calculation" class="headerlink" title="3.3.1 Similarity Calculation"></a><em>3.3.1</em> Similarity Calculation</h4><p>Vision 通过比较 <strong>漏洞签名 (𝑆𝑖𝑔vul)</strong> 和 **漏洞潜力签名 (𝑆𝑖𝑔vul’)**，以及 <strong>补丁签名 (𝑆𝑖𝑔pat)</strong> 和 <strong>补丁潜力签名 (𝑆𝑖𝑔pat’)</strong> 的相似度来识别 ALVs (可能存在的漏洞)。具体步骤如下：</p>
<ol>
<li><p><strong>语义嵌入计算</strong>：首先，Vision 使用 UniXcoder（一种跨模态的编程语言预训练模型）来生成代码的语义嵌入。对于来自原始签名 <strong>𝑆𝑖𝑔vul</strong> 或 <strong>𝑆𝑖𝑔pat</strong> 中的语句集合（在方法合并为单一节点时），Vision 生成每个语句的语义嵌入向量，并通过 L2 正则化来标准化这些向量。</p>
</li>
<li><p><strong>计算相似度</strong>：接着，Vision 计算原始 IPDG 和映射的 IPDG 中的每对语句 <strong>𝑠𝑖</strong> 和 <strong>𝑠𝑗</strong> 之间的余弦相似度。根据语句的相似度和它们的权重（𝑤𝑠𝑖 和 𝑤𝑠𝑗），计算两者的距离（公式 3）。对于边的相似度，计算源节点和目标节点之间的节点距离，并通过公式 4 求得边的距离。</p>
</li>
<li><p><strong>最小化总距离</strong>：通过最小化语句和边的距离，Vision 解决了一个二分匹配问题。最终，计算两个签名之间的相似度（公式 5），其中包括语句距离和边距离的加权平均。</p>
</li>
<li><p><strong>确定是否为 ALV</strong>：Vision 计算漏洞相似度 <strong>𝑠𝑖𝑚𝑣</strong> 和补丁相似度 <strong>𝑠𝑖𝑚𝑝</strong>。如果满足以下条件，则视为 ALV：</p>
<ul>
<li><strong>𝑠𝑖𝑚𝑣 &gt; 𝑡ℎ𝑠</strong>（漏洞相似度高于阈值）</li>
<li><strong>𝑠𝑖𝑚𝑣 &gt; 𝑠𝑖𝑚𝑝</strong>（漏洞签名比补丁签名更相似）</li>
</ul>
<p>如果这些条件满足，Vision 判定候选库版本为 <strong>受影响</strong>，否则为 <strong>未受影响</strong>。</p>
</li>
</ol>
<h2 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h2><p>我们使用了 11.4K 行 Python 代码和 1.6K 行 Java 代码实现了 Vision。我们设计了以下研究问题：</p>
<ul>
<li><strong>RQ1: 效能评估</strong>：与现有的先进方法相比，Vision 在识别 ALV（潜在漏洞）方面的有效性如何？</li>
<li><strong>RQ2: 消融研究</strong>：Vision 中每个组件对整体有效性的贡献如何？</li>
<li><strong>RQ3: 参数敏感性</strong>：参数的变化如何影响 Vision 的有效性？</li>
<li><strong>RQ4: 泛化性评估</strong>：将 Vision 应用到其他数据集时，其泛化性如何？</li>
<li><strong>RQ5: 效率评估</strong>：Vision 的时间开销如何？</li>
<li><strong>RQ6: 有用性评估</strong>：Vision 的有用性如何？</li>
</ul>
<h3 id="4-1-Evaluation-Setup"><a href="#4-1-Evaluation-Setup" class="headerlink" title="4.1 Evaluation Setup"></a><strong>4.1 Evaluation Setup</strong></h3><ol>
<li><strong>Ground Truth 建立</strong></li>
</ol>
<p>实验使用 Maven 中的 Java 库作为研究对象，因其受欢迎且具有较高复杂度。Ground truth 的建立遵循严格的四步流程：</p>
<ul>
<li><strong>收集漏洞信息</strong>：从 1999 年 1 月到 2024 年 5 月，收集了 1,083 个 CVE（公共漏洞与曝光），并获取了相关补丁信息（如 GitHub 提交记录）。收集的 CVE 数据包括了 V-SZZ 和 VerJava 等现有数据集。</li>
<li><strong>收集测试用例&#x2F;漏洞证明及创建测试用例</strong>：手动检查补丁中包含的测试用例，如果没有测试用例，则通过 CVE ID 和相关漏洞的“利用”或“证明概念（PoC）”在 GitHub 上查找相关提交。分析这些触发逻辑，并将其转化为 JUnit 测试用例，共获得了 102 个 CVE 对应的<strong>测试用例</strong>。  </li>
<li><strong>运行测试用例验证库版本</strong>：自动切换 Maven 库版本并运行测试用例，以验证漏洞是否被触发。如果测试用例执行不成功，手动检查并修改代码以保证其与相应版本兼容。</li>
<li><strong>人工检查</strong>：对于无法通过测试用例验证的库版本，手动检查这些版本，查看是否存在漏洞方法或修复方法，最终确认漏洞是否存在。</li>
<li><strong>一致性检验</strong>：通过 Cohen’s Kappa 系数检验，确保两位作者在漏洞检测上有较高的一致性（Kappa 值为 0.879）。若有争议，第三位作者进行裁定。最终收集到 12,073 个库版本与 102 个 CVE 相关，涵盖了 79 个库。</li>
</ul>
<ol start="2">
<li><strong>基准比较（Baselines）</strong></li>
</ol>
<p>本实验将 Vision 与现有的补丁和克隆基于方法进行比较：</p>
<ul>
<li>补丁基准方法：<ul>
<li>V-SZZ 和 VerJava，作为当前主流的 ALV 检测工具。</li>
<li>不与 AFV（专注于 PHP 的特定漏洞）进行比较。</li>
</ul>
</li>
<li>克隆基准方法：<ul>
<li>V0Finder、VUDDY 和 MVP，比较 Vision 与这些工具的效果。VUDDY 被修改为支持 Java。</li>
<li>不与 V1Scan 和 Movery 进行比较，因为它们依赖于多个漏洞版本的范围进行聚合签名生成，这在只有一个漏洞版本时会影响其效果。</li>
</ul>
</li>
</ul>
<ol start="3">
<li><strong>评估指标与环境</strong></li>
</ol>
<p>实验使用传统的评估指标：真阳性（TP）、假阳性（FP）、假阴性（FN）、精确度和召回率。此外，引入了“完全识别漏洞”（Perfectly Identified Vulnerability, PV）的新指标，用于衡量工具是否完全正确地识别出 ALV（即零假阳性和零假阴性）。</p>
<p>总结而言，该实验的设置包括了详尽的 Ground truth 构建过程，基准工具的比较，并采用了多种传统的评估指标，以确保结果的准确性和可信度。</p>
<h3 id="4-2-Effectiveness-Evaluation-RQ1"><a href="#4-2-Effectiveness-Evaluation-RQ1" class="headerlink" title="4.2 Effectiveness Evaluation (RQ1)"></a><strong>4.2 Effectiveness Evaluation (RQ1)</strong></h3><p><img src="/2024/11/29/Vision-Identifying-Affected-Library-Versions-for-Open-Source-Software-Vulnerabilities/image-20241129194715250.png" alt="image-20241129194715250"></p>
<img src="/2024/11/29/Vision-Identifying-Affected-Library-Versions-for-Open-Source-Software-Vulnerabilities/image-20241129200329689.png" alt="image-20241129200329689" style="zoom:67%;">

<img src="/2024/11/29/Vision-Identifying-Affected-Library-Versions-for-Open-Source-Software-Vulnerabilities/image-20241129200957008.png" alt="image-20241129200957008" style="zoom:80%;">

<p><strong>实验设置</strong>：</p>
<ol>
<li><strong>评估方法</strong>：<ul>
<li>使用 ground truth 数据集，与五种基线方法（V-SZZ、VerJava、V0Finder、VUDDY、MVP）进行比较。</li>
<li>评估包括 GitHub 仓库中的重叠库版本（O）和我们完整的 ground truth 数据集（C）。</li>
<li>修改 VerJava 以支持 Maven 上的完整库版本，称为 VerJava*。</li>
</ul>
</li>
<li><strong>数据集</strong>：<ul>
<li>重叠库版本：GitHub 和 ground truth 数据集中的公共版本。</li>
<li>完整库版本：包括所有相关版本的数据。</li>
</ul>
</li>
<li><strong>评估维度</strong>：<ul>
<li>CWE 类型：按照 12 个组对漏洞类型进行分类，包含 83 个标记了 CWE 的漏洞和 19 个未标记的漏洞。</li>
<li>更改类型：包括混合更改和仅添加更改（没有删除的变化）。</li>
<li>最优参数：根据灵敏度分析选择。</li>
</ul>
</li>
</ol>
<hr>
<p><strong>整体结果</strong>：</p>
<ol>
<li><strong>精确度与召回率</strong>：<ul>
<li>Vision：<ul>
<li>重叠库版本：精确度 0.91，召回率 0.95。</li>
<li>完整库版本：精确度 0.91，召回率 0.94。</li>
</ul>
</li>
<li><strong>VerJava</strong>（重叠库版本）：精确度 0.78，召回率 0.58。</li>
<li><strong>V0Finder</strong>（完整库版本）：精确度 0.81，召回率 0.25。</li>
</ul>
</li>
<li>**完美识别的漏洞 (PVs)**：<ul>
<li>重叠库版本：Vision 识别了 66 个 PVs（64.7%），超过 VerJava 的 37 个（36.3%）。</li>
<li>完整库版本：Vision 识别了 62 个 PVs（60.8%），超过 V0Finder 的 46 个（287.5%）。</li>
</ul>
</li>
<li><strong>假阳性与假阴性</strong>：<ul>
<li>Vision：<ul>
<li>重叠库版本：357 个假阳性，184 个假阴性，56 个非 PV 漏洞。</li>
<li>完整库版本：418 个假阳性，258 个假阴性，40 个非 PV 漏洞。</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<p><strong>错误分析</strong>：</p>
<ol>
<li>CVE 或提交描述误导：<ul>
<li>包含不相关的修复方法，影响了关键方法的选择。</li>
</ul>
</li>
<li>Joern 切片误差：<ul>
<li>程序切片中的错误数据或控制依赖，影响了关键语句的选择。</li>
</ul>
</li>
<li>版本修复逻辑不同：<ul>
<li>不同分支上可能存在不同的修复逻辑，导致补丁签名未能准确反映。</li>
</ul>
</li>
</ol>
<hr>
<p><strong>按 CWE 类型的有效性</strong>：</p>
<ol>
<li><strong>重叠库版本</strong>：<ul>
<li>Vision 超越 VerJava 在 8 个 CWE 类型的精确度，12 个类型的召回率。</li>
<li>在 6 个 CWE 类型中，Vision 达到 100% 的精确度或召回率。</li>
<li>平均精确度：Vision 0.87，VerJava 0.78。</li>
<li>平均召回率：Vision 0.95，VerJava 0.58。</li>
</ul>
</li>
<li><strong>完整库版本</strong>：<ul>
<li>Vision 超越 Vuddy 在 8 个 CWE 类型的精确度，12 个类型的召回率。</li>
<li>平均精确度：Vision 0.88，Vuddy 0.84。</li>
<li>平均召回率：Vision 0.94，Vuddy 0.91。</li>
</ul>
</li>
</ol>
<hr>
<p><strong>按更改方法的有效性</strong>：</p>
<ol>
<li>重叠库版本：<ul>
<li>Vision 精确度：0.84 到 0.97，召回率：0.92 到 0.95。</li>
<li>比基线工具表现更好，特别在精确度上。</li>
</ul>
</li>
<li>完整库版本：<ul>
<li>Vision 精确度：0.86 到 0.95，召回率：0.92 到 0.95。</li>
<li>相比 Vuddy，精确度略低，但在更多变化的情况下，Vision 超越了 Vuddy。</li>
</ul>
</li>
</ol>
<hr>
<p><strong>按更改类型的有效性</strong>：</p>
<ol>
<li>混合更改：<ul>
<li>Vision 在混合更改上超越 V-SZZ，精确度提高 0.27，召回率提高 0.16。</li>
</ul>
</li>
<li>仅添加更改：<ul>
<li>V-SZZ 对于仅添加的更改失败，而 Vision 表现优越。</li>
</ul>
</li>
</ol>
<hr>
<p><strong>总结</strong>：</p>
<ul>
<li>Vision 在所有评估维度上表现出色，尤其在处理不同类型和数量的漏洞修复时，展示了较高的精确度和召回率。</li>
<li>Vision 在处理混合更改和仅添加更改时均超过了现有的基线方法，特别是在处理复杂漏洞修复时的稳定性和有效性。</li>
</ul>
<p><strong>总结：Vision 在完整库版本和重叠库版本中均取得了最高的精确度和召回率，分别为 0.91 和 0.94，以及 0.91 和  0.95，平均精确度比现有的最先进方法高出 0.23（33.8%），召回率高出 0.71（308.7%）。相比于最先进的方法，Vision  平均识别了 3,352 个（312.7%）更多的真实 ALV。Vision 在不同的 CWE 类型、变更方法数量和变更类型上均表现出色。</strong></p>
<h3 id="4-3-Ablation-Study-RQ2"><a href="#4-3-Ablation-Study-RQ2" class="headerlink" title="4.3  Ablation Study (RQ2)"></a><strong>4.3  Ablation Study (RQ2)</strong></h3><p><img src="/2024/11/29/Vision-Identifying-Affected-Library-Versions-for-Open-Source-Software-Vulnerabilities/image-20241129201016748.png" alt="image-20241129201016748"></p>
<p><strong>RQ2 设置：</strong> 为了研究 Vision 各个组成部分的贡献，创建了五个消融版本：</p>
<ol>
<li><strong>w&#x2F;o CR</strong>：仅保留专家参考中识别的关键方法，消除调用关系。</li>
<li><strong>w&#x2F;o EF</strong>：保留调用关系，但不使用专家参考来识别关键方法。</li>
<li><strong>w&#x2F; CM</strong>：用变更方法代替关键方法进行选择。</li>
<li><strong>w&#x2F;o CS</strong>：将关键语句标记为普通语句，设定权重为 1。</li>
<li><strong>w&#x2F; LD</strong>：将 UniXcoder 替换为 Levenshtein 距离计算相似度。</li>
</ol>
<p>另外，消融实验还涉及在基于克隆的方法中应用关键方法选择（V0Finder w&#x2F; CMS, MVP w&#x2F; CMS, Vuddy w&#x2F; CMS）。</p>
<p><strong>整体结果：</strong></p>
<ul>
<li>所有消融版本的精确度和召回率均有所下降。</li>
<li><strong>w&#x2F;o CS</strong>：精确度下降 0.07，召回率下降 0.15，表明选择关键语句对性能至关重要。</li>
<li><strong>w&#x2F; CM</strong>：精确度下降 0.04，召回率下降 0.11，凸显了关键方法选择的重要性。</li>
<li><strong>w&#x2F;o CR</strong> 和 <strong>w&#x2F;o EF</strong>：去除调用关系或专家参考后，精确度和召回率均有所下降，表明两者对 Vision 的有效性有重要贡献。</li>
<li><strong>w&#x2F; LD</strong>：将 UniXcoder 替换为 Levenshtein 距离后，精确度和召回率均有所下降。</li>
<li><strong>基于克隆的方法</strong>（V0Finder, MVP, Vuddy）在使用关键方法选择后，精确度分别提升了 0.10、0.18 和 0.16，但召回率轻微下降（分别为 0.04、0.02 和 0.03）。</li>
</ul>
<p>总结：移除 Vision 的任何组件都会导致精确度和召回率的明显下降。去除关键语句导致召回率下降最大，下降幅度为  0.15；而移除调用关系则导致精确度下降最大，下降幅度为 0.10。通过使用我们的关键方法选择，基于克隆的方法在精确度上平均提高了  0.15，但召回率平均略微下降了 0.03。</p>
<h3 id="4-4-Parameter-Sensitivity-RQ3"><a href="#4-4-Parameter-Sensitivity-RQ3" class="headerlink" title="4.4 Parameter Sensitivity (RQ3)"></a><strong>4.4 Parameter Sensitivity (RQ3)</strong></h3><p><strong>RQ3 设置</strong>：<br>Vision 中有四个可配置的参数：</p>
<ol>
<li><strong>选择关键方法的阈值</strong> (𝑡ℎℎ𝑖𝑡𝑠)</li>
<li><strong>关键方法间的程序间调用权重</strong> (𝑤𝑐𝑟𝑖_𝑚)</li>
<li><strong>关键语句的权重</strong> (𝑤𝑐𝑟𝑖_𝑠)</li>
<li><strong>识别漏洞的相似度阈值</strong> (𝑡ℎ𝑠)<br>默认值分别为：0.4, 3, 3 和 0.6。为了评估这些参数对 Vision 准确度的灵敏度，我们分别调整一个参数，并将其他三个保持固定。</li>
</ol>
<p><strong>总体结果</strong>：<br>通过灵敏度分析，Vision 在以下配置下达到最佳性能：</p>
<ul>
<li>𝑡ℎℎ𝑖𝑡𝑠 &#x3D; 0.4</li>
<li>𝑤𝑐𝑟𝑖_𝑚 &#x3D; 3</li>
<li>𝑤𝑐𝑟𝑖_𝑠 &#x3D; 3</li>
<li>𝑡ℎ𝑠 &#x3D; 0.6</li>
</ul>
<img src="/2024/11/29/Vision-Identifying-Affected-Library-Versions-for-Open-Source-Software-Vulnerabilities/image-20241129201332767.png" alt="image-20241129201332767" style="zoom:67%;">



<h3 id="4-5-Generality-Evaluation-RQ4"><a href="#4-5-Generality-Evaluation-RQ4" class="headerlink" title="4.5 Generality Evaluation (RQ4)"></a><strong>4.5 Generality Evaluation (RQ4)</strong></h3><p><img src="/2024/11/29/Vision-Identifying-Affected-Library-Versions-for-Open-Source-Software-Vulnerabilities/image-20241129201504221.png" alt="image-20241129201504221"></p>
<ul>
<li><strong>RQ4 设置</strong>：<br>将 Vision 应用于 V-SZZ 和 VerJava 的原始数据集。选择了 V-SZZ 和 VerJava 重叠集中的 50%（41&#x2F;81）的 CVE，得到了 3,381 个完整库版本（C.）和 3,078 个重叠库版本（O.）。</li>
<li><strong>总体结果</strong>：<ol>
<li>性能对比：<ul>
<li>Vision, Vision −, MVP, V0Finder, 和 Vuddy 在这两个数据集上表现相似。</li>
<li>V-SZZ, VerJava 和 VerJava∗ 在它们自己的数据集上表现出更高的精度和召回率。</li>
</ul>
</li>
<li>精度和召回率变化：<ul>
<li>Vision 的精度下降了 1%，召回率下降了 2%。</li>
<li>Vision − 的精度略微上升了 2%，召回率下降了 1%。</li>
<li>这表明 Vision 在外部数据集上的泛化能力。</li>
</ul>
</li>
<li>Vision − 与 VerJava 比较：<ul>
<li>Vision − 相比于 VerJava 提高了 0.11（13.41%）的精度和 0.35（59.32%）的召回率。</li>
<li>Vision − 在重叠库版本中识别了 29 个（70.73%）完全识别的漏洞（PVs），超越了 VerJava 的 16 个（123.08%）。</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="4-6-Efficiency-Evaluation-RQ5"><a href="#4-6-Efficiency-Evaluation-RQ5" class="headerlink" title="4.6 Efficiency Evaluation (RQ5)"></a><strong>4.6 Efficiency Evaluation (RQ5)</strong></h3><p><strong>RQ5 设置：</strong></p>
<ul>
<li>测量了每个漏洞以及每个库版本识别 ALVs 所需的平均时间。</li>
</ul>
<p><strong>总体结果：</strong></p>
<ul>
<li><p>Vision</p>
<p> 的时间成本如下：</p>
<ul>
<li>平均需要 <strong>9.24 秒</strong> 来处理一个候选库版本并判断其是否受到影响。</li>
<li>平均需要 <strong>1,094.11 秒</strong> 来处理所有库版本对应一个漏洞的情况。</li>
</ul>
</li>
<li><p>虽然 Vision 的时间成本高于现有工具，但由于其在识别漏洞影响版本方面的卓越效果，这一时间成本是可以接受的。</p>
</li>
<li><p>时间成本的增加主要是由于需要反编译 JAR 文件、生成用于关键方法选择的调用图，以及进行相似度计算等过程。</p>
</li>
</ul>
<h3 id="4-7-Usefulness-Evaluation-RQ6"><a href="#4-7-Usefulness-Evaluation-RQ6" class="headerlink" title="4.7 Usefulness Evaluation (RQ6)"></a><strong>4.7 Usefulness Evaluation (RQ6)</strong></h3><p><strong>RQ6 设置：</strong></p>
<ul>
<li>本研究将 <strong>Vision</strong> 与五个漏洞数据库进行比较：<strong>NVD</strong>、<strong>Veracode</strong>、<strong>GitHub</strong>、<strong>GitLab</strong> 和 <strong>Snyk</strong>。</li>
<li>排除任何未知的 CVE 以及在我们的真实数据集中不存在的库版本。</li>
<li>使用与 <strong>RQ1</strong> 相同的度量标准评估这些数据库的准确性，同时评估 <strong>Vision</strong> 在这些数据库中的表现，并计算 <strong>Vision</strong> 相较于各数据库的准确性提升。</li>
</ul>
<p><strong>总体结果：</strong></p>
<ul>
<li>Vision 在所有五个数据库中均提高了精度和召回率：<ul>
<li>在 <strong>GitHub</strong> 和 <strong>GitLab</strong> 中，<strong>Vision</strong> 的精度提升最大，达到了 <strong>0.22</strong>。</li>
<li>在 <strong>NVD</strong> 中，<strong>Vision</strong> 的召回率提升最大，达到了 <strong>0.14</strong>。</li>
</ul>
</li>
<li>Vision 帮助识别了更多完全正确的漏洞（PVs）：<ul>
<li>在 <strong>Snyk</strong> 中增加了至少 <strong>19</strong> 个 PVs，在 <strong>NVD</strong> 中最多增加了 <strong>27</strong> 个 PVs。</li>
</ul>
</li>
<li>Vision 在识别不准确的漏洞时，提供了帮助：<ul>
<li>将 <strong>Vision</strong> 错误标记的漏洞报告给各数据库：<strong>52</strong> 个给 <strong>NVD</strong>、<strong>31</strong> 个给 <strong>Veracode</strong>、<strong>46</strong> 个给 <strong>Snyk</strong>，并通过创建问题将 <strong>39</strong> 和 <strong>42</strong> 个错误漏洞报告给 <strong>GitHub</strong> 和 <strong>GitLab</strong>。</li>
<li>目前，<strong>GitHub</strong> 和 <strong>GitLab</strong> 已解决了所有错误的库版本，<strong>NVD</strong> 修复了 <strong>8</strong> 个漏洞，剩余的漏洞仍在审查中。</li>
<li>值得注意的是，<strong>GitLab</strong> 表示对我们的工具在 <strong>ALV</strong> 检测方面非常感兴趣。</li>
</ul>
</li>
</ul>
<h3 id="4-8-Discussion"><a href="#4-8-Discussion" class="headerlink" title="4.8 Discussion"></a><strong>4.8 Discussion</strong></h3><ol>
<li><strong>威胁：</strong><ul>
<li><strong>构建真实数据集的威胁：</strong> 真实数据集的构建可能存在人工错误，尽管我们尽最大努力通过验证受影响的库版本来确保其准确性。为了减少这一威胁，数据集的构建过程涉及了三位作者的参与。</li>
<li><strong>数据集规模的影响：</strong> 评估结果受数据集规模的影响。我们构建了一个包含102个漏洞和12,073个受影响与未受影响的库版本的数据集，这一数据集的构建耗时约800人小时，是目前为止最大的评估数据集。</li>
</ul>
</li>
<li><strong>局限性：</strong><ul>
<li><strong>依赖语言特定工具：</strong> <strong>Vision</strong> 依赖于一些语言特定的工具，如 Java Decompiler 和 Joern，因此其适用性有限，主要针对特定的编程语言，不能广泛应用于其他编程语言。</li>
<li><strong>缺乏漏洞解释：</strong> <strong>Vision</strong> 没有提供预测的受影响库版本的解释。未来我们计划通过增加基于关键方法和语句的可视化漏洞原因和修复的解释来解决这一问题。</li>
<li><strong>补丁输入的多次提交问题：</strong> <strong>Vision</strong> 接受补丁提交作为输入，但目标补丁可能包含多个提交，这可能导致忽略漏洞签名和补丁签名，进而可能产生假阳性和假阴性。</li>
</ul>
</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Lin Li</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/11/29/Vision-Identifying-Affected-Library-Versions-for-Open-Source-Software-Vulnerabilities/">http://example.com/2024/11/29/Vision-Identifying-Affected-Library-Versions-for-Open-Source-Software-Vulnerabilities/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">LinLi's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/">论文阅读</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/11/30/Drowzee-Metamorphic-Testing-for-Fact-Conflicting-Hallucination-Detection-in-Large-Language-Models/" title="Drowzee Metamorphic Testing for Fact-Conflicting Hallucination Detection in Large Language Models"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Drowzee Metamorphic Testing for Fact-Conflicting Hallucination Detection in Large Language Models</div></div></a></div><div class="next-post pull-right"><a href="/2024/11/24/Validating-LLM-Generated-Programs-with-Metamorphic-Prompt-Testing/" title="Validating LLM-Generated Programs with Metamorphic Prompt Testing"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Validating LLM-Generated Programs with Metamorphic Prompt Testing</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/03/04/PLUMBER/" title="PLUMBER"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-04</div><div class="title">PLUMBER</div></div></a></div><div><a href="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/" title="通过NPM生态系统的依赖树揭开脆弱性传播及其演化的神秘面纱"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-08</div><div class="title">通过NPM生态系统的依赖树揭开脆弱性传播及其演化的神秘面纱</div></div></a></div><div><a href="/2023/04/03/Flexible-and-Optimal-Dependency-Management-via-Max-SMT/" title="Flexible and Optimal Dependency Management via Max-SMT"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-03</div><div class="title">Flexible and Optimal Dependency Management via Max-SMT</div></div></a></div><div><a href="/2023/04/11/What-the-Fork-Finding-Hidden-Code-Clones-in-npm/" title="What the Fork Finding Hidden Code Clones in npm"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-11</div><div class="title">What the Fork Finding Hidden Code Clones in npm</div></div></a></div><div><a href="/2023/04/12/Static-Type-Inference-for-Foreign-Functions-of-Python/" title="Static Type Inference for Foreign Functions of Python"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-12</div><div class="title">Static Type Inference for Foreign Functions of Python</div></div></a></div><div><a href="/2023/04/13/Where-to-Start-Studying-Type-Annotation-Practices-in-Python/" title="Where to Start Studying Type Annotation Practices in Python"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-13</div><div class="title">Where to Start Studying Type Annotation Practices in Python</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Lin Li</div><div class="author-info__description">今日事，今日毕</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">121</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Vision-Identifying-Affected-Library-Versions-for-Open-Source-Software-Vulnerabilities"><span class="toc-number">1.</span> <span class="toc-text">Vision: Identifying Affected Library Versions for Open Source Software Vulnerabilities</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ABSTRACT"><span class="toc-number">1.1.</span> <span class="toc-text">ABSTRACT</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NTRODUCTION"><span class="toc-number">1.2.</span> <span class="toc-text">NTRODUCTION</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MOTIVATION"><span class="toc-number">1.3.</span> <span class="toc-text">MOTIVATION</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-Inaccurate-Affected-Library-Versions-in-Vulnerability-Databases"><span class="toc-number">1.3.1.</span> <span class="toc-text">2.1 Inaccurate Affected Library Versions in Vulnerability Databases</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-Limitations-of-Existing-Works"><span class="toc-number">1.3.2.</span> <span class="toc-text">2.2 Limitations of Existing Works</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Library-Versions-from-Repository-Hosting-Platforms"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">Library Versions from Repository-Hosting Platforms.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Equal-Importance-to-Changed-Methods"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">Equal Importance to Changed Methods.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Equal-Importance-to-Changed-Statements"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">Equal Importance to Changed Statements</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#APPROACH"><span class="toc-number">1.4.</span> <span class="toc-text">APPROACH</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-Vulnerability-and-Patch-Signature-Generation"><span class="toc-number">1.4.1.</span> <span class="toc-text">3.1 Vulnerability and Patch Signature Generation</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-1-Critical-Method-Selection"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">3.1.1  Critical Method Selection</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A41%EF%BC%9A%E7%94%9F%E6%88%90%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E5%9B%BE%EF%BC%88MRGs%EF%BC%89"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">步骤1：生成方法引用图（MRGs）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A42%EF%BC%9A%E4%BD%BF%E7%94%A8-HITS-%E7%AE%97%E6%B3%95%E9%80%89%E6%8B%A9%E5%85%B3%E9%94%AE%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.1.3.</span> <span class="toc-text">步骤2：使用 HITS 算法选择关键方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A43%EF%BC%9A%E5%88%A4%E6%96%AD%E5%85%B3%E9%94%AE%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.1.4.</span> <span class="toc-text">步骤3：判断关键方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A44%EF%BC%9A%E6%8F%90%E5%8F%96%E8%B0%83%E7%94%A8%E5%85%B3%E7%B3%BB"><span class="toc-number">1.4.1.5.</span> <span class="toc-text">步骤4：提取调用关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-2-Change-Statement-Slicing"><span class="toc-number">1.4.1.6.</span> <span class="toc-text">3.1.2  Change Statement Slicing</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-3-Critical-Statement-Identification"><span class="toc-number">1.4.1.7.</span> <span class="toc-text">3.1.3  Critical Statement Identification</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-4-Signature-Generation"><span class="toc-number">1.4.1.8.</span> <span class="toc-text">3.1.4  Signature Generation</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-Vulnerability-potential-and-Patch-potential-Version-Signature-Generation"><span class="toc-number">1.4.2.</span> <span class="toc-text">3.2 Vulnerability-potential and Patch-potential Version Signature Generation</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-Critical-Method-Mapping"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">3.2.1  Critical Method Mapping</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-Change-Statement-Mapping-amp-Slicing"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">3.2.2  Change Statement Mapping &amp; Slicing</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-3-Critical-Statement-Mapping"><span class="toc-number">1.4.2.3.</span> <span class="toc-text">3.2.3 Critical Statement Mapping</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-4-Signature-Generation"><span class="toc-number">1.4.2.4.</span> <span class="toc-text">3.2.4  Signature Generation</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-Affected-Library-Versions-Detection"><span class="toc-number">1.4.3.</span> <span class="toc-text">3.3 Affected Library Versions Detection</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1-Similarity-Calculation"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">3.3.1 Similarity Calculation</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Evaluation"><span class="toc-number">1.5.</span> <span class="toc-text">Evaluation</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-Evaluation-Setup"><span class="toc-number">1.5.1.</span> <span class="toc-text">4.1 Evaluation Setup</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-Effectiveness-Evaluation-RQ1"><span class="toc-number">1.5.2.</span> <span class="toc-text">4.2 Effectiveness Evaluation (RQ1)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-Ablation-Study-RQ2"><span class="toc-number">1.5.3.</span> <span class="toc-text">4.3  Ablation Study (RQ2)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-Parameter-Sensitivity-RQ3"><span class="toc-number">1.5.4.</span> <span class="toc-text">4.4 Parameter Sensitivity (RQ3)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-Generality-Evaluation-RQ4"><span class="toc-number">1.5.5.</span> <span class="toc-text">4.5 Generality Evaluation (RQ4)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-Efficiency-Evaluation-RQ5"><span class="toc-number">1.5.6.</span> <span class="toc-text">4.6 Efficiency Evaluation (RQ5)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-Usefulness-Evaluation-RQ6"><span class="toc-number">1.5.7.</span> <span class="toc-text">4.7 Usefulness Evaluation (RQ6)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-8-Discussion"><span class="toc-number">1.5.8.</span> <span class="toc-text">4.8 Discussion</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/21/Sequence-Oriented-DBMS-Fuzzing/" title="Sequence-Oriented DBMS Fuzzing">Sequence-Oriented DBMS Fuzzing</a><time datetime="2025-02-21T09:35:08.000Z" title="发表于 2025-02-21 17:35:08">2025-02-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/18/AGENTLESS-Demystifying-LLM-based-Software-Engineering-Agents/" title="AGENTLESS: Demystifying LLM-based Software Engineering Agents">AGENTLESS: Demystifying LLM-based Software Engineering Agents</a><time datetime="2025-02-18T12:16:29.000Z" title="发表于 2025-02-18 20:16:29">2025-02-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/01/DeepSeek-R1-Incentivizing-Reasoning-Capability-in-LLMs-via-Reinforcement-Learning/" title="DeepSeek-R1: Incentivizing Reasoning Capability in LLMs via Reinforcement Learning">DeepSeek-R1: Incentivizing Reasoning Capability in LLMs via Reinforcement Learning</a><time datetime="2025-02-01T11:11:48.000Z" title="发表于 2025-02-01 19:11:48">2025-02-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/01/DeepSeek-Coder-When-the-Large-Language-Model-Meets-Programming-The-Rise-of-Code-Intelligence/" title="DeepSeek-Coder: When the Large Language Model Meets Programming - The Rise of Code Intelligence">DeepSeek-Coder: When the Large Language Model Meets Programming - The Rise of Code Intelligence</a><time datetime="2025-02-01T02:43:19.000Z" title="发表于 2025-02-01 10:43:19">2025-02-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/30/LLM-Hallucinations-in-Practical-Code-Generation-Phenomena-Mechanism-and-Mitigation/" title="LLM Hallucinations in Practical Code Generation: Phenomena, Mechanism, and Mitigation">LLM Hallucinations in Practical Code Generation: Phenomena, Mechanism, and Mitigation</a><time datetime="2025-01-30T12:14:09.000Z" title="发表于 2025-01-30 20:14:09">2025-01-30</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Lin Li</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>