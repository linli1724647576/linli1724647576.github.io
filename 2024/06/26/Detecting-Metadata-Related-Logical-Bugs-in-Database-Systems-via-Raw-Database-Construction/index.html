<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>Detecting Metadata-Related Logical Bugs in Database Systems via Raw Database Construction | LinLi's Blog</title><meta name="author" content="Lin Li"><meta name="copyright" content="Lin Li"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Detecting Metadata-Related Logical Bugs in Database Systems via Raw Database ConstructionABSTRACT:数据库管理系统（DBMSs）被广泛用于高效地存储和检索数据。DBMSs通常支持各种元数据，例如用于确保数据完整性的完整性约束和用于定位数据的索引。DBMSs还可以利用这些元数据来优化查询评估。然而，不正确">
<meta property="og:type" content="article">
<meta property="og:title" content="Detecting Metadata-Related Logical Bugs in Database Systems via Raw Database Construction">
<meta property="og:url" content="http://example.com/2024/06/26/Detecting-Metadata-Related-Logical-Bugs-in-Database-Systems-via-Raw-Database-Construction/index.html">
<meta property="og:site_name" content="LinLi&#39;s Blog">
<meta property="og:description" content="Detecting Metadata-Related Logical Bugs in Database Systems via Raw Database ConstructionABSTRACT:数据库管理系统（DBMSs）被广泛用于高效地存储和检索数据。DBMSs通常支持各种元数据，例如用于确保数据完整性的完整性约束和用于定位数据的索引。DBMSs还可以利用这些元数据来优化查询评估。然而，不正确">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2024-06-26T02:41:32.000Z">
<meta property="article:modified_time" content="2024-06-26T02:42:35.198Z">
<meta property="article:author" content="Lin Li">
<meta property="article:tag" content="论文阅读">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/06/26/Detecting-Metadata-Related-Logical-Bugs-in-Database-Systems-via-Raw-Database-Construction/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Detecting Metadata-Related Logical Bugs in Database Systems via Raw Database Construction',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-06-26 10:42:35'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">122</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="LinLi's Blog"><span class="site-name">LinLi's Blog</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Detecting Metadata-Related Logical Bugs in Database Systems via Raw Database Construction</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-06-26T02:41:32.000Z" title="发表于 2024-06-26 10:41:32">2024-06-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-06-26T02:42:35.198Z" title="更新于 2024-06-26 10:42:35">2024-06-26</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Detecting Metadata-Related Logical Bugs in Database Systems via Raw Database Construction"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Detecting-Metadata-Related-Logical-Bugs-in-Database-Systems-via-Raw-Database-Construction"><a href="#Detecting-Metadata-Related-Logical-Bugs-in-Database-Systems-via-Raw-Database-Construction" class="headerlink" title="Detecting Metadata-Related Logical Bugs in Database Systems via Raw Database Construction"></a>Detecting Metadata-Related Logical Bugs in Database Systems via Raw Database Construction</h1><h2 id="ABSTRACT"><a href="#ABSTRACT" class="headerlink" title="ABSTRACT:"></a>ABSTRACT:</h2><p>数据库管理系统（DBMSs）被广泛用于高效地存储和检索数据。DBMSs通常支持各种元数据，例如用于确保数据完整性的完整性约束和用于定位数据的索引。DBMSs还可以利用这些元数据来优化查询评估。然而，不正确的元数据相关优化可能会引入元数据相关的逻辑错误，这可能导致DBMS对给定查询返回不正确的查询结果。在本文中，我们提出了一种通用且有效的测试方法，原始数据库构建（Radar），以检测DBMS中的元数据相关逻辑错误。给定一个包含一些元数据的数据库DB，Radar首先构建一个原始数据库DB_raw，它清除DB中的元数据并包含与DB相同的数据。由于DB和DB_raw具有相同的数据，它们对给定查询应返回相同的查询结果。任何查询结果的不一致都表明存在元数据相关的逻辑错误。为了有效地检测元数据相关的逻辑错误，我们进一步提出了一种元数据导向的测试优化策略，重点测试以前未见过的元数据，从而快速检测更多的元数据相关逻辑错误。我们在五个广泛使用的DBMS上实现并评估了Radar，检测到42个错误，其中38个被确认是新错误，16个已被DBMS开发人员修复。</p>
<h2 id="INTRODUCTION"><a href="#INTRODUCTION" class="headerlink" title="INTRODUCTION:"></a>INTRODUCTION:</h2><p><font color="red">metadata</font></p>
<p>在DBMS中，数据库元数据描述了数据库中的数据组织，包括数据库结构（如数据类型和完整性约束）、索引和存储配置。DBMS可以利用这些元数据来确保其管理数据库中的数据完整性。例如，一个表中的TINYINT数据类型列只能存储-128到127之间的数值；如果对该列应用了NOT NULL约束，则该列不能存储NULL值；如果应用了UNIQUE约束，则该列不能存储重复的数值。</p>
<p>DBMS还可以利用数据库元数据（如完整性约束和索引）来优化查询评估。例如，如果在一个表的某列上c1应用了NOT NULL约束，在评估SELECT c1 FROM t1 WHERE ISNULL(c1)查询时，DBMS可以直接返回FALSE，而无需对每条记录进行评估；如果在某列上应用了索引，DBMS可以快速找到匹配条件的记录，避免不必要的数据访问。</p>
<p><font color="red">Motivation example</font></p>
<p>这个例子展示了我们的方法在广泛使用的DBMS TiDB中检测到的一个真实世界的元数据相关逻辑错误（MRL），编号为TiDB#41374。数据库DB包含一个表T1，表中有一个数据类型为INT并带有NOT NULL约束的列C1。由于IFNULL函数中的不正确优化（直接返回列C1的值，即INT值0），导致返回了错误的值“0000-00-00”。在正确的实现中，IFNULL函数需要将INT值0转换为字符串’0’，从而产生正确的查询结果NULL。我们将此错误报告给TiDB开发人员，他们将其分类为重大错误并迅速修复了它。</p>
<img src="/2024/06/26/Detecting-Metadata-Related-Logical-Bugs-in-Database-Systems-via-Raw-Database-Construction/image-20240625135920921.png" alt="image-20240625135920921" style="zoom:67%;">

<p><font color="red">Related work</font><br>最近，研究人员提出了许多方法来检测DBMS中的逻辑错误。RAGS通过在多个DBMS上执行查询并识别查询结果之间的差异。然而，差异测试无法检测到在所有DBMS中都发生的错误，也无法测试单个DBMS的特定功能。DQE、NoREC和TLP通过构造与原始查询等价的查询，并识别其执行结果之间的差异。然而，这些查询转换不能有效地禁用有问题的元数据相关优化，因此会遗漏MRLs。MutaSQL通过向表中添加索引并观察查询结果的变化来检测与索引相关的逻辑错误，但它不支持大多数数据库元数据，如NOT NULL、GENERATED和FOREIGN KEY。因此，现有的方法无法有效地检测DBMS中的MRLs，可能会遗漏许多实际存在的MRLs。</p>
<p>[34] Xinyue Chen, Chenglong Wang, and Alvin Cheung. 2020. Testing Query Execution Engines with Mutations. In <em>Proceedings of the Workshop on Testing Database Systems</em>. Article 6, 5 pages.</p>
<p><font color="green">Key insight有点小，和MutaSQL相比，仅仅是支持了大多数metadata？</font></p>
<p><font color="green">和Testing_Database_Engines_via_Query_Plan_Guidance的本质区别是？  都是涉及一些优化选项，本质相同，表现形式不同而已，和Mozi也差不多。</font></p>
<p><font color="red">approach</font></p>
<p>给定一个包含一些元数据（如完整性约束和索引）的数据库DB，DBMS可以利用这些元数据以优化的方式评估查询Q。如果我们从数据库DB中移除这些元数据，DBMS必须以相应的非优化方式评估相同的查询Q。我们观察到，这两种查询评估方式应该返回相同的查询结果。例子中展示了这种情况：如果在表T1的列C1上应用NOT NULL约束，TiDB以优化方式评估查询Q；如果我们移除NOT NULL约束，TiDB则以非优化方式评估查询Q。如果在优化和非优化查询评估之间出现任何不一致，就揭示了一个MRL。</p>
<p>基于上述观察，我们提出了一种通用的测试方法——<strong>原始数据库构建（Radar）</strong>，用于检测DBMS中的元数据相关逻辑错误（MRLs）。具体来说，我们首先随机生成一个包含一些元数据的数据库DB，然后构建一个与DB具有相同数据但不包含元数据的原始数据库DB_raw。给定一个查询Q，我们分别在DB和DB_raw上执行，并比较它们返回的查询结果。任何返回查询结果的不一致都表明目标DBMS中存在一个MRL。为了提高测试效率并避免测试具有相似元数据的数据库，我们进一步提出了一种元数据导向的测试优化策略，从而可以继续测试以前未见过元数据的数据库，并快速检测到更多独特的MRLs。</p>
<p><font color="red">Evaluation and contributions</font></p>
<p>为了评估Radar的有效性，我们在五个广泛使用的DBMS上实现并评估了它，分别是MySQL、SQLite、MariaDB、CockroachDB和TiDB。我们总共检测到了42个错误，其中38个被确认是独特的且以前未知的错误，16个错误已被DBMS开发人员修复。实验结果还表明，元数据导向的测试优化策略可以帮助更快地测试具有多样元数据的数据库，并发现更多独特的错误。我们进一步将Radar与四种最先进的DBMS测试方法（DQE、NoREC、TLP和MutaSQL）在错误检测能力上进行了比较。<strong>最多只有13个已确认的MRL可以被这些方法检测到。</strong>DBMS开发人员对我们的方法非常认可，例如，TiDB开发人员希望将Radar集成到他们的内部测试过程中。我们相信，Radar的普遍性可以大大提高DBMS的可靠性。</p>
<p>总结来说，我们的贡献如下：</p>
<ul>
<li>我们提出了Radar，一种通用且有效的测试方法，用于检测DBMS中的元数据相关逻辑错误。我们通过比较包含相同数据但元数据不同的数据库上的查询结果，解决了测试判定问题。</li>
<li>我们提出了一种元数据导向的测试优化策略，以提高Radar的测试效率，能够快速测试具有多样元数据的数据库并发现独特的错误。</li>
<li>我们在五个广泛使用的DBMS上实现并评估了Radar，发现了42个错误，其中38个被确认是独特且新发现的错误。</li>
</ul>
<h2 id="PRELIMINARIES"><a href="#PRELIMINARIES" class="headerlink" title="PRELIMINARIES"></a><strong>PRELIMINARIES</strong></h2><h3 id="2-1-Database-Management-Systems-and-SQL"><a href="#2-1-Database-Management-Systems-and-SQL" class="headerlink" title="2.1 Database Management Systems and SQL"></a><strong>2.1 Database Management Systems and SQL</strong></h3><p>数据库管理系统（DBMSs）为许多关键业务应用提供高效的数据存储和检索。特别是关系型数据库管理系统（如MySQL、PostgreSQL和SQLite）基于关系数据模型，将数据组织成由列和行组成的表。关系型DBMSs是最广泛使用的数据库管理系统之一。</p>
<p>关系型DBMSs通常支持SQL作为其标准查询语言。根据SQL语句的功能，大致可以分为四类：（1）用于创建和修改数据库元数据的语句，如CREATE TABLE、ALTER TABLE和CREATE INDEX；（2）用于检索数据库元数据的语句，如SHOW CREATE TABLE；（3）用于修改数据的语句，如INSERT、UPDATE、DELETE和TRUNCATE；（4）用于检索数据的语句，如SELECT。</p>
<p>在这项工作中，我们选择了五个流行的关系型DBMS（见表1），包括两个传统的DBMS（MySQL和MariaDB），一个嵌入式DBMS（SQLite）和两个NewSQL DBMS（CockroachDB和TiDB）。根据DB-Engines排名，MySQL、MariaDB和SQLite是最受欢迎的DBMS之一。根据GitHub数据库主题的排名，CockroachDB和TiDB是最受欢迎的DBMS之一。</p>
<h3 id="2-2-Database-Metadata"><a href="#2-2-Database-Metadata" class="headerlink" title="2.2 Database Metadata"></a><strong>2.2 Database Metadata</strong></h3><p>数据库管理系统（DBMSs）使用元数据来描述其管理的数据库中的数据组织和结构。数据库由一个或多个表组成，每个表包括表名、一个或多个列、一些可选的表约束和表配置。每列包括列名、数据类型和一些可选的列约束。这些数据库元数据都是用户可配置的，不包括系统级元数据如预写日志（WAL）和Manifest文件。</p>
<p><strong>数据类型定义</strong>了列中可以存储的值的类型，常见的数据类型有INT、VARCHAR、BLOB和BOOLEAN。除了SQLite之外，所有目标DBMSs中的每列都需要有一个数据类型。</p>
<p><strong>列约束</strong>是直接附加到特定列上的完整性约束，用于限制存储在列中的值。目标DBMSs支持三种列约束：NOT NULL、DEFAULT和GENERATED。NOT NULL约束强制列不能存储NULL值。DEFAULT约束指定列的默认值。GENERATED约束通过指定的表达式定义如何自动生成列的值。</p>
<p><strong>表约束</strong>是可以应用于一个或多个列的完整性约束，本文重点讨论四种表约束：</p>
<ul>
<li>PRIMARY KEY约束唯一标识表中的每条记录，必须包含唯一值，通常不能包含NULL值。</li>
<li>UNIQUE约束确保所有值唯一，可以应用于一个或多个列，这些列可以包含NULL值。</li>
<li>CHECK约束通过表达式限制存储在表中的值。</li>
<li>FOREIGN KEY约束定义两个表中列之间的关系。</li>
</ul>
<p><strong>索引是辅助数据结构</strong>，用于优化表中的数据查询。索引可以使用一个或多个列创建，可以声明为唯一索引（UNIQUE INDEX），这同时创建索引并在指定列上应用UNIQUE约束。</p>
<p><strong>表配置</strong>（即，tConfig）用于定制表的性能和存储特性。例如，我们可以使用MySQL中的ENGINE配置来指定表使用的存储引擎。我们可以通过CHARACTER SET和COLLATE配置分别指定字符集和字符集排序规则。我们可以使用TiDB中的PARTITIONING配置在表中物理分配数据。</p>
<img src="/2024/06/26/Detecting-Metadata-Related-Logical-Bugs-in-Database-Systems-via-Raw-Database-Construction/image-20240625143518036.png" alt="image-20240625143518036" style="zoom:67%;">



<h3 id="2-3-Metadata-Related-Query-Optimization"><a href="#2-3-Metadata-Related-Query-Optimization" class="headerlink" title="2.3 Metadata-Related Query Optimization"></a>2.3 Metadata-Related Query Optimization</h3><p>根据数据库元数据如何影响查询Q在数据库上的执行结果，我们将数据库元数据分为两类：强制性数据库元数据和可选数据库元数据。<strong>强制性数据库元数据是指执行查询Q所必需的元数据，包括表名、列名、数据类型和部分表配置（如ENGINE和CHARACTER SET）。可选数据库元数据不能影响查询Q的执行结果，包括列约束、表约束、索引和部分表配置（如PARTITIONING）。</strong></p>
<p>DBMSs利用可选数据库元数据来优化查询评估。例如，对于一个具有NOT NULL约束的列，DBMS可以直接返回一些函数和操作符的评估结果（如IFNULL函数和IS NULL操作符），而不需要在表的每条记录上评估这些函数或操作符。此外，DBMS可以利用索引快速查找满足谓词的记录。例如，哈希索引可以帮助MySQL在这些列上进行高效的相等比较查找。</p>
<h2 id="APPROACH"><a href="#APPROACH" class="headerlink" title="APPROACH"></a>APPROACH</h2><p><img src="/2024/06/26/Detecting-Metadata-Related-Logical-Bugs-in-Database-Systems-via-Raw-Database-Construction/image-20240625143738087.png" alt="image-20240625143738087"></p>
<h3 id="3-1-Architecture"><a href="#3-1-Architecture" class="headerlink" title="3.1 Architecture"></a>3.1 Architecture</h3><p>Radar的架构由五个组件组成：</p>
<ol>
<li><strong>数据库生成组件（①）</strong>：生成有效的数据库。</li>
<li><strong>查询生成组件（④）</strong>：利用生成的数据库生成有效的查询。</li>
<li><strong>原始数据库构建组件（③）</strong>：合成SQL语句以为给定数据库生成原始数据库rawDb。</li>
<li><strong>元数据优化组件（②）</strong>：过滤掉具有相似元数据的数据库，以提高测试效率。</li>
<li><strong>错误识别组件（⑤）</strong>：使用rawDb作为交叉参考，验证查询执行结果以识别元数据错误（metaBugs）。</li>
</ol>
<p>Radar的工作流程如下：</p>
<ol>
<li>随机生成一个包含表t1的数据库db，表t1中有一个带有INT数据类型和NOT NULL约束的列c1。</li>
<li>分析db的元数据，以确定是否需要测试db。如果db的元数据是新的（即以前未测试过），则测试db；否则，重新生成一个新数据库。</li>
<li>对于具有新元数据的有趣数据库db，构建其对应的原始数据库rawDb，去除db中的可选元数据（例如，列c1中的NOT NULL约束）。</li>
<li>生成基于db的随机查询Q。</li>
<li>分别在db和rawDb上执行查询Q，并比较返回的查询结果。</li>
<li>报告任何不一致作为metaBug。</li>
<li>重复测试过程，直到生成可配置数量的查询或耗尽固定时间预算。</li>
</ol>
<p>这个架构确保通过对比优化和非优化查询结果来有效检测DBMS中的元数据错误。</p>
<h3 id="3-2-Database-and-Query-Generation"><a href="#3-2-Database-and-Query-Generation" class="headerlink" title="3.2 Database and Query Generation"></a>3.2 Database and Query Generation</h3><h4 id="Database-Generation"><a href="#Database-Generation" class="headerlink" title="Database Generation"></a>Database Generation</h4><img src="/2024/06/26/Detecting-Metadata-Related-Logical-Bugs-in-Database-Systems-via-Raw-Database-Construction/image-20240625144510557.png" alt="image-20240625144510557" style="zoom:80%;">

<p><strong>算法2</strong>描述了构建<code>CREATE TABLE</code>语句的过程：</p>
<ul>
<li>生成一个随机名称的表（第3行）和随机数量（最多<code>maxColumns</code>个）的列（第5-15行）。</li>
<li>每列具有随机名称（第6行）、随机数据类型（如INT和DOUBLE）（第7行）和一些随机列约束（如NOT NULL、DEFAULT和GENERATED）（第8-13行）。</li>
<li>随机在一些列上添加表约束（如CHECK、PRIMARY KEY和UNIQUE）（第16行），例如<code>PRIMARY KEY (c1)</code>。</li>
<li>如果目标DBMS支持表配置（如MySQL和TiDB），则随机添加一些表配置及其适当的值（第18行），例如<code>ENGINE=InnoDB</code>。</li>
<li>在表生成过程中，记录生成的列和表约束以避免在<code>CREATE TABLE</code>语句中违反语义约束。例如，如果已经生成了一个PRIMARY KEY，则不再生成另一个PRIMARY KEY，因为一个表最多只能有一个PRIMARY KEY。</li>
</ul>
<p>对于生成的表，随机通过执行最多<code>maxIndexes</code>个<code>CREATE INDEX</code>语句来构建一些索引。当生成的数据库包含多个表时，通过执行最多<code>maxForeignKeys</code>个<code>ALTER TABLE</code>语句随机添加外键约束。最后，通过执行最多<code>maxInserts</code>个<code>INSERT</code>语句向每个表填充随机数据。</p>
<p>Radar支持生成包含各种元数据的数据库，包括各种数据类型、列约束、表约束、索引和表配置。用于生成数据库的SQL特性可以是标准的或方言的。</p>
<p>注意：<code>maxTables</code>、<code>maxColumns</code>、<code>maxIndexes</code>、<code>maxInserts</code>和<code>maxForeignKeys</code>都是可配置的。在我们的实验中，分别将它们设置为3、3、30、5和3。图2展示了我们可以生成一个包含表t1、列c1和一个值为0的行的数据库db。列c1具有INT数据类型和NOT NULL约束。</p>
<h4 id="Query-Generation"><a href="#Query-Generation" class="headerlink" title="Query Generation"></a>Query Generation</h4><p><img src="/2024/06/26/Detecting-Metadata-Related-Logical-Bugs-in-Database-Systems-via-Raw-Database-Construction/image-20240625144709578.png" alt="image-20240625144709578"></p>
<p>我们基于SELECT语句的语法和数据库db中的元数据生成查询。生成的查询应能够在生成的数据库db和原始数据库rawDb（第3.3节）上执行，并在这两个数据库上产生确定性的查询结果。</p>
<p>具体步骤如下：</p>
<ol>
<li>随机生成一个select-from-where查询，然后随机生成其他可选子句。</li>
<li>根据生成的数据库元数据，随机生成一个表源。表源可能包含一个表或多个通过连接操作符连接的表，例如<code>t1 JOIN t2</code>（步骤1）。</li>
<li>随机生成基于表源的一些列作为选择字段，例如<code>t1.c1, t2.c2</code>（步骤2）。</li>
<li>随机生成一个基于表源列的表达式以形成谓词，例如<code>t1.c1 &gt; 1 AND t2.c2 &lt; 3</code>（步骤3）。</li>
</ol>
<p>类似地，我们可以生成其他可选子句，例如GROUP BY、ORDER BY和LIMIT，并将这些可选子句附加到生成的select-from-where查询中。</p>
<p>Radar中的查询生成支持SQL标准中几乎所有的关键特性（例如连接、子查询和复杂谓词），以及目标DBMS采用的定制特性（例如MySQL中的high_priority和straight_join）。然而，Radar不能支持一些可能使其无效的功能：</p>
<ol>
<li>Radar不支持包含DEFAULT函数和索引提示的查询。例如，<code>DEFAULT(c1)</code>函数要求列c1具有DEFAULT约束，索引提示<code>@&#123;index_hint = i0&#125;</code>要求存在索引i0。但rawDb不包含DEFAULT约束和索引，因此上述查询不能在rawDb上执行。</li>
<li>Radar不支持返回数据库特定信息的查询，例如返回当前数据库名称的CURRENT_DATABASE函数，在db和rawDb上会返回不同的名称。</li>
<li>Radar不支持包含非确定性函数的查询，例如RAND函数在不同的执行中返回不同的值。</li>
</ol>
<h3 id="3-3-Raw-Database-Construction"><a href="#3-3-Raw-Database-Construction" class="headerlink" title="3.3 Raw Database Construction"></a>3.3 Raw Database Construction</h3><p><img src="/2024/06/26/Detecting-Metadata-Related-Logical-Bugs-in-Database-Systems-via-Raw-Database-Construction/image-20240625144809534.png" alt="image-20240625144809534"></p>
<p>在生成数据库db之后，我们通过清除db中的可选数据库元数据来构建其对应的原始数据库rawDb。本节首先介绍目标DBMS中原始数据库的数据库元数据的正式描述（第3.3.1节），然后解释如何构建给定数据库db的原始数据库rawDb（第3.3.2节）。</p>
<h4 id="3-3-1-Database-Metadata-in-Raw-Database"><a href="#3-3-1-Database-Metadata-in-Raw-Database" class="headerlink" title="3.3.1 Database Metadata in Raw Database"></a>3.3.1 Database Metadata in Raw Database</h4><p>原始数据库只能包含强制性数据库元数据，不能包含任何可选的数据库元数据。图5展示了目标DBMS中原始数据库的元数据的正式描述。原始数据库由一个或多个表组成，每个表包括表名（tName）、一个或多个列，每列包含列名（cName）和数据类型（type）。原始数据库可能包含一些表配置（如MySQL和TiDB中的ENGINE配置），但这些表配置在这些DBMS中是强制性的。</p>
<p><img src="/2024/06/26/Detecting-Metadata-Related-Logical-Bugs-in-Database-Systems-via-Raw-Database-Construction/image-20240626100404897.png" alt="image-20240626100404897"></p>
<h4 id="3-3-2-Constructing-Raw-Databases"><a href="#3-3-2-Constructing-Raw-Databases" class="headerlink" title="3.3.2 Constructing Raw Databases"></a>3.3.2 Constructing Raw Databases</h4><p>对于给定数据库db，我们首先通过执行<code>CREATE DATABASE</code>语句创建一个空数据库作为其对应的原始数据库rawDb。然后，我们从db中获取元数据，并根据图5的描述构建rawDb的元数据，最后创建对应的表并将数据从db复制到rawDb中。</p>
<p><img src="/2024/06/26/Detecting-Metadata-Related-Logical-Bugs-in-Database-Systems-via-Raw-Database-Construction/image-20240626100643240.png" alt="image-20240626100643240"></p>
<p><strong>步骤如下（都是具体实现）：</strong></p>
<p>提取并复制数据到rawDb：</p>
<ul>
<li>根据rawDb中的元数据，首先构建对应的<code>CREATE TABLE</code>语句并在rawDb上执行这些语句。</li>
<li>将db中的表数据复制到rawDb的对应表中。不同DBMS对跨数据库引用的支持不同，我们采用两种解决方案：<ul>
<li>对于支持跨数据库引用的DBMS（如MySQL、MariaDB、CockroachDB和TiDB），直接使用<code>INSERT INTO SELECT</code>语句将数据从db中的表复制到rawDb中的表。</li>
<li>对于不支持跨数据库引用的DBMS（如SQLite），首先将db中的表克隆到rawDb（例如，将表t1克隆为t1new），然后将这些克隆表重命名为rawDb中的对应表。接着，使用<code>INSERT INTO SELECT</code>语句将数据从t1new复制到rawDb中的t1，最后删除克隆表（如t1new）。</li>
</ul>
</li>
</ul>
<h3 id="3-4-metaBug-Identification"><a href="#3-4-metaBug-Identification" class="headerlink" title="3.4 metaBug Identification"></a>3.4 metaBug Identification</h3><p>对于在3.2.2节生成的查询Q，在数据库db及其对应的原始数据库rawDb上执行Q应返回相同的查询结果。</p>
<p>我们应用算法3来识别metaBugs。首先在数据库db和rawDb上执行查询Q，以获取它们的返回结果，包括查询结果Rdb和RrawDb，以及错误消息Edb和ErawDb（第2-3行）。然后分别比较查询结果和错误消息以识别metaBugs。如果db和rawDb返回不同的查询结果或不同的错误消息，则在目标DBMS中揭示出潜在的metaBug（第4-5行）。注意，我们在比较查询结果时忽略结果集中项目的顺序。</p>
<h3 id="3-5-Metadata-Oriented-Testing-Optimization"><a href="#3-5-Metadata-Oriented-Testing-Optimization" class="headerlink" title="3.5 Metadata-Oriented Testing Optimization"></a>3.5 Metadata-Oriented Testing Optimization</h3><p>随机数据库生成（第3.2.1节）可以生成许多具有相同或相似元数据的数据库。在这些相似数据库上进行测试通常会触发重复的metaBugs，难以发现新的metaBugs。为了提高测试效率，避免测试具有相似元数据的数据库，我们识别这些数据库并提高测试效率，快速发现更多的metaBugs。  (类似于去重)</p>
<h4 id="3-5-1-Extracting-Abstract-Database-Metadata"><a href="#3-5-1-Extracting-Abstract-Database-Metadata" class="headerlink" title="3.5.1 Extracting Abstract Database Metadata"></a>3.5.1 Extracting Abstract Database Metadata</h4><p>对于给定的数据库db，我们移除表名和列名等具体信息。从db的元数据中提取列名和列约束（如数据类型、约束类型）。然后，构建抽象元数据。这样可以生成一个没有具体表名和列名的抽象数据库元数据。如果db的抽象元数据没有被测试过，则继续在db上测试。否则，丢弃db并重新生成新数据库。</p>
<h4 id="3-5-2-Choosing-Interesting-Databases"><a href="#3-5-2-Choosing-Interesting-Databases" class="headerlink" title="3.5.2 Choosing Interesting Databases"></a>3.5.2 Choosing Interesting Databases</h4><p>我们维护一个已测试的抽象元数据集。通过比较db的抽象元数据与已记录的抽象元数据，判断是否需要测试。如果抽象元数据没有被测试过，则继续测试db并将其抽象元数据加入已测试集。我们只比较抽象元数据中的相同元素，忽略顺序，因为顺序通常与元数据相关的查询优化无关。</p>
<h2 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h2><p>我们在五个DBMS上实现了Radar，即MySQL、SQLite、MariaDB、CockroachDB和TiDB。Radar主要包括三个部分，即数据库和查询生成、原始数据库构建和元数据导向的测试优化。数据库和查询生成基于<strong>SQLancer</strong>在Java中实现。我们用179行代码实现了原始数据库构建和元数据导向测试优化的通用逻辑。为了测试目标DBMS，我们分别用261、192、161、243和431行代码实现了MySQL、SQLite、MariaDB、CockroachDB和TiDB的特定测试逻辑。</p>
<p>我们通过回答以下三个研究问题来评估Radar的有效性：</p>
<ul>
<li>RQ1. Radar可以在现实世界的DBMS中检测到哪些metaBugs？</li>
<li>RQ2. Radar中元数据导向的测试优化的效果如何？</li>
<li>RQ3. Radar检测到的错误有多少可以被现有方法发现？</li>
</ul>
<h3 id="4-1-Experiment-Setup"><a href="#4-1-Experiment-Setup" class="headerlink" title="4.1 Experiment Setup"></a>4.1 Experiment Setup</h3><p><strong>目标DBMS</strong></p>
<p>我们在五个广泛使用的DBMS上评估Radar。这些DBMS的具体版本如下：</p>
<ul>
<li>MySQL 8.0.32</li>
<li>SQLite 3.41.0</li>
<li>MariaDB 11.0.3</li>
<li>CockroachDB 22.2.5</li>
<li>TiDB 6.6.0</li>
</ul>
<p>当目标DBMS发布新版本时，我们会更新到最新版本并进行测试。</p>
<p><strong>实验基础设施</strong></p>
<p>我们在一台配备8个CPU核心和32GB RAM的机器上执行实验。我们通过Docker容器部署MySQL和MariaDB，通过官方命令行工具<code>tiup playground</code>以分布式方式部署TiDB，嵌入SQLite，并使用CockroachDB的三节点集群。</p>
<p><strong>实验过程</strong></p>
<p>我们在每个目标DBMS上运行Radar 24小时，然后将生成的错误报告提交给DBMS开发人员。在生成错误报告后，我们开始新一轮测试。</p>
<p>对于每个生成的错误报告，我们首先使用SQLancer的语句级别和语法级别减少技术自动简化错误报告。具体步骤如下：</p>
<ol>
<li>简化数据库db和rawDb：通过移除某些语句或替换常量等方法减少语句或表达式。</li>
<li>如果错误仍然存在，则恢复更改并尝试另一种简化方法，直到无法进一步简化。</li>
</ol>
<p>然后，我们根据抽象数据库元数据和SQL特性自动聚类错误报告。如果两个简化错误报告包含相同的抽象数据库元数据和SQL特性，我们认为它们是重复的。最后，我们手动分析聚类后的错误报告并识别独特的错误。</p>
<h3 id="4-2-Bug-Detection-Capability-of-Radar"><a href="#4-2-Bug-Detection-Capability-of-Radar" class="headerlink" title="4.2 Bug Detection Capability of Radar"></a><strong>4.2 Bug Detection Capability of</strong> <strong>Radar</strong></h3><p><img src="/2024/06/26/Detecting-Metadata-Related-Logical-Bugs-in-Database-Systems-via-Raw-Database-Construction/image-20240626102658133.png" alt="image-20240626102658133"></p>
<p>为了评估Radar的有效性并回答RQ1，我们在目标DBMS上运行Radar，调查其是否能在这些DBMS中检测到真实世界的元数据相关逻辑错误（metaBugs）。我们分别在每个目标DBMS上运行Radar，总共运行了24小时。</p>
<p><strong>错误检测结果</strong></p>
<ul>
<li>Radar总共生成了1,663份错误报告。我们按照4.1节中提到的步骤来简化和删除重复的错误报告。筛选出42个独特的错误花费了大约三周时间。</li>
<li>我们将这42个独特错误提交给相应的DBMS开发社区。提交的错误中有4个在MySQL，8个在SQLite，1个在MariaDB，2个在CockroachDB和1个在TiDB。</li>
<li>错误状态：提交的42个错误中，38个已被确认是新错误，16个已被DBMS开发人员修复。剩余的4个metaBugs中，有3个被认为是重复报告，1个被认为是误报。</li>
<li>错误严重性：在确认的38个错误中，有34个被分类为严重（critical），例如MySQL中的2个错误被分类为严重。MariaDB开发人员将1个错误分类为严重。TiDB开发人员将4个错误分类为严重，12个分类为重大，18个分类为中等。</li>
</ul>
<p><strong>metaBug分析</strong></p>
<ul>
<li>30个确认的38个错误是metaBugs：包括MySQL中的3个、SQLite中的12个、MariaDB中的1个、TiDB中的2个。剩余的8个不是metaBugs，因为它们在db和rawDb上的查询结果一致。</li>
<li>23个metaBugs发生在包含可选数据库元数据（如完整性约束和索引）的生成数据库中，这些元数据在rawDb中被禁用。7个metaBugs发生在不包含任何可选元数据的生成数据库中。</li>
</ul>
<p><strong>图表分析</strong></p>
<ul>
<li>表3比较了Radar和Radar_rnd在错误检测方面的表现。Radar在生成数据库、独特数据库和检测到的独特错误方面都表现出色。</li>
<li>表4比较了两者的代码覆盖率。Radar在测试中覆盖了更多的代码路径。</li>
</ul>
<p>这些结果显示了Radar在检测元数据相关逻辑错误方面的高效性和有效性。</p>
<h3 id="4-3-Effectiveness-of-Metadata-Oriented-Testing-Optimization"><a href="#4-3-Effectiveness-of-Metadata-Oriented-Testing-Optimization" class="headerlink" title="4.3 Effectiveness of Metadata-Oriented Testing Optimization"></a>4.3 Effectiveness of Metadata-Oriented Testing Optimization</h3><p>为了回答RQ2，我们在实现Radar之后，移除了元数据导向的测试优化，进行对比实验。</p>
<p><strong>错误检测</strong></p>
<p>我们在MySQL、SQLite、MariaDB、CockroachDB和TiDB上分别运行Radar和Radar_rnd 12小时。实验中，我们统计生成的数据库、总错误和独特错误的数量。如果数据库包含相同的抽象数据库元数据，我们认为生成的数据库是重复的，并使用4.1节中的方法筛选独特错误。</p>
<ul>
<li>Radar能有效消除45.2%、68.8%、49.6%、37.1%和39.1%的重复数据库。</li>
<li>Radar比Radar_rnd生成更多独特数据库，分别多11.2%、44.6%、40.7%、6.1%和13.7%。</li>
<li>Radar检测到比Radar_rnd多7个独特错误，分别多8个独特错误。</li>
</ul>
<p>我们的实验结果表明，元数据导向的测试优化策略有助于在更少的时间内检测到更多的metaBugs。</p>
<p><strong>代码覆盖率</strong></p>
<p>我们分析了MySQL和MariaDB在12小时测试中的代码覆盖率，包括函数覆盖率和行覆盖率。</p>
<ul>
<li>Radar在MySQL中的函数覆盖率为20.3%，行覆盖率为17.6%；在MariaDB中的函数覆盖率为19.7%，行覆盖率为17.0%。</li>
<li>Radar_rnd在MySQL中的函数覆盖率为19.7%，行覆盖率为17.4%；在MariaDB中的函数覆盖率为19.3%，行覆盖率为16.9%。</li>
</ul>
<p>虽然代码覆盖率略低，但这些覆盖率主要关注验证查询引擎的正确性，特别是元数据相关的查询优化。Radar能够覆盖目标DBMS中更广泛的功能和代码行。</p>
<p><img src="/2024/06/26/Detecting-Metadata-Related-Logical-Bugs-in-Database-Systems-via-Raw-Database-Construction/image-20240626102330884.png" alt="image-20240626102330884"></p>
<p><img src="/2024/06/26/Detecting-Metadata-Related-Logical-Bugs-in-Database-Systems-via-Raw-Database-Construction/image-20240626102434624.png" alt="image-20240626102434624"></p>
<h3 id="4-4-Comparing-with-Existing-Approaches"><a href="#4-4-Comparing-with-Existing-Approaches" class="headerlink" title="4.4 Comparing with Existing Approaches"></a>4.4 Comparing with Existing Approaches</h3><p>为了回答RQ3，我们将Radar与四种最先进的DBMS逻辑错误检测方法（DQE、NoREC、TLP和MutaSQL）进行比较。这些方法都采用随机策略测试DBMS，包括随机数据库生成和查询生成。我们首先调查Radar检测到的30个确认metaBugs是否可以被这些方法检测到，然后在目标DBMS上应用Radar和现有方法，比较其错误检测结果。</p>
<p>现有方法在概念上最多可以检测到我们确认的30个metaBugs中的13个。具体比较如下：</p>
<ul>
<li><strong>DQE</strong>：通过识别执行结果中的不一致来检测错误。由于构建了UPDATE和DELETE语句，DQE可以检测到8个metaBugs。</li>
<li><strong>NoREC</strong>：将<strong>优化后的查询转换为非优化查询</strong>，并比较执行结果。NoREC可以检测到13个metaBugs。</li>
<li><strong>TLP</strong>：通过将查询分解为三个子查询并比较结果来检测错误。TLP可以检测到3个metaBugs。</li>
<li><strong>MutaSQL</strong>：通过<strong>添加索引</strong>并观察查询结果变化来检测错误。MutaSQL可以检测到5个metaBugs。</li>
</ul>
<p><strong>实验比较</strong></p>
<p>我们应用DQE、NoREC、TLP和Radar在目标DBMS上分别运行12小时，使用相同的方法去重错误报告和识别独特错误。表6显示了实验结果：</p>
<ul>
<li>所有方法共检测到33个错误，其中21个是Radar在4.2节中检测到的metaBugs。</li>
<li>剩余的12个错误是其他类型的错误（如UPDATE或DELETE语句中的逻辑错误和错误）。</li>
<li>Radar检测到了21个metaBugs中的20个，其中15个metaBugs仅被Radar检测到。</li>
<li>替代方法检测到21个metaBugs中的6个。</li>
<li>唯一一个Radar未检测到的metaBug，是因为Radar未生成相应的测试用例来随机数据库和查询生成。</li>
</ul>
<p>metaBugs是由于数据库元数据相关的错误优化而引入的。尽管现有方法可以有效检测其他类型的逻辑错误，但不能有效检测metaBugs。</p>
<h3 id="4-5-Other-Experimental-Statistics"><a href="#4-5-Other-Experimental-Statistics" class="headerlink" title="4.5 Other Experimental Statistics"></a><strong>4.5 Other Experimental Statistics</strong></h3><p><strong>查询测试效率</strong></p>
<p>我们通过在目标DBMS上分别运行Radar 12小时，并统计测试的查询数量来衡量查询测试效率。在此实验中，Radar在MySQL、SQLite、MariaDB、CockroachDB和TiDB上每秒分别测试了118、4、795、948、132和280个查询。</p>
<p><strong>原始数据库构建的开销</strong></p>
<p>我们通过在目标DBMS上分别运行Radar 12小时来衡量原始数据库构建的开销。在此实验中，Radar平均花费95ms、33ms、34ms、2ms、645ms和877ms来构建MySQL、SQLite、MariaDB、CockroachDB和TiDB的原始数据库。</p>
<h3 id="4-6-Representative-Bugs"><a href="#4-6-Representative-Bugs" class="headerlink" title="4.6 Representative Bugs"></a><strong>4.6 Representative Bugs</strong></h3><p><img src="/2024/06/26/Detecting-Metadata-Related-Logical-Bugs-in-Database-Systems-via-Raw-Database-Construction/image-20240626103947549.png" alt="image-20240626103947549"></p>
<p><img src="/2024/06/26/Detecting-Metadata-Related-Logical-Bugs-in-Database-Systems-via-Raw-Database-Construction/image-20240626103958872.png" alt="image-20240626103958872"></p>
<p><img src="/2024/06/26/Detecting-Metadata-Related-Logical-Bugs-in-Database-Systems-via-Raw-Database-Construction/image-20240626104007038.png" alt="image-20240626104007038"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Lin Li</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/06/26/Detecting-Metadata-Related-Logical-Bugs-in-Database-Systems-via-Raw-Database-Construction/">http://example.com/2024/06/26/Detecting-Metadata-Related-Logical-Bugs-in-Database-Systems-via-Raw-Database-Construction/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">LinLi's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/">论文阅读</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/06/27/Testing-Database-Engines-via-Query-Plan-Guidance/" title="Testing Database Engines via Query Plan Guidance"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Testing Database Engines via Query Plan Guidance</div></div></a></div><div class="next-post pull-right"><a href="/2024/06/21/Fuzz4All-Universal-Fuzzing-with-Large-Language-Models/" title="Fuzz4All Universal Fuzzing with Large Language Models"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Fuzz4All Universal Fuzzing with Large Language Models</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/03/04/PLUMBER/" title="PLUMBER"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-04</div><div class="title">PLUMBER</div></div></a></div><div><a href="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/" title="通过NPM生态系统的依赖树揭开脆弱性传播及其演化的神秘面纱"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-08</div><div class="title">通过NPM生态系统的依赖树揭开脆弱性传播及其演化的神秘面纱</div></div></a></div><div><a href="/2023/04/03/Flexible-and-Optimal-Dependency-Management-via-Max-SMT/" title="Flexible and Optimal Dependency Management via Max-SMT"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-03</div><div class="title">Flexible and Optimal Dependency Management via Max-SMT</div></div></a></div><div><a href="/2023/04/11/What-the-Fork-Finding-Hidden-Code-Clones-in-npm/" title="What the Fork Finding Hidden Code Clones in npm"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-11</div><div class="title">What the Fork Finding Hidden Code Clones in npm</div></div></a></div><div><a href="/2023/04/12/Static-Type-Inference-for-Foreign-Functions-of-Python/" title="Static Type Inference for Foreign Functions of Python"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-12</div><div class="title">Static Type Inference for Foreign Functions of Python</div></div></a></div><div><a href="/2023/04/13/Where-to-Start-Studying-Type-Annotation-Practices-in-Python/" title="Where to Start Studying Type Annotation Practices in Python"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-13</div><div class="title">Where to Start Studying Type Annotation Practices in Python</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Lin Li</div><div class="author-info__description">今日事，今日毕</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">122</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Detecting-Metadata-Related-Logical-Bugs-in-Database-Systems-via-Raw-Database-Construction"><span class="toc-number">1.</span> <span class="toc-text">Detecting Metadata-Related Logical Bugs in Database Systems via Raw Database Construction</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ABSTRACT"><span class="toc-number">1.1.</span> <span class="toc-text">ABSTRACT:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#INTRODUCTION"><span class="toc-number">1.2.</span> <span class="toc-text">INTRODUCTION:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PRELIMINARIES"><span class="toc-number">1.3.</span> <span class="toc-text">PRELIMINARIES</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-Database-Management-Systems-and-SQL"><span class="toc-number">1.3.1.</span> <span class="toc-text">2.1 Database Management Systems and SQL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-Database-Metadata"><span class="toc-number">1.3.2.</span> <span class="toc-text">2.2 Database Metadata</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-Metadata-Related-Query-Optimization"><span class="toc-number">1.3.3.</span> <span class="toc-text">2.3 Metadata-Related Query Optimization</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#APPROACH"><span class="toc-number">1.4.</span> <span class="toc-text">APPROACH</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-Architecture"><span class="toc-number">1.4.1.</span> <span class="toc-text">3.1 Architecture</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-Database-and-Query-Generation"><span class="toc-number">1.4.2.</span> <span class="toc-text">3.2 Database and Query Generation</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Database-Generation"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">Database Generation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Query-Generation"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">Query Generation</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-Raw-Database-Construction"><span class="toc-number">1.4.3.</span> <span class="toc-text">3.3 Raw Database Construction</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1-Database-Metadata-in-Raw-Database"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">3.3.1 Database Metadata in Raw Database</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-Constructing-Raw-Databases"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">3.3.2 Constructing Raw Databases</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-metaBug-Identification"><span class="toc-number">1.4.4.</span> <span class="toc-text">3.4 metaBug Identification</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-Metadata-Oriented-Testing-Optimization"><span class="toc-number">1.4.5.</span> <span class="toc-text">3.5 Metadata-Oriented Testing Optimization</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-1-Extracting-Abstract-Database-Metadata"><span class="toc-number">1.4.5.1.</span> <span class="toc-text">3.5.1 Extracting Abstract Database Metadata</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-2-Choosing-Interesting-Databases"><span class="toc-number">1.4.5.2.</span> <span class="toc-text">3.5.2 Choosing Interesting Databases</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Evaluation"><span class="toc-number">1.5.</span> <span class="toc-text">Evaluation</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-Experiment-Setup"><span class="toc-number">1.5.1.</span> <span class="toc-text">4.1 Experiment Setup</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-Bug-Detection-Capability-of-Radar"><span class="toc-number">1.5.2.</span> <span class="toc-text">4.2 Bug Detection Capability of Radar</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-Effectiveness-of-Metadata-Oriented-Testing-Optimization"><span class="toc-number">1.5.3.</span> <span class="toc-text">4.3 Effectiveness of Metadata-Oriented Testing Optimization</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-Comparing-with-Existing-Approaches"><span class="toc-number">1.5.4.</span> <span class="toc-text">4.4 Comparing with Existing Approaches</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-Other-Experimental-Statistics"><span class="toc-number">1.5.5.</span> <span class="toc-text">4.5 Other Experimental Statistics</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-Representative-Bugs"><span class="toc-number">1.5.6.</span> <span class="toc-text">4.6 Representative Bugs</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/08/%E8%A7%A3%E5%86%B3Camera-ready-%E2%9C%98-Problem-Not-all-fonts-are-embedded-%E9%97%AE%E9%A2%98/" title="解决Camera ready ✘ Problem: Not all fonts are embedded. 问题">解决Camera ready ✘ Problem: Not all fonts are embedded. 问题</a><time datetime="2025-04-08T14:19:21.000Z" title="发表于 2025-04-08 22:19:21">2025-04-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/21/Sequence-Oriented-DBMS-Fuzzing/" title="Sequence-Oriented DBMS Fuzzing">Sequence-Oriented DBMS Fuzzing</a><time datetime="2025-02-21T09:35:08.000Z" title="发表于 2025-02-21 17:35:08">2025-02-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/18/AGENTLESS-Demystifying-LLM-based-Software-Engineering-Agents/" title="AGENTLESS: Demystifying LLM-based Software Engineering Agents">AGENTLESS: Demystifying LLM-based Software Engineering Agents</a><time datetime="2025-02-18T12:16:29.000Z" title="发表于 2025-02-18 20:16:29">2025-02-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/01/DeepSeek-R1-Incentivizing-Reasoning-Capability-in-LLMs-via-Reinforcement-Learning/" title="DeepSeek-R1: Incentivizing Reasoning Capability in LLMs via Reinforcement Learning">DeepSeek-R1: Incentivizing Reasoning Capability in LLMs via Reinforcement Learning</a><time datetime="2025-02-01T11:11:48.000Z" title="发表于 2025-02-01 19:11:48">2025-02-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/01/DeepSeek-Coder-When-the-Large-Language-Model-Meets-Programming-The-Rise-of-Code-Intelligence/" title="DeepSeek-Coder: When the Large Language Model Meets Programming - The Rise of Code Intelligence">DeepSeek-Coder: When the Large Language Model Meets Programming - The Rise of Code Intelligence</a><time datetime="2025-02-01T02:43:19.000Z" title="发表于 2025-02-01 10:43:19">2025-02-01</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Lin Li</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>