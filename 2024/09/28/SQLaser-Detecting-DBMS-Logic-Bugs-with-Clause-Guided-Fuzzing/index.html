<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>SQLaser: Detecting DBMS Logic Bugs with Clause-Guided Fuzzing | LinLi's Blog</title><meta name="author" content="Lin Li"><meta name="copyright" content="Lin Li"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="SQLaser: Detecting DBMS Logic Bugs with Clause-Guided Fuzzing这篇文章是arXiv 24上的，存在许多问题，不值得学习。。。 ABSTRACT数据库管理系统（DBMS）是现代数据驱动系统中的重要组成部分。由于其复杂性，这些系统中往往会出现逻辑错误，这些错误是DBMS内部的实现错误，可能导致错误的查询结果、数据泄露、未经授权的访问等问题，而">
<meta property="og:type" content="article">
<meta property="og:title" content="SQLaser: Detecting DBMS Logic Bugs with Clause-Guided Fuzzing">
<meta property="og:url" content="http://example.com/2024/09/28/SQLaser-Detecting-DBMS-Logic-Bugs-with-Clause-Guided-Fuzzing/index.html">
<meta property="og:site_name" content="LinLi&#39;s Blog">
<meta property="og:description" content="SQLaser: Detecting DBMS Logic Bugs with Clause-Guided Fuzzing这篇文章是arXiv 24上的，存在许多问题，不值得学习。。。 ABSTRACT数据库管理系统（DBMS）是现代数据驱动系统中的重要组成部分。由于其复杂性，这些系统中往往会出现逻辑错误，这些错误是DBMS内部的实现错误，可能导致错误的查询结果、数据泄露、未经授权的访问等问题，而">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2024-09-28T08:37:40.000Z">
<meta property="article:modified_time" content="2024-09-28T08:38:41.125Z">
<meta property="article:author" content="Lin Li">
<meta property="article:tag" content="论文阅读">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/09/28/SQLaser-Detecting-DBMS-Logic-Bugs-with-Clause-Guided-Fuzzing/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'SQLaser: Detecting DBMS Logic Bugs with Clause-Guided Fuzzing',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-09-28 16:38:41'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">122</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="LinLi's Blog"><span class="site-name">LinLi's Blog</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">SQLaser: Detecting DBMS Logic Bugs with Clause-Guided Fuzzing</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-09-28T08:37:40.000Z" title="发表于 2024-09-28 16:37:40">2024-09-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-09-28T08:38:41.125Z" title="更新于 2024-09-28 16:38:41">2024-09-28</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="SQLaser: Detecting DBMS Logic Bugs with Clause-Guided Fuzzing"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="SQLaser-Detecting-DBMS-Logic-Bugs-with-Clause-Guided-Fuzzing"><a href="#SQLaser-Detecting-DBMS-Logic-Bugs-with-Clause-Guided-Fuzzing" class="headerlink" title="SQLaser: Detecting DBMS Logic Bugs with Clause-Guided Fuzzing"></a>SQLaser: Detecting DBMS Logic Bugs with Clause-Guided Fuzzing</h1><p>这篇文章是arXiv 24上的，存在许多问题，不值得学习。。。</p>
<h2 id="ABSTRACT"><a href="#ABSTRACT" class="headerlink" title="ABSTRACT"></a>ABSTRACT</h2><p>数据库管理系统（DBMS）是现代数据驱动系统中的重要组成部分。由于其复杂性，这些系统中往往会出现逻辑错误，这些错误是DBMS内部的实现错误，可能导致错误的查询结果、数据泄露、未经授权的访问等问题，而这些错误并不一定会引起系统的明显故障。现有的检测方法主要采用两种策略：基于<strong>规则的错误检测</strong>和<strong>基于覆盖率的模糊测试</strong>。然而，规则的指定本身就是一个挑战，因此基于规则的检测通常仅限于特定和简单的规则。基于覆盖率的模糊测试则是盲目地探索代码路径或代码块，其中许多路径不太可能包含逻辑错误，因此这种策略的成本效益较低。</p>
<p>在本文中，我们设计了SQLaser，一种基于SQL子句引导的模糊测试工具，用于检测DBMS中的逻辑错误。通过对现有大多数逻辑错误的全面研究（不包括导致系统崩溃的错误），我们识别了35种逻辑错误模式。这些模式表现为某些常见的SQL子句组合，而这些<strong>子句组合背后是一系列函数的组合</strong>。因此，我们将逻辑错误模式建模为容易出错的函数链（即一系列函数的组合）。我们进一步开发了一种新的路径到路径距离计算机制，以有效地测试这些链条并发现其他逻辑错误。该机制使SQLaser能够迅速导航到目标站点并揭示从这些路径中出现的潜在错误。</p>
<p>我们的评估是在SQLite、MySQL、PostgreSQL和TiDB上进行的，结果表明，与其他模糊测试方法相比，SQLaser显著加快了错误发现的速度，将检测时间减少了约60%。作为一个独立的测试工具，SQLaser在相同的测试期间（即60天）内发现了22个错误，涵盖了35种逻辑错误模式中的18种，而像SQLRight这样的模糊测试工具在相同的测试期间内只发现了2个错误。此外，SQLaser发现的4个错误是零日漏洞，所有这些错误已向厂商报告并得到确认。</p>
<p>关键词：数据库管理系统、逻辑错误检测、定向模糊测试。</p>
<p><font color="green">子句组合背后是一系列函数的组合，验证了我们的motivation</font></p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a><strong>Introduction</strong></h2><p><font color="red">related work：</font></p>
<p>数据库管理系统（DBMS）作为现代数据驱动应用的核心组件，广泛用于数据的集中存储和管理。例如，SQLite在全球约35亿部智能手机上被使用。由于DBMS在现代应用中扮演着至关重要的角色，其内部的逻辑错误可能会导致严重后果。这些逻辑错误通常是由DBMS代码实现中的错误引起的，可能导致一系列问题，如错误的查询结果、敏感数据泄露、未经授权的访问和数据损坏。</p>
<p><strong>逻辑错误的检测挑战</strong>：</p>
<ul>
<li>大多数逻辑错误不会导致系统崩溃，因此很难被检测到。</li>
<li>研究人员提出了多种Oracle机制来检测SQL查询结果的错误，例如：<ul>
<li><strong>NoREC Oracle</strong>：将原始SQL查询转换为一个等效形式，如果两者结果有差异，则可能存在逻辑错误。</li>
<li><strong>TLP Oracle</strong>：通过组合多个子查询来实现原始查询的语义，如果结果不同，则表明可能存在错误。</li>
</ul>
</li>
</ul>
<p><strong>现有工具的局限性</strong>：</p>
<ul>
<li><strong>SQLancer</strong>：实现了多种Oracle机制，但由于其基于特定规则生成SQL查询，可能限制了代码路径的探索。</li>
<li><strong>SQLRight</strong>：为了解决SQLancer的局限性，引入了基于覆盖率引导的模糊测试，通过有效性导向的变异生成高质量查询语句，增加代码覆盖率，从而更高效地发现更多的逻辑错误</li>
</ul>
<p>总结来说，现有的研究针对DBMS中的逻辑错误提出了多种检测方法，包括<strong>差分测试</strong>和基于<strong>覆盖率的模糊测试</strong>，但这些方法在探索范围和效率上各有优劣</p>
<p><font color="green">总结的不太对，差分测试的思想是变换不同组件，SQLancer等应该是蜕变测试。而且SQLRight也实现几种test oracle？侧重的点不同而已</font></p>
<p><font color="red">limitations</font></p>
<ol>
<li><strong>motivation example未考虑多种SQL子句组合的效果</strong>：<ul>
<li>尽管已有很多工作致力于检测DBMS中的逻辑错误，但现有研究往往忽视了逻辑错误模式背后多种SQL子句组合的综合影响。文章中提到的示例显示，在SQLite中，由于错误地应用了NOCASE操作，导致条件表达式的错误结果，这表明逻辑错误的产生往往是多种子句和函数交互的结果。</li>
<li><img src="/2024/09/28/SQLaser-Detecting-DBMS-Logic-Bugs-with-Clause-Guided-Fuzzing/image-20240928152341100.png" alt="image-20240928152341100"></li>
</ul>
</li>
<li><strong>SQLRight的不足</strong>：<ul>
<li>SQLRight在选择测试用例（种子）时，假设每个种子触发逻辑错误的可能性相同。这种覆盖率引导的模糊测试方法未能有效地优先测试更可能触发逻辑错误的代码路径，导致探索的代码路径中很多部分是无效的，从而降低了检测效率。 <font color="green">我不太赞同这个说法，覆盖率就是Fuzzing的最终目的</font></li>
</ul>
</li>
<li><strong>针对性不足</strong>：<ul>
<li>基于覆盖率的模糊测试方法主要关注尽可能多地覆盖代码路径，而不是有针对性地快速到达和测试预定义的目标站点（即可能存在逻辑错误的地方）。这种策略在发现逻辑错误方面效率较低，因为它忽略了特定SQL子句组合所对应的易出错的代码目标。</li>
</ul>
</li>
<li><strong>三大关键问题</strong>：<ul>
<li>如何识别SQL层面的错误模式？</li>
<li>如何将这些SQL层面的错误模式作为定向模糊测试的目标站点？</li>
<li>如何设计一个定向模糊测试工具，能够快速到达和测试预定义的目标站点？这些问题在现有的方法中尚未得到有效解决。</li>
</ul>
</li>
</ol>
<p>总结：现有方法在覆盖率引导模糊测试中往往缺乏针对性和效率，难以识别和优先测试特定的SQL逻辑错误模式。因此，本文提出了基于SQL子句组合引导的定向模糊测试，以更高效地检测数据库管理系统中的逻辑错误。</p>
<p><font color="red">approaches</font></p>
<p><strong>问题 1：系统性研究现有逻辑错误</strong>：</p>
<ul>
<li>文章首次系统性地研究了四个不同DBMS（SQLite、MySQL、PostgreSQL和TiDB）中大部分已知的逻辑错误（不包括导致系统崩溃的错误）。研究发现某些SQL子句或子句组合（如表元素&#x2F;模式、数据处理函数、条件表达式、特殊关键字、查询优化函数等）容易导致逻辑错误。作者总结了35种与现有逻辑错误相关的SQL子句组合模式。</li>
</ul>
<p><strong>问题 2：动态追踪和分析代码路径</strong>：</p>
<ul>
<li>通过动态分析，作者发现执行SQL语句导致逻辑错误时，通常涉及一系列函数调用链。为了在定向模糊测试中使用这些函数调用链作为目标站点，作者提出了一种方法来“修剪”函数调用链，去除与SQL逻辑错误模式无关的函数。这样可以有效聚焦在真正的错误点上，避免由于调用链过长而导致的检测效率低下。  <font color="green">SQL精简？</font></li>
</ul>
<p><strong>问题 3：提出SQLaser工具</strong>：</p>
<ul>
<li>为了解决上述问题，作者提出了SQLaser，这是一种基于子句引导的模型，用于检测DBMS中的逻辑错误。SQLaser引入了一种新的方法来计算种子和目标站点之间的距离，并利用基于区分度的策略来优先选择更接近目标调用链的种子。最终，SQLaser利用SQLRight的测试Oracle，通过生成原始查询的变体并评估其执行结果来有效地检测逻辑错误，同时确保查询功能的完整性。</li>
</ul>
<p><font color="red">Evaluation</font></p>
<ol>
<li><strong>覆盖DBMS范围广泛</strong>：<ul>
<li>SQLaser在四个主流DBMS系统（SQLite、MySQL、PostgreSQL和TiDB）上进行了评估。结果显示，SQLaser可以重现所有35种已知的逻辑错误模式（即SQL子句组合），这些错误模式是从现有工具的集体发现中总结出来的。</li>
</ul>
</li>
<li><strong>发现新的逻辑错误</strong>：<ul>
<li>SQLaser成功发现了35种错误模式中的22个逻辑错误。其中，4个是其他模糊测试工具无法检测到的新型错误，这些错误已经全部报告给供应商并得到确认。</li>
</ul>
</li>
<li><strong>效率显著提升</strong>：<ul>
<li>相比SQLRight和传统的定向模糊测试方法，SQLaser的检测效率提高了约60%。它能够更快地到达目标站点，并有效地验证是否存在逻辑错误。</li>
</ul>
</li>
</ol>
<p><font color="red">contributions</font></p>
<ol>
<li><strong>系统性研究</strong>：<ul>
<li>首次系统性地研究了DBMS中的大多数逻辑错误，揭示了这些错误源自于特定SQL子句组合，以及背后的一系列关键函数。基于此发现，提出了子句引导的模糊测试（clause-guided fuzzing），能够聚焦于容易出错的函数链，从而高效地发现逻辑错误。</li>
</ul>
</li>
<li><strong>新的模糊测试反馈机制</strong>：<ul>
<li>提出了一种新的模糊测试反馈机制，可以计算种子调用链与目标调用链之间的距离。这种路径到路径的距离计算不同于传统的单点距离计算，支持基于路径的定向模糊测试，使得SQLaser能够优先选择更接近目标路径的种子。</li>
</ul>
</li>
<li><strong>开发SQLaser工具</strong>：<ul>
<li>提出了SQLaser工具，利用定向模糊测试高效地导航到目标站点，并自动生成输入查询以验证是否能触发逻辑错误。通过实验验证了SQLaser的有效性和性能。相比于基于覆盖率引导的模糊测试和传统的定向模糊测试方法，SQLaser在效率上提升了约60%。</li>
</ul>
</li>
</ol>
<p>总结：SQLaser不仅能够重现现有的已知逻辑错误模式，还能够发现新的逻辑错误，并显著提高了逻辑错误检测的效率。</p>
<h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a><strong>Background</strong></h2><h3 id="2-1-Logic-Bugs-and-Threat-Model"><a href="#2-1-Logic-Bugs-and-Threat-Model" class="headerlink" title="2.1. Logic Bugs and Threat Model"></a><em>2.1. Logic Bugs and Threat Model</em></h3><p>一个logical bug 的 example。 SQLaser工具发现了一些新的逻辑错误，例如MySQL中的ANY逻辑错误和LIKE逻辑错误，这些错误可能会导致DBMS泄露不应暴露给用户的数据。对于DBMS安全或特权信息而言，这些逻辑错误会带来显著的安全风险。</p>
<h3 id="2-2-Logic-Bug-Testing-Oracles-and-Differential-Testing"><a href="#2-2-Logic-Bug-Testing-Oracles-and-Differential-Testing" class="headerlink" title="2.2. Logic Bug Testing Oracles and Differential Testing"></a><em>2.2. Logic Bug Testing Oracles and Differential Testing</em></h3><p>差分测试和各种Oracle机制提供了检测DBMS逻辑错误的有效手段，但构建覆盖所有逻辑错误的Oracle具有挑战性。每种Oracle方法都有其适用场景和局限性，需要针对特定DBMS功能特点进行设计。</p>
<h3 id="2-3-Coverage-guided-Fuzzing-and-Directed-Fuzzing"><a href="#2-3-Coverage-guided-Fuzzing-and-Directed-Fuzzing" class="headerlink" title="2.3. Coverage-guided Fuzzing and Directed Fuzzing"></a><em>2.3. Coverage-guided Fuzzing and Directed Fuzzing</em></h3><p><strong>基于覆盖率的模糊测试（Coverage-guided Fuzzing）</strong>：</p>
<ul>
<li>这是一种软件测试技术，涉及向程序提供无效、意外或随机的数据输入，并观察程序如何响应这些输入，以发现漏洞或错误。</li>
<li>其核心思想是测量当前输入集所实现的代码覆盖率，并利用这些信息生成新的测试输入，从而探索新的或未覆盖的代码路径。此方法旨在最大化程序代码的探索，增加发现隐藏漏洞的机会。</li>
<li>基于覆盖率的模糊测试已被应用于多种程序测试，包括操作系统、编译器、网页浏览器、文档阅读器和智能合约等。最近的研究也将其用于测试DBMS系统，如SQLRight通过这种方法在SQLite和MySQL中发现逻辑错误。</li>
</ul>
<p><strong>定向模糊测试（Directed Fuzzing）</strong>：</p>
<ul>
<li>定向模糊测试则是提供有针对性的特定输入，以探索特定的代码路径或功能。与依赖随机或变异输入的基于覆盖率的模糊测试不同，定向模糊测试更加集中和有目的性。</li>
<li>这种方法通常用于已经知道潜在漏洞位置或测试特定程序功能时。例如，在本文中，定向模糊测试被用于故意检测逻辑错误，而不是随机测试代码路径。研究人员将大部分时间分配给这些高度可能触发逻辑错误的路径，以提高发现错误的效率。</li>
</ul>
<p>总结：基于覆盖率的模糊测试侧重于代码路径的广泛覆盖，通过随机或变异输入来发现潜在的漏洞；而定向模糊测试则更关注已知问题区域或特定代码路径，以更加精确、高效地检测逻辑错误。两者在不同场景中各有优势，并可以互补使用。</p>
<h2 id="Analysis-of-Existing-Logic-Bug-Patterns"><a href="#Analysis-of-Existing-Logic-Bug-Patterns" class="headerlink" title="Analysis of Existing Logic Bug Patterns"></a><strong>Analysis of Existing Logic Bug Patterns</strong></h2><p><strong>研究范围</strong>：</p>
<ul>
<li>本研究对四个不同数据库管理系统（DBMS）中的144个现有逻辑错误进行了系统性研究，包括SQLite（102个错误）、MySQL（15个错误）、PostgreSQL（1个错误）和TiDB（26个错误）。研究排除了导致系统崩溃的错误，主要关注那些不会导致可观测系统故障（如崩溃）的逻辑错误。</li>
</ul>
<p><font color="green">144个太少了，分类的意义在哪里？</font></p>
<p><strong>SQL子句分类</strong>：</p>
<ul>
<li>根据SQL子句的语义，将与这些逻辑错误相关的子句分为五类：<ol>
<li><strong>表元素&#x2F;模式（Table Element&#x2F;Schema）</strong>：涉及已创建表中的元素或模式，例如列索引、列值和主键。</li>
<li><strong>数据处理函数（Data Processing Functions）</strong>：涉及数据处理函数，例如将数据类型转换为兼容的另一种数据类型的<code>CAST</code>函数，或将数值进行四舍五入的<code>ROUND</code>函数。</li>
<li><strong>条件表达式（Conditional Expressions）</strong>：用于条件检查的表达式，例如<code>EXISTS</code>、<code>INSERT OR FAIL</code>等，确保数据完整性，防止插入无效或重复的记录。</li>
<li><strong>特殊关键字（Special Keywords）</strong>：用于设置约束或定义虚拟表等特定结构的特殊关键字，例如<code>WITHOUT ROWID</code>、<code>NOCASE</code>、<code>DISTINCT</code>等。</li>
<li><strong>查询优化函数（Query Optimization Functions）</strong>：用于进一步优化和控制查询执行的函数，例如LIKELY 函数表示某个条件可能发生，函数表示某个条件可能发生，而<code>UNLIKELY</code>表示某个条件不太可能发生</li>
</ol>
</li>
</ul>
<p><strong>错误模式分类</strong>：</p>
<ul>
<li>基于这些SQL子句的分类，研究将现有逻辑错误划分为35种错误模式。其中，SQLite中有17种模式，MySQL中有10种，PostgreSQL中有1种，TiDB中有7种。</li>
</ul>
<p><img src="/2024/09/28/SQLaser-Detecting-DBMS-Logic-Bugs-with-Clause-Guided-Fuzzing/image-20240928154749083.png" alt="image-20240928154749083"></p>
<p><img src="/2024/09/28/SQLaser-Detecting-DBMS-Logic-Bugs-with-Clause-Guided-Fuzzing/image-20240928154802092.png" alt="image-20240928154802092"></p>
<h2 id="SQLaser"><a href="#SQLaser" class="headerlink" title="SQLaser"></a><strong>SQLaser</strong></h2><h3 id="overview"><a href="#overview" class="headerlink" title="overview"></a>overview</h3><p><img src="/2024/09/28/SQLaser-Detecting-DBMS-Logic-Bugs-with-Clause-Guided-Fuzzing/image-20240928154847229.png" alt="image-20240928154847229"></p>
<p>SQLaser工具的概览由两个主要部分组成：逻辑错误模式建模和子句引导模糊测试。</p>
<ol>
<li><strong>逻辑错误模式建模（Logic-bug Pattern Modeling）</strong>：<ul>
<li>在这一阶段，SQLaser的目标是将逻辑错误模式的信息作为调用链（call chains）插入到二进制代码中。这些调用链在模糊测试阶段表现为目标调用链。</li>
<li>首先，通过动态分析（Step ❶），SQLaser获取在错误发生时执行的完整调用链。然而，完整的调用链中包含许多与错误无关的函数，过多的函数会限制模糊测试的探索能力。</li>
<li>为了解决这个问题，SQLaser通过手动分析确定代表错误模式属性的数据对象（称为子句相关数据，Step ❷），然后利用自动静态分析工具，跟踪子句相关数据，从完整调用链中提取出部分调用链（Step ❸）。这些修剪后的调用链将作为目标调用链被插入到二进制代码中，用于后续模糊测试。</li>
</ul>
</li>
<li><strong>子句引导模糊测试（Clause-guided Fuzzing）</strong>：<ul>
<li>在这一阶段，SQLaser通过计算种子调用链与目标调用链之间的距离（Step ❹）来确定种子的“能量值”（energy），根据该距离优先选择需要变异的种子（Step ❺）。</li>
<li>变异种子后，SQLaser执行这些种子并通过测试Oracle分析结果，以确定是否触发了任何逻辑错误（Step ❻）。最终，触发错误的变异种子会被保留并加入到种子队列中，供后续执行。</li>
</ul>
</li>
</ol>
<p>整个过程包括：</p>
<ul>
<li><strong>步骤 1-3</strong>：通过动态和静态分析获取并修剪调用链，将其插入到二进制代码中。</li>
<li><strong>步骤 4-6</strong>：计算种子和目标调用链之间的距离，基于距离优先选择种子进行变异，并利用测试Oracle分析结果。</li>
</ul>
<p>该过程中的各个步骤将在后续章节中详细说明，包括4.1节中关于调用链距离计算，4.2节中关于种子能量的计算和基于测试Oracle的分析</p>
<p>在设计SQLaser时，主要面临两个技术挑战：</p>
<ol>
<li><strong>逻辑错误模式建模阶段的挑战</strong>：<ul>
<li>在逻辑错误模式建模阶段，主要的挑战是如何识别执行SQL子句组合（即SQL级别错误模式）的调用链，并将其作为模糊测试的目标站点。由于SQL子句组合的复杂性和调用链的多样性，如何从庞大的调用链中提取出与错误模式直接相关的部分，并准确地标注为目标站点，是一个复杂且关键的问题。</li>
</ul>
</li>
<li><strong>子句引导模糊测试阶段的挑战</strong>：<ul>
<li>在子句引导模糊测试阶段，由于目标站点是函数调用链，因此路径到路径的距离计算与传统的单点距离计算不同。需要设计一种新的距离计算机制，以便根据该机制来确定变异和测试Oracle所需的调整。该机制的设计需要能够准确地反映种子调用链与目标调用链之间的距离，从而指导模糊测试过程中种子的优先级分配和变异策略的选择。</li>
</ul>
</li>
</ol>
<p>这两个挑战分别涉及如何有效地建模逻辑错误模式，以及如何在模糊测试过程中准确地计算和应用调用链之间的距离，以提高错误检测的效率和精确性。</p>
<h3 id="4-1-Logic-Bug-Pattern-Modeling"><a href="#4-1-Logic-Bug-Pattern-Modeling" class="headerlink" title="4.1. Logic-Bug Pattern Modeling"></a><em>4.1. Logic-Bug Pattern Modeling</em></h3><ol>
<li><p><strong>完整调用链分析</strong>：</p>
<ul>
<li>在这一阶段，SQLaser通过动态分析来获取执行错误时的完整调用链。具体来说，使用LLVM Pass在函数入口处设置钩子，记录函数调用信息，从而获取包含所有相关函数的完整调用链（Step ❶）。然而，完整的调用链中包含了许多与逻辑错误无关的函数，这可能会限制模糊测试的探索能力，因此需要对调用链进行“修剪”。</li>
</ul>
</li>
<li><p><strong>手动识别子句相关的数据对象</strong>：</p>
<ul>
<li>为了修剪调用链，研究人员手动分析错误模式中各子句的属性（如表元素、数据处理函数、条件表达式、特殊关键字等），并将其与程序中的变量进行关联（Step ❷）。例如，对于 NOCASE 和 INDEX i0 的组合错误，可以确定与其相关的变量为 TK_COLLATE 和 pWhere 。通过分析这些数据对象，可以定位处理这些对象的特定函数。</li>
</ul>
</li>
<li><p><strong>自动提取部分调用链</strong>：</p>
<ul>
<li>使用静态分析工具（LLVM Pass），跟踪这些子句相关的数据对象在代码中的数据流动，提取与这些对象处理相关的部分调用链。这样做可以过滤掉不相关的函数，只保留那些直接操作子句相关数据对象的函数，形成“修剪”后的调用链（Step ❸）。这些精简后的调用链将作为模糊测试的目标调用链。</li>
</ul>
</li>
<li><p><strong>子句相关数据对象的识别规则</strong>：</p>
<ul>
<li><p>识别子句相关的数据对象时，依据以下规则：</p>
<ul>
<li><p><strong>表元素&#x2F;模式（Table Element&#x2F;Schema）</strong>：识别引用这些元素或模式的变量，如<code>pWhere</code>表示索引，<code>pPk</code>表示主键。</p>
</li>
<li><p><strong>数据处理函数（Data Processing Functions）</strong>：识别函数的参数或返回值，如<code>CAST</code>函数中的<code>TK_CAST</code>、<code>ppVal</code>等。</p>
</li>
<li><p><strong>条件表达式（Conditional Expressions）</strong>：识别表示条件检查的标志或变量，如<code>EXISTS</code>表达式中的<code>pExpr-&gt;op</code>变量。</p>
</li>
<li><p><strong>特殊关键字（Special Keywords）</strong>：识别用于实现某些功能的标志，如<code>TK_COLLATE</code>、<code>TF_WithoutRowid</code>等。</p>
</li>
<li><p><strong>查询优化函数（Query Optimization Functions）</strong> ：识别与优化功能相关的标志或变量，如 LIKELY 函数中的</p>
<p>EP_Unlikely标志。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>实例说明</strong>：</p>
<ul>
<li><p>通过示例展示了如何应用这些规则。例如，在 NOCASE 和 INDEX i0 的错误模式中，定位子句相关的数据对象 TK_COLLATE</p>
<p>和 pWhere 后，提取相关的函数 whereUsablePartialIndex 和 sqlite3ExprCompare ，最终形成修剪后的调用链。</p>
</li>
</ul>
</li>
</ol>
<p>总结：在4.1节中，SQLaser通过动态分析获取完整调用链，并通过手动分析和静态分析相结合的方法提取与子句相关的数据对象，修剪出与错误模式密切相关的部分调用链。这些调用链将在模糊测试阶段用于优先探索可能存在逻辑错误的代码路径。</p>
<p><img src="/2024/09/28/SQLaser-Detecting-DBMS-Logic-Bugs-with-Clause-Guided-Fuzzing/image-20240928160328319.png" alt="image-20240928160328319"></p>
<blockquote>
<p>该例子描述了如何从一个具体的逻辑错误出发，提取与错误相关的目标调用链。</p>
<ol>
<li><strong>确定错误子句组合</strong>：<ul>
<li>首先，分析示例中的逻辑错误，确定该错误与“NOCASE”和“INDEX i0”这两个SQL子句组合有关。</li>
</ul>
</li>
<li><strong>获取完整调用链</strong>：<ul>
<li>然后，使用动态分析方法获取执行<code>SELECT</code>语句时的完整调用链。通过使用LLVM Pass在函数入口处设置钩子，记录程序执行期间的函数调用信息，从而获得了一个完整的调用链，包括诸如<code>sqlite3Select</code>、<code>sqlite3WhereBegin</code>、<code>whereLoopAddAll</code>等函数。</li>
</ul>
</li>
<li><strong>分析调用链</strong>：<ul>
<li>完整调用链展示了SQL子句组合的内部工作原理，例如<code>whereUsablePartialIndex</code>处理部分索引的操作，而<code>sqlite3ExprImpliesExpr</code>则定义了在“NOCASE”场景下如何比较两个值。</li>
</ul>
</li>
<li><strong>精简调用链</strong>：<ul>
<li>由于完整的调用链中包含了许多与逻辑错误无关的函数，会限制模糊测试的探索能力，因此仅使用完整调用链作为模糊测试目标是不合适的。</li>
<li>为了解决这个问题，作者确定了与“NOCASE”和“INDEX i0”相关的数据对象变量，即<code>TK_COLLATE</code>和<code>pWhere</code>。</li>
<li><font color="green">如何确定相关的数据变量对象？手动识别？</font></li>
</ul>
</li>
<li><strong>跟踪相关变量</strong>：<ul>
<li>通过在IR级别跟踪这些变量，发现只有<code>whereUsablePartialIndex</code>、<code>sqlite3ExprImpliesExpr</code>和<code>sqlite3ExprCompare</code>这三个函数直接操作这些变量，而其他函数则没有。</li>
</ul>
</li>
<li><strong>生成精简后的调用链</strong>：<ul>
<li>因此，最终精简后的目标调用链仅包括：<code>whereUsablePartialIndex → sqlite3ExprImpliesExpr → sqlite3ExprCompare</code>。</li>
</ul>
</li>
</ol>
<p>总结：该例子通过动态分析获取完整调用链，手动识别与错误子句组合相关的数据对象，并通过静态分析精简调用链，提取出最相关的目标调用链，用于后续模糊测试。</p>
</blockquote>
<h3 id="4-2-Call-Chain-Distance-Calculation"><a href="#4-2-Call-Chain-Distance-Calculation" class="headerlink" title="4.2. Call Chain Distance Calculation"></a><em>4.2. Call Chain Distance Calculation</em></h3><ol>
<li><p><strong>目标调用链表示</strong>：</p>
<ul>
<li><p>SQLaser的目标是到达目标站点，即函数调用链。与传统的单点距离计算不同，这里需要定义一种支持路径到路径距离计算的新机制。精简后的目标调用链用一个m元组模型表示，形式为  targetCallChain &#x3D; trimCallChain &#x3D; (f1, f2, …, fm) ，其中每个 </p>
<p>fi  代表调用链中的一个函数。</p>
</li>
</ul>
</li>
<li><p><strong>控制关系模型</strong>：</p>
<ul>
<li>调用链中的每个函数调用关系用 ctl_{fi→fj} 表示，包含两部分信息： fi 和 BB_{fi→fj}。BB_{fi→fj} 是函数 fi 在LLVM IR代码中调用 fj 的基本块。</li>
</ul>
</li>
<li><p><strong>计算种子调用链与目标调用链的距离</strong>：</p>
<ul>
<li>SQLaser首先自动获取种子调用链的控制关系 <code>seedCtl</code>，并将种子调用链和目标调用链分别表示为基本块集合 <code>SBB</code> 和 <code>TBB</code>。</li>
<li>然后，计算 SBB  中每个基本块与  TBB 中基本块之间的距离 d_{BB}，作为种子调用链与目标调用链之间的距离 d_{CallChain}。</li>
</ul>
</li>
<li><p><strong>基本块间距离计算</strong>：</p>
<ul>
<li>基本块 b 和 tb 之间的距离 d(b, tb) 的计算使用调和平均值。如果两个基本块在同一个函数内，则距离定义为 undefined；否则，距离等于两个基本块所在函数之间的距离 df(d, tb)。</li>
<li>df(d, tb) 表示基本块 b 和 tb 所在函数间的最短路径距离，等于两函数间最短路径上的边数。</li>
</ul>
</li>
<li><p><strong>多目标调用链选择</strong>：</p>
<ul>
<li>SQLaser为不同逻辑错误引入了多个目标调用链。在选择与当前种子调用链最匹配的目标调用链时，先计算文本相似度，再用最短距离作为选择标准。当多个目标调用链的文本相似度相同时，选择距离最短的目标调用链。</li>
</ul>
</li>
<li><p><strong>应用场景</strong>：</p>
<ul>
<li>以上距离计算方法用于确定种子与目标调用链之间的距离。根据该距离计算出的种子“能量”值用于指导种子的变异策略，更接近目标调用链的种子将获得更多的变异机会。</li>
</ul>
</li>
</ol>
<p>总结：4.2节提出了一种路径到路径的距离计算方法，用于量化种子调用链与目标调用链之间的距离，从而优化模糊测试中的种子选择和变异策略。</p>
<h3 id="4-3-Mutation-based-on-Seed-Energy-and-Testing-Oracles"><a href="#4-3-Mutation-based-on-Seed-Energy-and-Testing-Oracles" class="headerlink" title="4.3. Mutation based on Seed Energy and Testing Oracles"></a><em>4.3. Mutation based on Seed Energy and Testing Oracles</em></h3><p><strong>4.3.1 基于种子能量的变异（Mutation based on Seed Energy）</strong></p>
<ul>
<li>SQLaser使用SQLRight提出的有效性导向的查询生成方法，避免生成语法或语义错误的查询。生成的查询作为模糊测试的种子，SQLaser为每个种子分配“能量值”。能量值越高，意味着种子有更大的机会经历较多的变异操作。</li>
<li>SQLaser根据种子调用链与目标调用链之间的距离（公式8），分配种子的能量值。距离越短，能量值越高，从而种子被赋予更多的变异机会。能量计算公式为：energy&#x3D;dCallChain−1energy &#x3D; d_{CallChain}^{-1}energy&#x3D;dCallChain−1 这里， d_{CallChain} 表示种子调用链与目标调用链之间的距离。</li>
</ul>
<p><strong>4.3.2 测试Oracle（Testing Oracles）</strong></p>
<ul>
<li>SQLaser利用五种测试Oracle来分析种子执行的结果，通过差分测试方法将原始查询转换为具有不同语法结构但功能等价的变体，比较原始查询和变体的执行结果，以检测潜在的逻辑错误。这五种Oracle包括：<ol>
<li><strong>NoREC Oracle</strong>：将包含<code>WHERE</code>子句的优化查询重写为不包含<code>WHERE</code>优化的查询。</li>
<li><strong>TLP Oracle</strong>：将原始查询分割成多个等价子查询，子查询的结果可以组合成与原始查询相同的结果。</li>
<li><strong>INDEX Oracle</strong>：向查询集中插入不同的<code>CREATE INDEX</code>子句，测试索引使用对查询执行的影响。</li>
<li><strong>ROWID Oracle</strong>：检查原始查询中是否包含<code>WITHOUT ROWID</code>子句，如果没有，则插入该子句，观察其对查询执行的影响。</li>
<li><strong>LIKELY Oracle</strong>：检查原始查询中是否包含 LIKELY 子句，如果没有，则添加 LIKELY 子句，查看其对查询执行的影响。</li>
</ol>
</li>
</ul>
<h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a><strong>Implementation</strong></h2><ol>
<li><strong>插桩阶段（Instrumentation Phase）</strong>：</li>
</ol>
<ul>
<li>在编译时，SQLaser插入四种类型的代码片段：<ol>
<li><strong>边覆盖信息</strong>：收集模糊测试器执行过程中代码覆盖率的信息。</li>
<li><strong>基本块距离信息</strong>：用于计算种子调用链与目标调用链之间的距离。</li>
<li><strong>函数入口钩子</strong>：在每个函数入口处设置钩子，以在执行期间获取种子调用链。</li>
<li><strong>逻辑错误模式信息</strong>：在相关函数入口处插入唯一标识符，以区分不同的调用链，并在运行时收集这些标识符，以确定执行的调用链是否构建了目标调用链。</li>
</ol>
</li>
<li>这些插桩方法类似于WindRanger的方法，通过收集覆盖率信息、基本块距离信息及逻辑错误模式信息来进行模糊测试和距离计算。</li>
</ul>
<ol start="2">
<li><strong>模糊测试阶段（Fuzzing Phase）</strong>：</li>
</ol>
<ul>
<li>在模糊测试阶段，SQLaser修改了WindRanger的代码，以适应其设计，包括距离计算和变异方法。</li>
<li>总共修改了约10,000行代码，并通过更改WindRanger的执行分析部分实现了测试Oracle。</li>
<li>这部分修改的代码大约有3,000行，用于实现与SQLaser模糊测试目标相符的逻辑错误检测策略。</li>
</ul>
<h2 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a><strong>Evaluation</strong></h2><p>以下是这三个研究问题的翻译：</p>
<ol>
<li><strong>SQLaser在实际程序中发现错误的效果如何？它是否能发现新的独特错误？</strong>（对应第6.1节）<ul>
<li>这一问题旨在评估SQLaser在真实环境中检测逻辑错误的有效性，特别是是否能够识别出以往未被发现的新的逻辑错误。</li>
</ul>
</li>
<li><strong>在相关指标（如性能、代码覆盖率和种子距离分布）方面，SQLaser与现有最先进的模糊测试方法相比如何？</strong>（对应第6.2节）<ul>
<li>该问题探讨SQLaser在各种性能指标上的表现，包括与其他顶尖模糊测试方法相比时的效率、代码覆盖范围以及种子与目标调用链之间的距离分布情况。</li>
</ul>
</li>
<li><strong>修剪的效果如何？当目标设定为完整调用链或修剪后的调用链时，SQLaser生成的误报和漏报数量分别是多少？</strong>（对应第6.3节）<ul>
<li>这个问题关注调用链修剪策略的影响，通过比较目标为完整调用链和修剪后的调用链时的误报（false positives）和漏报（false negatives）数量来评估修剪策略的有效性。</li>
</ul>
</li>
</ol>
<p><strong>Test DBMS</strong> : 为了与SQLRight进行对比，SQLaser选择测试了与SQLRight相同版本和类型的数据库管理系统（DBMS）。具体测试如下：</p>
<ol>
<li><strong>相同版本的DBMS</strong>：<ul>
<li>SQLite：版本3.28</li>
<li>MySQL：版本8.0.27</li>
<li>PostgreSQL：版本13.0</li>
</ul>
</li>
<li><strong>额外测试的DBMS</strong>：<ul>
<li>TiDB：版本3.0.12</li>
<li>SQLite：版本3.41</li>
</ul>
</li>
</ol>
<p><font color="green">测试的不是最新版本，说明很多bug SQLRight已经发现了被修复了，只是重复发现而已</font></p>
<h3 id="6-1-Finding-Bugs-in-DBMSs"><a href="#6-1-Finding-Bugs-in-DBMSs" class="headerlink" title="6.1. Finding Bugs in DBMSs"></a><em>6.1. Finding Bugs in DBMSs</em></h3><p>SQLaser在四个测试的DBMS（SQLite、MySQL、PostgreSQL和TiDB）中，共总结了35种错误模式，其中包括SQLite的17种、MySQL的10种、PostgreSQL的1种和TiDB的7种。SQLaser作为一个独立的模糊测试工具，成功复现了所有35种错误模式，并在其中18种模式中发现了22个错误。具体来说，SQLite检测到10种错误模式，MySQL和TiDB各检测到4种。在22个发现的错误中，18个是已知错误，4个是新的零日漏洞（Zero-day bugs），其中包括SQLite的2个新错误和MySQL的2个新错误。</p>
<p><font color="green">仅仅提交了4个bug report.</font></p>
<h3 id="6-2-Comparison-with-Existing-Tools"><a href="#6-2-Comparison-with-Existing-Tools" class="headerlink" title="6.2. Comparison with Existing Tools"></a><em>6.2. Comparison with Existing Tools</em></h3><p>在评估SQLaser时，研究人员还运行了SQLRight和WindRanger进行对比。SQLRight是基于覆盖率引导的模糊测试工具，WindRanger则是单函数目标的定向模糊测试工具。在本部分中，研究者深入比较了这三个模糊测试工具在以下几个方面的表现：</p>
<ol>
<li><strong>性能</strong>：比较三个工具在逻辑错误检测过程中的效率，包括发现错误的速度和数量。  (更快)</li>
<li><strong>代码覆盖率</strong>：评估每个工具在测试过程中覆盖的代码路径，分析它们在探索代码上的能力。  （更低） <font color="green">在低覆盖率的情况下找到同样的bug？</font></li>
<li><strong>种子距离分布</strong>：分析种子与目标调用链之间的距离分布情况，以评估种子选择和优先级策略的有效性。</li>
</ol>
<p><img src="/2024/09/28/SQLaser-Detecting-DBMS-Logic-Bugs-with-Clause-Guided-Fuzzing/image-20240928162035783.png" alt="image-20240928162035783"></p>
<p><img src="/2024/09/28/SQLaser-Detecting-DBMS-Logic-Bugs-with-Clause-Guided-Fuzzing/image-20240928162255660.png" alt="image-20240928162255660"></p>
<p><strong>实验设置</strong>：</p>
<ul>
<li>研究者对SQLite进行了测试，每隔15天（15天、30天、45天、60天）随机选择100个种子，评估这些种子与目标调用链的距离分布情况。</li>
</ul>
<p><strong>SQLaser的表现</strong>：</p>
<ul>
<li>在第15天时，SQLaser的一些种子距离目标调用链仍然较远，分布较为分散。</li>
<li>随着测试时间的增加，种子距离逐渐减少，大多数种子在第60天时集中到0到2的距离范围内。这表明SQLaser的种子生成策略随着时间推移，种子变得越来越接近目标调用链，验证了其距离计算算法的有效性。</li>
</ul>
<p><strong>SQLRight的表现</strong>：</p>
<ul>
<li>SQLRight由于缺乏基于种子与目标调用链距离的反馈策略，在60天的测试期间，种子的距离分布始终较为分散。</li>
<li>尽管SQLRight专注于单一函数的测试，但依旧有部分种子距离目标调用链较远，无法有效覆盖目标调用链。</li>
</ul>
<p><strong>WindRanger的表现</strong>：</p>
<ul>
<li>WindRanger也专注于单一函数的测试，虽然部分种子距离有所收敛，但依旧存在较大距离的种子。</li>
<li>这表明WindRanger的种子策略在覆盖目标调用链方面表现不足</li>
</ul>
<h3 id="6-3-Trimmed-Call-Chains-vs-Complete-Call-Chains"><a href="#6-3-Trimmed-Call-Chains-vs-Complete-Call-Chains" class="headerlink" title="6.3. Trimmed Call Chains vs. Complete Call Chains"></a><em>6.3. Trimmed Call Chains vs. Complete Call Chains</em></h3><p><strong>研究目标</strong>：</p>
<ul>
<li>本文将SQLaser的目标设置为修剪后的调用链（Trimmed Call Chain），而非完整的调用链（Complete Call Chain），以增强模糊测试工具发现新错误的能力。研究比较了这两种方法的结果，包括它们分别引入的误报（False Positives）和漏报（False Negatives）。</li>
</ul>
<p><strong>SQLite上的测试结果</strong>：</p>
<ul>
<li>当目标是修剪后的调用链时，SQLaser在SQLite上产生了25个误报。手动验证这些误报并不耗时，研究者用半小时验证了这25个误报。</li>
<li>当目标是完整的调用链时，SQLaser报告了18个误报，并发现了8个错误，而修剪后的调用链发现了3个错误。这表明完整调用链可能更容易遗漏（漏报）某些潜在的错误。</li>
</ul>
<p><strong>结果分析</strong>：</p>
<ul>
<li>修剪后的调用链由于覆盖了更广泛的代码路径，可能会在不是实际错误的情况下报告更多的误报。但相对来说，由于覆盖了更广泛的可能性，它也会导致更多错误的发现，即使其中有些是误报。</li>
<li>而完整的调用链则减少了误报，因为模糊测试工具对目标的上下文有更好的理解，但也可能因为避免某些路径而导致更多漏报。这是因为完整调用链的目标更具体，可能会限制模糊测试的探索能力。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Lin Li</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/09/28/SQLaser-Detecting-DBMS-Logic-Bugs-with-Clause-Guided-Fuzzing/">http://example.com/2024/09/28/SQLaser-Detecting-DBMS-Logic-Bugs-with-Clause-Guided-Fuzzing/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">LinLi's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/">论文阅读</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/10/03/THANOS-DBMS-Bug-Detection-via-Storage-Engine-Rotation-Based-Differential-Testing/" title="THANOS: DBMS Bug Detection via Storage Engine Rotation Based Differential Testing"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">THANOS: DBMS Bug Detection via Storage Engine Rotation Based Differential Testing</div></div></a></div><div class="next-post pull-right"><a href="/2024/08/18/MVP-Detecting-Vulnerabilities-using-Patch-Enhanced-Vulnerability-Signatures/" title="MVP: Detecting Vulnerabilities using Patch-Enhanced Vulnerability Signatures"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">MVP: Detecting Vulnerabilities using Patch-Enhanced Vulnerability Signatures</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/03/04/PLUMBER/" title="PLUMBER"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-04</div><div class="title">PLUMBER</div></div></a></div><div><a href="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/" title="通过NPM生态系统的依赖树揭开脆弱性传播及其演化的神秘面纱"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-08</div><div class="title">通过NPM生态系统的依赖树揭开脆弱性传播及其演化的神秘面纱</div></div></a></div><div><a href="/2023/04/03/Flexible-and-Optimal-Dependency-Management-via-Max-SMT/" title="Flexible and Optimal Dependency Management via Max-SMT"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-03</div><div class="title">Flexible and Optimal Dependency Management via Max-SMT</div></div></a></div><div><a href="/2023/04/11/What-the-Fork-Finding-Hidden-Code-Clones-in-npm/" title="What the Fork Finding Hidden Code Clones in npm"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-11</div><div class="title">What the Fork Finding Hidden Code Clones in npm</div></div></a></div><div><a href="/2023/04/12/Static-Type-Inference-for-Foreign-Functions-of-Python/" title="Static Type Inference for Foreign Functions of Python"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-12</div><div class="title">Static Type Inference for Foreign Functions of Python</div></div></a></div><div><a href="/2023/04/13/Where-to-Start-Studying-Type-Annotation-Practices-in-Python/" title="Where to Start Studying Type Annotation Practices in Python"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-13</div><div class="title">Where to Start Studying Type Annotation Practices in Python</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Lin Li</div><div class="author-info__description">今日事，今日毕</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">122</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#SQLaser-Detecting-DBMS-Logic-Bugs-with-Clause-Guided-Fuzzing"><span class="toc-number">1.</span> <span class="toc-text">SQLaser: Detecting DBMS Logic Bugs with Clause-Guided Fuzzing</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ABSTRACT"><span class="toc-number">1.1.</span> <span class="toc-text">ABSTRACT</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Introduction"><span class="toc-number">1.2.</span> <span class="toc-text">Introduction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Background"><span class="toc-number">1.3.</span> <span class="toc-text">Background</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-Logic-Bugs-and-Threat-Model"><span class="toc-number">1.3.1.</span> <span class="toc-text">2.1. Logic Bugs and Threat Model</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-Logic-Bug-Testing-Oracles-and-Differential-Testing"><span class="toc-number">1.3.2.</span> <span class="toc-text">2.2. Logic Bug Testing Oracles and Differential Testing</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-Coverage-guided-Fuzzing-and-Directed-Fuzzing"><span class="toc-number">1.3.3.</span> <span class="toc-text">2.3. Coverage-guided Fuzzing and Directed Fuzzing</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Analysis-of-Existing-Logic-Bug-Patterns"><span class="toc-number">1.4.</span> <span class="toc-text">Analysis of Existing Logic Bug Patterns</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SQLaser"><span class="toc-number">1.5.</span> <span class="toc-text">SQLaser</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#overview"><span class="toc-number">1.5.1.</span> <span class="toc-text">overview</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-Logic-Bug-Pattern-Modeling"><span class="toc-number">1.5.2.</span> <span class="toc-text">4.1. Logic-Bug Pattern Modeling</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-Call-Chain-Distance-Calculation"><span class="toc-number">1.5.3.</span> <span class="toc-text">4.2. Call Chain Distance Calculation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-Mutation-based-on-Seed-Energy-and-Testing-Oracles"><span class="toc-number">1.5.4.</span> <span class="toc-text">4.3. Mutation based on Seed Energy and Testing Oracles</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Implementation"><span class="toc-number">1.6.</span> <span class="toc-text">Implementation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Evaluation"><span class="toc-number">1.7.</span> <span class="toc-text">Evaluation</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-Finding-Bugs-in-DBMSs"><span class="toc-number">1.7.1.</span> <span class="toc-text">6.1. Finding Bugs in DBMSs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-Comparison-with-Existing-Tools"><span class="toc-number">1.7.2.</span> <span class="toc-text">6.2. Comparison with Existing Tools</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-Trimmed-Call-Chains-vs-Complete-Call-Chains"><span class="toc-number">1.7.3.</span> <span class="toc-text">6.3. Trimmed Call Chains vs. Complete Call Chains</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/08/%E8%A7%A3%E5%86%B3Camera-ready-%E2%9C%98-Problem-Not-all-fonts-are-embedded-%E9%97%AE%E9%A2%98/" title="解决Camera ready ✘ Problem: Not all fonts are embedded. 问题">解决Camera ready ✘ Problem: Not all fonts are embedded. 问题</a><time datetime="2025-04-08T14:19:21.000Z" title="发表于 2025-04-08 22:19:21">2025-04-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/21/Sequence-Oriented-DBMS-Fuzzing/" title="Sequence-Oriented DBMS Fuzzing">Sequence-Oriented DBMS Fuzzing</a><time datetime="2025-02-21T09:35:08.000Z" title="发表于 2025-02-21 17:35:08">2025-02-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/18/AGENTLESS-Demystifying-LLM-based-Software-Engineering-Agents/" title="AGENTLESS: Demystifying LLM-based Software Engineering Agents">AGENTLESS: Demystifying LLM-based Software Engineering Agents</a><time datetime="2025-02-18T12:16:29.000Z" title="发表于 2025-02-18 20:16:29">2025-02-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/01/DeepSeek-R1-Incentivizing-Reasoning-Capability-in-LLMs-via-Reinforcement-Learning/" title="DeepSeek-R1: Incentivizing Reasoning Capability in LLMs via Reinforcement Learning">DeepSeek-R1: Incentivizing Reasoning Capability in LLMs via Reinforcement Learning</a><time datetime="2025-02-01T11:11:48.000Z" title="发表于 2025-02-01 19:11:48">2025-02-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/01/DeepSeek-Coder-When-the-Large-Language-Model-Meets-Programming-The-Rise-of-Code-Intelligence/" title="DeepSeek-Coder: When the Large Language Model Meets Programming - The Rise of Code Intelligence">DeepSeek-Coder: When the Large Language Model Meets Programming - The Rise of Code Intelligence</a><time datetime="2025-02-01T02:43:19.000Z" title="发表于 2025-02-01 10:43:19">2025-02-01</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Lin Li</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>