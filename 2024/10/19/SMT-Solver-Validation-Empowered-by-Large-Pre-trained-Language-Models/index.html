<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>SMT Solver Validation Empowered by Large Pre-trained Language Models | LinLi's Blog</title><meta name="author" content="Lin Li"><meta name="copyright" content="Lin Li"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="SMT Solver Validation Empowered by Large Pre-trained Language ModelsABSTRACTSMT求解器已被用于检验逻辑公式的可行性，并已应用于多个关键领域，包括软件验证、测试用例生成和程序合成。然而，隐藏在SMT求解器中的错误可能导致严重的后果，引发SMT求解器中的错误结果。因此，确保SMT求解器的可靠性和健壮性至关重要。尽管已提出了多">
<meta property="og:type" content="article">
<meta property="og:title" content="SMT Solver Validation Empowered by Large Pre-trained Language Models">
<meta property="og:url" content="http://example.com/2024/10/19/SMT-Solver-Validation-Empowered-by-Large-Pre-trained-Language-Models/index.html">
<meta property="og:site_name" content="LinLi&#39;s Blog">
<meta property="og:description" content="SMT Solver Validation Empowered by Large Pre-trained Language ModelsABSTRACTSMT求解器已被用于检验逻辑公式的可行性，并已应用于多个关键领域，包括软件验证、测试用例生成和程序合成。然而，隐藏在SMT求解器中的错误可能导致严重的后果，引发SMT求解器中的错误结果。因此，确保SMT求解器的可靠性和健壮性至关重要。尽管已提出了多">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2024-10-19T12:57:20.000Z">
<meta property="article:modified_time" content="2024-10-19T12:58:06.649Z">
<meta property="article:author" content="Lin Li">
<meta property="article:tag" content="论文阅读">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/10/19/SMT-Solver-Validation-Empowered-by-Large-Pre-trained-Language-Models/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'SMT Solver Validation Empowered by Large Pre-trained Language Models',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-10-19 20:58:06'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">122</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="LinLi's Blog"><span class="site-name">LinLi's Blog</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">SMT Solver Validation Empowered by Large Pre-trained Language Models</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-10-19T12:57:20.000Z" title="发表于 2024-10-19 20:57:20">2024-10-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-10-19T12:58:06.649Z" title="更新于 2024-10-19 20:58:06">2024-10-19</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="SMT Solver Validation Empowered by Large Pre-trained Language Models"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="SMT-Solver-Validation-Empowered-by-Large-Pre-trained-Language-Models"><a href="#SMT-Solver-Validation-Empowered-by-Large-Pre-trained-Language-Models" class="headerlink" title="SMT Solver Validation Empowered by Large Pre-trained Language Models"></a>SMT Solver Validation Empowered by Large Pre-trained Language Models</h1><h2 id="ABSTRACT"><a href="#ABSTRACT" class="headerlink" title="ABSTRACT"></a>ABSTRACT</h2><p>SMT求解器已被用于检验逻辑公式的可行性，并已应用于多个关键领域，包括软件验证、测试用例生成和程序合成。然而，隐藏在SMT求解器中的错误可能导致严重的后果，引发SMT求解器中的错误结果。因此，确保SMT求解器的可靠性和健壮性至关重要。尽管已提出了多种测试方法用于SMT求解器，生成有效的测试公式对于全面测试SMT求解器仍是一项挑战。为了解决这一挑战，本研究提出将大型语言模型（LLMs）用于生成用于模糊测试SMT求解器的SMT公式。具体而言，本研究提出了一种新的重训细调流程来释放语言模型生成有效SMT公式的潜力，并通过数据增强提高其生成性能。我们将该方法实现为一个实用的模糊测试工具，名为LAST，并对当前最先进的SMT求解器，即Z3、cvc5和Bitwuzla进行了广泛测试。迄今为止，LAST已成功揭示了65个真实错误，其中45个已被开发者修复。</p>
<h2 id="INTRODUCTION"><a href="#INTRODUCTION" class="headerlink" title="INTRODUCTION"></a>INTRODUCTION</h2><p><font color="red">Background</font></p>
<ol>
<li><strong>SMT求解器概述</strong>:<ul>
<li>定义：高级自动定理证明工具，检验特定理论中一阶逻辑公式的可满足性。</li>
<li>应用：广泛用于软件验证、程序合成、程序分析等领域。</li>
</ul>
</li>
<li><strong>SMT求解器的重要性</strong>:<ul>
<li>影响：求解器的质量直接影响其应用的可靠性和效率。</li>
<li>实例：亚马逊每天调用数百万次SMT求解器进行服务访问控制。</li>
</ul>
</li>
<li><strong>测试SMT求解器的方法</strong>:<ul>
<li>主要策略：公式生成和公式变异。<ol>
<li>公式生成:<ul>
<li>工具例子：FuzzSMT, Murxla。</li>
<li>方法：使用预定义策略从零开始生成测试公式。</li>
</ul>
</li>
<li>公式变异:<ul>
<li>工具例子：YinYang, STORM, OpFuzz, TypeFuzz, HistFuzz。</li>
<li>方法：通过变异现有公式来产生新的测试实例。<ul>
<li>YinYang：结合两个具有相同可满足性的公式生成更复杂的公式。</li>
<li>STORM：将种子公式分割成多个子公式并重新组合生成满足条件的变异体。</li>
<li>OpFuzz：变异公式中的操作符。</li>
<li>TypeFuzz：扩展变异空间，生成新的公式片段。</li>
<li>HistFuzz：利用历史错误触发公式中的元素生成有效变异体。</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><strong>技术挑战</strong>:<ul>
<li>变异空间限制：导致测试效果可能受限。</li>
<li>数据利用不足：HistFuzz虽使用历史错误数据，但方法基础，许多有价值的线索未被充分利用。</li>
</ul>
</li>
</ol>
<p><font color="red">Limitations</font></p>
<p>这段文本探讨了设计有效的SMT求解器测试公式的挑战以及大型预训练语言模型（LLMs）的潜在应用。以下是关键点的概括：</p>
<ol>
<li><strong>挑战</strong>:<ul>
<li>设计有效的SMT求解器测试方法是一项具有挑战性的任务。</li>
<li>即使是经验丰富的SMT求解器专家也可能无法充分发掘历史错误触发公式和求解器特有行为中的有效元素。</li>
<li>仅依赖人工编写的测试公式或独立技术生成的公式不足以全面验证SMT求解器。</li>
</ul>
</li>
<li><strong>预训练语言模型的应用</strong>:<ul>
<li>大型预训练语言模型（LLMs）在各种自然语言和编程语言任务（例如代码理解、程序修复和编译器测试）上表现出色，提供了解决测试公式缺失挑战的有希望的方法。</li>
<li>SMT公式具有高度专业化的语法和严格的规则，尽管与自然语言和编程语言不同，但展现了一定的“自然性”，因此LLMs有望有效生成SMT公式。</li>
</ul>
</li>
<li><strong>存在的问题和限制</strong>:<ul>
<li>当前缺乏经验证据支持LLMs在生成测试公式方面的有效性。</li>
<li>获取高质量的SMT公式生成训练数据几乎不可行，这也是将预训练的LLMs成功迁移到原始领域之外的一个重大挑战。</li>
</ul>
</li>
</ol>
<p><font color="red">Approach</font></p>
<p>这段文本描述了利用大型预训练语言模型（LLMs）改进对SMT求解器测试的方法，主要包括两个步骤：<strong>重训练</strong>和<strong>微调</strong>。</p>
<ol>
<li><strong>重训练</strong>:<ul>
<li>目的是让LLMs能够在特定于SMT的语料库上生成准确的公式。</li>
<li>通过收集标准规范的SMT公式作为训练数据，确保生成的公式符合SMT求解器的标准。</li>
<li>引入<strong>多样性导向的变异</strong>方法，包括<strong>术语变异</strong>和<strong>操作符变异</strong>，以从现有公式中创造出不同的新公式，这有助于模型生成更多能够触发求解器错误的测试公式。</li>
</ul>
</li>
<li><strong>微调</strong>:<ul>
<li>采用<strong>语义保持变异</strong>策略，保证变异后的公式在语义上与原公式等效，从而能够触发相同的错误。</li>
<li>利用SMT求解器Z3的功能进行语义等效变换，生成足够的触发错误的公式。</li>
<li>这一步骤旨在指导LLMs生成更有效的测试公式，增加发现求解器潜在错误的概率。</li>
</ul>
</li>
</ol>
<p>这种方法通过系统的重训练和精确的微调，旨在构建一个强大的LLM，能够生成用于测试SMT求解器的有效和多样化的测试公式。</p>
<p><font color="red">Result</font></p>
<ul>
<li><strong>工具实现</strong>：<ul>
<li>实现了名为 <strong>LAST</strong> 的SMT求解器测试工具，基于GPT-2模型。</li>
<li>评估了LAST在三个SMT求解器（Z3、cvc5、Bitwuzla）上的效果，共报告65个漏洞，其中45个已被修复。</li>
</ul>
</li>
<li><strong>主要发现</strong>：<ul>
<li>LAST能够生成大量有效的公式，显示出LLMs（大语言模型）在生成超出传统自然语言和编程语言的内容上的有效性。</li>
<li>LAST生成的测试公式具有高代码覆盖率，并且在bug检测方面展示了较强的能力。</li>
</ul>
</li>
<li><strong>贡献</strong>：<ol>
<li><strong>原创性</strong>：<ul>
<li>提出了一种新的 <strong>retrain-finetune</strong> 管道，重定向LLMs生成多样化的公式以进行SMT求解器的压力测试。</li>
<li>这是首次将LLMs应用于SMT求解器验证的工作，提供了LLMs有效性的实证依据。</li>
</ul>
</li>
<li><strong>新颖性</strong>：<ul>
<li>引入了两个策略：<ul>
<li><strong>多样性导向变异</strong>（diversity-oriented mutation）</li>
<li><strong>语义保持变异</strong>（semantic-preserving mutation）</li>
</ul>
</li>
<li>这些策略丰富了用于LLMs再训练和微调的数据，提高了SMT公式的生成效果。</li>
</ul>
</li>
<li><strong>重要性</strong>：<ul>
<li>目标是识别SMT求解器中的真实漏洞，证明LLMs可以生成超出典型自然语言和编程语言的内容，具有未来研究潜力。</li>
</ul>
</li>
<li><strong>实用性</strong>：<ul>
<li>报告了三个高级SMT求解器（Z3、cvc5、Bitwuzla）的65个漏洞，其中45个已被开发者修复。</li>
<li>评估结果显示，LAST工具对现有SMT求解器模糊测试技术具有补充作用。</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="BACKGROUND-AND-MOTIVATION"><a href="#BACKGROUND-AND-MOTIVATION" class="headerlink" title="BACKGROUND AND MOTIVATION"></a>BACKGROUND AND MOTIVATION</h2><h3 id="A-SMT-LIB-Language"><a href="#A-SMT-LIB-Language" class="headerlink" title="A. SMT-LIB Language"></a><em>A. SMT-LIB Language</em></h3><p><strong>SMT-LIB语言</strong>：SMT-LIB 是广泛用于 SMT 求解器的输入语言，采用该语言的求解器数量众多。其规范定义了多种命令，用于不同目的。基本命令包括 <code>declare-fun</code>、<code>assert</code> 和 <code>check-sat</code>。</p>
<ul>
<li><strong><code>declare-fun</code> 命令</strong>：用于声明新的符号。</li>
<li><strong><code>assert</code> 命令</strong>：将公式添加到断言栈，表示需要求解的问题。</li>
<li><strong><code>check-sat</code> 命令</strong>：用于询问求解器断言栈中的公式是否可满足，返回 <code>sat</code>（可满足）或 <code>unsat</code>（不可满足）。</li>
</ul>
<p><strong>基本概念</strong>：</p>
<ul>
<li><strong>操作符与项</strong>：是 SMT 公式的基本构建块。预定义的函数符号（如 <code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>）是操作符。<code>项</code> 是表示特定类型值的语法表达式。</li>
<li><strong>项的结构</strong>：项可以是常量、变量、函数符号或限定符，如全称量词 <code>forall</code> 和存在量词 <code>exists</code>。</li>
</ul>
<p><strong>实例说明</strong>：给出了一个 SMT-LIB 实例，说明了如何使用 <code>declare-fun</code> 和 <code>assert</code> 命令来声明变量和构建公式。</p>
<p><img src="/2024/10/19/SMT-Solver-Validation-Empowered-by-Large-Pre-trained-Language-Models/image-20241019200802040.png" alt="image-20241019200802040"></p>
<blockquote>
<p><strong>变量声明</strong>：</p>
<ul>
<li><code>(declare-fun x () Bool)</code>：声明了一个名为 <code>x</code> 的布尔变量，表示 <code>x</code> 的值是 <code>true</code> 或 <code>false</code>。</li>
<li><code>(declare-fun y () Real)</code>：声明了一个名为 <code>y</code> 的实数变量，表示 <code>y</code> 的值是一个实数。</li>
</ul>
<p><strong>断言公式</strong>：</p>
<ul>
<li>(assert (forall ((z Real)) (&#x3D; x (&lt; z y)))) ：<ul>
<li>这个 <code>assert</code> 语句将一个量化公式加入断言栈中。</li>
<li><code>forall ((z Real))</code>：表示对所有实数 <code>z</code>，公式中的条件都必须成立。</li>
<li><code>(= x (&lt; z y))</code>：公式断言 <code>x</code> 等于 <code>z &lt; y</code> 的结果，即 <code>x</code> 的值为 <code>z</code> 是否小于 <code>y</code> 的布尔结果。如果 <code>z</code> 小于 <code>y</code>，则 <code>x</code> 为 <code>true</code>，否则 <code>x</code> 为 <code>false</code>。</li>
</ul>
</li>
</ul>
<p><strong>可满足性检查</strong>：</p>
<ul>
<li>(check-sat)：这是一个标准的SMT-LIB命令，表示求解器需要检查当前断言栈中的公式是否可以满足。<ul>
<li>求解器将返回 <code>sat</code>（可满足）或 <code>unsat</code>（不可满足），这取决于是否存在一组 <code>x</code>、<code>y</code>、<code>z</code> 的值使得所有断言成立。</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="B-Large-Pre-trained-Language-Models"><a href="#B-Large-Pre-trained-Language-Models" class="headerlink" title="B. Large Pre-trained Language Models"></a><em>B. Large Pre-trained Language Models</em></h3><p>大型预训练语言模型（LLMs）：</p>
<ul>
<li><strong>LLMs 的基本原理</strong>：通常是基于 Transformer 的神经网络，通过预测句子中下一个词来学习语言的结构和模式。这使得LLMs可以在没有特定任务目标的情况下，从大量文本中学习语言的普遍结构。</li>
<li><strong>微调与下游任务</strong>：LLMs 可以在更小且更具体的数据集上进行微调，用于文本分类、摘要生成、内容生成等下游任务。LLMs 还可以通过程序数据集的训练，学习不同编程语言的语法和语义，已经成功应用于代码补全和代码总结等任务。</li>
<li><strong>在软件测试中的应用</strong>：LLMs 可以生成大量测试用例，在模糊测试（fuzzing）JavaScript 引擎和深度学习库方面也显示了有效性。</li>
</ul>
<p>生成 SMT 公式的挑战：</p>
<ul>
<li><strong>SMT-LIB 语言的复杂性</strong>：SMT-LIB 是一种形式逻辑语言，具有高度专业化的语法和严格的规则，用于表达复杂的逻辑约束。尽管如此，SMT-LIB 语言也表现出一定程度的“自然性”，这意味着LLMs 可以通过学习生成 SMT 公式。</li>
<li><strong>自然性与程序的关系</strong>：SMT 公式能够表示程序的约束，表明这些公式与程序的语义紧密相连。根据编程语言的自然性推测，SMT 公式也具有一定的“自然性”，这暗示 LLMs 可能适用于生成 SMT 公式。</li>
<li><strong>挑战与研究目标</strong>：尽管这种推测缺乏充分的实证依据，LLMs 的再利用和生成高效 SMT 公式需要高质量的训练数据，而这些数据不易获得。本研究旨在解决这些挑战，并探讨训练 LLMs 以用于 SMT 求解器模糊测试的可行性。</li>
</ul>
<h3 id="C-Data-Augmentation（数据增强）"><a href="#C-Data-Augmentation（数据增强）" class="headerlink" title="C. Data Augmentation（数据增强）"></a><em>C. Data Augmentation（数据增强）</em></h3><p><strong>定义与应用</strong>：数据增强是一种广泛使用的技术，通过对原始数据应用各种变换来增加数据集的多样性和规模。这种技术能够提升深度神经网络的泛化能力和鲁棒性。最初，数据增强技术主要应用于计算机视觉领域，通过翻转、旋转、颜色修改等图像变换来增加训练数据的多样性。</p>
<p><strong>扩展到其他领域</strong>：最近，数据增强技术的应用扩展到了其他领域，包括代码数据。例如，使用代码转换工具来增强代码数据集的规模，并保持原始代码语义不变。增强的数据集能够提升模型在源代码理解方面的性能。</p>
<p><strong>在SMT公式中的应用</strong>：受这些进展的启发，本文提出在SMT公式生成中引入数据增强技术，以解决高质量训练数据有限的问题。通过扩充训练数据集，提高模型的泛化能力，从而在生成有效SMT公式方面获得更好的性能。</p>
<h2 id="APPROACH"><a href="#APPROACH" class="headerlink" title="APPROACH"></a>APPROACH</h2><p><img src="/2024/10/19/SMT-Solver-Validation-Empowered-by-Large-Pre-trained-Language-Models/image-20241019201514397.png" alt="image-20241019201514397"></p>
<h3 id="A-Overview"><a href="#A-Overview" class="headerlink" title="A. Overview"></a><em>A. Overview</em></h3><p><strong>目标</strong>：本文提出了一种重新训练-微调（retrain-finetune）管道，旨在通过学习SMT求解器特定知识以及触发漏洞的公式来增强大规模预训练语言模型（LLMs）的能力。</p>
<p><strong>挑战与解决方案</strong>：由于缺乏足够的多样化训练数据，本文提出了两种数据增强策略：</p>
<ol>
<li><strong>多样性导向的变异策略</strong>（diversity-oriented mutation strategy）</li>
<li><strong>语义保持变异策略</strong>（semantic-preserving mutation strategy）</li>
</ol>
<p>这些策略生成了多样且高质量的训练数据，以帮助重新训练和微调LLMs。</p>
<p><strong>微调过程</strong>：首先使用多样性变异增强的公式重新训练LLM，然后进一步微调LLM，使其能够生成触发漏洞的公式。微调时结合使用触发漏洞的公式和语义保持变异生成的公式。</p>
<p><strong>成果</strong>：最终，利用训练好的LLM生成大量测试公式，用于对SMT求解器进行模糊测试（fuzzing）。通过检测不同SMT求解器对相同公式的求解结果中的不一致性，LLM能够有效地发现漏洞。</p>
<h3 id="B-Data-Collection"><a href="#B-Data-Collection" class="headerlink" title="B. Data Collection"></a><em>B. Data Collection</em></h3><p><strong>LLMs 转换成功的依赖性</strong>：LLMs 生成 SMT 公式的成功很大程度上依赖于用于重新训练 LLMs 的训练数据的多样性。因此，收集高质量的训练数据对于有效地重新训练预训练的 LLMs 至关重要。</p>
<p><strong>数据来源</strong>：SMT-LIB 提供了官方的SMT求解器基准测试集，其中包含数千个严格遵循规范的公式。大多数这些公式来源于实际应用或用于评估性能，通常不会触发 SMT 求解器中的漏洞。开源 SMT 求解器（如 Z3 和 cvc5）的 bug 跟踪系统中包含了触发漏洞的公式，这些公式可以从系统中提取以进行训练。</p>
<p><strong>数据增强工具</strong>：使用 HistFuzz 工具来收集这些触发漏洞的公式，这些公式包含大量的特定求解器知识，未在之前的研究中得到充分利用。</p>
<p><strong>训练数据筛选</strong>：为了确保数据适合 LLMs，过滤掉了过长的公式（超过 LLMs 上下文窗口的限制）。例如，GPT-2 的限制是 1024 个 token。一般来说，bug 触发公式较短，90% 的公式小于 5KB，因此也排除了超过 5KB 的公式。  <font color="green">Bug触发的公式较短</font></p>
<p><strong>数据集规模</strong>：最终收集了 139,367 个用于重新训练 LLM 的公式，以及来自 Z3 和 cvc5 的 3,474 个 bug 触发公式用于微调。</p>
<p><strong>数据格式化</strong>：在数据增强之前，对公式进行了重构和统一格式化。具体来说，移除了 <code>let</code> 绑定符号，并根据变量的类型重命名变量（例如，将 <code>x</code> 和 <code>y</code> 分别重命名为 <code>bool_0</code> 和 <code>real_0</code>）。</p>
<h3 id="C-Augmentation-for-Training-Data"><a href="#C-Augmentation-for-Training-Data" class="headerlink" title="C. Augmentation for Training Data"></a><em>C. Augmentation for Training Data</em></h3><p><strong>目的</strong>：为了解决微调数据集相对较小的问题，本文通过数据增强技术来提高训练数据的数量和多样性。</p>
<p><strong>多样性导向变异</strong>：</p>
<ul>
<li>介绍了两种变异策略：术语变异和操作符变异。</li>
<li><strong>术语变异</strong>：通过替换、添加或删除公式中的术语来生成变异体。例如，术语可以通过不同的转换函数（如 <code>to_real</code> 或 <code>str.to_int</code>）进行转换，以确保类型一致性。</li>
<li><strong>操作符变异</strong>：用与原始操作符有相同操作数和返回值类型的操作符替换原操作符，从而生成变异体。每个基准测试中的每个公式随机生成 10 个变异体，总共生成超过一百万个变异体。</li>
</ul>
<p><strong>语义保持变异</strong>：</p>
<ul>
<li>采用 SMT 求解器 Z3 的内置策略来生成语义等价的变异体，从而确保变异体保留漏洞触发能力。</li>
<li>通过过滤冗余和重复的变异体，最终从 bug 触发公式中收集了 19,062 个变异体。</li>
</ul>
<p><strong>数据增强效果</strong>：通过这些数据增强策略，生成了大量的变异体，显著扩展了训练数据集的规模和多样性，从而有助于提高 LLM 的整体性能。这些增强数据能够帮助模型学习大量 SMT 公式知识，进而生成新的测试公式以揭露漏洞。</p>
<blockquote>
<p><img src="/2024/10/19/SMT-Solver-Validation-Empowered-by-Large-Pre-trained-Language-Models/image-20241019203016494.png" alt="image-20241019203016494"></p>
<p><img src="/2024/10/19/SMT-Solver-Validation-Empowered-by-Large-Pre-trained-Language-Models/image-20241019203108345.png" alt="image-20241019203108345"></p>
</blockquote>
<h3 id="D-Test-Formula-Generation"><a href="#D-Test-Formula-Generation" class="headerlink" title="D. Test Formula Generation"></a><em>D. Test Formula Generation</em></h3><p><strong>模型使用</strong>：</p>
<ul>
<li>LAST 使用 OpenAI 提供的 GPT-2 语言模型，该模型经过大量自然语言数据的预训练。</li>
<li>为了生成 SMT 公式，首先通过 Byte Pair Encoding (BPE) 对公式进行分词，将每个 SMT 公式中的命令、符号、常量等分解为子词或字符，并映射为整数值，构建词汇表。</li>
</ul>
<p><strong>模型重训练</strong>：</p>
<ul>
<li>通过使用基准公式及其多样性导向变异版本，对 GPT-2 模型进行重训练。</li>
<li>重训练使用 Adam 优化器，在 150,000 次迭代和初始学习率 0.0001 下进行，并使用两块 NVIDIA RTX 3080 Ti GPU。</li>
</ul>
<p><strong>模型微调</strong>：</p>
<ul>
<li>重训练完成后，使用漏洞触发公式及其变异体进行微调，以捕捉漏洞触发元素并纳入求解器的特定知识。</li>
<li>微调采用与重训练相同的设置，但只更新模型中最后两层的全连接层权重，训练 50,000 次迭代。</li>
</ul>
<p><strong>测试输入实例化</strong>：</p>
<ul>
<li>一旦模型完成训练，可以生成新的测试公式。通过空提示符生成一系列 token，并选取其中最长的完整公式作为测试输入。</li>
<li>生成公式时使用温度参数 0.7 控制模型的创造性，由于生成的公式不一定完整，最后会对不完整的公式进行修正，确保它们能够被 SMT 求解器正常执行。</li>
</ul>
<h3 id="E-Differential-Testing"><a href="#E-Differential-Testing" class="headerlink" title="E. Differential Testing"></a><em>E. Differential Testing</em></h3><p><strong>目的</strong>：为了发现 SMT 求解器中的漏洞，采用了差分测试方法，即比较多个 SMT 求解器在相同测试公式上的结果。</p>
<p><strong>方法</strong>：</p>
<ol>
<li>如果一个求解器返回 <code>sat</code>，而另一个求解器返回 <code>unsat</code>，则认为这可能是一个潜在的健全性漏洞。通过使用 <code>get-model</code> 命令获取使公式满足的模型来确定哪个求解器出现了问题。</li>
<li>如果模型可以评估为 <code>sat</code>，则将返回 <code>unsat</code> 的求解器视为存在健全性漏洞，反之亦然。</li>
<li>为避免误报，排除 SMT-LIB 规范不足导致的不同求解器行为差异的情况。</li>
<li>还通过模型检查是否能正确评估为 <code>sat</code>，如果不能，则认为是无效模型漏洞。</li>
<li>如果求解器出现异常行为（如断言失败），则记录为崩溃漏洞。</li>
</ol>
<p><strong>报告</strong>：经过手动检查后，报告已识别的漏洞给相关求解器的 bug 跟踪系统。</p>
<h2 id="EVALUATION"><a href="#EVALUATION" class="headerlink" title="EVALUATION"></a>EVALUATION</h2><p><strong>研究问题</strong>：</p>
<ul>
<li><strong>RQ1</strong>: LAST 是否可以生成有效的 SMT 公式？</li>
<li><strong>RQ2</strong>: LAST 能否用于揭示 SMT 求解器中的真实漏洞？</li>
<li><strong>RQ3</strong>: LAST 是否能够补充最先进的 SMT fuzzers？</li>
<li><strong>RQ4</strong>: LAST 的主要组件有多大效果？</li>
</ul>
<p><strong>漏洞类型</strong>：</p>
<ul>
<li><strong>健全性漏洞（Soundness bugs）</strong>：当两个求解器对同一个公式给出相反结果（一个返回 <code>sat</code>，另一个返回 <code>unsat</code>）时，认为存在健全性漏洞。</li>
<li><strong>无效模型漏洞（Invalid model bugs）</strong>：求解器错误地将某个公式判断为 <code>sat</code>，但提供的模型无法满足公式的约束条件。</li>
<li><strong>崩溃漏洞（Crash bugs）</strong>：当求解器在求解过程中出现异常行为（如断言违规或段错误）时，认为存在崩溃漏洞。</li>
</ul>
<p><strong>实验环境</strong>：</p>
<ul>
<li>实验运行在具有 40 核心 Intel Xeon CPU Gold-6230 和 128GB 内存的 Ubuntu 20.04 系统上。使用 AddressSanitizer 工具识别和去重崩溃（如内存泄漏和自由后使用漏洞）。每个公式的求解时间限制为 10 秒。</li>
</ul>
<h3 id="A-RQ1-Validity-of-Generated-Formulas"><a href="#A-RQ1-Validity-of-Generated-Formulas" class="headerlink" title="A. RQ1: Validity of Generated Formulas"></a><em>A. RQ1: Validity of Generated Formulas</em></h3><p><strong>实验设置</strong>：</p>
<ul>
<li>公式被认为是有效的，前提是它可以通过 Z3 或 cvc5 求解且不出现任何错误。</li>
<li>Z3 和 cvc5 是两个被广泛应用于评估的成熟 SMT 求解器，支持多种逻辑。</li>
<li>实验生成了 1,000 个公式，在不同温度下使用 Z3 和 cvc5 进行测试。温度从 0.1 到 1.0，间隔为 0.1。</li>
<li>通过计算在不同温度下生成的有效公式的比例来评估公式的有效性。</li>
</ul>
<p><strong>实验结果</strong>：</p>
<ul>
<li>当温度设置在 0.2 到 0.7 之间时，LAST 生成有效公式的比例较高，超过 60%。</li>
<li>在 0.2 的温度下，<strong>81%</strong> 的公式是有效的，达到最高比例。</li>
<li>这些结果表明训练后的模型可以在适当的温度范围内生成有效公式。</li>
<li>为了在确保高创造性的同时生成有效公式，实验建议将温度设置为 0.7。</li>
</ul>
<h3 id="B-RQ2-Bug-Detection"><a href="#B-RQ2-Bug-Detection" class="headerlink" title="B. RQ2: Bug Detection"></a><em>B. RQ2: Bug Detection</em></h3><img src="/2024/10/19/SMT-Solver-Validation-Empowered-by-Large-Pre-trained-Language-Models/image-20241019204243523.png" alt="image-20241019204243523" style="zoom:67%;">

<ol>
<li><strong>实验目标：</strong><ul>
<li>RQ2的目标是验证LAST能否检测出SMT求解器中的真实bug，这是衡量LAST有效性的重要指标。</li>
</ul>
</li>
<li><strong>实验设置：</strong><ul>
<li>目标求解器：实验中选择了Z3、cvc5和Bitwuzla作为目标求解器。<ul>
<li>Z3和cvc5是社区中广泛使用的SMT求解器，支持广泛的逻辑功能。</li>
<li>Bitwuzla是一个相对较新的SMT求解器，由cvc5的开发者推荐，其在某些特定逻辑领域表现强大。</li>
</ul>
</li>
<li>选项选择：实验集中于求解器的默认模式，同时启用一些必要的选项来检测模型错误和其他潜在问题。</li>
</ul>
</li>
<li><strong>Bug检查与减少：</strong><ul>
<li>为了避免误报，研究采用了一些策略来减少bug报告的重复性。</li>
<li>使用分组方法将可能的相关bug归类为一个问题，并对bug进行去重和简化处理。</li>
<li>通过工具如ddsMT和Delta来减少公式的大小，使之更容易理解和修复。</li>
</ul>
</li>
<li><strong>结果：</strong><ul>
<li>表格显示了在Z3、cvc5和Bitwuzla中发现的65个bug的状态，其中45个已经被开发者修复。</li>
<li>在修复的bug中，大部分是<strong>崩溃类型</strong>的bug，少数是无效模型和可靠性问题。</li>
<li>其中一些bug在Z3和cvc5中已潜伏多年，表明LAST可以揭示长期未被发现的bug。LAST甚至将测试实例提交给Z3的测试仓库，已被开发者采纳，进一步展示了这些bug的重要性。</li>
</ul>
</li>
</ol>
<p>这段内容展示了LAST对SMT求解器的有效bug检测能力，尤其是检测出长期潜在的bug，并表明LAST对提高求解器的可靠性有显著作用。</p>
<h3 id="C-RQ3-Complementarity-Analysis"><a href="#C-RQ3-Complementarity-Analysis" class="headerlink" title="C. RQ3: Complementarity Analysis"></a><em>C. RQ3: Complementarity Analysis</em></h3><p>RQ3的目标是研究LAST是否能够从以下两个方面补充现有的SMT模糊测试工具：</p>
<ol>
<li><strong>代码覆盖率</strong>：通过生成的公式所实现的代码覆盖范围。</li>
<li><strong>暴露Bug的能力</strong>：生成公式揭露bug的能力。</li>
</ol>
<p>实验设置：</p>
<ul>
<li><strong>基线工具</strong>：实验比较了LAST与其他前沿的SMT模糊测试工具（如YinYang、STORM、OpFuzz、TypeFuzz和HistFuzz），所有这些工具均开源，并使用最新版本及默认配置进行测试。</li>
<li><strong>代码覆盖率</strong>：通过从SMT-LIB基准中随机抽取100个公式，并利用这些工具生成1000个变异公式进行测试，最后使用gcov工具收集求解器的代码覆盖率。结果表明，LAST的代码覆盖率在Z3和cvc5上的表现优于其他基线工具，尤其是当LAST与其他工具结合使用时，覆盖率会进一步提升。</li>
<li><strong>Bug揭露能力</strong>：每个模糊测试工具在24小时内运行，并记录所找到的唯一bug数量。LAST通过纠正提交的方法验证bug的有效性。结果显示，LAST在同一时间内比其他模糊测试工具发现了更多bug，尤其是能找到基线工具未能检测到的bug。</li>
</ul>
<p>结果：</p>
<ul>
<li><strong>代码覆盖率</strong>：LAST在Z3和cvc5上的代码覆盖率分别为30.4%和27.5%，显著超过其他模糊测试工具。当LAST与其他模糊测试工具结合使用时，代码覆盖率进一步提升到33.2%。</li>
<li><img src="/2024/10/19/SMT-Solver-Validation-Empowered-by-Large-Pre-trained-Language-Models/image-20241019204822295.png" alt="image-20241019204822295" style="zoom:50%;"></li>
<li><strong>Bug揭露能力</strong>：在已知的六个bug中，LAST在24小时内发现了其中的五个，而基线工具如STORM在相同时间内未能发现任何bug。特别是，对于最新版本的求解器，LAST揭露了Z3和cvc5中的多个长期潜伏的bug。</li>
</ul>
<img src="/2024/10/19/SMT-Solver-Validation-Empowered-by-Large-Pre-trained-Language-Models/image-20241019204755408.png" alt="image-20241019204755408" style="zoom:67%;">

<h3 id="D-RQ4-Ablation-Study"><a href="#D-RQ4-Ablation-Study" class="headerlink" title="D. RQ4: Ablation Study"></a><em>D. RQ4: Ablation Study</em></h3><p>RQ4 研究了LAST各个组成部分对其有效性的贡献，主要关注微调过程和数据增强技术。</p>
<p>实验设置：</p>
<ul>
<li>进行了消融实验，测试了两种变体：<ol>
<li><strong>LAST-woFT</strong>：不包含微调过程。</li>
<li><strong>LAST-woDF</strong>：不包含数据增强和微调过程。</li>
</ol>
</li>
</ul>
<p>实验与RQ3相同，主要比较代码覆盖率。</p>
<p>结果：</p>
<ul>
<li><strong>LAST-woFT</strong> 的代码覆盖率比完整的LAST低，说明微调过程有助于提高代码覆盖率。</li>
<li><strong>LAST-woDF</strong> 的覆盖率进一步降低，表明数据增强技术也对提高代码覆盖率有显著贡献。</li>
</ul>
<p>结论：</p>
<p>微调过程和数据增强技术均对提高LAST的代码覆盖率有重要作用，两个过程共同提升了LAST的有效性。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Lin Li</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/10/19/SMT-Solver-Validation-Empowered-by-Large-Pre-trained-Language-Models/">http://example.com/2024/10/19/SMT-Solver-Validation-Empowered-by-Large-Pre-trained-Language-Models/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">LinLi's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/">论文阅读</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/11/19/METAL-Metamorphic-Testing-Framework-for-Analyzing-Large-Language-Model-Qualities/" title="METAL Metamorphic Testing Framework for Analyzing Large-Language Model Qualities"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">METAL Metamorphic Testing Framework for Analyzing Large-Language Model Qualities</div></div></a></div><div class="next-post pull-right"><a href="/2024/10/13/MR-Adopt-Automatic-Deduction-of-Input-Transformation-Function-for-Metamorphic-Testing/" title="MR-Adopt: Automatic Deduction of Input Transformation Function for Metamorphic Testing"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">MR-Adopt: Automatic Deduction of Input Transformation Function for Metamorphic Testing</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/03/04/PLUMBER/" title="PLUMBER"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-04</div><div class="title">PLUMBER</div></div></a></div><div><a href="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/" title="通过NPM生态系统的依赖树揭开脆弱性传播及其演化的神秘面纱"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-08</div><div class="title">通过NPM生态系统的依赖树揭开脆弱性传播及其演化的神秘面纱</div></div></a></div><div><a href="/2023/04/03/Flexible-and-Optimal-Dependency-Management-via-Max-SMT/" title="Flexible and Optimal Dependency Management via Max-SMT"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-03</div><div class="title">Flexible and Optimal Dependency Management via Max-SMT</div></div></a></div><div><a href="/2023/04/11/What-the-Fork-Finding-Hidden-Code-Clones-in-npm/" title="What the Fork Finding Hidden Code Clones in npm"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-11</div><div class="title">What the Fork Finding Hidden Code Clones in npm</div></div></a></div><div><a href="/2023/04/12/Static-Type-Inference-for-Foreign-Functions-of-Python/" title="Static Type Inference for Foreign Functions of Python"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-12</div><div class="title">Static Type Inference for Foreign Functions of Python</div></div></a></div><div><a href="/2023/04/13/Where-to-Start-Studying-Type-Annotation-Practices-in-Python/" title="Where to Start Studying Type Annotation Practices in Python"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-13</div><div class="title">Where to Start Studying Type Annotation Practices in Python</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Lin Li</div><div class="author-info__description">今日事，今日毕</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">122</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#SMT-Solver-Validation-Empowered-by-Large-Pre-trained-Language-Models"><span class="toc-number">1.</span> <span class="toc-text">SMT Solver Validation Empowered by Large Pre-trained Language Models</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ABSTRACT"><span class="toc-number">1.1.</span> <span class="toc-text">ABSTRACT</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#INTRODUCTION"><span class="toc-number">1.2.</span> <span class="toc-text">INTRODUCTION</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BACKGROUND-AND-MOTIVATION"><span class="toc-number">1.3.</span> <span class="toc-text">BACKGROUND AND MOTIVATION</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#A-SMT-LIB-Language"><span class="toc-number">1.3.1.</span> <span class="toc-text">A. SMT-LIB Language</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-Large-Pre-trained-Language-Models"><span class="toc-number">1.3.2.</span> <span class="toc-text">B. Large Pre-trained Language Models</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-Data-Augmentation%EF%BC%88%E6%95%B0%E6%8D%AE%E5%A2%9E%E5%BC%BA%EF%BC%89"><span class="toc-number">1.3.3.</span> <span class="toc-text">C. Data Augmentation（数据增强）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#APPROACH"><span class="toc-number">1.4.</span> <span class="toc-text">APPROACH</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#A-Overview"><span class="toc-number">1.4.1.</span> <span class="toc-text">A. Overview</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-Data-Collection"><span class="toc-number">1.4.2.</span> <span class="toc-text">B. Data Collection</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-Augmentation-for-Training-Data"><span class="toc-number">1.4.3.</span> <span class="toc-text">C. Augmentation for Training Data</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#D-Test-Formula-Generation"><span class="toc-number">1.4.4.</span> <span class="toc-text">D. Test Formula Generation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#E-Differential-Testing"><span class="toc-number">1.4.5.</span> <span class="toc-text">E. Differential Testing</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EVALUATION"><span class="toc-number">1.5.</span> <span class="toc-text">EVALUATION</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#A-RQ1-Validity-of-Generated-Formulas"><span class="toc-number">1.5.1.</span> <span class="toc-text">A. RQ1: Validity of Generated Formulas</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-RQ2-Bug-Detection"><span class="toc-number">1.5.2.</span> <span class="toc-text">B. RQ2: Bug Detection</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-RQ3-Complementarity-Analysis"><span class="toc-number">1.5.3.</span> <span class="toc-text">C. RQ3: Complementarity Analysis</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#D-RQ4-Ablation-Study"><span class="toc-number">1.5.4.</span> <span class="toc-text">D. RQ4: Ablation Study</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/08/%E8%A7%A3%E5%86%B3Camera-ready-%E2%9C%98-Problem-Not-all-fonts-are-embedded-%E9%97%AE%E9%A2%98/" title="解决Camera ready ✘ Problem: Not all fonts are embedded. 问题">解决Camera ready ✘ Problem: Not all fonts are embedded. 问题</a><time datetime="2025-04-08T14:19:21.000Z" title="发表于 2025-04-08 22:19:21">2025-04-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/21/Sequence-Oriented-DBMS-Fuzzing/" title="Sequence-Oriented DBMS Fuzzing">Sequence-Oriented DBMS Fuzzing</a><time datetime="2025-02-21T09:35:08.000Z" title="发表于 2025-02-21 17:35:08">2025-02-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/18/AGENTLESS-Demystifying-LLM-based-Software-Engineering-Agents/" title="AGENTLESS: Demystifying LLM-based Software Engineering Agents">AGENTLESS: Demystifying LLM-based Software Engineering Agents</a><time datetime="2025-02-18T12:16:29.000Z" title="发表于 2025-02-18 20:16:29">2025-02-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/01/DeepSeek-R1-Incentivizing-Reasoning-Capability-in-LLMs-via-Reinforcement-Learning/" title="DeepSeek-R1: Incentivizing Reasoning Capability in LLMs via Reinforcement Learning">DeepSeek-R1: Incentivizing Reasoning Capability in LLMs via Reinforcement Learning</a><time datetime="2025-02-01T11:11:48.000Z" title="发表于 2025-02-01 19:11:48">2025-02-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/01/DeepSeek-Coder-When-the-Large-Language-Model-Meets-Programming-The-Rise-of-Code-Intelligence/" title="DeepSeek-Coder: When the Large Language Model Meets Programming - The Rise of Code Intelligence">DeepSeek-Coder: When the Large Language Model Meets Programming - The Rise of Code Intelligence</a><time datetime="2025-02-01T02:43:19.000Z" title="发表于 2025-02-01 10:43:19">2025-02-01</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Lin Li</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>