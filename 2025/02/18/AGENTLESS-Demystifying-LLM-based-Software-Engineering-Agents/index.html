<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>AGENTLESS: Demystifying LLM-based Software Engineering Agents | LinLi's Blog</title><meta name="author" content="Lin Li"><meta name="copyright" content="Lin Li"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Agentless：Demystifying LLM-based Software Engineering Agents近年来，大型语言模型（LLMs）的进展显著推动了软件开发任务的自动化，包括代码合成、程序修复和测试生成。最近，研究人员和行业从业者开发了各种自治LLM代理，以执行端到端的软件开发任务。这些代理具备使用工具、运行命令、观察环境反馈和规划未来行动的能力。然而，这些基于代理的方法的复杂">
<meta property="og:type" content="article">
<meta property="og:title" content="AGENTLESS: Demystifying LLM-based Software Engineering Agents">
<meta property="og:url" content="http://example.com/2025/02/18/AGENTLESS-Demystifying-LLM-based-Software-Engineering-Agents/index.html">
<meta property="og:site_name" content="LinLi&#39;s Blog">
<meta property="og:description" content="Agentless：Demystifying LLM-based Software Engineering Agents近年来，大型语言模型（LLMs）的进展显著推动了软件开发任务的自动化，包括代码合成、程序修复和测试生成。最近，研究人员和行业从业者开发了各种自治LLM代理，以执行端到端的软件开发任务。这些代理具备使用工具、运行命令、观察环境反馈和规划未来行动的能力。然而，这些基于代理的方法的复杂">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2025-02-18T12:16:29.000Z">
<meta property="article:modified_time" content="2025-02-18T12:17:52.661Z">
<meta property="article:author" content="Lin Li">
<meta property="article:tag" content="论文阅读">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2025/02/18/AGENTLESS-Demystifying-LLM-based-Software-Engineering-Agents/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'AGENTLESS: Demystifying LLM-based Software Engineering Agents',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-02-18 20:17:52'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">121</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="LinLi's Blog"><span class="site-name">LinLi's Blog</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">AGENTLESS: Demystifying LLM-based Software Engineering Agents</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-02-18T12:16:29.000Z" title="发表于 2025-02-18 20:16:29">2025-02-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-02-18T12:17:52.661Z" title="更新于 2025-02-18 20:17:52">2025-02-18</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="AGENTLESS: Demystifying LLM-based Software Engineering Agents"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Agentless：Demystifying-LLM-based-Software-Engineering-Agents"><a href="#Agentless：Demystifying-LLM-based-Software-Engineering-Agents" class="headerlink" title="Agentless：Demystifying LLM-based Software Engineering Agents"></a><strong>Agentless：Demystifying LLM-based Software Engineering Agents</strong></h1><p>近年来，大型语言模型（LLMs）的进展显著推动了软件开发任务的自动化，包括代码合成、程序修复和测试生成。最近，研究人员和行业从业者开发了各种自治LLM代理，以执行端到端的软件开发任务。这些代理具备使用工具、运行命令、观察环境反馈和规划未来行动的能力。然而，这些基于代理的方法的复杂性，以及当前LLM的能力限制，提出了一个问题：我们真的需要使用复杂的自治软件代理吗？为了尝试回答这个问题，我们提出了AGENTLESS——一种无需代理的自动化软件开发问题解决方法。与基于代理方法的冗长复杂设置相比，AGENTLESS采用了简单的三阶段流程：定位、修复和补丁验证，且无需让LLM决定未来的行动或使用复杂工具。我们在流行的SWE-bench Lite基准测试中的结果表明，令人惊讶的是，简单的AGENTLESS不仅能达到最高的性能（32.00%，96个正确修复），还具有较低的成本（$0.70），与现有所有开源软件代理相比表现更佳！事实上，AGENTLESS已被OpenAI采纳，作为展示GPT-4o和新发布的OpenAI o1模型在实际编程任务中表现的首选方法。此外，我们手动分类了SWE-bench Lite中的问题，并发现了一些具有准确地面真值补丁或不足&#x2F;误导性问题描述的问题。因此，我们构建了SWE-bench Lite-S，排除了这些有问题的内容，以进行更严格的评估和比较。我们的工作突出了当前被忽视的简单且具成本效益的技术在自治软件开发中的潜力。我们希望AGENTLESS能够帮助重设自治软件代理的基准、起点和前景，并激发未来在这一重要方向上的研究工作。我们已经开源了AGENTLESS，地址：<a target="_blank" rel="noopener" href="https://github.com/OpenAutoCoder/Agentless">https://github.com/OpenAutoCoder/Agentless</a></p>
<h2 id="INTRODUCTION"><a href="#INTRODUCTION" class="headerlink" title="INTRODUCTION"></a>INTRODUCTION</h2><p><font color="red">Background</font></p>
<p><strong>大型语言模型（LLMs）的应用</strong>：</p>
<ul>
<li>LLMs已成为代码生成的首选工具，如GPT-4和Claude 3.5 Sonnet。</li>
<li>这些LLMs在根据用户描述生成代码片段方面表现出色。</li>
</ul>
<p><strong>当前应用的局限性</strong>：</p>
<ul>
<li>相较于简单、独立的问题评估设置，LLMs在处理<strong>仓库级别的软件工程任务</strong>（如特性添加、程序修复和测试生成）方面的研究较少。</li>
<li>这些任务需要对不仅是文件内容（包含成千上万行代码）的信息，还需要对跨文件的仓库级依赖有深入的理解。</li>
</ul>
<p><strong>SWE-bench基准测试的提出</strong>：</p>
<ul>
<li>为了填补这一研究空白，评估工具自动解决实际软件工程问题的能力，提出了<strong>SWE-bench</strong>基准测试。</li>
<li>在SWE-bench中，每个问题包括一个真实的GitHub问题描述和对应的Python仓库。</li>
<li>任务是修改仓库以解决问题，可能是修复bug或引入新特性。</li>
</ul>
<p><strong>SWE-bench Lite的发布</strong>：</p>
<ul>
<li>最近，SWE-bench的子集SWE-bench Lite（300个问题）被发布，进一步筛选，专注于bug修复问题。</li>
</ul>
<p><font color="red">Limitations of Agent-based Approach</font></p>
<p><strong>Agent-based方法的研究背景</strong>：</p>
<ul>
<li>为了解决SWE-bench中的实际软件开发问题，学术界和工业界大量研究了基于代理的方法，灵感来源于Devin AI Software Engineer。</li>
<li>这些方法通常给LLMs配备一组工具，允许代理通过迭代方式自动执行操作、观察反馈并规划下一步。</li>
</ul>
<p><strong>Agent-based方法的工具使用与设计</strong>：</p>
<ul>
<li>工具包括开&#x2F;写&#x2F;创建文件、搜索代码行、运行测试和执行shell命令等。</li>
<li>代理执行问题解决任务时，会有多个回合，每回合包括执行一个操作，后续回合依赖于前一回合的操作和环境反馈。</li>
</ul>
<p><strong>Agent-based方法的局限性</strong>：</p>
<ul>
<li><strong>工具使用与设计复杂</strong>：<ul>
<li>现有的代理方法通过抽象层将代理与环境之间的工具使用进行连接（例如，通过API调用），但这种抽象和API调用设计可能导致工具使用不当或不精确，特别是当操作空间复杂时。迭代的特点使得工具使用不当可能导致性能下降并增加额外的成本。</li>
</ul>
</li>
<li><strong>决策规划缺乏控制</strong>：<ul>
<li>代理方法将决策过程委托给代理，让代理根据前一步的反馈决定当前操作。然而，由于可能的操作空间和反馈的多样性，代理可能会陷入困惑并做出次优的选择。问题的解决可能需要多达30到40个回合，导致决策过程难以理解，也难以调试错误决策。</li>
</ul>
</li>
<li><strong>自我反思能力有限</strong>：<ul>
<li>现有代理缺乏自我反思能力，无法有效地过滤或修正无关、不正确或误导性的信息。这使得错误步骤容易被放大，进而影响后续的决策。</li>
</ul>
</li>
</ul>
<p><font color="red">Approach</font></p>
<p><strong>问题提出</strong>：</p>
<ul>
<li>文章提出在软件开发中，不应急于开发越来越复杂的LLM代理工具，而是应首先反思是否真的需要使用复杂的自治软件代理。</li>
</ul>
<p><strong>AGENTLESS方法</strong>：</p>
<ul>
<li>为回答这一问题，提出了AGENTLESS——一种无需代理的方法来自动解决软件开发问题。</li>
<li>AGENTLESS的解决过程包括三个简单的阶段：定位、修复和补丁验证。<ul>
<li><strong>定位</strong>：通过层级化的过程定位问题，从文件到相关类&#x2F;函数，最终到细粒度的编辑位置，结合LLM和经典信息检索方法。</li>
<li><strong>修复</strong>：基于定位结果生成多个候选补丁，并生成重现测试以帮助选择补丁。</li>
<li><strong>补丁验证</strong>：重新排序所有剩余补丁，并选择一个提交以修复问题。</li>
</ul>
</li>
</ul>
<p><strong>设计理念</strong>：</p>
<ul>
<li>AGENTLESS避免了复杂的代理设计，不让LLM自主决定未来行动或使用复杂工具，保持简洁且易于理解。</li>
<li>这种设计有助于避免LLM代理在软件开发中的一些限制，如复杂工具使用和决策规划问题。</li>
</ul>
<p><strong>实验结果</strong>：</p>
<ul>
<li>在SWE-bench Lite基准测试中，AGENTLESS不仅在所有开源方法中表现最佳（32.00%的修复率），还以极低的成本实现。</li>
</ul>
<p><strong>数据集分析</strong>：</p>
<ul>
<li>对SWE-bench Lite数据集进行了细致的手动分析，发现一些问题存在准确的地面真值补丁（4.3%）、缺少解决问题所需的关键信息（10.0%）、以及误导性的解决方案（5.0%）。</li>
<li>基于这些问题，构建了SWE-bench Lite-S，去除了这些有问题的问题，提供了更严格的基准测试。</li>
</ul>
<p><strong>总结与展望</strong>：</p>
<ul>
<li>本文强调了在追求排行榜名次的时代，简单、成本效益高的技术在自治软件开发中的被忽视的潜力。</li>
<li>AGENTLESS的提出希望能够重新设定自治软件代理的基准，启发未来在这一方向的研究。</li>
</ul>
<h2 id="Background-and-Related-Work"><a href="#Background-and-Related-Work" class="headerlink" title="Background and Related Work"></a><strong>Background and Related Work</strong></h2><h3 id="2-1-Agent-based-Software-Engineering"><a href="#2-1-Agent-based-Software-Engineering" class="headerlink" title="2.1 Agent-based Software Engineering"></a>2.1 Agent-based Software Engineering</h3><p><strong>Agent-based软件工程</strong>：</p>
<ul>
<li>随着代理框架的兴起，研究人员和行业从业者开始开发基于代理的方法来解决软件工程任务。</li>
</ul>
<p><strong>典型的Agent-based框架</strong>：</p>
<ul>
<li><strong>Devin</strong>：首个端到端的LLM代理框架，使用代理进行任务规划，并利用文件编辑器、终端和网页搜索工具执行任务。</li>
<li><strong>SWE-agent</strong>：设计了一个自定义的代理-计算机接口（ACI），让LLM代理与代码库环境交互，执行文件读取、编辑和运行bash命令等操作。</li>
<li><strong>Aider</strong>：通过静态和调用图分析提供详细的代码库地图，帮助LLM定位需要编辑的文件，生成简单的diff格式补丁，并使用回归测试验证修复效果。</li>
<li><strong>Moatless</strong>：另一个开源工具，通过代码搜索工具和LLM构建的查询获取相关代码位置，生成补丁并提交。</li>
<li><strong>AutoCodeRover</strong>：提供代码搜索API帮助LLM代理定位错误位置，迭代检索代码上下文。</li>
<li><strong>SpecRover</strong>：在AutoCodeRover的基础上进一步改进，通过生成函数摘要、反馈消息和重现测试来推断程序行为并选择最终补丁。</li>
</ul>
<p><strong>AGENTLESS的创新与优势</strong>：</p>
<ul>
<li>相比这些复杂的代理方法，AGENTLESS提供了一个简单、可解释、成本效益高的解决方案。</li>
<li>AGENTLESS的设计包括明确的定位、修复和补丁验证阶段，而无需让LLM代理决定未来的行动或使用复杂的工具。</li>
<li>AGENTLESS首次证明了无需代理的方法也能在解决实际软件工程问题时取得非常竞争力的表现，并避免了复杂工具和环境行为建模的额外负担。</li>
</ul>
<h3 id="2-2-Fault-Localization-and-Program-Repair"><a href="#2-2-Fault-Localization-and-Program-Repair" class="headerlink" title="2.2 Fault Localization and Program Repair"></a>2.2 Fault Localization and Program Repair</h3><p><strong>故障定位（Fault Localization，FL）</strong>：</p>
<ul>
<li><strong>动态故障定位</strong>：包括基于频谱的FL（SBFL）和基于变异的FL（MBFL）。SBFL通过计算测试覆盖的源代码位置来判定更可能出现故障的位置，MBFL则进一步考虑每个代码位置对测试结果的影响。</li>
<li><strong>静态故障定位</strong>：利用信息检索（IR）技术将故障定位问题转化为搜索问题，通过代码元素与错误报告的文本相似度进行比较。</li>
<li><strong>基于学习的故障定位</strong>：结合动态和静态信息，使用机器学习技术进行故障定位，如DeepFL、FLUCCS、TRANSFER等。</li>
<li><strong>LLM-based故障定位</strong>：近年来，LLM-based方法利用现代LLM强大的代码和自然语言理解能力进行故障定位。然而，这些方法通常无法执行仓库级的故障定位，或依赖于复杂和高成本的代理设计。</li>
<li>相比之下，AGENTLESS采用简洁的分层故障定位方法（结合LLM和IR），高效地计算细粒度的编辑位置。</li>
</ul>
<p><strong>程序修复（Program Repair）</strong>：</p>
<ul>
<li><strong>传统的自动化程序修复（APR）技术</strong>：可以分为基于模板、启发式和约束的工具。尽管有效，但传统APR工具存在可扩展性问题，并且补丁种类有限。</li>
<li><strong>基于学习的APR工具</strong>：使用神经机器翻译（NMT）模型或预训练LLM进行修复，LLM-based APR工具因其强大的编程能力而成为当前的最佳方法。</li>
<li><strong>代理基础APR技术</strong>：最近也提出了基于代理的APR技术，灵感来源于现有的LLM-based APR工具。</li>
<li><strong>AGENTLESS的修复方法</strong>：AGENTLESS与LLM-based APR工具相似，采样多个候选补丁以增加修复成功的概率。</li>
<li>不同于大多数LLM-based APR方法，AGENTLESS生成简单的diff格式补丁，避免生成完整代码，专注于产生成本效益高的小修补，从而提高修复的可靠性和准确性。AGENTLESS还针对更复杂的仓库级问题，解决跨多个位置的复杂故障。</li>
</ul>
<h3 id="2-3-LLM-based-Test-Generation"><a href="#2-3-LLM-based-Test-Generation" class="headerlink" title="2.3 LLM-based Test Generation"></a>2.3 LLM-based Test Generation</h3><p><strong>LLM在测试生成中的应用</strong>：</p>
<ul>
<li>LLM已被应用于测试生成领域，尤其是<strong>模糊测试</strong>（fuzz testing），用于生成大量输入以暴露系统中的bug。研究者们在深度学习库、操作系统内核、编译器、网络协议和移动应用等领域应用LLM进行模糊测试，取得了较传统模糊测试工具更好的效果，发现了许多传统模糊测试无法检测的bug。</li>
<li>除了模糊测试，LLM还被用于<strong>单元测试生成</strong>，测试单独的软件单元（如方法&#x2F;类），如CodeMosa、ChatTester、TestPilot和CoverUp等工具。</li>
</ul>
<p><strong>Bug重现</strong>：</p>
<ul>
<li>Bug重现是调查bug报告的关键步骤，并已集成到许多最近的软件工程代理中。例如，SpecRover首先生成一个测试来重现bug报告中描述的问题，然后通过该测试引导上下文检索和修复过程。</li>
</ul>
<p><strong>AGENTLESS的不同之处</strong>：</p>
<ul>
<li>与基于代理的方法不同，AGENTLESS通过简单执行多个采样的测试来验证是否重现了问题，而不是依赖LLM代理决定测试是否正确。</li>
</ul>
<h2 id="AgentLess-Approach"><a href="#AgentLess-Approach" class="headerlink" title="AgentLess Approach"></a><strong>AgentLess Approach</strong></h2><p><img src="/2025/02/18/AGENTLESS-Demystifying-LLM-based-Software-Engineering-Agents/image-20250218162913241.png" alt="image-20250218162913241"></p>
<p><strong>AGENTLESS概述</strong>：</p>
<ul>
<li>AGENTLESS包括三个主要阶段：<strong>定位</strong>、<strong>修复</strong>和<strong>补丁验证</strong>。</li>
</ul>
<p><strong>定位阶段</strong>：</p>
<ul>
<li>输入：问题描述和现有项目代码库。</li>
<li>首先将项目代码库转化为树状结构，展示每个文件的位置。</li>
<li>使用该结构和问题描述提示LLM定位并排名最有可能需要编辑的N个文件。</li>
<li>通过嵌入式检索获取与问题描述最相关的代码片段，并将这些文件与LLM定位的文件结合，得到最终的可疑文件列表。</li>
<li>进一步提供每个文件的类和函数声明头信息，询问LLM需关注的类和函数。</li>
<li>最后，提供完整的代码内容并请LLM确定具体的编辑位置（如类、函数或特定行）。</li>
</ul>
<p><strong>修复阶段</strong>：</p>
<ul>
<li>提供定位到的代码片段和问题描述，提示LLM生成多个补丁来修复问题。</li>
</ul>
<p><strong>补丁验证阶段</strong>：</p>
<ul>
<li>让LLM生成多个重现测试，以验证是否能重现原始问题。</li>
<li>根据执行结果选择最佳的重现测试。</li>
<li>结合重现测试和回归测试对补丁进行排名和选择。</li>
<li>最终选择排名最高的补丁作为最终提交的修复补丁。</li>
</ul>
<p><strong>总结</strong>：</p>
<ul>
<li>AGENTLESS通过这三个阶段：定位、修复和补丁验证，自动化解决软件开发中的问题，并确保补丁的正确性。</li>
</ul>
<h3 id="3-1-Localization"><a href="#3-1-Localization" class="headerlink" title="3.1 Localization"></a>3.1 Localization</h3><p><strong>定位的重要性</strong>：</p>
<ul>
<li>在修复或实现新功能时，首先需要确定源代码中的正确位置，因为没有正确的定位就无法进行有效的修改。</li>
</ul>
<p><strong>挑战</strong>：</p>
<ul>
<li>代码库可能包含数百个文件和成千上万行代码，而需要编辑的只是少数几行或函数。</li>
</ul>
<p><strong>AGENTLESS的解决方案</strong>：</p>
<ul>
<li>AGENTLESS采用简单的三步分层定位过程：<ol>
<li>定位到可疑文件；</li>
<li>在每个文件中定位到相关的类、函数和变量；</li>
<li>定位到具体的代码编辑位置。</li>
</ol>
</li>
</ul>
<h4 id="3-1-1-Localize-to-suspicious-files"><a href="#3-1-1-Localize-to-suspicious-files" class="headerlink" title="3.1.1 Localize to suspicious files."></a>3.1.1 Localize to suspicious files.</h4><p><strong>定位到可疑文件</strong>：</p>
<ul>
<li><strong>第一步</strong>：AGENTLESS通过构建简洁的代码库文件和目录结构表示（类似Linux的tree命令）来缩小潜在位置范围。这个“代码库结构格式”展示了根文件夹及其下的文件和文件夹层次关系，供LLM使用。</li>
<li><strong>第二步</strong>：AGENTLESS将处理后的代码库结构和问题描述输入LLM，要求它识别出需要进一步检查或修改的前N个可疑文件。</li>
</ul>
<p><strong>嵌入式检索补充定位</strong>：</p>
<ul>
<li>为了补充基于提示的定位方法，AGENTLESS使用简单的嵌入式检索方法来识别额外的可疑文件。首先，AGENTLESS通过提供代码库结构，要求LLM生成不需要进一步检查的无关文件夹列表，并移除这些无关文件夹中的文件。</li>
<li>接着，将剩余文件分块，并计算每个代码块的嵌入。AGENTLESS还将原始问题描述进行嵌入，并计算查询嵌入与每个代码块嵌入的余弦相似度，以检索出与查询最相关的文件。</li>
</ul>
<p><strong>最终文件列表</strong>：</p>
<ul>
<li>AGENTLESS结合基于提示的方法和嵌入检索的方法，选择出前N个最常见的文件，生成最终的相关文件列表。</li>
</ul>
<h4 id="3-1-2-Localize-to-related-elements"><a href="#3-1-2-Localize-to-related-elements" class="headerlink" title="3.1.2 Localize to related elements."></a>3.1.2 Localize to related elements.</h4><p><strong>定位到相关元素</strong>：</p>
<ul>
<li>在获取到可疑文件列表后，AGENTLESS进入第二部分：定位文件中的相关元素。</li>
<li>直接提供文件的完整上下文可能过于庞大，因此AGENTLESS构建了一种压缩格式，称为**”骨架格式”**（skeleton format），只包含类、函数或变量的声明。</li>
<li>在骨架格式中，AGENTLESS仅提供类和函数的头部信息。对于类，还包括类字段和方法（仅限签名）。此外，还会保留类和模块级别的注释以提供更多信息。</li>
<li>与提供完整文件上下文相比，骨架格式更加简洁，特别是在文件包含大量行时，处理整个文件可能不切实际或成本过高。骨架格式使得LLM可以在一次提示中处理所有可疑文件，帮助模型分析相关信息并决定最相关的元素。</li>
</ul>
<img src="/2025/02/18/AGENTLESS-Demystifying-LLM-based-Software-Engineering-Agents/image-20250218165537391.png" alt="image-20250218165537391" style="zoom:67%;">

<h4 id="3-1-3-Localize-to-edit-locations"><a href="#3-1-3-Localize-to-edit-locations" class="headerlink" title="3.1.3 Localize to edit locations."></a>3.1.3 Localize to edit locations.</h4><p><strong>定位到相关元素</strong>：</p>
<ul>
<li>在获取到可疑文件列表后，AGENTLESS进入第二部分：定位文件中的相关元素。</li>
<li>直接提供文件的完整上下文可能过于庞大，因此AGENTLESS构建了一种压缩格式，称为**”骨架格式”**（skeleton format），只包含类、函数或变量的声明。</li>
<li>在骨架格式中，AGENTLESS仅提供类和函数的头部信息。对于类，还包括类字段和方法（仅限签名）。此外，还会保留类和模块级别的注释以提供更多信息。</li>
<li>与提供完整文件上下文相比，骨架格式更加简洁，特别是在文件包含大量行时，处理整个文件可能不切实际或成本过高。骨架格式使得LLM可以在一次提示中处理所有可疑文件，帮助模型分析相关信息并决定最相关的元素。</li>
</ul>
<img src="/2025/02/18/AGENTLESS-Demystifying-LLM-based-Software-Engineering-Agents/image-20250218165848297.png" alt="image-20250218165848297" style="zoom:67%;">



<h3 id="3-2-Repair"><a href="#3-2-Repair" class="headerlink" title="3.2 Repair"></a>3.2 Repair</h3><p><strong>修复阶段目标</strong>：</p>
<ul>
<li>目标是生成正确的补丁来解决问题，AGENTLESS借鉴了现有的LLM-based程序修复方法。</li>
</ul>
<p><strong>上下文窗口构建</strong>：</p>
<ul>
<li>使用已定位的编辑位置，AGENTLESS为LLM构建一个代码片段的上下文窗口。若定位位置为40到78行，则创建一个上下文窗口[40 - x, 78 + x]，其中x为上下文窗口的大小，旨在为LLM提供相关的上下文信息。</li>
</ul>
<p><strong>多位置修复</strong>：</p>
<ul>
<li>若有多个编辑位置，AGENTLESS将多个上下文窗口连接起来，使用“…”表示中间缺失的上下文。</li>
</ul>
<p><strong>生成补丁</strong>：</p>
<ul>
<li><p>使用代码片段，AGENTLESS要求LLM生成补丁来修复问题，但不直接生成完整的代码，而是要求生成一个Search&#x2F;Replace</p>
<p>格式的补丁。</p>
<ul>
<li><strong>Search</strong>：表示原始代码片段，需要被替换的部分。</li>
<li><strong>Replace</strong>：表示替换的代码片段。</li>
</ul>
</li>
<li><p>这种简单的diff格式专注于生成小的修改，既提高了成本效益，也增加了修复的可靠性和准确性。</p>
</li>
</ul>
<p><strong>生成多个补丁</strong>：</p>
<ul>
<li>对每个问题，AGENTLESS让LLM生成多个候选补丁，首先使用贪心策略生成补丁，然后使用更高温度进行多样化采样。</li>
</ul>
<h3 id="3-3-Patch-Validation"><a href="#3-3-Patch-Validation" class="headerlink" title="3.3 Patch Validation"></a>3.3 Patch Validation</h3><h4 id="3-3-1-Reproduction-test-generation"><a href="#3-3-1-Reproduction-test-generation" class="headerlink" title="3.3.1 Reproduction test generation."></a>3.3.1 Reproduction test generation.</h4><p><strong>重现测试生成</strong>：</p>
<ul>
<li>由于AGENTLESS生成多个候选补丁，需要一种方法来选择最终的补丁提交。</li>
<li>在SWE-bench设置下，原始项目代码库仅能提供回归测试，而没有bug触发测试，因此无法访问触发问题的测试。</li>
</ul>
<p><strong>生成重现测试</strong>：</p>
<ul>
<li>AGENTLESS借鉴之前的工作，生成额外的重现测试来帮助补丁选择。</li>
<li>AGENTLESS利用LLM合成一个完整的测试文件，试图重现描述中的问题，并验证问题是否已解决。</li>
<li>重现测试的输出应当在重现问题时打印“Issue reproduced”，而在问题解决时打印“Issue resolved”。</li>
</ul>
<p><strong>重现测试执行</strong>：</p>
<ul>
<li>AGENTLESS还提供原始问题描述的重现测试示例，并执行每个候选重现测试来过滤掉未能重现问题的测试。</li>
<li>测试会经过标准化（去除注释、额外的空格等），并选择测试结果最佳的重现测试作为最终测试。</li>
</ul>
<img src="/2025/02/18/AGENTLESS-Demystifying-LLM-based-Software-Engineering-Agents/image-20250218170652007.png" alt="image-20250218170652007" style="zoom:67%;">

<h4 id="3-3-2-Patch-selection"><a href="#3-3-2-Patch-selection" class="headerlink" title="3.3.2 Patch selection."></a>3.3.2 Patch selection.</h4><p><strong>补丁选择过程</strong>：</p>
<ul>
<li><strong>初步测试</strong>：AGENTLESS首先运行代码库中所有现有的测试，识别通过的测试。这些通过的测试并非都应作为回归测试，因为修复问题可能涉及更改现有功能。</li>
<li><strong>去除非回归测试</strong>：AGENTLESS将通过的测试提供给LLM，要求其识别哪些测试不应运行，以验证问题是否已修复，并去除这些非回归测试。</li>
<li><strong>回归测试</strong>：然后运行剩余的回归测试，选择回归失败最少的补丁。</li>
<li><strong>重现测试验证</strong>：AGENTLESS运行所选的重现测试，确保输出为“Issue resolved”，并剔除未通过重现测试的补丁。如果没有补丁通过重现测试，AGENTLESS会仅依据回归测试结果进行选择。</li>
</ul>
<p><strong>补丁标准化和选择</strong>：</p>
<ul>
<li>为了忽略表面级差异（如空格、新行和注释），AGENTLESS对每个补丁进行标准化处理，解析并重新格式化代码，最终计算标准化后的差异作为补丁。</li>
<li>使用多数投票法对补丁进行重新排序，并选择出现次数最多的补丁作为最终提交的补丁。</li>
</ul>
<p><strong>AGENTLESS的优势</strong>：</p>
<ul>
<li>AGENTLESS采用简单的三阶段方法：定位、修复和验证，无需依赖代理进行决策。</li>
<li>通过层级化的定位方式，AGENTLESS高效地计算出细粒度的编辑位置。</li>
<li>采用简单的diff格式进行修复，并使用生成的重现测试来辅助验证补丁的有效性。</li>
</ul>
<h2 id="Experimental-Setup"><a href="#Experimental-Setup" class="headerlink" title="Experimental Setup"></a><strong>Experimental Setup</strong></h2><p><strong>数据集</strong>：</p>
<ul>
<li>AGENTLESS和基准方法在流行的SWE-bench数据集上进行评估，专注于SWE-bench Lite版本（包含300个高质量问题）。此外，还对SWE-bench Lite进行详细研究，识别潜在问题和偏差，并构建一个更严格的过滤问题集。</li>
</ul>
<p><strong>实现</strong>：</p>
<ul>
<li>使用GPT-4o实现AGENTLESS，并采用贪心解码和采样温度为0.8。通过LlamaIndex实现基于嵌入的检索方法，使用OpenAI的text-embedding-3-small模型来计算嵌入。</li>
<li>在定位阶段，每个问题首先定位到前3个可疑文件，然后进一步定位相关类和函数，并生成4个编辑位置样本，每个样本生成10个补丁。</li>
<li>生成40个重现测试样本，并进行回归测试来识别非回归测试。</li>
</ul>
<p><strong>基准对比</strong>：</p>
<ul>
<li>将AGENTLESS与26种基于代理的方法进行比较，包括开源和闭源方法。还包括一个简单的无代理基线方法（RAG），它使用LLM直接生成补丁。</li>
</ul>
<p><strong>评估指标</strong>：</p>
<ul>
<li>评估指标包括：1) <strong>解决问题的百分比</strong>（% Resolved），2) <strong>平均成本</strong>（Avg. $ Cost），3) <strong>平均输入输出token数</strong>（Avg. # Tokens），以及4) <strong>正确定位的百分比</strong>（% Correct Location），评估补丁是否覆盖正确的编辑位置，包括文件、函数和行级别。</li>
</ul>
<p><strong>方法说明</strong>：</p>
<ul>
<li>基准方法的结果直接取自SWE-bench的官方排行榜或相关工具的官方论文&#x2F;仓库。</li>
</ul>
<h2 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a><strong>Evaluation</strong></h2><p><img src="/2025/02/18/AGENTLESS-Demystifying-LLM-based-Software-Engineering-Agents/image-20250218170927394.png" alt="image-20250218170927394"></p>
<h3 id="5-1-Performance-on-SWE-bench-Lite"><a href="#5-1-Performance-on-SWE-bench-Lite" class="headerlink" title="5.1 Performance on SWE-bench Lite"></a>5.1 Performance on SWE-bench Lite</h3><p><strong>SWE-bench Lite评估结果</strong>：</p>
<ul>
<li>AGENTLESS解决了300个问题中的96个（32.00%），虽然这一解决率不是最高，但相较于现有的基于代理的方法，AGENTLESS在使用更简单的设计和技术的情况下仍表现得非常有竞争力。</li>
<li>很多顶级方法是闭源&#x2F;商业工具，没有发布源代码以供复现实验或验证。</li>
<li>相较于所有开源方法，AGENTLESS在SWE-bench Lite上的表现最高，解决了32.00%的问题。</li>
</ul>
<p><strong>成本效益</strong>：</p>
<ul>
<li>AGENTLESS的平均成本为$0.70，低于大多数基于代理的方法。</li>
<li>相比RAG无代理基线方法，虽然AGENTLESS的成本略高，但其能够修复更多问题。</li>
</ul>
<h4 id="5-1-1-Unique-issues-fixed"><a href="#5-1-1-Unique-issues-fixed" class="headerlink" title="5.1.1 Unique issues fixed."></a>5.1.1 Unique issues fixed.</h4><p><strong>独特问题修复</strong>：</p>
<ul>
<li><strong>图5</strong>展示了AGENTLESS与顶级闭源&#x2F;商业和开源工具相比解决的独特问题。</li>
<li>相比于开源的基于代理的工具，AGENTLESS能够修复2个其他工具无法解决的问题，展示了使用简单无代理方法在解决难题上的成功。</li>
<li>即使与表现优秀的商业工具相比，AGENTLESS仍能提供独特的修复，证明其在解决特定问题上的能力。</li>
</ul>
<p><strong>AGENTLESS的独特优势</strong>：</p>
<ul>
<li>AGENTLESS解决了少量独特问题，这些问题也被某些现有工具部分或完全解决，这些工具可能是基于AGENTLESS或受到其启发（如Bytedance MarsCode）。</li>
<li>尽管如此，结果表明AGENTLESS仍具有竞争力，并能与现有代理工具互补。</li>
</ul>
<p><img src="/2025/02/18/AGENTLESS-Demystifying-LLM-based-Software-Engineering-Agents/image-20250218171151641.png" alt="image-20250218171151641"></p>
<h4 id="5-1-2-Localization-performance"><a href="#5-1-2-Localization-performance" class="headerlink" title="5.1.2 Localization performance."></a>5.1.2 Localization performance.</h4><p><strong>定位性能</strong>：</p>
<ul>
<li>在实际的软件开发中，除了直接修复问题外，提供正确的编辑位置对开发人员调试非常有帮助。因此，本文比较了每种技术生成的补丁与地面真值补丁的位置。</li>
<li><strong>表1</strong>展示了每个工具在行、函数和文件级别上正确位置的百分比。</li>
</ul>
<p><strong>定位结果分析</strong>：</p>
<ul>
<li>观察发现，正确位置的百分比与问题解决率高度相关。对于文件级位置，<strong>OpenCSG StarShip</strong>的结果最高，达到90.0%，但其解决率较低（23.67%）。由于OpenCSG StarShip是一个商业产品，且未提供源代码或详细轨迹，难以解释其定位与修复性能之间的巨大差异。</li>
</ul>
<p><strong>AGENTLESS的竞争力</strong>：</p>
<ul>
<li>通过采用简单的分层定位方法，AGENTLESS在定位性能上与先前的基于代理的方法相比仍具有很强的竞争力。</li>
</ul>
<h4 id="5-1-3-Reproduction-test-results"><a href="#5-1-3-Reproduction-test-results" class="headerlink" title="5.1.3 Reproduction test results."></a>5.1.3 Reproduction test results.</h4><p><strong>重现测试结果</strong>：</p>
<ul>
<li>AGENTLESS使用回归测试和生成的重现测试来筛选最终提交的补丁，因此需要评估生成的重现测试的质量。</li>
<li>在SWE-bench Lite的300个问题中，AGENTLESS成功生成了213个重现测试，这些测试在原始代码库中输出了所需的重现信息。</li>
</ul>
<p><strong>问题与解决</strong>：</p>
<ul>
<li>尽管生成了许多重现测试，只有94个测试在应用地面真值补丁后成功输出“Issue resolved”信息。此下降可部分归因于问题描述可能没有提供足够信息来生成完整的测试用例以验证正确解决方案。</li>
</ul>
<p><strong>问题缓解措施</strong>：</p>
<ul>
<li>AGENTLESS采取保守方法，要求所有补丁首先通过回归测试，如果补丁通过生成的重现测试但未通过回归测试，则会被移除。这减少了错误的重现测试选中正确补丁的可能性。</li>
<li>如果所有生成的补丁都无法通过重现测试，AGENTLESS将仅依赖回归测试结果进行选择。</li>
</ul>
<p><strong>后续研究</strong>：</p>
<ul>
<li>第5.2.3节将深入探讨回归测试和重现测试在补丁选择中的组合对性能的影响。</li>
</ul>
<h4 id="5-1-4-Adoption-of-AGENTLESS"><a href="#5-1-4-Adoption-of-AGENTLESS" class="headerlink" title="5.1.4 Adoption of AGENTLESS."></a>5.1.4 Adoption of AGENTLESS.</h4><p><strong>AGENTLESS的采用情况</strong>：</p>
<ul>
<li>虽然AGENTLESS最近才发布，但已经得到广泛采用。</li>
<li><strong>RepoGraph</strong>是一个开源工具，结合了AGENTLESS和仓库级图形，<strong>Isoform</strong>是一个闭源商业工具，也基于AGENTLESS构建。此外，<strong>Bytedance MarsCode</strong>部分受到AGENTLESS启发，<strong>OpenDevin</strong>正在将AGENTLESS集成到他们的生态系统中。</li>
<li>AGENTLESS已被OpenAI作为默认方法，用于展示GPT-4o在新SWE-bench验证基准上的表现，并且在该基准中AGENTLESS取得了最佳表现。</li>
</ul>
<p><strong>表格2：不同定位步骤的性能</strong>：</p>
<ul>
<li><strong>文件级定位</strong>：多种方法的表现比较，包括基于提示、基于嵌入的定位方法和组合方法。组合方法的正确率为81.67%，且成本最低（$0.06）。</li>
<li><strong>相关元素定位</strong>：包括完整文件和骨架格式。骨架格式表现较好，正确率为58.33%，成本仅为$0.02。</li>
<li><strong>编辑位置定位</strong>：不同采样方法的性能比较，包括贪心方法和多样本合并方法。贪心方法表现较为突出，正确率为50.67%，成本为$0.06。</li>
</ul>
<p><strong>AGENTLESS的优势</strong>：</p>
<ul>
<li>AGENTLESS在所有基于代理的方法中表现最佳，且OpenAI已将其作为展示GPT-4o性能的标准方法。</li>
</ul>
<img src="/2025/02/18/AGENTLESS-Demystifying-LLM-based-Software-Engineering-Agents/image-20250218173155697.png" alt="image-20250218173155697" style="zoom:67%;">



<h3 id="5-2-Ablation-study-on-components-of-AGENTLESS"><a href="#5-2-Ablation-study-on-components-of-AGENTLESS" class="headerlink" title="5.2 Ablation study on components of AGENTLESS"></a>5.2 Ablation study on components of AGENTLESS</h3><h4 id="5-2-1-Localization-ablation"><a href="#5-2-1-Localization-ablation" class="headerlink" title="5.2.1 Localization ablation."></a>5.2.1 Localization ablation.</h4><p><strong>定位步骤的性能与成本</strong>：</p>
<ul>
<li><strong>表2</strong>展示了AGENTLESS定位阶段的三个步骤的性能和成本，包括每个步骤在定位地面真值编辑位置后的百分比、每个定位集的平均代码行数和每个步骤的平均成本。粗体方法表示AGENTLESS的默认设置。</li>
</ul>
<p><strong>不同配置的效果</strong>：</p>
<ul>
<li><strong>文件级定位</strong>：AGENTLESS通过嵌入式检索方法取得了较好的性能，分别在78.7%和67.7%的案例中定位到正确文件，结合提示和嵌入方法后达到81.7%的正确文件定位。</li>
<li><strong>相关元素定位</strong>：AGENTLESS通过使用骨架格式减少了上下文窗口，性能有所提升，相比完全文件内容方法减少了代码行数和成本。</li>
</ul>
<p><strong>编辑位置定位</strong>：</p>
<ul>
<li><strong>方法比较</strong>：使用贪心方法、从文件级别直接定位和多样本合并等方法进行比较，发现直接从文件级定位到编辑位置效果较差，而多样本合并的效果更好，但成本也更高。</li>
<li><strong>默认设置</strong>：AGENTLESS采用多次采样的方法以确保良好的定位性能，并通过分层定位减少成本，同时确保定位准确。</li>
</ul>
<p><strong>总结</strong>：</p>
<ul>
<li>AGENTLESS通过层次化的定位方法，在确保准确性的同时，也有效地控制了成本，且能够处理复杂的定位任务。</li>
</ul>
<img src="/2025/02/18/AGENTLESS-Demystifying-LLM-based-Software-Engineering-Agents/image-20250218184103526.png" alt="image-20250218184103526" style="zoom:80%;">

<p><img src="/2025/02/18/AGENTLESS-Demystifying-LLM-based-Software-Engineering-Agents/image-20250218184554602.png" alt="image-20250218184554602"></p>
<h4 id="5-2-2-Repair-ablation"><a href="#5-2-2-Repair-ablation" class="headerlink" title="5.2.2 Repair ablation."></a>5.2.2 Repair ablation.</h4><p><strong>修复步骤的影响</strong>：</p>
<ul>
<li><strong>表3</strong>展示了不同修复设置的性能和成本。使用贪心定位集生成的编辑位置已经能够修复超过88个问题。通过将多个位置集合并为一个，性能也可以达到类似水平。</li>
<li>通过分别考虑每个采样位置并生成多个候选补丁，性能进一步提高，达到了96个问题修复。</li>
</ul>
<p><strong>采样对性能的影响</strong>：</p>
<ul>
<li><strong>图6</strong>展示了增加采样数目对修复性能的影响。使用1个贪心样本时，AGENTLESS已经能够修复80个问题。随着样本数的增加，修复性能逐步提高，但当样本数达到40时，性能趋于平稳，新增样本对性能的提升较小。</li>
<li>由于使用多数投票法选择最终补丁，后续样本可能被忽略，因为它们难以影响已投票选中的补丁。</li>
</ul>
<p><strong>潜力和未来改进</strong>：</p>
<ul>
<li>如果考虑所有补丁样本而非只选取一个，AGENTLESS可以解决126个问题（占42%），这表明AGENTLESS具有很大的潜力。未来的工作可以通过更好的补丁重排序和选择技术进一步提升整体性能。</li>
</ul>
<p><img src="/2025/02/18/AGENTLESS-Demystifying-LLM-based-Software-Engineering-Agents/image-20250218184528618.png" alt="image-20250218184528618"></p>
<h4 id="5-2-3-Patch-validation-ablation"><a href="#5-2-3-Patch-validation-ablation" class="headerlink" title="5.2.3 Patch validation ablation."></a>5.2.3 Patch validation ablation.</h4><p><strong>补丁选择的影响</strong>：</p>
<ul>
<li><strong>表4</strong>展示了不同补丁选择方法的性能和成本。通过仅使用多数投票，AGENTLESS能够修复77个问题。加入回归测试后，修复数量提升至81个。最显著的性能提升是通过引入重现测试进行额外的过滤，最终修复了96个问题。</li>
<li>重现测试的使用提高了AGENTLESS的补丁选择能力，但也增加了额外的成本，因为AGENTLESS需要生成这些测试。</li>
<li><img src="/2025/02/18/AGENTLESS-Demystifying-LLM-based-Software-Engineering-Agents/image-20250218184732996.png" alt="image-20250218184732996"></li>
</ul>
<p><strong>重现测试生成的效果</strong>：</p>
<ul>
<li><strong>图7</strong>展示了增加重现测试样本数对修复性能的影响。随着候选重现测试数的增加，成功修复的问题数量逐步提升，但重现测试的可行性并未显著增加（除了从1到5个样本的提升）。这一现象可能是因为问题描述的模糊性，导致缺少足够的信息来验证问题是否已解决。</li>
<li><img src="/2025/02/18/AGENTLESS-Demystifying-LLM-based-Software-Engineering-Agents/image-20250218184804533.png" alt="image-20250218184804533"></li>
</ul>
<p><strong>最终结果</strong>：</p>
<ul>
<li>随着增加候选重现测试样本的数量，AGENTLESS修复了96个问题，显示出较高的性能上限。</li>
</ul>
<h2 id="Additional-Analysis-on-SWE-bench-Lite"><a href="#Additional-Analysis-on-SWE-bench-Lite" class="headerlink" title="Additional Analysis on SWE-bench Lite"></a><strong>Additional Analysis on SWE-bench Lite</strong></h2><h3 id="6-1-Problem-Classification"><a href="#6-1-Problem-Classification" class="headerlink" title="6.1 Problem Classification"></a>6.1 Problem Classification</h3><p><img src="/2025/02/18/AGENTLESS-Demystifying-LLM-based-Software-Engineering-Agents/image-20250218184904042.png" alt="image-20250218184904042"></p>
<p><strong>问题分类</strong>：</p>
<ul>
<li>为了更好地理解SWE-bench Lite中的问题，AGENTLESS和其他方法的性能，进行了手动分类，基于问题描述和开发者补丁进行分析。</li>
</ul>
<p><strong>分类维度</strong>：</p>
<ul>
<li>描述质量：<ul>
<li>分类为：足够信息（如自然语言描述和可重现的失败示例）、部分可重现的示例、不足够信息（如问题要求特定名称的函数或错误消息）。约10%的问题缺少足够信息，这会导致测试失败，尽管功能可能实现正确。</li>
</ul>
</li>
<li>描述中的解决方案：<ul>
<li>分类为：无解决方案、部分解决方案、完整解决方案、精确补丁、误导性解决方案。发现4.3%的问题描述中包含了准确的补丁，9.7%提供了正确的解决步骤。但也有5.0%的问题描述提供了与开发者补丁不符的解决方案，可能导致错误的生成解决方案。</li>
</ul>
</li>
<li>位置描述：<ul>
<li>分类为：自然语言中提供精确位置、在失败堆栈中提供精确位置、提供相关关键字、未提供位置。仅少数问题提供精确的行号，但随着粒度增大（到函数和文件级别），大约一半的问题提供了文件级别的编辑位置。</li>
</ul>
</li>
</ul>
<p><strong>潜在问题</strong>：</p>
<ul>
<li>SWE-bench Lite中存在无法解决的问题、误导性解决方案以及问题难度差异较大的情况，这些问题在基准创建和先前方法中未得到充分考虑。</li>
</ul>
<p><strong>总结</strong>：</p>
<ul>
<li>这些分类为后续分析AGENTLESS和基准方法的修复性能提供了有用的见解，尤其是描述中提供的位置信息对修复结果的影响。</li>
</ul>
<h3 id="6-2-SWE-bench-Lite-S"><a href="#6-2-SWE-bench-Lite-S" class="headerlink" title="6.2 SWE-bench Lite-S"></a>6.2 SWE-bench Lite-<em>S</em></h3><p><strong>SWE-bench Lite-S的构建</strong>：</p>
<ul>
<li>基于前述的问题分类，AGENTLESS和现有方法进行了更严格的比较。通过移除问题描述中已提供准确补丁、误导性解决方案或缺乏足够信息的问题，构建了一个包含249个问题的子集，称为<strong>SWE-bench Lite-S</strong>。这个子集规范了基准的难度级别。</li>
<li>SWE-bench Lite-S相比于原始的SWE-bench Lite，提供了更准确的自动化软件开发工具能力反映。</li>
</ul>
<p><strong>SWE-bench Lite-S的评估</strong>：</p>
<ul>
<li>表5展示了在SWE-bench Lite-S基准上的结果，并与原始300个问题的结果进行了比较。虽然所有方法的排名大体相同，但过滤后的SWE-bench Lite-S基准更准确地反映了工具的真实能力。</li>
</ul>
<p><strong>分类结果与工具表现</strong>：</p>
<ul>
<li><strong>可重现的代码示例</strong>：当问题描述中提供了可重现的代码示例时，所有先前方法的解决率下降。然而，AGENTLESS在这些问题上的表现仍然很高，因为它能更好地利用这些可重现的代码示例，这突显了测试生成阶段在补丁选择中的重要性。</li>
<li><strong>问题描述中的解决方案</strong>：提供自然语言解决步骤的问题表现较好，AGENTLESS和其他方法在这类问题上有较好的表现。</li>
<li><strong>位置线索</strong>：问题描述中提供的位置信息对解决率有显著影响。提供自然语言位置或堆栈跟踪的位置问题解决率较高。对于没有位置信息的问题，AGENTLESS和闭源方法相比，后者在没有位置线索的情况下表现更好，突显了代理工具在解决这些复杂问题中的优势。</li>
</ul>
<p><strong>总结与展望</strong>：</p>
<ul>
<li>AGENTLESS在解决包含可重现代码示例的问题时表现优异，但在没有位置信息的复杂问题中，代理工具显示了其优势。未来的工作可以进一步优化AGENTLESS，特别是在没有位置线索的复杂问题上的表现。</li>
</ul>
<p><img src="/2025/02/18/AGENTLESS-Demystifying-LLM-based-Software-Engineering-Agents/image-20250218185900089.png" alt="image-20250218185900089"></p>
<h3 id="6-3-SWE-bench-Verified"><a href="#6-3-SWE-bench-Verified" class="headerlink" title="6.3 SWE-bench Verified"></a>6.3 SWE-bench Verified</h3><img src="/2025/02/18/AGENTLESS-Demystifying-LLM-based-Software-Engineering-Agents/image-20250218190112075.png" alt="image-20250218190112075" style="zoom:67%;">

<p><strong>SWE-bench Verified数据集</strong>：</p>
<ul>
<li>受6.1节的启发，OpenAI生成了经过人工开发者验证的新过滤数据集SWE-bench Verified，确保每个问题都包含足够的信息可以解决。</li>
</ul>
<p><strong>AGENTLESS在SWE-bench Verified的表现</strong>：</p>
<ul>
<li>在SWE-bench Verified数据集上，AGENTLESS能够解决500个问题中的194个（38.80%），保持了强劲的表现。</li>
<li>AGENTLESS在所有开源方法中排名第二，且表现优于许多闭源&#x2F;商业方法。</li>
</ul>
<p><strong>AGENTLESS的优势</strong>：</p>
<ul>
<li>AGENTLESS在所有使用GPT-4o作为LLM的技术中表现最佳。</li>
</ul>
<h2 id="Threats-to-Validity"><a href="#Threats-to-Validity" class="headerlink" title="Threats to Validity"></a><strong>Threats to Validity</strong></h2><p><strong>内部有效性威胁</strong>：</p>
<ul>
<li>数据泄露问题：SWE-bench Lite中的ground truth开发者补丁可能被用作GPT-4o训练数据的一部分。由于GPT-4o是闭源模型，无法访问其训练数据。不过，先前的研究大多使用类似的闭源LLM（如GPT-4o、GPT-4、Claude-3.5等），AGENTLESS在相同模型下的表现优于所有开源解决方案。</li>
<li>GPT-4的知识截止日期前后的比较研究表明，问题解决率没有显著差异。为了完全解决这一威胁，可能需要从头开始重新训练GPT-4o，但这对于学术项目来说是不可行的。</li>
</ul>
<p><strong>外部有效性威胁</strong>：</p>
<ul>
<li>评估数据集：SWE-bench Lite是最流行的评估数据集，包含多种问题，但AGENTLESS的性能可能无法普遍适用于其他数据集。然而，OpenAI在多个基准（SWE-bench Lite、SWE-bench和SWE-bench Verified）上对AGENTLESS进行了独立评估，进一步确认AGENTLESS优于所有其他开源方法。</li>
<li>未来计划：为了进一步解决外部威胁，计划在其他基准上评估AGENTLESS的表现。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Lin Li</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/02/18/AGENTLESS-Demystifying-LLM-based-Software-Engineering-Agents/">http://example.com/2025/02/18/AGENTLESS-Demystifying-LLM-based-Software-Engineering-Agents/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">LinLi's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/">论文阅读</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/02/21/Sequence-Oriented-DBMS-Fuzzing/" title="Sequence-Oriented DBMS Fuzzing"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Sequence-Oriented DBMS Fuzzing</div></div></a></div><div class="next-post pull-right"><a href="/2025/02/01/DeepSeek-R1-Incentivizing-Reasoning-Capability-in-LLMs-via-Reinforcement-Learning/" title="DeepSeek-R1: Incentivizing Reasoning Capability in LLMs via Reinforcement Learning"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">DeepSeek-R1: Incentivizing Reasoning Capability in LLMs via Reinforcement Learning</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/03/04/PLUMBER/" title="PLUMBER"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-04</div><div class="title">PLUMBER</div></div></a></div><div><a href="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/" title="通过NPM生态系统的依赖树揭开脆弱性传播及其演化的神秘面纱"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-08</div><div class="title">通过NPM生态系统的依赖树揭开脆弱性传播及其演化的神秘面纱</div></div></a></div><div><a href="/2023/04/03/Flexible-and-Optimal-Dependency-Management-via-Max-SMT/" title="Flexible and Optimal Dependency Management via Max-SMT"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-03</div><div class="title">Flexible and Optimal Dependency Management via Max-SMT</div></div></a></div><div><a href="/2023/04/11/What-the-Fork-Finding-Hidden-Code-Clones-in-npm/" title="What the Fork Finding Hidden Code Clones in npm"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-11</div><div class="title">What the Fork Finding Hidden Code Clones in npm</div></div></a></div><div><a href="/2023/04/12/Static-Type-Inference-for-Foreign-Functions-of-Python/" title="Static Type Inference for Foreign Functions of Python"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-12</div><div class="title">Static Type Inference for Foreign Functions of Python</div></div></a></div><div><a href="/2023/04/13/Where-to-Start-Studying-Type-Annotation-Practices-in-Python/" title="Where to Start Studying Type Annotation Practices in Python"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-13</div><div class="title">Where to Start Studying Type Annotation Practices in Python</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Lin Li</div><div class="author-info__description">今日事，今日毕</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">121</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Agentless%EF%BC%9ADemystifying-LLM-based-Software-Engineering-Agents"><span class="toc-number">1.</span> <span class="toc-text">Agentless：Demystifying LLM-based Software Engineering Agents</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#INTRODUCTION"><span class="toc-number">1.1.</span> <span class="toc-text">INTRODUCTION</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Background-and-Related-Work"><span class="toc-number">1.2.</span> <span class="toc-text">Background and Related Work</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-Agent-based-Software-Engineering"><span class="toc-number">1.2.1.</span> <span class="toc-text">2.1 Agent-based Software Engineering</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-Fault-Localization-and-Program-Repair"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.2 Fault Localization and Program Repair</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-LLM-based-Test-Generation"><span class="toc-number">1.2.3.</span> <span class="toc-text">2.3 LLM-based Test Generation</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AgentLess-Approach"><span class="toc-number">1.3.</span> <span class="toc-text">AgentLess Approach</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-Localization"><span class="toc-number">1.3.1.</span> <span class="toc-text">3.1 Localization</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-1-Localize-to-suspicious-files"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">3.1.1 Localize to suspicious files.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-2-Localize-to-related-elements"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">3.1.2 Localize to related elements.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-3-Localize-to-edit-locations"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">3.1.3 Localize to edit locations.</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-Repair"><span class="toc-number">1.3.2.</span> <span class="toc-text">3.2 Repair</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-Patch-Validation"><span class="toc-number">1.3.3.</span> <span class="toc-text">3.3 Patch Validation</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1-Reproduction-test-generation"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">3.3.1 Reproduction test generation.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-Patch-selection"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">3.3.2 Patch selection.</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Experimental-Setup"><span class="toc-number">1.4.</span> <span class="toc-text">Experimental Setup</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Evaluation"><span class="toc-number">1.5.</span> <span class="toc-text">Evaluation</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-Performance-on-SWE-bench-Lite"><span class="toc-number">1.5.1.</span> <span class="toc-text">5.1 Performance on SWE-bench Lite</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-1-Unique-issues-fixed"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">5.1.1 Unique issues fixed.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-2-Localization-performance"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">5.1.2 Localization performance.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-3-Reproduction-test-results"><span class="toc-number">1.5.1.3.</span> <span class="toc-text">5.1.3 Reproduction test results.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-4-Adoption-of-AGENTLESS"><span class="toc-number">1.5.1.4.</span> <span class="toc-text">5.1.4 Adoption of AGENTLESS.</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-Ablation-study-on-components-of-AGENTLESS"><span class="toc-number">1.5.2.</span> <span class="toc-text">5.2 Ablation study on components of AGENTLESS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-1-Localization-ablation"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">5.2.1 Localization ablation.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-2-Repair-ablation"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">5.2.2 Repair ablation.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-3-Patch-validation-ablation"><span class="toc-number">1.5.2.3.</span> <span class="toc-text">5.2.3 Patch validation ablation.</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Additional-Analysis-on-SWE-bench-Lite"><span class="toc-number">1.6.</span> <span class="toc-text">Additional Analysis on SWE-bench Lite</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-Problem-Classification"><span class="toc-number">1.6.1.</span> <span class="toc-text">6.1 Problem Classification</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-SWE-bench-Lite-S"><span class="toc-number">1.6.2.</span> <span class="toc-text">6.2 SWE-bench Lite-S</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-SWE-bench-Verified"><span class="toc-number">1.6.3.</span> <span class="toc-text">6.3 SWE-bench Verified</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Threats-to-Validity"><span class="toc-number">1.7.</span> <span class="toc-text">Threats to Validity</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/21/Sequence-Oriented-DBMS-Fuzzing/" title="Sequence-Oriented DBMS Fuzzing">Sequence-Oriented DBMS Fuzzing</a><time datetime="2025-02-21T09:35:08.000Z" title="发表于 2025-02-21 17:35:08">2025-02-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/18/AGENTLESS-Demystifying-LLM-based-Software-Engineering-Agents/" title="AGENTLESS: Demystifying LLM-based Software Engineering Agents">AGENTLESS: Demystifying LLM-based Software Engineering Agents</a><time datetime="2025-02-18T12:16:29.000Z" title="发表于 2025-02-18 20:16:29">2025-02-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/01/DeepSeek-R1-Incentivizing-Reasoning-Capability-in-LLMs-via-Reinforcement-Learning/" title="DeepSeek-R1: Incentivizing Reasoning Capability in LLMs via Reinforcement Learning">DeepSeek-R1: Incentivizing Reasoning Capability in LLMs via Reinforcement Learning</a><time datetime="2025-02-01T11:11:48.000Z" title="发表于 2025-02-01 19:11:48">2025-02-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/01/DeepSeek-Coder-When-the-Large-Language-Model-Meets-Programming-The-Rise-of-Code-Intelligence/" title="DeepSeek-Coder: When the Large Language Model Meets Programming - The Rise of Code Intelligence">DeepSeek-Coder: When the Large Language Model Meets Programming - The Rise of Code Intelligence</a><time datetime="2025-02-01T02:43:19.000Z" title="发表于 2025-02-01 10:43:19">2025-02-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/30/LLM-Hallucinations-in-Practical-Code-Generation-Phenomena-Mechanism-and-Mitigation/" title="LLM Hallucinations in Practical Code Generation: Phenomena, Mechanism, and Mitigation">LLM Hallucinations in Practical Code Generation: Phenomena, Mechanism, and Mitigation</a><time datetime="2025-01-30T12:14:09.000Z" title="发表于 2025-01-30 20:14:09">2025-01-30</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Lin Li</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>