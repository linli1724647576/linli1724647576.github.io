<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>Sequence-Oriented DBMS Fuzzing | LinLi's Blog</title><meta name="author" content="Lin Li"><meta name="copyright" content="Lin Li"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Sequence-Oriented DBMS FuzzingABSTRACTSQL规范包括数百种语句类型，这给DBMS模糊测试带来了困难：现有的工作通常重复使用预定义类型的语句；这些有限的类型无法覆盖完整的输入空间，从而无法有效测试相应的逻辑。本文提出了一种名为LEGO的模糊测试器，旨在生成具有丰富类型的SQL序列，以提高DBMS模糊测试的覆盖率。序列生成的关键思想是类型亲和性，即SQL类型对（例">
<meta property="og:type" content="article">
<meta property="og:title" content="Sequence-Oriented DBMS Fuzzing">
<meta property="og:url" content="http://example.com/2025/02/21/Sequence-Oriented-DBMS-Fuzzing/index.html">
<meta property="og:site_name" content="LinLi&#39;s Blog">
<meta property="og:description" content="Sequence-Oriented DBMS FuzzingABSTRACTSQL规范包括数百种语句类型，这给DBMS模糊测试带来了困难：现有的工作通常重复使用预定义类型的语句；这些有限的类型无法覆盖完整的输入空间，从而无法有效测试相应的逻辑。本文提出了一种名为LEGO的模糊测试器，旨在生成具有丰富类型的SQL序列，以提高DBMS模糊测试的覆盖率。序列生成的关键思想是类型亲和性，即SQL类型对（例">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2025-02-21T09:35:08.000Z">
<meta property="article:modified_time" content="2025-02-21T09:36:35.454Z">
<meta property="article:author" content="Lin Li">
<meta property="article:tag" content="论文阅读">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2025/02/21/Sequence-Oriented-DBMS-Fuzzing/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Sequence-Oriented DBMS Fuzzing',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-02-21 17:36:35'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">122</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="LinLi's Blog"><span class="site-name">LinLi's Blog</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Sequence-Oriented DBMS Fuzzing</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-02-21T09:35:08.000Z" title="发表于 2025-02-21 17:35:08">2025-02-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-02-21T09:36:35.454Z" title="更新于 2025-02-21 17:36:35">2025-02-21</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Sequence-Oriented DBMS Fuzzing"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Sequence-Oriented-DBMS-Fuzzing"><a href="#Sequence-Oriented-DBMS-Fuzzing" class="headerlink" title="Sequence-Oriented DBMS Fuzzing"></a>Sequence-Oriented DBMS Fuzzing</h1><h2 id="ABSTRACT"><a href="#ABSTRACT" class="headerlink" title="ABSTRACT"></a>ABSTRACT</h2><p>SQL规范包括数百种语句类型，这给DBMS模糊测试带来了困难：现有的工作通常重复使用预定义类型的语句；这些有限的类型无法覆盖完整的输入空间，从而无法有效测试相应的逻辑。本文提出了一种名为LEGO的模糊测试器，旨在生成具有丰富类型的SQL序列，以提高DBMS模糊测试的覆盖率。序列生成的关键思想是类型亲和性，即SQL类型对（例如INSERT和SELECT）之间的有意义出现。在每次模糊测试迭代中，LEGO首先主动探索不同类型的SQL语句，并根据覆盖反馈分析类型亲和性。接下来，当发现新的亲和性时，LEGO会逐步合成包含这些类型的新SQL序列。</p>
<p>我们在PostgreSQL、MySQL、MariaDB和Comdb2上评估了LEGO，并与SQLancer、SQLsmith和SQUIRREL进行了对比。基于序列的模糊测试帮助LEGO在分支覆盖率上超越了其他模糊测试器，提升幅度为44%–198%。更重要的是，在持续的模糊测试过程中，LEGO发现了102个新漏洞，并得到了相关厂商的确认，其中包括6个PostgreSQL的漏洞、21个MySQL的漏洞、42个MariaDB的漏洞和33个Comdb2的漏洞。其中，22个漏洞因其严重的安全影响已被分配了CVE编号。</p>
<h2 id="INTRODUCTION"><a href="#INTRODUCTION" class="headerlink" title="INTRODUCTION"></a>INTRODUCTION</h2><p><font color="red">Background</font></p>
<p><strong>DBMS的重要性</strong>：</p>
<ul>
<li>数据库管理系统（DBMS）对现代数据密集型系统至关重要。</li>
<li>DBMS作为用户和数据库之间的中介，负责优化和管理数据的存储与检索。</li>
</ul>
<p><strong>DBMS的安全漏洞</strong>：</p>
<ul>
<li>安全漏洞，尤其是内存漏洞（如缓冲区溢出），对DBMS特别危险，可能导致信息泄露、数据篡改、系统崩溃和重大损失。</li>
</ul>
<p><strong>现有研究的关注点</strong>：</p>
<ul>
<li>现有研究主要集中在DBMS中的逻辑错误、性能问题和内存漏洞。</li>
<li>逻辑和性能错误的测试通常使用差异测试。</li>
<li>许多模糊测试方法专注于检测DBMS的内存漏洞，特别是生成有效的SQL查询。</li>
</ul>
<p><strong>SQL类型序列的关键作用</strong>：</p>
<ul>
<li>生成的测试用例中包含的SQL类型序列对DBMS的模糊测试至关重要。</li>
<li>测试用例由一系列SQL语句组成，每个SQL语句都有特定的类型。</li>
</ul>
<p><strong>SQL类型的定义与分类</strong>：</p>
<ul>
<li>SQL语句有数百种类型，按功能分为不同类别，如SELECT和INSERT。</li>
<li>SQL类型序列是测试用例中每个SQL语句类型的顺序。</li>
</ul>
<p><strong>SQL类型序列的重要性</strong>：</p>
<ul>
<li>SQL类型序列隐含了测试用例的语义特征，其丰富性对覆盖目标DBMS的功能至关重要。</li>
<li>特定DBMS逻辑的触发：<ul>
<li>某些DBMS逻辑必须通过特定类型的语句触发，例如，仅测试SELECT语句无法触发INSERT语句的逻辑。</li>
</ul>
</li>
<li>语句顺序的影响：<ul>
<li>某些DBMS逻辑必须通过特定顺序的语句触发，如先创建表再插入数据才有意义，而先插入数据后创建表则会导致第一个语句无效。</li>
</ul>
</li>
</ul>
<p><strong>SQL类型序列的丰富性</strong>：</p>
<ul>
<li>SQL类型序列的丰富性取决于语句类型的组合和排列。</li>
</ul>
<p><font color="red">Limitations and challenges</font></p>
<p><strong>现有模糊测试的局限性</strong>：</p>
<ul>
<li>现有的模糊测试工作主要关注生成有效的测试用例，忽视了丰富SQL类型序列。</li>
<li>模糊测试器一般分为基于生成的模糊测试器和基于变异的模糊测试器。<ul>
<li><strong>基于生成的模糊测试器</strong>：根据自定义规则生成测试用例，语句类型和序列之间的关系受限，导致覆盖面有限。 SQLSmith。</li>
<li><strong>基于变异的模糊测试器</strong>：从输入池中选择测试用例（种子），通过变异生成新输入，如果触发新的代码区域，则将输入保存回池中。多数模糊测试器关注单个语句内部结构的变异，未能增加SQL类型序列的丰富性。  Squirrel。</li>
<li><img src="/2025/02/21/Sequence-Oriented-DBMS-Fuzzing/image-20250221151841125.png" alt="image-20250221151841125"></li>
</ul>
</li>
</ul>
<p><strong>现有模糊测试器的局限性</strong>：</p>
<ul>
<li>现有模糊测试器通常生成的SQL类型序列不会增加，无法探索完整的输入空间和覆盖目标DBMS中的逻辑。</li>
<li>SQLsmith等生成器主要生成SELECT语句，限制了其探索的状态空间。</li>
</ul>
<p><strong>生成丰富SQL类型序列的挑战</strong>：</p>
<ul>
<li><strong>状态爆炸</strong>：DBMS通常有<strong>数百种SQL语句类型</strong>，尽管限定序列长度，可能的序列数量仍然极为庞大。例如，假设有100种语句类型，限制序列为5条语句时，可能的唯一序列将达到100亿。</li>
<li><strong>低相关性序列</strong>：许多语句序列缺乏逻辑关联，可能不适用于有效测试。例如，一个创建触发器的语句与一个修改数据访问权限的语句之间亲和性低，组合后的序列对测试效果贡献较小。</li>
<li><strong>不适合的测试用例</strong>：生成的SQL类型序列的测试用例可能过长且包含重复子序列，这会导致模糊测试器在处理时遇到困难。</li>
</ul>
<p><font color="red">Approach and evaluation</font></p>
<p><strong>提出的方案：LEGO</strong>：</p>
<ul>
<li>LEGO旨在通过增加SQL类型序列的丰富性来提高DBMS模糊测试在发现内存安全漏洞方面的有效性。</li>
<li>关键概念是<strong>类型亲和性</strong>，即描述两个SQL语句类型之间的时间顺序关系。</li>
</ul>
<p><strong>LEGO的工作原理</strong>：</p>
<ul>
<li>LEGO采用逐步推进的方法，通过DBMS实现代码覆盖反馈指导的主动亲和性分析，探索类型亲和性。</li>
<li>在每次模糊测试迭代开始时，LEGO从现有测试用例中挑选一个，修改其中每个语句的类型，并通过覆盖分析来评估其重要性。若修改导致新的代码覆盖，则记录该亲和性。</li>
<li>LEGO通过合成新序列来利用亲和性，进一步增加覆盖率。每当发现新的亲和性时，LEGO会对包含该亲和性的所有SQL类型序列进行排列组合，生成可执行的测试用例。</li>
</ul>
<p><strong>实验评估</strong>：</p>
<ul>
<li>LEGO在PostgreSQL、MySQL、MariaDB和Comdb2的最新版本上进行了评估，并与SQLancer、SQLsmith和SQUIRREL进行了对比。</li>
<li>基于序列的模糊测试使LEGO在分支覆盖率上分别比SQLancer、SQLsmith和SQUIRREL高出198%、44%和120%。</li>
</ul>
<p><strong>漏洞发现与贡献</strong>：</p>
<ul>
<li>在持续模糊测试中，LEGO发现了102个新漏洞，而其他模糊测试器总共只发现了11个漏洞。</li>
<li>这些漏洞包括PostgreSQL的6个漏洞、MySQL的21个漏洞、MariaDB的42个漏洞和Comdb2的33个漏洞，其中22个漏洞已被确认并分配了CVE编号。</li>
</ul>
<h2 id="SQL-TYPE-SEQUENCE"><a href="#SQL-TYPE-SEQUENCE" class="headerlink" title="SQL TYPE SEQUENCE"></a>SQL TYPE SEQUENCE</h2><h4 id="Basic-concepts"><a href="#Basic-concepts" class="headerlink" title="Basic concepts."></a><strong>Basic concepts.</strong></h4><p><strong>数据库管理系统（DBMS）</strong>：</p>
<ul>
<li>管理数据库中数据存储和检索的软件。</li>
</ul>
<p><strong>结构化查询语言（SQL）</strong>：</p>
<ul>
<li>一种与DBMS交互的领域特定语言。</li>
<li>用于管理DBMS中的数据。</li>
</ul>
<p><strong>SQL语句</strong>：</p>
<ul>
<li>输入到DBMS中的最小执行单元。</li>
<li>用于执行查询或更新数据等操作。</li>
</ul>
<p><strong>测试用例或查询</strong>：</p>
<ul>
<li>DBMS模糊测试器的输入对象。</li>
<li>由一系列SQL语句组成。</li>
<li>用于DBMS的测试，特别是基本操作如变异测试。</li>
</ul>
<p><strong>种子（Seeds）</strong>：</p>
<ul>
<li>测试用例的另一种说法。</li>
<li>作为DBMS模糊测试中的输入对象，用于操作的执行。</li>
</ul>
<h4 id="SQL-statements-types"><a href="#SQL-statements-types" class="headerlink" title="SQL statements types."></a><strong>SQL statements types.</strong></h4><p><strong>SQL语句类型</strong>：</p>
<ul>
<li>SQL语句有数百种类型，每种语句类型定义了对特定对象进行特定操作。</li>
</ul>
<p><strong>主要的SQL语句类型</strong>：</p>
<ul>
<li><strong>数据定义语言（DDL）</strong>：如CREATE TABLE，用于定义数据库对象。</li>
<li><strong>数据查询语言（DQL）</strong>：如SELECT，用于查询数据。</li>
<li><strong>数据操作语言（DML）</strong>：如INSERT，用于操作数据。</li>
<li><strong>数据控制语言（DCL）</strong>：如GRANT，用于控制数据库权限。</li>
</ul>
<p><strong>事务相关语句</strong>：</p>
<ul>
<li>如COMMIT，用于处理数据库中的事务操作。</li>
</ul>
<h4 id="Definition"><a href="#Definition" class="headerlink" title="Definition."></a><strong>Definition.</strong></h4><p><strong>SQL语句类型序列（SQL Type Sequence）</strong>：</p>
<ul>
<li>是测试用例中每个SQL语句类型的序列，通过类型抽象出SQL语句的执行顺序。</li>
</ul>
<p><strong>示例</strong>：</p>
<ul>
<li>测试用例Q1的SQL类型序列为：“CREATE TABLE → INSERT → INSERT → SELECT”。</li>
<li>测试用例Q2的SQL类型序列为：“CREATE TABLE → SELECT → INSERT → INSERT”。</li>
</ul>
<p><strong>区别</strong>：</p>
<ul>
<li>虽然两个测试用例包含相同的SQL语句，但它们的SQL类型序列不同。</li>
</ul>
<h4 id="Importance-of-abundant-SQL-Type-Sequences"><a href="#Importance-of-abundant-SQL-Type-Sequences" class="headerlink" title="Importance of abundant SQL Type Sequences."></a><strong>Importance of abundant SQL Type Sequences.</strong></h4><p><strong>SQL类型序列的重要性</strong>：</p>
<ul>
<li>SQL类型序列隐含地表征了测试用例的语义，是进行充分DBMS模糊测试的关键。</li>
</ul>
<p><strong>SQL类型序列的丰富性</strong>：</p>
<ul>
<li>序列中的类型丰富性是覆盖DBMS各类功能的前提。</li>
<li>即使SQL语句相同，执行顺序的不同也会覆盖不同的代码区域，从而影响测试结果。例如，Q1和Q2虽然有相同的SQL语句组合，但执行顺序不同，导致结果不同。</li>
</ul>
<p><strong>有助于模糊测试的丰富类型序列</strong>：</p>
<ul>
<li>丰富的SQL类型序列与语句级结构和数据变异相结合，有助于更深度的模糊测试。</li>
<li>大多数现有DBMS模糊测试器擅长单个SQL语句的变异，但较少关注序列的变异。丰富的类型序列能增加探索的状态空间宽度，并通过细粒度变异进一步提升深度。</li>
</ul>
<p><strong>总结</strong>：</p>
<ul>
<li>生成丰富的SQL类型序列有助于促进模糊测试器状态空间的探索，从而发现更多潜在的BUG。然而，生成丰富类型序列面临挑战。</li>
</ul>
<p><img src="/2025/02/21/Sequence-Oriented-DBMS-Fuzzing/image-20250221152204630.png" alt="image-20250221152204630"></p>
<h4 id="Challenge-in-generating-abundant-SQL-Type-Sequences"><a href="#Challenge-in-generating-abundant-SQL-Type-Sequences" class="headerlink" title="Challenge in generating abundant SQL Type Sequences."></a><strong>Challenge in generating abundant SQL Type Sequences.</strong></h4><ul>
<li><strong>C1：SQL类型序列的状态空间巨大</strong>：<ul>
<li>随机排列或列举所有可能的组合只能探索有限空间，导致状态爆炸。</li>
<li>例如，PostgreSQL有188种SQL语句类型，若测试用例包含20个语句，则所有可能的序列数量为$3 \times 10^{45}$。即使SQUIRREL每秒执行10到60个测试用例，也需要超过$10^{35}$年才能执行所有可能的SQL类型序列。</li>
</ul>
</li>
<li><strong>C2：许多SQL类型序列没有意义</strong>：<ul>
<li>列举所有序列或随机排列可能生成没有意义的SQL类型序列，无法增加丰富性。</li>
<li>无意义的表现为：<ol>
<li>某些语句序列容易引起语义错误，导致覆盖面低。例如，执行<code>SELECT * FROM t2</code>之前若没有创建表<code>t2</code>，会导致语义错误。</li>
<li>许多语句类型没有紧密关联，形成的序列不会覆盖新的逻辑，如创建表与更改数据访问权限的语句之间没有直接关系。</li>
</ol>
</li>
</ul>
</li>
<li><strong>C3：生成的SQL类型序列不适合模糊测试</strong>：<ul>
<li>模糊测试需要大量执行生成的测试用例来寻找BUG，因此更倾向于高覆盖率且执行速度快的种子。</li>
<li>即使测试用例有丰富的SQL类型序列，可能仍不利于模糊测试。例如，<strong>SQUIRREL的测试种子包含945条SQL语句</strong>，重复调用多个类似的<code>INSERT</code>语句，虽然增加了工作负载，但对覆盖面贡献不大，导致测试执行时间过长，甚至导致程序挂起。</li>
</ul>
</li>
</ul>
<h4 id="Status-of-existing-fuzzers"><a href="#Status-of-existing-fuzzers" class="headerlink" title="Status of existing fuzzers."></a><strong>Status of existing fuzzers.</strong></h4><p><strong>现有模糊测试器的现状</strong>：</p>
<ul>
<li>现有模糊测试器主要集中在生成语法和语义正确的种子，忽视了生成丰富的SQL类型序列。</li>
</ul>
<p><strong>两种主要的模糊测试方法</strong>：</p>
<ul>
<li>生成型模糊测试器（如SQLsmith、SQLancer）：<ul>
<li>基于自定义规则生成种子。</li>
<li>为了应对挑战C1和C2，常通过手动添加大量规则来生成序列，但这种方法费时且丰富性有限。</li>
<li>为了应对C3，简化规则可以提高执行速度，但可能降低覆盖率。</li>
</ul>
</li>
<li>变异型模糊测试器（如SQUIRREL、RATEL）：<ul>
<li>通过修改已有种子来变异种子，通常只改变单个语句的结构或数据，因此测试用例的序列和关系不会改变。</li>
<li><font color="green">Griffin是变异语句的顺序？ 和 LEGO的区别是什么？</font></li>
</ul>
</li>
</ul>
<p><strong>面临的挑战</strong>：</p>
<ul>
<li><strong>C1和C2</strong>：生成有意义且丰富的SQL类型序列是技术难点，现有模糊测试器缺乏有效的解决方法。</li>
<li><strong>C3</strong>：现有方法包括选择执行快速的种子或根据覆盖率裁剪种子，但仍可能生成大型种子，导致测试卡住。</li>
</ul>
<h4 id="Basic-Idea-of-LEGO"><a href="#Basic-Idea-of-LEGO" class="headerlink" title="Basic Idea of LEGO"></a><strong>Basic Idea of LEGO</strong></h4><p><strong>LEGO的基本思路</strong>：</p>
<ul>
<li>LEGO通过探索SQL类型空间，主动分析类型之间的关联性（type-affinity），并利用这些关联性生成高质量的测试用例，增加SQL类型序列的丰富性，并适合模糊测试。</li>
</ul>
<p><strong>解决挑战C1和C2</strong>：</p>
<ul>
<li>LEGO引入类型关联性（type-affinity）来抽象生成有意义SQL类型序列的问题。</li>
<li>类型关联性是相邻SQL语句类型之间的时间关系。LEGO通过类型关联性决定在现有语句后应连接哪些类型的语句，从而探索广泛的状态空间并确保生成有意义的序列。</li>
<li>LEGO通过对现有测试用例进行序列化变异来探索新的类型关联性，并仅对覆盖新分支的种子进行关联性分析，以确保关联性有意义。</li>
</ul>
<p><strong>解决挑战C3</strong>：</p>
<ul>
<li>为适应模糊测试并生成丰富的序列，LEGO限制最大序列长度，同时使用序列合成来适应不同的序列长度。</li>
<li>尽管某些BUG只能通过长时间重复的SQL序列触发，但处理这些序列可能会降低模糊测试器的性能，甚至导致卡死。</li>
</ul>
<h4 id="Motivation-Example"><a href="#Motivation-Example" class="headerlink" title="Motivation Example"></a>Motivation Example</h4><p><img src="/2025/02/21/Sequence-Oriented-DBMS-Fuzzing/image-20250221153956446.png" alt="image-20250221153956446"></p>
<p><strong>SQL类型序列表示</strong>：</p>
<ul>
<li>LEGO使用1到6的数字表示不同的SQL语句类型：<ul>
<li>1：<code>DROP TABLE</code></li>
<li>2：<code>CREATE TABLE</code></li>
<li>3：<code>INSERT</code></li>
<li>4：<code>SELECT</code></li>
<li>5：<code>CREATE TRIGGER</code></li>
<li>6：<code>ALTER SYSTEM</code></li>
</ul>
</li>
<li>图中展示的原始测试用例较长，但为了简化，仅显示了其中的一部分。</li>
</ul>
<p><strong>关联性分析</strong>：</p>
<ul>
<li>LEGO分析测试用例中的SQL类型序列，提取出<strong>类型关联性</strong>。类型关联性是指SQL语句类型之间的关系，它们通常会一起出现在序列中。</li>
<li>例如，在第8到第11行之间，子序列是“1 → 2 → 3 → 6”（即<code>DROP TABLE → CREATE TABLE → INSERT → ALTER SYSTEM</code>），而在第231到第234行之间，子序列是“4 → 3 → 5 → 4”（即<code>SELECT → INSERT → CREATE TRIGGER → SELECT</code>）。</li>
</ul>
<p><strong>新类型关联性的发现</strong>：</p>
<ul>
<li>LEGO发现了一个新的类型关联性：“<code>INSERT</code>语句后可以跟随<code>CREATE TRIGGER</code>语句”（即3 → 5）。这种SQL语句类型之间的关系被认为是一个有用的序列，值得进一步探索。</li>
</ul>
<p><strong>序列合成</strong>：</p>
<ul>
<li>基于新的类型关联性，LEGO合成新的SQL类型序列。这些序列通常较短，SQL结构简单，但包含丰富的SQL类型。</li>
<li>新生成的序列可能覆盖新的代码路径或直接触发崩溃。例如，合成的测试用例“2 → 3 → 5 → 4”（即<code>CREATE TABLE → INSERT → CREATE TRIGGER → SELECT</code>）比原始测试用例要短，但覆盖了不同的类型，可能触发崩溃。</li>
</ul>
<p><strong>触发崩溃</strong>：</p>
<ul>
<li>最终，新的合成测试用例触发了MySQL服务器的崩溃。通过生成和执行像这样的种子，LEGO帮助模糊测试器更高效地探索状态空间，发现潜在的BUG。</li>
</ul>
<h2 id="DESIGN-OF-LEGO"><a href="#DESIGN-OF-LEGO" class="headerlink" title="DESIGN OF LEGO"></a>DESIGN OF LEGO</h2><p><img src="/2025/02/21/Sequence-Oriented-DBMS-Fuzzing/image-20250221154901557.png" alt="image-20250221154901557"></p>
<p><strong>步骤1：主动关联性分析（Proactive Affinity Analysis）</strong></p>
<ul>
<li><strong>Seed Pool</strong>（种子池）：首先，LEGO从种子池中选择一个现有的种子。种子是测试用例的起始SQL语句集合。</li>
<li><strong>Sequence Mutator</strong>（序列变异器）：LEGO执行基于序列的变异操作，改变每个语句的类型。如果变异后的种子能够覆盖目标DBMS中的新分支（即新代码路径），则记录产生的类型关联性（type-affinity）。</li>
<li><strong>Analyzer</strong>（分析器）：分析变异后的SQL类型序列，提取类型关联性（affinities），这些关联性表示了哪些SQL类型序列经常一起出现。</li>
</ul>
<p><strong>步骤2：渐进式序列合成（Progressive Sequence Synthesis）</strong></p>
<ul>
<li><strong>Sequence Generator</strong>（序列生成器）：在发现类型关联性后，LEGO生成所有包含这些类型关联性的SQL类型序列。</li>
<li><strong>Instantiator</strong>（实例化器）：将生成的SQL类型序列实例化为可执行的测试用例，并准备将这些测试用例输入到DBMS中。</li>
<li><strong>Candidate Seeds</strong>（候选种子）：生成的种子包含了新的SQL类型序列，并作为候选种子被进一步测试。</li>
<li><strong>DBMS</strong>：将这些候选种子输入到目标DBMS中进行执行。</li>
<li><strong>Bugs</strong>（错误）：如果输入的测试用例触发了错误或崩溃，LEGO就能发现这些BUG，并进一步探索DBMS的状态空间。</li>
</ul>
<h3 id="A-Proactive-Affinity-Analysis"><a href="#A-Proactive-Affinity-Analysis" class="headerlink" title="A. Proactive Affinity Analysis"></a><em>A. Proactive Affinity Analysis</em></h3><p>生成丰富的SQL类型序列可以提升DBMS模糊测试的效果，但随机排列或组合不同类型的语句往往无法形成有意义的序列，同时可能导致状态空间过大。LEGO通过主动生成新序列，利用基于序列的变异操作解决这一问题。</p>
<h4 id="1-Type-Affinity"><a href="#1-Type-Affinity" class="headerlink" title="1) Type-Affinity"></a><em><strong>1) Type-Affinity</strong></em></h4><p><strong>类型关联性（Type-Affinity）</strong>：</p>
<ul>
<li><strong>定义</strong>：在测试用例中，SQL语句的类型序列通常具有一定的模式。例如，“CREATE TABLE → INSERT → SELECT”是一种常见模式，用于创建、更新和查询数据。类型关联性描述了相邻语句类型之间的时间关系，表示某种类型的语句可能紧跟另一种类型的语句。例如，如果<code>INSERT</code>语句紧跟在<code>CREATE TABLE</code>语句之后，则认为<code>INSERT</code>与<code>CREATE TABLE</code>之间存在类型关联性。</li>
<li><strong>表示</strong>：用部分有序的元组<code>(type1, type2)</code>表示这种关系，表示<code>type1</code>可以被<code>type2</code>跟随。</li>
</ul>
<h4 id="2-Proactive-Sequence-Oriented-Mutation"><a href="#2-Proactive-Sequence-Oriented-Mutation" class="headerlink" title="2) Proactive Sequence-Oriented Mutation"></a><em><strong>2) Proactive Sequence-Oriented Mutation</strong></em></h4><p><strong>主动序列变异（Proactive Sequence-Oriented Mutation）</strong>：</p>
<ul>
<li>LEGO通过序列变异探索SQL类型序列的状态空间，以生成不同于当前测试用例的SQL类型序列。LEGO采用覆盖引导的模糊测试原则，即通过反馈的覆盖信息逐步探索程序状态空间。当变异后的SQL类型序列发现新的分支时，认为该序列是有意义的，并记录下由此产生的类型关联性供进一步合成序列使用。</li>
<li>如果生成的序列没有覆盖新分支，则认为该序列对扩展覆盖面没有帮助，将被丢弃。</li>
</ul>
<img src="/2025/02/21/Sequence-Oriented-DBMS-Fuzzing/image-20250221155707998.png" alt="image-20250221155707998" style="zoom:67%;">

<p>这个算法（Algorithm 1）展示了LEGO的<strong>基于序列的变异</strong>过程。以下是对每个步骤的解释：</p>
<p><strong>输入：</strong></p>
<ul>
<li><strong>输入种子（Q）</strong>：原始测试用例，包含一系列SQL语句。</li>
<li><strong>类型关联性（T）</strong>：在种子中已经分析出的SQL类型序列之间的关联关系。</li>
<li><strong>目标DBMS（D）</strong>：要执行和测试的数据库管理系统。</li>
</ul>
<p><strong>过程：</strong></p>
<p>算法通过三种不同的变异方法（替换、插入和删除）逐一处理输入种子中的每个SQL语句（statement）。</p>
<ol>
<li><strong>替换（Substitution）</strong>：<ul>
<li>对当前语句进行变异，替换成一个新的语句。</li>
<li><strong>步骤</strong>：首先随机选择一个不同的语句类型，并实例化它以替换当前的语句。然后，通过分析依赖关系来修复可能出现的语义错误，类似SQUIRREL的处理方法，填充SQL数据。</li>
<li><strong>类型变化</strong>：类型的变化会导致SQL类型序列的变化。如果变异后的种子触发了新的代码分支（即覆盖了新的状态），则保留该种子并分析其类型关联性。</li>
</ul>
</li>
<li><strong>插入（Insertion）</strong>：<ul>
<li>在当前语句后面插入一个新的SQL语句。</li>
<li><strong>步骤</strong>：随机选择一个SQL语句类型，实例化它作为新的语句插入到当前语句之后。同样，需要修复可能的语义错误。</li>
<li><strong>类型关联性</strong>：如果变异后的种子覆盖了新的代码分支，则保留该种子并记录其类型关联性。</li>
</ul>
</li>
<li><strong>删除（Deletion）</strong>：<ul>
<li>删除当前的SQL语句，从而生成一个新的测试用例。</li>
<li><strong>步骤</strong>：删除语句后，生成的测试用例会进行验证，并用实际数据填充。</li>
<li><strong>类型关联性</strong>：如果删除操作导致新的代码分支被覆盖，LEGO会分析删除操作引入的类型关联性。</li>
</ul>
</li>
</ol>
<p><strong>总结：</strong></p>
<ul>
<li>该算法通过三种变异方式（替换、插入和删除）变异SQL语句，并在每次变异后检查是否覆盖了新的代码分支。如果覆盖了新的分支，变异后的种子会被保存，并且相关的类型关联性会被分析和记录。</li>
<li>这样，LEGO能够在庞大的SQL类型序列状态空间中寻找有意义的序列，并帮助模糊测试器更有效地发现潜在的BUG。</li>
</ul>
<p><img src="/2025/02/21/Sequence-Oriented-DBMS-Fuzzing/image-20250221160035507.png" alt="image-20250221160035507"></p>
<p><strong>原始种子（Original Seed）</strong>：</p>
<ul>
<li>原始的SQL测试用例包含5个语句，SQL类型序列为：“CREATE TABLE → INSERT → INSERT → UPDATE → SELECT”。</li>
</ul>
<p><strong>替换（Substitution）</strong>：</p>
<ul>
<li>在变异过程中，假设我们将第4个语句（UPDATE）替换为一个DELETE语句。</li>
<li>变异后的SQL类型序列变为：“CREATE TABLE → INSERT → INSERT → DELETE → SELECT”。</li>
<li>通过这次变异，生成了两个新的类型关联性：<ul>
<li><strong>“INSERT → DELETE”</strong></li>
<li><strong>“DELETE → SELECT”</strong></li>
</ul>
</li>
<li>这些新的类型关联性帮助我们识别了更有意义的SQL语句组合。</li>
</ul>
<p><strong>插入（Insertion）</strong>：</p>
<ul>
<li>接下来，在第4个语句后插入一个DELETE语句。</li>
<li>变异后的SQL类型序列变为：“CREATE TABLE → INSERT → INSERT → UPDATE → DELETE → SELECT”。</li>
<li>插入操作生成了两个新的类型关联性：<ul>
<li><strong>“UPDATE → DELETE”</strong></li>
<li><strong>“DELETE → SELECT”</strong></li>
</ul>
</li>
</ul>
<p><strong>删除（Deletion）</strong>：</p>
<ul>
<li>最后，删除第4个语句（UPDATE）。</li>
<li>变异后的SQL类型序列变为：“CREATE TABLE → INSERT → INSERT → SELECT”。</li>
<li>删除操作创建了一个新的类型关联性：<ul>
<li><strong>“INSERT → SELECT”</strong></li>
</ul>
</li>
</ul>
<h4 id="3-Type-Affinity-Analysis"><a href="#3-Type-Affinity-Analysis" class="headerlink" title="3) Type-Affinity Analysis"></a><em>3) Type-Affinity Analysis</em></h4><p><strong>类型关联性分析（Type-Affinity Analysis）</strong>：</p>
<ul>
<li>类型关联性帮助我们抽象不同SQL语句组合的原则，通过分析这些关联性，我们可以列出SQL语句类型的新排列组合，从而生成丰富且有意义的SQL类型序列。</li>
</ul>
<p><strong>序列变异</strong>：</p>
<ul>
<li>基于类型关联性，序列变异主动探索各种可能的SQL类型序列，生成不同的测试用例。</li>
</ul>
<p><strong>提取类型关联性</strong>：</p>
<ul>
<li>提取测试用例的类型关联性，首先需要准确识别语句的SQL类型。由于DBMS可能有多种或独特的语句类型，识别这些类型是一个挑战。</li>
<li>例如，PostgreSQL定义了188种SQL语句类型、1025个关键词和349个子句类型（如表达式和“WITH”子句）。</li>
</ul>
<p><strong>解决方案</strong>：</p>
<ul>
<li>使用抽象语法树（AST）模型来准确识别SQL语句类型，该模型基于DBMS的语法规范构建，支持识别所有语句类型和其他结构。</li>
</ul>
<img src="/2025/02/21/Sequence-Oriented-DBMS-Fuzzing/image-20250221160624538.png" alt="image-20250221160624538" style="zoom:67%;">

<p>Algorithm 2）展示了类型关联性分析的过程。以下是对该算法的详细解释： </p>
<p><strong>输入：</strong></p>
<ul>
<li>**Test case (Q)**：测试用例，包含一系列SQL语句。</li>
<li>**Type-affinity map (T)**：类型关联性映射，一个字典，键是SQL语句的类型，值是一个集合，表示可以紧跟在该类型后面的其他类型。</li>
</ul>
<p><strong>过程：</strong></p>
<ol>
<li><strong>初始化</strong>：<ul>
<li><code>lastType</code> 用于记录上一个语句的类型，初始值为<code>NULL</code>。</li>
</ul>
</li>
<li><strong>遍历测试用例中的每个语句</strong>：<ul>
<li>对于测试用例中的每个SQL语句，首先通过<code>parse(s)</code>获取当前语句的类型并保存在<code>currentType</code>中（第3行）。</li>
</ul>
</li>
<li><strong>检查当前语句的类型与上一个语句类型是否相同</strong>：<ul>
<li>如果<code>lastType != NULL</code>，即之前已经有语句类型记录过，并且当前语句的类型与上一个语句类型相同（第5行），则跳过当前语句（第6-7行）。这避免了相同类型的连续语句对SQL类型序列的贡献有限。</li>
</ul>
</li>
<li><strong>记录类型关联性</strong>：<ul>
<li>如果<code>lastType</code>不在类型关联性映射<code>T</code>中（即之前没有记录该类型），则为该类型创建一个新的集合（第8行），并将其加入映射<code>T</code>（第9行）。</li>
<li>将当前语句的类型（<code>currentType</code>）加入到<code>lastType</code>对应的集合中，表示<code>lastType → currentType</code>这种类型关联性（第12行）。</li>
</ul>
</li>
<li><strong>更新</strong>：<ul>
<li>完成当前语句处理后，更新<code>lastType</code>为当前的<code>currentType</code>，并继续处理下一个SQL语句（第14行）。</li>
</ul>
</li>
<li><strong>结束</strong>：<ul>
<li>经过所有语句处理后，<code>T</code>中将记录所有在测试用例中出现的类型关联性。</li>
</ul>
</li>
</ol>
<p><strong>总结：</strong></p>
<ul>
<li>该算法的目标是分析测试用例中的类型关联性。它遍历每个SQL语句，识别相邻语句类型之间的关系，并记录这些关联性。</li>
<li>最终，生成的类型关联性映射<code>T</code>能够帮助识别哪些SQL语句类型常常一起出现，从而为生成丰富的SQL类型序列提供支持。</li>
</ul>
<h3 id="B-Progressive-Sequence-Synthesis"><a href="#B-Progressive-Sequence-Synthesis" class="headerlink" title="B. Progressive Sequence Synthesis"></a><em>B. Progressive Sequence Synthesis</em></h3><p>分析出的类型关联性为合成丰富且有意义的SQL类型序列提供了可能性。LEGO从特定的起始语句类型（如<code>CREATE TABLE</code>）开始，逐步合成所有可能的、长度不超过指定值的SQL类型序列。</p>
<p><strong>合成过程</strong>：</p>
<ul>
<li>在图6(a)中，假设根节点表示一个起始类型，每条从根节点到其他节点的路径代表一个SQL类型序列。LEGO根据分析得到的类型关联性合成所有SQL类型序列，并将这些序列实例化为测试用例，以探索目标DBMS的状态空间。</li>
</ul>
<p><strong>新类型关联性的发现</strong>：</p>
<ul>
<li>当新的类型关联性（如“4 → 6”）被发现时，LEGO不会重新合成所有SQL类型序列，而是只合成包含此新关联性的序列（如图6(b)中的红色箭头部分）。</li>
</ul>
<p><strong>前缀序列（Prefix Sequence）数据结构</strong>：</p>
<ul>
<li>为了实现渐进式合成，设计了一种数据结构——前缀序列，用于记录所有已生成的、指定长度且以某个SQL语句类型结尾的序列。</li>
<li>具体而言，使用向量S存储所有已生成的、长度不超过LEN的序列。前缀序列是一个映射，键为一对（<code>τ</code>，<code>λ</code>），值为一个向量，存储所有以类型<code>τ</code>结尾且长度为<code>λ</code>的序列的索引。</li>
<li>当LEGO发现新类型关联性<code>t1 → t2</code>时，它将根据前缀序列查找所有以<code>t1</code>结尾且长度小于LEN的序列，然后合成所有包含此新类型关联性的序列。</li>
</ul>
<p><img src="/2025/02/21/Sequence-Oriented-DBMS-Fuzzing/image-20250221161304222.png" alt="image-20250221161304222"></p>
<img src="/2025/02/21/Sequence-Oriented-DBMS-Fuzzing/image-20250221161350398.png" alt="image-20250221161350398" style="zoom:67%;">

<p>这个算法（Algorithm 3）展示了当发现新的类型关联性（t1 → t2）时，如何合成新的SQL类型序列。以下是该算法的详细解释：</p>
<p><strong>输入：</strong></p>
<ul>
<li><strong>LEN</strong>：目标序列的最大长度。</li>
<li><strong>t1 → t2</strong>：新发现的类型关联性，表示某类型语句（t1）后可以跟随另一类型语句（t2）。</li>
<li><strong>PS</strong>：前缀序列，用于记录已生成的序列。</li>
<li><strong>T</strong>：类型关联性映射，存储各个SQL类型及其可接续的类型。</li>
<li><strong>S</strong>：生成的序列向量，存储所有已合成的序列。</li>
</ul>
<p><strong>过程：</strong></p>
<ol>
<li><strong>初始化</strong>：<ul>
<li>遍历所有可能的序列长度，从1到LEN-1（第1行）。</li>
</ul>
</li>
<li><strong>查找前缀序列</strong>：<ul>
<li>对于当前长度<code>level</code>，从前缀序列中查找以<code>t1</code>结尾的所有序列（第2行）。</li>
<li>如果没有找到，则继续检查下一个长度（第3-5行）。</li>
</ul>
</li>
<li><strong>合成新序列</strong>：<ul>
<li>如果找到了以<code>t1</code>结尾的前缀序列<code>seq</code>，则在每个序列后加上<code>t2</code>，并将序列<code>seq</code>的克隆版本添加到<code>S</code>中（第6-9行）。</li>
<li>同时，将生成的序列索引记录到前缀序列<code>PS</code>中（第10行）。</li>
</ul>
</li>
<li><strong>递归合成所有可能的序列</strong>：<ul>
<li>使用递归函数<code>listSeq</code>，以<code>seq</code>为基础，生成所有可能的SQL类型序列（第11行）。</li>
<li><code>listSeq</code>函数（第14-25行）通过当前语句类型和所有类型关联性，逐步合成所有可能的下一个类型，并记录每个生成的序列。</li>
<li>一旦生成的序列长度达到目标长度<code>LEN</code>，算法就会返回，继续尝试下一个组合。</li>
</ul>
</li>
<li><strong>例子</strong>：<ul>
<li>假设目标序列的长度为2，当前序列为“CREATE TABLE”，类型关联性为“CREATE TABLE → [INSERT, SELECT]”，则生成的所有长度为2的序列为：“CREATE TABLE, INSERT”和“CREATE TABLE, SELECT”。</li>
</ul>
</li>
</ol>
<p><strong>总结：</strong></p>
<ul>
<li>该算法通过逐步合成新的SQL类型序列，利用类型关联性<code>t1 → t2</code>，确保所有可能的、符合要求的序列都被生成。生成的序列将被保存在序列向量<code>S</code>中，并通过递归方法合成所有可能的序列组合。</li>
</ul>
<p><font color="green">如何确保语义正确性？</font></p>
<p><strong>目标</strong>：</p>
<ul>
<li>LEGO通过实例化SQL类型序列生成可执行的测试用例，面临的挑战是<strong>如何确保从类型生成的SQL语句在语法和语义上都正确</strong>。</li>
</ul>
<p><strong>解决方案</strong>：</p>
<ul>
<li><strong>抽象语法树（AST）</strong>：LEGO使用AST作为测试用例和类型之间的中间表示。在实例化过程中，分析并维护语句之间的依赖关系。</li>
</ul>
<p><strong>实例化过程</strong>：</p>
<ul>
<li><strong>步骤一：AST合成</strong>：当发现新种子时，LEGO解析每个语句，提取AST结构并保存到全局库中。在实例化时，为每个SQL类型序列的条目随机选择一个类型匹配的结构，构建AST。</li>
<li><strong>步骤二：语句连接</strong>：LEGO将每个AST条目翻译为SQL语句，并将它们连接成候选SQL测试用例。</li>
<li><strong>步骤三：验证</strong>：候选测试用例被重新翻译为AST，分析不同数据之间的依赖关系，并填充满足所有依赖关系的具体值。然后，将AST转换为可执行的测试用例并提交给目标DBMS。</li>
</ul>
<p><strong>多次实例化</strong>：</p>
<ul>
<li>由于随机选择结构，一个SQL类型序列会被多次实例化，从而增加AST结构和类型序列组合的多样性。</li>
</ul>
<p><strong>示例</strong>：</p>
<ul>
<li>对于“PRAGMA → CREATE TABLE → INSERT”序列，LEGO首先构建SQL语句框架并随机实例化数据，但可能包含语义错误，如表v2不存在。然后，LEGO通过构建数据依赖图修复这些错误，最终生成正确的测试用例：“PRAGMA foreign keys&#x3D;ON; CREATE TABLE v0(x INT PRIMARY KEY, y INT REFERENCE); INSERT INTO v0(x) VALUES(100);”。</li>
</ul>
<h2 id="IMPLEMENTATION"><a href="#IMPLEMENTATION" class="headerlink" title="IMPLEMENTATION"></a>IMPLEMENTATION</h2><ol>
<li><strong>实现基础</strong>：<ul>
<li>LEGO基于AFL++实现，包含两个主要组件：**类型关联性分析器（Affinity Analyzer）**和**序列合成器（Sequence Synthesizer）**。</li>
<li>类型关联性分析器实现了算法1和2，用于分析并记录新的类型关联性。</li>
<li>序列合成器实现了算法3，用于合成新的SQL类型序列。</li>
<li>LEGO将这两个组件作为AFL++的自定义变异器（mutator）集成。</li>
</ul>
</li>
<li><strong>支持组件</strong>：<ul>
<li><strong>AST解析器（AST Parser）</strong>：为类型关联性分析器和序列合成器提供支持，使用SQUIRREL定义的中间表示（IR）。AST解析器基于Bison 3.3.2和Flex 2.6.4实现，确保支持最新DBMS的特性和方言。</li>
</ul>
</li>
<li><strong>数据库支持</strong>：<ul>
<li>对MariaDB和MySQL的解析器使用了748个Flex令牌定义、852个声明和2855个规则；对PostgreSQL和Comdb2使用了494个、695个声明和3179个规则等。</li>
</ul>
</li>
<li><strong>适应性与转换</strong>：<ul>
<li>为了适应DBMS，LEGO还编写了逻辑来将这些新规则转换为IR，并能够将IR转换回SQL语句。</li>
<li>LEGO使用AFL++的持久模式编写了特定DBMS的模糊测试驱动程序。</li>
</ul>
</li>
</ol>
<h2 id="EVALUATION"><a href="#EVALUATION" class="headerlink" title="EVALUATION"></a>EVALUATION</h2><p>我们评估了LEGO在发现新漏洞以及在探索目标DBMS状态空间方面的效率。评估的目的是回答以下研究问题：</p>
<ul>
<li><strong>RQ1</strong>：LEGO能否发现新的漏洞？</li>
<li><strong>RQ2</strong>：LEGO是否优于其他先进的DBMS模糊测试工具？</li>
<li><strong>RQ3</strong>：基于序列的算法效果如何？</li>
</ul>
<h3 id="A-Evaluation-Setup"><a href="#A-Evaluation-Setup" class="headerlink" title="A. Evaluation Setup"></a><em>A. Evaluation Setup</em></h3><ol>
<li><strong>测试的DBMS和对比的模糊测试器</strong>：<ul>
<li>为评估LEGO的通用性和效率，使用了四个流行的开源DBMS：PostgreSQL、MySQL、MariaDB和Comdb2，涵盖了广泛应用于工业和学术研究的数据库系统。</li>
<li>将LEGO与其他流行的模糊测试器进行对比，包括来自学术界的SQUIRREL和SQLancer，以及来自工业界的SQLsmith。</li>
</ul>
</li>
<li><strong>基本设置</strong>：<ul>
<li>实验在一台运行64位Ubuntu 20.04的机器上进行，配备128个核心（AMD EPYC 7742处理器，2.25 GHz）和488 GiB内存。</li>
<li>所有DBMS都使用了AddressSanitizer（ASAN）进行检测。每个模糊测试器使用其默认配置。</li>
<li>每个DBMS与一个模糊测试器一起运行24小时，以进行全面对比。每个模糊测试器实例单独在docker中运行，并使用一个CPU核心。</li>
</ul>
</li>
<li><strong>兼容性问题</strong>：<ul>
<li>由于SQLsmith未官方支持MySQL、MariaDB和Comdb2的语法，实验仅在PostgreSQL上将LEGO与SQLsmith进行对比。</li>
</ul>
</li>
<li><strong>错误识别与分析</strong>：<ul>
<li>通过比较调用栈，区分不同的BUG。为了提高准确性，还进行了手动分析。</li>
</ul>
</li>
</ol>
<h3 id="B-DBMS-Vulnerability-Detection"><a href="#B-DBMS-Vulnerability-Detection" class="headerlink" title="B. DBMS Vulnerability Detection"></a><em>B. DBMS Vulnerability Detection</em></h3><ol>
<li><strong>总体结果</strong>：<ul>
<li>四个测试的DBMS广泛使用且已被工程师广泛测试，发现新漏洞较为困难。尽管如此，LEGO在连续模糊测试中检测到102个漏洞，而其他工具总共只发现了11个漏洞。具体来说，SQLancer和SQLsmith没有发现任何漏洞，SQUIRREL在MySQL中发现了3个漏洞，在MariaDB中发现了8个漏洞。</li>
<li>LEGO分别在PostgreSQL、MySQL、MariaDB和Comdb2中发现了6、21、42和33个漏洞。</li>
</ul>
</li>
<li><strong>漏洞详情</strong>：<ul>
<li>在<strong>102个漏洞</strong>中，有61个是高危漏洞，包括17个缓冲区溢出、7个释放后使用、29个段错误和8个使用后污染漏洞，这些漏洞可以被攻击者远程利用，导致任意代码执行、系统控制或权限提升。</li>
<li>还有6个空指针解引用、13个断言失败和22个未定义行为，表明DBMS内部错误，可能导致拒绝服务或其他意外损害。</li>
</ul>
</li>
<li><strong>漏洞报告与确认</strong>：<ul>
<li>所有漏洞已报告给相应的DBMS供应商并获得确认反馈。在撰写论文时，22个漏洞已在美国国家漏洞数据库（NVD）中确认，并成为CVE。根据CVSS评分，其中8个CVE被标记为高风险，8个为中风险，6个由于其高危性和复杂性按供应商要求被保留（尚未公开且未评分）。</li>
</ul>
</li>
<li><strong>总结</strong>：<ul>
<li>结果表明，基于序列的模糊测试有助于LEGO探索DBMS中的意外状态，这些状态可能导致严重的漏洞。通过分析漏洞，发现许多漏洞与意外的SQL类型序列相关。</li>
</ul>
</li>
</ol>
<p><img src="/2025/02/21/Sequence-Oriented-DBMS-Fuzzing/image-20250221165625740.png" alt="image-20250221165625740"></p>
<p><strong>漏洞为何仅被LEGO检测到：</strong></p>
<ul>
<li>该漏洞是由一个意外的SQL类型序列引发的，这种序列测试者很少使用，因此漏洞长期未被发现。</li>
<li>LEGO通过分析类型关联性，合成包含预期序列的丰富SQL类型序列。基于合成种子的类型序列，LEGO有效地变异这些种子，最终合成出特定的测试用例来触发该漏洞。</li>
<li>其他模糊测试器难以构建特定的SQL类型序列，因此无法发现这个漏洞。具体而言：<ul>
<li><strong>SQLsmith</strong>主要生成<code>SELECT</code>语句，忽略了由不同类型的SQL语句组成的漏洞。</li>
<li><strong>SQLancer</strong>基于自定义规则生成测试用例，主要针对<code>SELECT</code>语句，能够生成的SQL类型序列有限。</li>
<li><strong>SQUIRREL</strong>通过改变单个语句的结构或数据生成测试用例，难以生成新的SQL类型序列，无法覆盖现有种子中未包含的序列。因此，包含新SQL类型序列的漏洞未被它们发现。</li>
</ul>
</li>
</ul>
<h3 id="C-Comparison-with-Other-DBMS-Fuzzers"><a href="#C-Comparison-with-Other-DBMS-Fuzzers" class="headerlink" title="C. Comparison with Other DBMS Fuzzers"></a><em>C. Comparison with Other DBMS Fuzzers</em></h3><p><strong>评估标准</strong>：</p>
<ul>
<li>使用<strong>覆盖的分支</strong>和<strong>触发的漏洞</strong>两个指标来评估模糊测试器的表现。评估时，比较了LEGO与SQLancer、SQLsmith和SQUIRREL的效果。</li>
</ul>
<p><strong>覆盖率</strong>：</p>
<ul>
<li>图9显示了24小时模糊测试中不同模糊测试器覆盖的分支数量。结果表明，LEGO在覆盖率上表现优异，分别比SQLancer、SQLsmith和SQUIRREL多覆盖了198%、44%和120%的分支。</li>
<li>LEGO的优势在于它生成丰富的SQL类型序列，能够敏感地反映SQL语句的执行顺序，从而覆盖更多的代码区域并触发隐藏的漏洞。相比之下，SQLancer和SQLsmith生成的SQL类型序列有限，难以覆盖所有代码区域。</li>
<li><img src="/2025/02/21/Sequence-Oriented-DBMS-Fuzzing/image-20250221170106749.png" alt="image-20250221170106749" style="zoom:50%;"></li>
</ul>
<p><strong>类型关联性</strong>：</p>
<ul>
<li>表II显示了不同模糊测试器生成的种子在24小时内包含的类型关联性。LEGO通过主动探索类型序列空间并分析变异种子中的新关联性，生成更多有意义的序列，从而提高了SQL类型序列的丰富性，进而提高了覆盖率。</li>
<li><img src="/2025/02/21/Sequence-Oriented-DBMS-Fuzzing/image-20250221170152479.png" alt="image-20250221170152479" style="zoom:67%;"></li>
</ul>
<p><strong>漏洞检测</strong>：</p>
<ul>
<li>表III显示了每个模糊测试器发现的漏洞数量。LEGO分别比SQLancer、SQLsmith和SQUIRREL多发现了52、52和41个漏洞。</li>
<li>SQLancer主要检测逻辑漏洞，但由于预定义规则的限制，它未能触发最新版本DBMS中的漏洞。SQLsmith生成的语句类型有限，尤其是<code>SELECT</code>语句，虽然确保了语法正确性，但未能在PostgreSQL的最新版本中发现漏洞。</li>
<li>LEGO通过更广泛的状态空间探索发现了更多漏洞，且很多漏洞是由意外的SQL类型序列引发的。LEGO通过分析有意义的测试用例中的类型关联性，合成丰富的SQL类型序列，从而发现了更多漏洞。</li>
<li><img src="/2025/02/21/Sequence-Oriented-DBMS-Fuzzing/image-20250221170216519.png" alt="image-20250221170216519" style="zoom: 67%;"></li>
</ul>
<h3 id="D-Effectiveness-of-Sequence-Oriented-Algorithms-in-LEGO"><a href="#D-Effectiveness-of-Sequence-Oriented-Algorithms-in-LEGO" class="headerlink" title="D. Effectiveness of Sequence-Oriented Algorithms in LEGO"></a><em>D. Effectiveness of Sequence-Oriented Algorithms in</em> LEGO</h3><p>为了评估序列导向模糊测试算法的有效性，并排除其他因素的干扰（如AST解析器的扩展），我们实现了一个对比版本**LEGO-**，禁用了序列导向算法，包括主动的类型关联性分析和渐进的序列合成。然后，我们将LEGO与LEGO-在PostgreSQL、MySQL、MariaDB和Comdb2上进行了24小时对比。</p>
<ol>
<li><strong>类型关联性的发现</strong>：<ul>
<li>LEGO能发现比LEGO-更多的类型关联性。具体来说，LEGO在PostgreSQL、MySQL、MariaDB和Comdb2上分别比LEGO多发现337、48、119和29个类型关联性。</li>
<li>禁用序列导向算法后，LEGO-的常规变异方法仅限于改变测试用例中的单个语句，而LEGO通过主动探索类型关联性来增加SQL类型序列的丰富性，从而发现更多类型关联性。</li>
</ul>
</li>
<li><strong>分支覆盖率</strong>：<ul>
<li>由于发现更多类型关联性，LEGO能够在四个DBMS上覆盖更多的分支。具体来说，LEGO在PostgreSQL、MySQL、MariaDB和Comdb2上分别比LEGO多覆盖20%、15%、25%和7%的分支。</li>
<li>更多的类型关联性帮助LEGO合成更多有意义的SQL类型序列，增加了序列的丰富性，从而触发了更多的DBMS功能，导致覆盖更多分支。</li>
</ul>
</li>
<li><strong>类型关联性与分支覆盖率的关系</strong>：<ul>
<li>结果表明，DBMS的语句类型越多，LEGO在发现类型关联性和覆盖分支方面的改进也越大。具体来说，当一个DBMS具有更多的语句类型时，LEGO能够发现更多的类型关联性，从而提高覆盖率。</li>
<li>例如，LEGO在PostgreSQL上比LEGO多发现337个类型关联性，并且在分支覆盖率上提高了20%。对于Comdb2，由于其语句类型较少，LEGO的改进较小，但依然在类型关联性和分支覆盖率上有所提升。</li>
</ul>
</li>
</ol>
<p><strong>总结：</strong></p>
<ul>
<li>序列导向算法显著提高了LEGO在发现类型关联性和覆盖分支方面的表现，尤其是在语句类型较多的DBMS中，LEGO比LEGO-取得了更大的改进。</li>
</ul>
<p><img src="/2025/02/21/Sequence-Oriented-DBMS-Fuzzing/image-20250221170634779.png" alt="image-20250221170634779"></p>
<h2 id="DISCUSSION"><a href="#DISCUSSION" class="headerlink" title="DISCUSSION"></a>DISCUSSION</h2><p><strong>冗余类型关联性：</strong></p>
<ul>
<li>在主动的类型关联性分析中，除了SQL类型的变化外，数据的变化或非相邻SQL语句的组合可能会触发新的覆盖并产生冗余的类型关联性。尽管如此，这对LEGO的影响有限。LEGO通过逐步合成包含新类型关联性的序列来避免冗余关联性浪费过多资源。对于非相邻SQL语句的组合产生的冗余关联性，LEGO可以通过传递关系学习到，例如，如果<code>A→B</code>和<code>B→C</code>被发现，LEGO也能推断出<code>A→B→C</code>。</li>
</ul>
<p><strong>合成测试用例的语义丰富性：</strong></p>
<ul>
<li>LEGO在合成过程中通过解析AST结构并与SQL类型序列结合，重构了语义信息。然而，某些语义信息仍可能丢失。未来计划自动学习语义信息（如语句间的依赖关系）并用来指导序列合成。</li>
</ul>
<p><strong>限制序列长度可能错过一些漏洞：</strong></p>
<ul>
<li>一些漏洞只能通过长时间重复的序列触发，但处理这些长序列可能导致性能下降或使模糊测试器挂起。为了平衡，LEGO限制了序列长度。在对MariaDB进行的实验中，LEGO在不同长度设置下分别找到了30、35和27个漏洞，表明过短或过长的序列都会错过一些漏洞。未来计划将长序列拆分为多个等效的短序列，以检测这类漏洞。</li>
</ul>
<p><strong>LEGO的适应性：</strong></p>
<ul>
<li>LEGO的方案适用于大多数DBMS。要适应新DBMS，LEGO需要学习该DBMS特定的SQL类型信息，这可以通过提供原始语法规范来实现。LEGO将自动从语法规范中推导SQL类型信息，并重用现有的类型关联性基础设施。然而，语句类型的数量会影响LEGO的性能。例如，LEGO在Comdb2上的改进较小，未来计划通过增加合成序列的多样性来解决这一问题。</li>
</ul>
<p><strong>扩展现有模糊测试器的可行性：</strong></p>
<ul>
<li>直接将LEGO的解决方案简单地应用到现有模糊测试器上并不容易。可以通过使用LEGO发现的类型关联性来扩展现有模糊测试器。对于基于生成的模糊测试器，可以添加LEGO的类型关联性转化规则；对于基于变异的模糊测试器，可以在LEGO类型关联性的指导下添加变异操作符。然而，现有工作如果没有LEGO的结果，则需要重新实现LEGO的逻辑来有效增加丰富性。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Lin Li</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/02/21/Sequence-Oriented-DBMS-Fuzzing/">http://example.com/2025/02/21/Sequence-Oriented-DBMS-Fuzzing/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">LinLi's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/">论文阅读</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/04/08/%E8%A7%A3%E5%86%B3Camera-ready-%E2%9C%98-Problem-Not-all-fonts-are-embedded-%E9%97%AE%E9%A2%98/" title="解决Camera ready ✘ Problem: Not all fonts are embedded. 问题"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">解决Camera ready ✘ Problem: Not all fonts are embedded. 问题</div></div></a></div><div class="next-post pull-right"><a href="/2025/02/18/AGENTLESS-Demystifying-LLM-based-Software-Engineering-Agents/" title="AGENTLESS: Demystifying LLM-based Software Engineering Agents"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">AGENTLESS: Demystifying LLM-based Software Engineering Agents</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/03/04/PLUMBER/" title="PLUMBER"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-04</div><div class="title">PLUMBER</div></div></a></div><div><a href="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/" title="通过NPM生态系统的依赖树揭开脆弱性传播及其演化的神秘面纱"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-08</div><div class="title">通过NPM生态系统的依赖树揭开脆弱性传播及其演化的神秘面纱</div></div></a></div><div><a href="/2023/04/03/Flexible-and-Optimal-Dependency-Management-via-Max-SMT/" title="Flexible and Optimal Dependency Management via Max-SMT"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-03</div><div class="title">Flexible and Optimal Dependency Management via Max-SMT</div></div></a></div><div><a href="/2023/04/11/What-the-Fork-Finding-Hidden-Code-Clones-in-npm/" title="What the Fork Finding Hidden Code Clones in npm"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-11</div><div class="title">What the Fork Finding Hidden Code Clones in npm</div></div></a></div><div><a href="/2023/04/12/Static-Type-Inference-for-Foreign-Functions-of-Python/" title="Static Type Inference for Foreign Functions of Python"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-12</div><div class="title">Static Type Inference for Foreign Functions of Python</div></div></a></div><div><a href="/2023/04/13/Where-to-Start-Studying-Type-Annotation-Practices-in-Python/" title="Where to Start Studying Type Annotation Practices in Python"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-13</div><div class="title">Where to Start Studying Type Annotation Practices in Python</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Lin Li</div><div class="author-info__description">今日事，今日毕</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">122</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Sequence-Oriented-DBMS-Fuzzing"><span class="toc-number">1.</span> <span class="toc-text">Sequence-Oriented DBMS Fuzzing</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ABSTRACT"><span class="toc-number">1.1.</span> <span class="toc-text">ABSTRACT</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#INTRODUCTION"><span class="toc-number">1.2.</span> <span class="toc-text">INTRODUCTION</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SQL-TYPE-SEQUENCE"><span class="toc-number">1.3.</span> <span class="toc-text">SQL TYPE SEQUENCE</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Basic-concepts"><span class="toc-number">1.3.0.1.</span> <span class="toc-text">Basic concepts.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SQL-statements-types"><span class="toc-number">1.3.0.2.</span> <span class="toc-text">SQL statements types.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Definition"><span class="toc-number">1.3.0.3.</span> <span class="toc-text">Definition.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Importance-of-abundant-SQL-Type-Sequences"><span class="toc-number">1.3.0.4.</span> <span class="toc-text">Importance of abundant SQL Type Sequences.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Challenge-in-generating-abundant-SQL-Type-Sequences"><span class="toc-number">1.3.0.5.</span> <span class="toc-text">Challenge in generating abundant SQL Type Sequences.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Status-of-existing-fuzzers"><span class="toc-number">1.3.0.6.</span> <span class="toc-text">Status of existing fuzzers.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Basic-Idea-of-LEGO"><span class="toc-number">1.3.0.7.</span> <span class="toc-text">Basic Idea of LEGO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Motivation-Example"><span class="toc-number">1.3.0.8.</span> <span class="toc-text">Motivation Example</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DESIGN-OF-LEGO"><span class="toc-number">1.4.</span> <span class="toc-text">DESIGN OF LEGO</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#A-Proactive-Affinity-Analysis"><span class="toc-number">1.4.1.</span> <span class="toc-text">A. Proactive Affinity Analysis</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Type-Affinity"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">1) Type-Affinity</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Proactive-Sequence-Oriented-Mutation"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">2) Proactive Sequence-Oriented Mutation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Type-Affinity-Analysis"><span class="toc-number">1.4.1.3.</span> <span class="toc-text">3) Type-Affinity Analysis</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-Progressive-Sequence-Synthesis"><span class="toc-number">1.4.2.</span> <span class="toc-text">B. Progressive Sequence Synthesis</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IMPLEMENTATION"><span class="toc-number">1.5.</span> <span class="toc-text">IMPLEMENTATION</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EVALUATION"><span class="toc-number">1.6.</span> <span class="toc-text">EVALUATION</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#A-Evaluation-Setup"><span class="toc-number">1.6.1.</span> <span class="toc-text">A. Evaluation Setup</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-DBMS-Vulnerability-Detection"><span class="toc-number">1.6.2.</span> <span class="toc-text">B. DBMS Vulnerability Detection</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-Comparison-with-Other-DBMS-Fuzzers"><span class="toc-number">1.6.3.</span> <span class="toc-text">C. Comparison with Other DBMS Fuzzers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#D-Effectiveness-of-Sequence-Oriented-Algorithms-in-LEGO"><span class="toc-number">1.6.4.</span> <span class="toc-text">D. Effectiveness of Sequence-Oriented Algorithms in LEGO</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DISCUSSION"><span class="toc-number">1.7.</span> <span class="toc-text">DISCUSSION</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/08/%E8%A7%A3%E5%86%B3Camera-ready-%E2%9C%98-Problem-Not-all-fonts-are-embedded-%E9%97%AE%E9%A2%98/" title="解决Camera ready ✘ Problem: Not all fonts are embedded. 问题">解决Camera ready ✘ Problem: Not all fonts are embedded. 问题</a><time datetime="2025-04-08T14:19:21.000Z" title="发表于 2025-04-08 22:19:21">2025-04-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/21/Sequence-Oriented-DBMS-Fuzzing/" title="Sequence-Oriented DBMS Fuzzing">Sequence-Oriented DBMS Fuzzing</a><time datetime="2025-02-21T09:35:08.000Z" title="发表于 2025-02-21 17:35:08">2025-02-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/18/AGENTLESS-Demystifying-LLM-based-Software-Engineering-Agents/" title="AGENTLESS: Demystifying LLM-based Software Engineering Agents">AGENTLESS: Demystifying LLM-based Software Engineering Agents</a><time datetime="2025-02-18T12:16:29.000Z" title="发表于 2025-02-18 20:16:29">2025-02-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/01/DeepSeek-R1-Incentivizing-Reasoning-Capability-in-LLMs-via-Reinforcement-Learning/" title="DeepSeek-R1: Incentivizing Reasoning Capability in LLMs via Reinforcement Learning">DeepSeek-R1: Incentivizing Reasoning Capability in LLMs via Reinforcement Learning</a><time datetime="2025-02-01T11:11:48.000Z" title="发表于 2025-02-01 19:11:48">2025-02-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/01/DeepSeek-Coder-When-the-Large-Language-Model-Meets-Programming-The-Rise-of-Code-Intelligence/" title="DeepSeek-Coder: When the Large Language Model Meets Programming - The Rise of Code Intelligence">DeepSeek-Coder: When the Large Language Model Meets Programming - The Rise of Code Intelligence</a><time datetime="2025-02-01T02:43:19.000Z" title="发表于 2025-02-01 10:43:19">2025-02-01</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Lin Li</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>