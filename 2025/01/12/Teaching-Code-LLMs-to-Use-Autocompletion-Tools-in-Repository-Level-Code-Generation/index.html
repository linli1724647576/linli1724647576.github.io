<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>Teaching Code LLMs to Use Autocompletion Tools in Repository-Level Code Generation | LinLi's Blog</title><meta name="author" content="Lin Li"><meta name="copyright" content="Lin Li"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Teaching Code LLMs to Use Autocompletion Tools in Repository-Level Code GenerationABSTRACET摘要：近年来，大型代码语言模型（LLMs）在生成独立函数方面表现出色。然而，由于缺乏对仓库级依赖（如用户自定义属性）的感知，它们在仓库级代码生成中存在一定局限性，容易导致依赖性错误，例如未定义变量错误和缺少成员错误。在">
<meta property="og:type" content="article">
<meta property="og:title" content="Teaching Code LLMs to Use Autocompletion Tools in Repository-Level Code Generation">
<meta property="og:url" content="http://example.com/2025/01/12/Teaching-Code-LLMs-to-Use-Autocompletion-Tools-in-Repository-Level-Code-Generation/index.html">
<meta property="og:site_name" content="LinLi&#39;s Blog">
<meta property="og:description" content="Teaching Code LLMs to Use Autocompletion Tools in Repository-Level Code GenerationABSTRACET摘要：近年来，大型代码语言模型（LLMs）在生成独立函数方面表现出色。然而，由于缺乏对仓库级依赖（如用户自定义属性）的感知，它们在仓库级代码生成中存在一定局限性，容易导致依赖性错误，例如未定义变量错误和缺少成员错误。在">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2025-01-12T10:28:21.000Z">
<meta property="article:modified_time" content="2025-01-12T10:29:05.979Z">
<meta property="article:author" content="Lin Li">
<meta property="article:tag" content="论文阅读">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2025/01/12/Teaching-Code-LLMs-to-Use-Autocompletion-Tools-in-Repository-Level-Code-Generation/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Teaching Code LLMs to Use Autocompletion Tools in Repository-Level Code Generation',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-01-12 18:29:05'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">122</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="LinLi's Blog"><span class="site-name">LinLi's Blog</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Teaching Code LLMs to Use Autocompletion Tools in Repository-Level Code Generation</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-01-12T10:28:21.000Z" title="发表于 2025-01-12 18:28:21">2025-01-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-01-12T10:29:05.979Z" title="更新于 2025-01-12 18:29:05">2025-01-12</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Teaching Code LLMs to Use Autocompletion Tools in Repository-Level Code Generation"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Teaching-Code-LLMs-to-Use-Autocompletion-Tools-in-Repository-Level-Code-Generation"><a href="#Teaching-Code-LLMs-to-Use-Autocompletion-Tools-in-Repository-Level-Code-Generation" class="headerlink" title="Teaching Code LLMs to Use Autocompletion Tools in Repository-Level Code Generation"></a>Teaching Code LLMs to Use Autocompletion Tools in Repository-Level Code Generation</h1><h2 id="ABSTRACET"><a href="#ABSTRACET" class="headerlink" title="ABSTRACET"></a>ABSTRACET</h2><p>摘要：近年来，大型代码语言模型（LLMs）在生成独立函数方面表现出色。然而，<strong>由于缺乏对仓库级依赖（如用户自定义属性）的感知，它们在仓库级代码生成中存在一定局限性，容易导致依赖性错误，例如未定义变量错误和缺少成员错误。在本研究中，我们提出了TOOLGEN方法，通过将自动补全工具集成到代码LLM的生成过程中，以解决这些依赖性问题。</strong>TOOLGEN包含两个主要阶段：触发器插入和模型微调（离线阶段），以及工具集成代码生成（在线阶段）。在离线阶段，TOOLGEN对给定代码语料库中的函数进行增强，加入一个特殊的标记符号，用于指示触发自动补全工具的位置。这些增强的函数及其对应的描述随后用于微调所选的代码LLM。在在线阶段，TOOLGEN通过微调后的LLM逐步预测生成函数的每个标记。当遇到标记符号时，TOOLGEN调用自动补全工具提供代码补全建议，并通过约束贪婪搜索选择最合适的建议。</p>
<p>我们进行了全面的实验，评估了TOOLGEN在三种代码LLM（CodeGPT、CodeT5和CodeLlama）上的仓库级代码生成效果。为了辅助评估，我们创建了一个包含671个真实代码仓库的基准数据集，并引入了两个新的依赖性指标：依赖覆盖率（Dependency Coverage）和静态有效率（Static Validity Rate）。实验结果表明，TOOLGEN在三种代码LLM上显著提升了依赖覆盖率（31.4%至39.1%）和静态有效率（44.9%至57.7%），同时在广泛认可的相似性指标（如BLEU-4、CodeBLEU、编辑相似度和精确匹配）上也保持了竞争性或更好的表现。在CoderEval数据集上，TOOLGEN在CodeT5和CodeLlama的测试通过率（Pass@1）上分别提升了40.0%和25.0%，同时在CodeGPT上保持了相同的通过率。此外，TOOLGEN在仓库级代码生成中表现出较高的效率，每个函数的生成延迟在0.63至2.34秒之间。进一步的通用性评估证实，TOOLGEN在不同代码LLM模型架构和规模上的表现始终保持一致。</p>
<h2 id="INTRODUCTION"><a href="#INTRODUCTION" class="headerlink" title="INTRODUCTION"></a>INTRODUCTION</h2><p><font color="red">Background</font></p>
<p><strong>代码生成的背景与发展</strong>：</p>
<ul>
<li>代码生成一直是软件工程领域的重点研究方向。</li>
<li>最近的研究引入了多种基于Transformer模型架构的大型代码语言模型（LLMs），通过对大规模代码语料库的预训练或微调，实现了代码自动生成。</li>
<li>这些LLMs在代码块或函数的生成中表现出色，例如CodeLlama在HumanEval和MBPP等基准测试中达到了开源代码LLMs的最新性能。</li>
</ul>
<p><strong>现有代码LLMs的局限性</strong>：</p>
<ul>
<li>实际代码仓库中超过70%的函数并非独立函数，而代码LLMs缺乏对仓库级依赖（如用户自定义函数和属性）的感知。</li>
<li>这种局限性会导致生成的代码中出现依赖性错误（如未定义变量错误和缺少成员错误），显著降低其可用性和有效性。</li>
</ul>
<p><strong>现代IDE的自动补全工具</strong>：</p>
<ul>
<li>IDE中的自动补全工具（如Jedi）通过程序分析，能分析当前不完整的函数状态和上下文，提供有效的代码补全建议。</li>
<li>这些工具可以推荐当前对象可访问的变量、属性和函数。例如：<ul>
<li>在图1中，Jedi面对“self.”时，推荐了68个属性，其中包括目标建议“_registered_updates”。</li>
</ul>
</li>
</ul>
<p><strong>外部工具与LLMs的结合尝试</strong>：</p>
<ul>
<li><strong>ToolFormer</strong>：通过增强数据集，教会LLMs调用现有的外部工具（如算术计算器），显著减少涉及算术计算的文本生成错误。</li>
<li><strong>ToolCoder</strong>：设计用于指导LLMs在生成代码时使用基于信息检索（IR）的API搜索工具，主要解决独立函数的功能正确性，但其忽略了仓库级依赖。</li>
<li><strong>Repilot</strong>：利用代码补全工具过滤掉LLMs生成的无效修复建议，专注于单点错误修复（如生成单块补丁），但在函数级代码生成中会频繁调用自动补全工具，导致开销较大。</li>
</ul>
<p><strong>工具结合的挑战</strong>：</p>
<ul>
<li>当前工具（如ToolCoder）未充分考虑仓库级依赖，难以解决依赖性错误。</li>
<li>对多候选建议的处理能力不足，使得这些工具在复杂场景下的应用效果有限。</li>
</ul>
<p><font color="red">Motivation example</font></p>
<p><strong>图1示例说明</strong>：</p>
<ul>
<li><p>问题</p>
<p>：在代码仓库“zomux&#x2F;deepy”的文件“layers&#x2F;layer.py”中，函数register_updates的生成场景。</p>
<ul>
<li><strong>CodeLlama生成结果</strong>：预测了属性“_updates”，但因“self”对象没有该属性，导致“no-member error”错误。</li>
<li><strong>Jedi补全结果</strong>：推荐了68个属性，其中包含目标“_registered_updates”，可以有效避免上述错误。</li>
</ul>
</li>
</ul>
<p><strong>意义</strong>： 通过结合像Jedi这样的自动补全工具，能够显著提高代码生成的正确性，解决依赖性错误的问题。</p>
<p><img src="/2025/01/12/Teaching-Code-LLMs-to-Use-Autocompletion-Tools-in-Repository-Level-Code-Generation/image-20250112173658257.png" alt="image-20250112173658257"></p>
<p><font color="red">Approach</font></p>
<p><strong>目标</strong></p>
<p>将基于程序分析的代码自动补全工具集成到代码LLMs的生成过程中，以支持仓库级代码生成。</p>
<p><strong>主要挑战</strong></p>
<ol>
<li><strong>触发自动补全工具的时机</strong>：<ul>
<li>LLMs逐步解码生成代码，每步生成一个标记，但函数可能包含数十到数百个标记，不可能在每步都调用补全工具。</li>
<li>现有方法（如ToolFormer、ToolCoder）通过标注特殊标记来触发工具，但对仓库级依赖的处理效果不佳，需精准定位用户自定义变量等依赖的位置。</li>
</ul>
</li>
<li><strong>从推荐建议中选择目标补全</strong>：<ul>
<li>补全工具（如Jedi）通常返回多个建议（如图1中有68个），目标建议可能并不在列表前列。</li>
<li>需要基于生成的代码评估建议，选择最合适的补全，同时保证生成过程的高效性和连贯性。</li>
</ul>
</li>
</ol>
<p><strong>解决方案：TOOLGEN</strong></p>
<p>TOOLGEN分为两个主要阶段：</p>
<ol>
<li><strong>离线阶段</strong>：<ul>
<li>触发器插入：<ul>
<li>分析代码仓库中的源文件，通过抽象语法树（AST）提取函数定义。</li>
<li>在函数中插入特殊标记<code>&lt;COMP&gt;</code>，标记可能触发补全工具的位置（如涉及仓库依赖的标识符）。</li>
</ul>
</li>
<li>模型微调：<ul>
<li>使用带有<code>&lt;COMP&gt;</code>标记的增强函数及其描述，微调选定的代码LLM。</li>
</ul>
</li>
</ul>
</li>
<li><strong>在线阶段</strong>：<ul>
<li>工具集成代码生成：<ul>
<li>基于给定描述，通过微调后的LLM逐步生成函数。</li>
<li>遇到<code>&lt;COMP&gt;</code>标记时，调用自动补全工具并基于当前仓库上下文获取补全建议。</li>
<li>使用约束贪婪搜索算法评估建议，选择最合适的补全并添加到生成的代码中。</li>
<li>持续预测标记，直至满足终止条件。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>关键创新</strong></p>
<p>通过触发器插入和约束搜索的结合，TOOLGEN解决了仓库级依赖问题和补全建议选择的难题，显著提高了仓库级代码生成的准确性和效率。</p>
<p><font color="red">Evaluation and contributions</font></p>
<p><strong>实验设计与评估</strong></p>
<ol>
<li><strong>评估对象</strong>：<ul>
<li>在三种代码LLMs（CodeGPT、CodeT5、CodeLlama）上评估TOOLGEN在仓库级代码生成中的效果。</li>
</ul>
</li>
<li><strong>数据集</strong>：<ul>
<li><strong>Benchmark</strong>：包含12,406个Python函数（来自671个真实代码仓库）和176个来自CoderEval数据集的编程任务。</li>
</ul>
</li>
<li><strong>新定义的指标</strong>：<ul>
<li><strong>依赖覆盖率（Dependency Coverage）</strong>：衡量生成函数中成功覆盖的仓库级依赖的比例。</li>
<li><strong>静态有效率（Static Validity Rate）</strong>：衡量生成函数通过依赖错误检查的比例。</li>
</ul>
</li>
<li><strong>实验结果</strong>：<ul>
<li><strong>相似性指标</strong>：TOOLGEN在BLEU-4、CodeBLEU、编辑相似度和精确匹配等标准指标上表现出与现有方法相当或更优的效果。</li>
<li><strong>依赖覆盖率</strong>：提升31.4%至39.1%。</li>
<li><strong>静态有效率</strong>：提升44.9%至57.7%。</li>
<li>测试通过率（Pass@1）：<ul>
<li>在CoderEval任务上，CodeT5和CodeLlama分别提升40.0%和25.0%。</li>
<li>CodeGPT的通过率保持不变。</li>
</ul>
</li>
<li><strong>效率</strong>：生成效率较高，平均延迟为0.63至2.34秒。</li>
</ul>
</li>
<li><strong>通用性</strong>：<ul>
<li>TOOLGEN在不同模型架构和规模的代码LLMs上表现一致。</li>
</ul>
</li>
</ol>
<hr>
<p><strong>主要贡献</strong></p>
<ol>
<li><strong>提出TOOLGEN</strong>：<ul>
<li><strong>功能</strong>：将自动补全工具无缝集成到代码LLMs的生成过程中。</li>
<li>方法：<ul>
<li><strong>离线阶段</strong>：通过触发器插入和模型微调生成增强数据集（249,298个Python函数，来自12,231个代码仓库），每个函数插入特殊标记<code>&lt;COMP&gt;</code>，标记适合调用补全工具的位置。</li>
<li><strong>在线阶段</strong>：通过工具集成代码生成，实现仓库级代码生成。</li>
</ul>
</li>
</ul>
</li>
<li><strong>建立评估基准</strong>：<ul>
<li>包括12,406个Python函数和176个CoderEval任务。</li>
<li>引入两项新仓库级指标：依赖覆盖率和静态有效率。</li>
</ul>
</li>
<li><strong>实验验证</strong>：<ul>
<li>TOOLGEN显著提升依赖覆盖率和静态有效率，在CodeT5和CodeLlama的测试通过率上也表现突出，同时保持较高生成效率。</li>
</ul>
</li>
</ol>
<p><strong>总结</strong>：TOOLGEN是一种创新方法，显著提升了代码LLMs在仓库级代码生成中的性能，同时在多种模型架构上表现出色。</p>
<h2 id="PRELIMINARIES"><a href="#PRELIMINARIES" class="headerlink" title="PRELIMINARIES"></a>PRELIMINARIES</h2><h3 id="A-Code-LLMs"><a href="#A-Code-LLMs" class="headerlink" title="A. Code LLMs"></a><em>A. Code LLMs</em></h3><p><strong>代码LLMs分类</strong></p>
<ol>
<li><strong>两种主要模型类别</strong>：<ul>
<li>Decoder-only 模型：<ul>
<li>如图2a所示，这类模型（例如CodeGPT和CodeLlama）仅包含Transformer架构的解码器部分。</li>
<li>通过将描述文本（docstring）分解为一系列标记（tokens），逐步生成函数，每一步基于描述文本和前一步生成的上下文预测下一个标记。</li>
</ul>
</li>
<li>Encoder-Decoder 模型：<ul>
<li>如图2b所示，这类模型（例如CodeT5和CodeT5+）包含Transformer架构的编码器和解码器部分。</li>
<li>描述文本先由编码器处理生成中间表示，然后解码器根据这个中间表示以及前面生成的上下文逐步生成函数。</li>
</ul>
</li>
</ul>
</li>
<li><strong>特殊标记（<COMP>）的引入</COMP></strong>：<ul>
<li>为了让模型识别和预测特殊标记<code>&lt;COMP&gt;</code>，首先将其加入LLM的词汇表中，扩展后的词汇表用<code>V</code>表示。</li>
<li>描述文本或代码片段的标记化（tokenization）和下一标记预测的过程被定义为数学形式：<ul>
<li><strong>标记化过程</strong>：将字符序列转化为标记序列。</li>
<li><strong>预测过程</strong>：基于描述和当前不完整的函数生成一个概率分布，其中每个标记都有对应的预测概率。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><img src="/2025/01/12/Teaching-Code-LLMs-to-Use-Autocompletion-Tools-in-Repository-Level-Code-Generation/image-20250112174338422.png" alt="image-20250112174338422"></p>
<p>图2对比了两种模型结构在代码生成中的处理方式：</p>
<ul>
<li><strong>图2a（Decoder-only 模型）</strong>：<ul>
<li>模型直接从描述文本中提取信息，并在生成函数的过程中仅依赖解码器的上下文信息。</li>
<li>优势：结构简单，专注于生成阶段。</li>
<li>局限性：描述信息仅通过初始标记传递，信息可能随生成过程逐渐丢失。</li>
</ul>
</li>
<li><strong>图2b（Encoder-Decoder 模型）</strong>：<ul>
<li>模型使用编码器先对描述文本进行更深层次的语义分析，然后解码器基于中间表示生成函数。</li>
<li>优势：编码器提供了全局的上下文表示，更适合复杂的描述和代码依赖。</li>
<li>局限性：模型结构更复杂，训练和推理时间可能较长。</li>
</ul>
</li>
</ul>
<p>图2旨在说明这两种模型在处理描述文本（docstring）到函数生成的不同机制，为理解TOOLGEN的实现提供背景支持。</p>
<h3 id="B-Autocompletion-Tools"><a href="#B-Autocompletion-Tools" class="headerlink" title="B. Autocompletion Tools"></a><em>B. Autocompletion Tools</em></h3><p><strong>自动补全工具的功能</strong></p>
<ol>
<li><p><strong>输入和输出</strong>：</p>
<ul>
<li><strong>输入</strong>：自动补全工具需要一个代码仓库和光标位置（由文件名、行号、列号组成的元组）。</li>
<li><strong>输出</strong>：提供一个补全建议列表，包括可能的标识符（identifiers）。</li>
</ul>
</li>
<li><p><strong>定义形式</strong>：</p>
<ul>
<li><p>自动补全过程被定义为：</p>
<p><code>TOOL-COMPLETE : (Σrepo, Σpos) → Σ∗iden</code></p>
<ul>
<li><code>Σrepo</code>：代码仓库的集合。</li>
<li><code>Σpos</code>：光标位置的集合。</li>
<li><code>Σiden</code>：所有可能的标识符集合，<code>Σ∗iden</code>为标识符列表。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>限制范围</strong>：</p>
<ul>
<li>在本研究中，自动补全工具仅关注标识符级别的补全，不包括以下内容：<ul>
<li><strong>关键词</strong>：因为关键词易于被代码LLMs预测。</li>
<li><strong>部分标识符</strong>：被完整标识符补全所覆盖。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>示例说明</strong></p>
<ul>
<li>在图1中，给定代码仓库和光标位置，Jedi自动补全工具为不完整的函数<code>&quot;... self.&quot;</code>提供了<strong>86个补全建议</strong>。</li>
</ul>
<p><strong>意义</strong></p>
<p>此部分主要说明自动补全工具的工作机制和研究中所聚焦的标识符补全，为研究如何集成自动补全工具到代码生成提供基础支持。</p>
<h2 id="APPROACH"><a href="#APPROACH" class="headerlink" title="APPROACH"></a>APPROACH</h2><p><img src="/2025/01/12/Teaching-Code-LLMs-to-Use-Autocompletion-Tools-in-Repository-Level-Code-Generation/image-20250112174628130.png" alt="image-20250112174628130"></p>
<h3 id="A-Overview"><a href="#A-Overview" class="headerlink" title="A. Overview"></a><em>A. Overview</em></h3><p>TOOLGEN包含两个主要阶段：</p>
<ol>
<li><strong>触发器插入与模型微调（离线阶段）</strong><ul>
<li>将代码仓库中的每个源文件解析为抽象语法树（AST），并从中提取函数定义。</li>
<li>对每个提取的函数定义，使用自动补全工具生成带有特殊标记<code>&lt;COMP&gt;</code>的增强函数，标记调用自动补全工具的位置。</li>
<li>将描述文本与增强后的函数组合成对。</li>
<li>使用这些描述与增强函数对，微调代码LLM，使其能够在适当位置预测<code>&lt;COMP&gt;</code>，从而触发自动补全工具。</li>
</ul>
</li>
<li><strong>工具集成代码生成（在线阶段）</strong><ul>
<li>TOOLGEN通过迭代过程生成函数，每步包括以下操作：<ol>
<li>预测下一个标记：<ul>
<li>微调后的代码LLM接收描述和当前不完整的函数作为输入，预测下一个标记。</li>
<li>将预测的标记添加到不完整的函数中。</li>
</ul>
</li>
<li>触发补全工具：<ul>
<li>如果预测标记为<code>&lt;COMP&gt;</code>，触发自动补全工具，返回一个基于当前仓库上下文的补全建议列表。</li>
</ul>
</li>
<li>选择补全建议：<ul>
<li>TOOLGEN通过微调后的代码LLM选择最合适的补全建议，并将其添加到不完整的函数中。</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ol>
<p><strong>意义</strong></p>
<p>TOOLGEN通过离线阶段的标记插入和模型微调，使代码LLM能够自动调用补全工具；在线阶段通过动态集成补全工具和标记预测，有效提升了仓库级代码生成的准确性和效率。</p>
<h3 id="B-Trigger-Insertion-and-Model-Fine-tuning"><a href="#B-Trigger-Insertion-and-Model-Fine-tuning" class="headerlink" title="B. Trigger Insertion and Model Fine-tuning"></a><em>B. Trigger Insertion and Model Fine-tuning</em></h3><p><strong>触发器插入与模型微调</strong></p>
<ol>
<li><p><strong>触发器插入（Trigger Insertion）</strong>：</p>
<ul>
<li><strong>目标</strong>：通过插入特殊标记<code>&lt;COMP&gt;</code>，帮助代码LLM学习在何时调用自动补全工具。</li>
<li>过程：<ol>
<li>遍历代码仓库中的每个源文件，解析为抽象语法树（AST），提取函数定义。</li>
<li>对每个函数的函数体进行分析，利用算法定位需要触发自动补全工具的位置（具体为标识符）。</li>
<li>条件判断：<ul>
<li><strong>标识符</strong>：使用<code>ISIDENTIFIER</code>检查是否为标识符。</li>
<li><strong>非内置属性</strong>：使用<code>ISBUILTIN</code>排除内置属性（如<code>__dict__</code>）。</li>
</ul>
</li>
<li>调用自动补全工具获取建议列表<code>C</code>，若<code>C</code>中包含目标标识符<code>t</code>，则在<code>t</code>前插入<code>&lt;COMP&gt;</code>。</li>
</ol>
</li>
<li>结果：<ul>
<li>生成增强函数代码<code>Faug</code>，并将其与函数签名和文档字符串（docstring）的组合形成数据对<code>(D, Faug)</code>。</li>
<li>如果函数缺少文档字符串，则跳过，因为生成任务依赖描述文本作为输入。</li>
<li>累积处理后的所有数据对构成增强数据集。</li>
</ul>
</li>
</ul>
<p><strong>示例（图4）</strong>：</p>
<ul>
<li>在一个增强函数中，共插入了4个<code>&lt;COMP&gt;</code>标记，分别标记了自动补全工具推荐列表中包含的标识符：<code>updates</code>、<code>_registered_updates</code>、<code>add</code>和<code>update</code>。</li>
<li><strong>作用</strong>：这些标记明确了调用自动补全工具的位置，确保代码LLM能准确预测并处理仓库级依赖。</li>
</ul>
</li>
<li><p><strong>模型微调（Model Fine-tuning）</strong>：</p>
<ul>
<li><strong>目标</strong>：使用增强数据集优化代码LLM的参数，使其学习如何准确预测<code>&lt;COMP&gt;</code>并触发补全工具。</li>
<li>过程：<ol>
<li>将每对数据<code>(D, Faug)</code>标记化，输入到基础代码LLM中，进行逐步生成。</li>
<li>在每一步，计算下一个标记的预测概率分布与真实标记之间的交叉熵损失。</li>
</ol>
</li>
<li>参数高效微调（LoRA）：<ul>
<li>对于大规模模型（如CodeLlama-7B），微调所有参数的计算成本高。</li>
<li>使用LoRA方法，仅在特定Transformer层的投影矩阵中引入可训练的低秩矩阵，其余参数保持冻结状态，从而实现参数高效的权重更新。</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<p><strong>示例（图4）详解</strong></p>
<ul>
<li><strong>场景</strong>：一个增强函数代码中，插入了4个<code>&lt;COMP&gt;</code>标记。</li>
<li>标记位置：<ul>
<li>**<code>updates</code>**：在补全工具推荐列表中定位到了用户自定义变量。</li>
<li>**<code>_registered_updates</code>**：确认该标识符是目标，并在其前插入标记。</li>
<li>**<code>add</code> 和 <code>update</code>**：类似地，通过补全工具识别并标记。</li>
</ul>
</li>
<li>意义：<ul>
<li>插入标记明确了触发工具的时机，有效减少依赖错误。</li>
<li>提供清晰的上下文，优化LLM的仓库级代码生成能力。</li>
</ul>
</li>
</ul>
<p><img src="/2025/01/12/Teaching-Code-LLMs-to-Use-Autocompletion-Tools-in-Repository-Level-Code-Generation/image-20250112175315625.png" alt="image-20250112175315625"></p>
<h3 id="C-Tool-integrated-Code-Generation"><a href="#C-Tool-integrated-Code-Generation" class="headerlink" title="C. Tool-integrated Code Generation"></a><em>C. Tool-integrated Code Generation</em></h3><p><strong>工具集成代码生成</strong></p>
<ol>
<li><strong>总体流程（Algorithm 2）</strong>：<ul>
<li><strong>输入</strong>：代码仓库<code>R</code>、插入位置<code>P</code>、描述文本<code>D</code>。</li>
<li>过程：<ol>
<li>初始化生成序列<code>F</code>，从<code>&lt;BOS&gt;</code>开始。</li>
<li>使用微调后的代码LLM预测下一个标记<code>tok</code>，基于概率分布选取最高概率标记并加入到<code>F</code>中。</li>
<li>如果<code>tok</code>为<code>&lt;EOS&gt;</code>，生成结束，返回最终函数。</li>
<li>如果tok为<COMP>：<ul>
<li>触发自动补全工具，基于代码仓库<code>R</code>和插入位置返回补全建议列表<code>C</code>。</li>
<li>使用<code>LLM-SELECT</code>过程，从<code>C</code>中选择最合适的补全建议并将其加入到<code>F</code>中。</li>
</ul>
</COMP></li>
</ol>
</li>
<li><strong>结果</strong>：最终生成函数<code>F</code>。</li>
</ul>
</li>
<li><strong>补全建议选择（Algorithm 3，LLM-SELECT）</strong>：<ul>
<li><strong>输入</strong>：补全建议列表<code>C</code>。</li>
<li>过程：<ol>
<li>将每个建议标记化并插入前缀树（trie）。</li>
<li>基于微调代码LLM的预测，在前缀树中以贪婪方式选择最优路径，对每一步预测进行概率筛选。</li>
<li>将选定路径对应的标记序列加入到生成函数<code>F</code>中。</li>
</ol>
</li>
<li><strong>结果</strong>：生成包含补全建议的完整函数。</li>
</ul>
</li>
</ol>
<hr>
<p><strong>示例解释</strong></p>
<ol>
<li><strong>示例场景（图1）</strong>：<ul>
<li>未完成的代码片段为<code>&quot;... self.&quot;</code>。</li>
<li>微调后的代码LLM预测下一个标记为<code>&lt;COMP&gt;</code>，触发自动补全工具。</li>
<li>补全工具返回建议列表，包括68个可能的补全项。</li>
</ul>
</li>
<li><strong>选择过程（图5）</strong>：<ul>
<li>在补全建议生成的前缀树中（图5展示），微调后的代码LLM逐步预测并选择标记。</li>
<li>通过贪婪搜索沿着前缀树的绿色路径，最终选择了补全建议<code>&quot;_registered_updates&quot;</code>。</li>
<li>该补全建议被加入到函数中，生成完整的代码片段。</li>
</ul>
</li>
</ol>
<hr>
<p><strong>意义</strong></p>
<ul>
<li><strong>工具集成生成</strong>：<ul>
<li>通过动态调用自动补全工具和<code>&lt;COMP&gt;</code>标记，确保生成的代码适配仓库级依赖。</li>
<li>解决LLM单独生成时难以捕捉依赖关系的问题。</li>
</ul>
</li>
<li><strong>补全建议选择的优化</strong>：<ul>
<li>使用前缀树结构对补全建议进行高效管理，结合LLM预测进行筛选，显著提高生成准确性。</li>
<li>示例中，从68个建议中精准选择了目标标识符<code>&quot;_registered_updates&quot;</code>，展现了方法的有效性。</li>
</ul>
</li>
<li><strong>实际效果</strong>：<ul>
<li>工具集成生成和建议选择策略有效减少了依赖性错误，提高了仓库级代码生成的实用性和精度。</li>
</ul>
</li>
</ul>
<h2 id="EVALUATION-SETUP"><a href="#EVALUATION-SETUP" class="headerlink" title="EVALUATION SETUP"></a>EVALUATION SETUP</h2><h3 id="A-Research-Questions"><a href="#A-Research-Questions" class="headerlink" title="A. Research Questions"></a><em>A. Research Questions</em></h3><ol>
<li><strong>RQ1 - 基于相似性的有效性</strong>：<br>TOOLGEN生成的代码在常见相似性指标（如BLEU、CodeBLEU等）下，与真实代码的匹配程度如何？</li>
<li><strong>RQ2 - 基于依赖性的有效性</strong>：<br>TOOLGEN在多大程度上能覆盖仓库级依赖（如用户自定义函数和属性），并减少依赖错误？</li>
<li><strong>RQ3 - 基于执行的有效性</strong>：<br>TOOLGEN生成的代码功能是否正确，并能通过测试用例？</li>
<li><strong>RQ4 - 效率</strong>：<br>TOOLGEN生成单个函数的平均时间是多少？</li>
<li><strong>RQ5 - 泛化性</strong>：<br>TOOLGEN在不同的代码LLMs上是否仍能表现出色的代码生成能力？</li>
</ol>
<h3 id="B-Implementation"><a href="#B-Implementation" class="headerlink" title="B. Implementation"></a><em>B. Implementation</em></h3><p><strong>TOOLGEN 实现细节</strong></p>
<ol>
<li><strong>语言与模型选择</strong>：<ul>
<li><strong>语言支持</strong>：TOOLGEN被设计为语言无关，但目前开发了专注于<strong>Python</strong>的原型。</li>
<li>基础模型： TOOLGEN使用三种代码LLM，涵盖不同的模型架构和参数规模：<ul>
<li>CodeGPT：<ul>
<li>Decoder-only 模型，基于CodeSearchNet的Python语料库（1.1百万Python函数）预训练。</li>
<li>使用CodeGPT-small版本，124M参数。</li>
</ul>
</li>
<li>CodeT5：<ul>
<li>Encoder-decoder 模型，同样基于CodeSearchNet的Python语料库预训练。</li>
<li>使用CodeT5-base版本，220M参数。</li>
</ul>
</li>
<li>CodeLlama：<ul>
<li>Decoder-only 模型，专注代码任务，基于Llama2开发。</li>
<li>预训练于更大规模的Python语料库（1000亿标记）。</li>
<li>使用CodeLlama-7b版本，7B参数。</li>
</ul>
</li>
<li><strong>TOOLGEN变体</strong>：TOOLGEN的不同版本分别对应上述模型（TOOLGEN-gpt、TOOLGEN-t5、TOOLGEN-llama）。</li>
</ul>
</li>
</ul>
</li>
<li><strong>自动补全工具</strong>：<ul>
<li>使用Jedi作为补全工具，支持静态分析和生成与仓库级依赖（如用户定义的属性和函数）相关的补全建议。</li>
</ul>
</li>
<li><strong>触发器插入（Trigger Insertion）</strong>：<ul>
<li><strong>数据来源</strong>：基于CodeSearchNet数据集的Python语料库，通过爬取数据集列出的代码仓库获取完整代码。</li>
<li>过程：<ul>
<li>提取代码仓库中的Python函数，并按照预定流程对函数进行增强，插入特殊标记<code>&lt;COMP&gt;</code>。</li>
<li>生成增强数据集，包含249,298对描述和增强函数，来自12,231个Python代码仓库。</li>
</ul>
</li>
<li>数据统计：<ul>
<li>描述平均标记数为10.98，增强函数平均标记数为55.31。</li>
<li>每个增强函数平均插入5.54个<code>&lt;COMP&gt;</code>标记。</li>
</ul>
</li>
</ul>
</li>
<li><strong>模型微调（Model Fine-tuning）</strong>：<ul>
<li>策略：<ul>
<li>CodeGPT和CodeT5：采用全参数微调。</li>
<li>CodeLlama：使用LoRA参数高效微调，优化3.86%的可训练参数。</li>
</ul>
</li>
<li>设置：<ul>
<li>学习率：5E-6。</li>
<li>批量大小：32。</li>
<li>微调周期：CodeGPT和CodeT5为10轮，CodeLlama为3轮。</li>
</ul>
</li>
<li><strong>一致性</strong>：为确保可复现性，所有随机函数设置种子为42。</li>
</ul>
</li>
</ol>
<hr>
<p><strong>总结</strong></p>
<p>TOOLGEN通过使用不同架构和规模的模型（CodeGPT、CodeT5、CodeLlama）与Jedi自动补全工具相结合，构建了一个基于Python的增强数据集并进行了微调，实现了仓库级代码生成的优化。其中，LoRA技术显著提高了大规模模型微调的效率。</p>
<h3 id="C-Evaluation-Benchmark"><a href="#C-Evaluation-Benchmark" class="headerlink" title="C. Evaluation Benchmark"></a><em>C. Evaluation Benchmark</em></h3><ol>
<li><strong>数据集</strong>：<ul>
<li><strong>CodeSearchNet</strong>：<ul>
<li>用于评估基于相似性和依赖性的有效性（RQ1 和 RQ2）。</li>
<li>数据集由CodeSearchNet测试集中的代码仓库构建，包含<strong>12,406个Python函数</strong>，来自671个代码仓库。</li>
<li>描述的平均标记数为10.66，函数的平均标记数为54.54。</li>
</ul>
</li>
<li><strong>CoderEval</strong>：<ul>
<li>用于评估基于执行的有效性（RQ3）。</li>
<li>包含<strong>176个任务</strong>，由43个Python代码仓库中的任务构成，任务包括自然语言描述、真实代码片段和测试用例。</li>
<li>按运行级别分类：包括独立运行、自定义依赖运行、文件级运行等。</li>
<li>从CoderEval中移除了与训练集重叠的任务。</li>
</ul>
</li>
</ul>
</li>
<li>**基线模型 (Baselines)**：<ul>
<li><strong>Vanilla Baselines</strong>：<ul>
<li>对基础模型（CodeGPT、CodeT5、CodeLlama）进行微调，不包含工具集成。</li>
<li>微调基于增强数据集中的原始函数（未包含<code>&lt;COMP&gt;</code>标记），设置与TOOLGEN一致。</li>
<li>分别命名为：<code>VANILLA-gpt</code>、<code>VANILLA-t5</code>、<code>VANILLA-llama</code>。</li>
</ul>
</li>
<li>**RAG Baselines (检索增强生成)**：<ul>
<li>使用REPOCODER框架，结合相似性检索和代码生成。</li>
<li>创建三个变体：<code>REPOCODER-gpt</code>、<code>REPOCODER-t5</code>、<code>REPOCODER-llama</code>，分别使用不同基础模型。</li>
</ul>
</li>
<li><strong>RAG-TOOLGEN变体</strong>：<ul>
<li>将TOOLGEN与REPOCODER结合，创建<code>ragTOOLGEN-gpt</code>、<code>ragTOOLGEN-t5</code>和<code>ragTOOLGEN-llama</code>。</li>
</ul>
</li>
</ul>
</li>
<li>**评估指标 (Metrics)**：<ul>
<li><strong>基于相似性的指标</strong>：<ul>
<li><strong>BLEU-4</strong>：评估生成代码与真实代码在n-gram上的相似度。</li>
<li><strong>CodeBLEU</strong>：考虑代码特定词汇和结构的生成质量评估。</li>
<li>**Edit Similarity (EditSim)**：通过编辑操作评估代码片段的字符级相似性。</li>
<li><strong>Exact Match</strong>：衡量生成代码与真实代码完全匹配的比例。</li>
</ul>
</li>
<li><strong>基于依赖性的指标</strong>：<ul>
<li>**Dependency Coverage (DepCov)**：计算生成函数对仓库级依赖（如用户自定义函数和属性）的覆盖率。</li>
<li>**Static Validity Rate (ValRate)**：衡量生成代码在静态检查中通过的比例，主要检查<code>no-member</code>和<code>undefined-variable</code>错误。</li>
</ul>
</li>
<li><strong>基于执行的指标</strong>：<ul>
<li>**Test Pass Rate (Pass@1)**：计算生成函数通过所有对应测试用例的比例，在CoderEval数据集上评估。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="RESULTS-AND-ANALYSES"><a href="#RESULTS-AND-ANALYSES" class="headerlink" title="RESULTS AND ANALYSES"></a>RESULTS AND ANALYSES</h2><h3 id="A-RQ1-Similarity-based-Effectiveness"><a href="#A-RQ1-Similarity-based-Effectiveness" class="headerlink" title="A. RQ1: Similarity-based Effectiveness"></a><em>A. RQ1: Similarity-based Effectiveness</em></h3><ol>
<li><strong>评估结果（表II）</strong>：<ul>
<li>TOOLGEN在相似性指标（BLEU-4、CodeBLEU、Edit Similarity、Exact Match）上的表现与基线模型（VANILLA变体）相当或有所提升。</li>
<li>CodeGPT 基础模型：<ul>
<li>TOOLGEN-gpt相比VANILLA-gpt：<ul>
<li>BLEU-4提升2.7%，Exact Match提升11.9%。</li>
<li>CodeBLEU下降1.0%，Edit Similarity下降1.1%。</li>
</ul>
</li>
</ul>
</li>
<li>CodeT5 基础模型：<ul>
<li>TOOLGEN-t5相比VANILLA-t5：<ul>
<li>BLEU-4提升6.2%，CodeBLEU提升1.4%，Exact Match提升27.9%。</li>
<li>Edit Similarity下降3.1%。</li>
</ul>
</li>
</ul>
</li>
<li>CodeLlama 基础模型：<ul>
<li>TOOLGEN-llama相比VANILLA-llama：<ul>
<li>BLEU-4提升4.2%，Exact Match提升21.1%。</li>
<li>CodeBLEU下降0.6%，Edit Similarity下降2.4%。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>Exact Match 分析</strong>：<ul>
<li>尽管Exact Match的提升幅度（0.5%-1.2%）较小，但由于测试集规模大（12,406样本），对应的完全匹配函数增加了62到149个。</li>
</ul>
</li>
<li><strong>指标变化原因</strong>：<ul>
<li>BLEU-4 与 CodeBLEU：<ul>
<li>差异源于两种指标使用不同的标记化方法。</li>
<li>BLEU-4基于代码LLM的标记器，而CodeBLEU使用基于空格的简单拆分法，可能导致匹配n-gram统计的不准确性。</li>
</ul>
</li>
<li>Edit Similarity：<ul>
<li>基于字符级别计算，对变量名等语义无关元素非常敏感。</li>
<li>不同变量名的字符级相似性显著低于标记级相似性。</li>
</ul>
</li>
</ul>
</li>
<li><strong>总结</strong>：<ul>
<li>TOOLGEN在BLEU-4和Exact Match上表现出色，在CodeBLEU和Edit Similarity上表现可比。</li>
<li>结果表明，TOOLGEN在相似性指标上具有竞争力，尤其是在生成代码与真实代码的完全匹配方面表现突出。</li>
</ul>
</li>
</ol>
<p><img src="/2025/01/12/Teaching-Code-LLMs-to-Use-Autocompletion-Tools-in-Repository-Level-Code-Generation/image-20250112181203994.png" alt="image-20250112181203994"></p>
<h3 id="B-RQ2-Dependency-based-Effectiveness"><a href="#B-RQ2-Dependency-based-Effectiveness" class="headerlink" title="B. RQ2: Dependency-based Effectiveness"></a><em>B. RQ2: Dependency-based Effectiveness</em></h3><ol>
<li><strong>依赖覆盖率（Dependency Coverage）</strong>：<ul>
<li>TOOLGEN在仓库级依赖覆盖率上显著优于基线模型：<ul>
<li><strong>CodeGPT</strong>：提升**39.1%**。</li>
<li><strong>CodeT5</strong>：提升**36.4%**。</li>
<li><strong>CodeLlama</strong>：提升**31.4%**。</li>
</ul>
</li>
<li>效果说明：<ul>
<li>TOOLGEN通过工具集成生成过程（借助Jedi），增强了对仓库级依赖的感知。</li>
<li>示例：在图1中，CodeLlama无法识别<code>self</code>的有效属性，而TOOLGEN通过补全工具识别候选项，选择最合适的依赖项（如用户定义的属性）。</li>
</ul>
</li>
<li>局限性：<ul>
<li>生成顺序从左到右的暴露偏差问题（Exposure Bias）会导致错误逐步累积。</li>
<li>特别是在生成较长函数时，模型可能无法正确触发<code>&lt;COMP&gt;</code>标记，影响依赖覆盖。</li>
</ul>
</li>
</ul>
</li>
<li><strong>静态有效率（Static Validity Rate）</strong>：<ul>
<li>TOOLGEN在仓库级静态分析中的有效率显著高于基线模型：<ul>
<li>ValRate（整体有效率）：<ul>
<li>CodeGPT：提升**57.7%**。</li>
<li>CodeT5：提升**49.3%**。</li>
<li>CodeLlama：提升**44.9%**。</li>
</ul>
</li>
<li>ValRate-dep（依赖函数的有效率）：<ul>
<li>CodeGPT：提升**67.7%**。</li>
<li>CodeT5：提升**60.0%**。</li>
<li>CodeLlama：提升**56.8%**。</li>
</ul>
</li>
</ul>
</li>
<li>效果说明：<ul>
<li>TOOLGEN仅考虑由Jedi推断的有效补全建议，避免了生成无效标识符（如<code>no-member</code>或<code>undefined-variable</code>错误）。</li>
<li>示例：在图1中，CodeLlama可能预测不存在的属性（如<code>updates</code>），而TOOLGEN通过工具集成避免了该问题。</li>
</ul>
</li>
</ul>
</li>
<li><strong>总结</strong>：<ul>
<li><strong>依赖覆盖率</strong>：TOOLGEN在所有模型上提升显著（31.4%-39.1%）。</li>
<li><strong>静态有效率</strong>：TOOLGEN有效减少无效标识符的生成，提升幅度从44.9%到57.7%不等。</li>
<li>意义：<ul>
<li>TOOLGEN显著增强了代码生成对仓库级依赖的感知能力。</li>
<li>有效解决了传统代码LLMs在仓库级代码生成中常见的依赖识别和标识符有效性问题。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><img src="/2025/01/12/Teaching-Code-LLMs-to-Use-Autocompletion-Tools-in-Repository-Level-Code-Generation/image-20250112181321701.png" alt="image-20250112181321701"></p>
<h3 id="C-RQ3-Execution-based-Effectiveness"><a href="#C-RQ3-Execution-based-Effectiveness" class="headerlink" title="C. RQ3: Execution-based Effectiveness"></a><em>C. RQ3: Execution-based Effectiveness</em></h3><p><strong>与VANILLA基线的比较</strong>：</p>
<ul>
<li>Pass@1改进：<ul>
<li><strong>TOOLGEN-gpt</strong>：生成的功能正确函数与VANILLA-gpt相同（0个额外提升），提升幅度为**0%**。</li>
<li><strong>TOOLGEN-t5</strong>：生成了2个额外的功能正确函数，Pass@1提升**40.0%**。</li>
<li><strong>TOOLGEN-llama</strong>：生成了3个额外的功能正确函数，Pass@1提升**25.0%**。</li>
</ul>
</li>
<li>任务类型改进：<ul>
<li>TOOLGEN-gpt：改进了文件级任务，但降低了独立任务的通过率。</li>
<li>TOOLGEN-t5：改进了库依赖（slib-runnable）和文件级任务。</li>
<li>TOOLGEN-llama：改进了独立任务、公共库依赖（plib-runnable）和类级任务。</li>
</ul>
</li>
</ul>
<p><strong>与REPOCODER基线的比较</strong>：</p>
<ul>
<li>表现波动：<ul>
<li>REPOCODER-gpt和REPOCODER-t5在Pass@1上表现不稳定，未表现出明显提升或有所下降。</li>
<li>REPOCODER-llama表现突出，Pass@1显著高于VANILLA-llama。</li>
</ul>
</li>
<li>TOOLGEN对比：<ul>
<li>TOOLGEN-gpt和TOOLGEN-t5分别生成1和2个额外的功能正确函数，相较于REPOCODER-gpt和REPOCODER-t5表现更好。</li>
<li>TOOLGEN-llama的通过率（15个函数通过）低于REPOCODER-llama（19个函数通过），可能因REPOCODER更好地利用了CodeLlama的参数规模和长序列支持。</li>
</ul>
</li>
</ul>
<p><strong>与RAG集成的效果</strong>：</p>
<ul>
<li>ragTOOLGEN-gpt和ragTOOLGEN-t5未显示改进。</li>
<li>ragTOOLGEN-llama在项目级任务（project-runnable）中表现突出，生成4个额外的功能正确函数，但整体Pass@1未提升。</li>
</ul>
<p><strong>总结</strong>：</p>
<ul>
<li>TOOLGEN相较于VANILLA基线模型在Pass@1上有显著提升：<ul>
<li>改进幅度为0%、40.0%、25.0%（TOOLGEN-gpt、TOOLGEN-t5、TOOLGEN-llama）。</li>
</ul>
</li>
<li>与REPOCODER相比，TOOLGEN和REPOCODER在不同模型和依赖级别任务上各有优势。</li>
<li>TOOLGEN与RAG的结合在某些依赖任务上显示潜力，但整体表现未显著改善，表明不同方法在处理依赖问题时具有互补特性。</li>
</ul>
<p><img src="/2025/01/12/Teaching-Code-LLMs-to-Use-Autocompletion-Tools-in-Repository-Level-Code-Generation/image-20250112181747791.png" alt="image-20250112181747791"></p>
<h3 id="D-RQ4-Efficiency"><a href="#D-RQ4-Efficiency" class="headerlink" title="D. RQ4: Efficiency"></a><em>D. RQ4: Efficiency</em></h3><ol>
<li><strong>效率评估结果</strong>：<ul>
<li>在NVIDIA H100 Tensor Core GPU（80GB内存）上测试，TOOLGEN在<strong>CoderEval数据集的176个任务</strong>中，每个函数的生成时间范围为<strong>0.63到2.34秒</strong>。</li>
<li>与基线相比，TOOLGEN的生成时间约为基线的两倍。</li>
</ul>
</li>
<li><strong>效率来源</strong>：<ul>
<li>离线优化：<ul>
<li>触发器插入和模型微调在离线阶段完成，减少了在线生成时的计算负担。</li>
</ul>
</li>
<li>触发器预测：<ul>
<li>自动补全工具仅在预测到<code>&lt;COMP&gt;</code>标记时被触发，避免了不必要的工具调用。</li>
<li>每个任务平均触发<COMP>标记的次数：<ul>
<li>CodeGPT：5.02次。</li>
<li>CodeT5：6.24次。</li>
<li>CodeLlama：7.05次。</li>
</ul>
</COMP></li>
<li>触发次数远低于函数的平均长度。</li>
</ul>
</li>
<li>缓存机制：<ul>
<li>对重复对象（如<code>self</code>）的补全建议进行缓存，避免对相同对象的重复调用。</li>
</ul>
</li>
</ul>
</li>
<li><strong>总结</strong>：<ul>
<li>TOOLGEN在仓库级代码生成中表现出高效性：<ul>
<li>平均生成延迟为<strong>0.63至2.34秒</strong>。</li>
</ul>
</li>
<li>效率提升得益于触发器标记的预测机制和补全建议的缓存机制，显著减少了工具调用的冗余。</li>
</ul>
</li>
</ol>
<p><img src="/2025/01/12/Teaching-Code-LLMs-to-Use-Autocompletion-Tools-in-Repository-Level-Code-Generation/image-20250112181819447.png" alt="image-20250112181819447"></p>
<h3 id="E-RQ5-Generalizability"><a href="#E-RQ5-Generalizability" class="headerlink" title="E. RQ5: Generalizability"></a><em>E. RQ5: Generalizability</em></h3><p><strong>性能表现</strong>：</p>
<ul>
<li>依赖性指标：<ul>
<li>TOOLGEN在所有模型架构（Decoder-only和Encoder-Decoder）和参数规模（124M到7B）下，依赖覆盖率和静态有效率均有显著提升。</li>
</ul>
</li>
<li>相似性指标：<ul>
<li>TOOLGEN在相似性指标上表现与基线模型相当。</li>
</ul>
</li>
<li>执行指标：<ul>
<li>TOOLGEN在Pass@1上有所改进或保持相同水平，同时生成延迟保持在可接受范围内（详见表IV和图6）。</li>
</ul>
</li>
</ul>
<p><strong>模型适用性</strong>：</p>
<ul>
<li>TOOLGEN适用于多种基础模型和参数规模，表现出良好的泛化能力。</li>
</ul>
<p><strong>总结</strong>：</p>
<ul>
<li>TOOLGEN在依赖性和执行性指标上持续提升或保持，且相似性指标具备竞争力。</li>
<li>其方法的通用性和高效性表明，该工具集成生成方法具有在其他基础模型和仓库级代码生成场景中广泛应用的潜力。</li>
</ul>
<h2 id="DISCUSSION"><a href="#DISCUSSION" class="headerlink" title="DISCUSSION"></a>DISCUSSION</h2><h3 id="A-Case-Study"><a href="#A-Case-Study" class="headerlink" title="A. Case Study"></a><em>A. Case Study</em></h3><p>Figure 7展示了VANILLA-llama和TOOLGEN-llama在三个具体例子中的表现，每个例子包括描述、真实代码（ground truth）、VANILLA-llama生成的代码和TOOLGEN-llama生成的代码。</p>
<ol>
<li><strong>示例 1</strong>：<ul>
<li><strong>TOOLGEN的表现</strong>：成功预测了类<code>Counter</code>中的成员<code>_value</code>。</li>
<li><strong>VANILLA的表现</strong>：错误预测为未定义成员<code>value</code>，导致<code>no-member error</code>。</li>
<li><strong>原因</strong>：TOOLGEN通过自动补全工具识别用户定义的属性&#x2F;成员依赖，避免了类似错误。</li>
</ul>
</li>
<li><strong>示例 2</strong>：<ul>
<li><strong>结果</strong>：VANILLA和TOOLGEN都生成了错误代码，未能通过测试用例。</li>
<li>原因：描述质量低，未完整表达功能需求。<ul>
<li>描述仅提到将<code>w:st=&quot;</code>替换为<code>w-st=&quot;</code>。</li>
<li>实际需求是处理匹配模式<code>\bw:[a-z]&#123;1,&#125;=&quot;</code>的所有字符串。</li>
</ul>
</li>
<li><strong>发现</strong>：低质量描述在现实代码生成中是主要挑战，且现有基准中存在描述不准确的问题。</li>
</ul>
</li>
<li><strong>示例 3</strong>：<ul>
<li>依赖性分析：<ul>
<li>正确依赖为<code>cls._get_service()</code>和<code>ServiceName.PLUGINS_MANAGER</code>。</li>
<li><strong>VANILLA的表现</strong>：预测了不存在的依赖（如<code>cls._plugins_manager</code>和<code>PluginManager()</code>），导致生成代码无法通过检查和测试。</li>
<li><strong>TOOLGEN的表现</strong>：成功预测<code>cls._get_service()</code>，但在预测参数时选择了错误的<code>cls</code>而非<code>ServiceName</code>，未能正确生成<code>ServiceName.PLUGINS_MANAGER</code>。</li>
</ul>
</li>
<li>发现：<ul>
<li>TOOLGEN虽然能解决部分依赖性问题，但生成过程中任意一步的关键错误都会导致代码最终出错。</li>
<li>这表明即使集成了自动补全工具，代码LLMs在实际代码生成中仍然面临重大挑战。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>总结</strong></p>
<ul>
<li>TOOLGEN通过集成自动补全工具，在依赖预测方面比VANILLA更有效，但仍受描述质量和生成过程中错误传播的影响。</li>
<li>案例突出了：<ul>
<li>高质量描述的重要性。</li>
<li>代码LLMs在处理复杂依赖关系时的局限性，即便使用了工具集成。</li>
</ul>
</li>
</ul>
<p><img src="/2025/01/12/Teaching-Code-LLMs-to-Use-Autocompletion-Tools-in-Repository-Level-Code-Generation/image-20250112182402278.png" alt="image-20250112182402278"></p>
<h3 id="B-Limitations"><a href="#B-Limitations" class="headerlink" title="B. Limitations"></a><em>B. Limitations</em></h3><p><strong>静态补全工具对动态类型语言的局限</strong>：</p>
<ul>
<li>TOOLGEN目前专注于Python（动态类型语言），其使用的静态分析工具有时无法处理某些仓库级依赖。<ul>
<li>例如：当函数参数类型无法通过静态分析明确推断时，工具可能无法识别参数类型中的属性。</li>
</ul>
</li>
<li><strong>未来计划</strong>：探索结合学习型类型推断工具，进一步提升Python代码生成能力。</li>
</ul>
<p><strong>贪婪预测策略的限制</strong>：</p>
<ul>
<li>在生成过程中，TOOLGEN采用贪婪策略（使用ARGMAX函数选择最高概率的标记）。</li>
<li>这一策略可能导致选择次优标记，影响后续生成质量。</li>
<li><strong>未来计划</strong>：引入更高级的解码方法，如束搜索（Beam Search）和其他策略，缓解贪婪预测的缺陷。</li>
</ul>
<p><strong>依赖性评估指标的局限</strong>：</p>
<ul>
<li>依赖覆盖率（Dependency Coverage）和静态有效率（Static Validity Rate）计算依赖静态分析工具。</li>
<li>静态工具可能引入一定的不准确性，但对TOOLGEN的相对有效性影响有限，因为基线指标也基于相同的静态分析。</li>
</ul>
<p><strong>与SOTA闭源LLMs的集成与比较</strong>：</p>
<ul>
<li>TOOLGEN可应用于任何Encoder-Decoder或Decoder-only模型，但难以集成至如GPT-3.5和GPT-4等闭源LLMs中。<ul>
<li>原因：闭源模型无法微调，也难以嵌入触发器和工具集成过程。</li>
</ul>
</li>
<li><strong>未来计划</strong>：研究无需微调的方式，将自动补全工具集成至闭源LLMs。</li>
<li><strong>当前评价</strong>：评估仅限于TOOLGEN、VANILLA和REPOCODER在相同基础模型下的比较，未与SOTA闭源LLMs进行直接对比。</li>
</ul>
<h3 id="C-Threats-to-Validity"><a href="#C-Threats-to-Validity" class="headerlink" title="C. Threats to Validity"></a><em>C. Threats to Validity</em></h3><ol>
<li><strong>内部威胁（Internal Threats）</strong>：<ul>
<li>数据质量问题：<ul>
<li>数据质量可能影响学习效果。</li>
<li><strong>缓解措施</strong>：使用被广泛采用的CodeSearchNet数据集构建增强数据集和评估基准，确保数据来源可靠。</li>
</ul>
</li>
<li>数据泄露风险：<ul>
<li>CodeLlama的预训练可能包含评估基准中的部分代码仓库，导致数据泄露。</li>
<li><strong>缓解措施</strong>：通过泛化性评估（RQ5），验证TOOLGEN在不同模型下的一致性能，表明TOOLGEN-llama的改进并非源于数据泄露。</li>
</ul>
</li>
</ul>
</li>
<li><strong>外部威胁（External Threats）</strong>：<ul>
<li>语言特异性：<ul>
<li>TOOLGEN的实现和评估目前仅针对Python，可能无法推广到其他编程语言。</li>
<li><strong>未来方向</strong>：探索工具集成生成过程在其他编程语言中的应用。</li>
</ul>
</li>
</ul>
</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Lin Li</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/01/12/Teaching-Code-LLMs-to-Use-Autocompletion-Tools-in-Repository-Level-Code-Generation/">http://example.com/2025/01/12/Teaching-Code-LLMs-to-Use-Autocompletion-Tools-in-Repository-Level-Code-Generation/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">LinLi's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/">论文阅读</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/01/24/Diversity-Drives-Fairness-Ensemble-of-Higher-Order-Mutants-for-Intersectional-Fairness-of-Machine-Learning-Software/" title="Diversity Drives Fairness Ensemble of Higher Order Mutants for Intersectional Fairness of Machine Learning Software"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Diversity Drives Fairness Ensemble of Higher Order Mutants for Intersectional Fairness of Machine Learning Software</div></div></a></div><div class="next-post pull-right"><a href="/2024/12/27/Explaining-Structured-Queries-in-Natural-Language/" title="Explaining Structured Queries in Natural Language"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Explaining Structured Queries in Natural Language</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/03/04/PLUMBER/" title="PLUMBER"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-04</div><div class="title">PLUMBER</div></div></a></div><div><a href="/2023/03/08/%E9%80%9A%E8%BF%87NPM%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91%E6%8F%AD%E5%BC%80%E8%84%86%E5%BC%B1%E6%80%A7%E4%BC%A0%E6%92%AD%E5%8F%8A%E5%85%B6%E6%BC%94%E5%8C%96%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/" title="通过NPM生态系统的依赖树揭开脆弱性传播及其演化的神秘面纱"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-08</div><div class="title">通过NPM生态系统的依赖树揭开脆弱性传播及其演化的神秘面纱</div></div></a></div><div><a href="/2023/04/03/Flexible-and-Optimal-Dependency-Management-via-Max-SMT/" title="Flexible and Optimal Dependency Management via Max-SMT"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-03</div><div class="title">Flexible and Optimal Dependency Management via Max-SMT</div></div></a></div><div><a href="/2023/04/11/What-the-Fork-Finding-Hidden-Code-Clones-in-npm/" title="What the Fork Finding Hidden Code Clones in npm"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-11</div><div class="title">What the Fork Finding Hidden Code Clones in npm</div></div></a></div><div><a href="/2023/04/12/Static-Type-Inference-for-Foreign-Functions-of-Python/" title="Static Type Inference for Foreign Functions of Python"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-12</div><div class="title">Static Type Inference for Foreign Functions of Python</div></div></a></div><div><a href="/2023/04/13/Where-to-Start-Studying-Type-Annotation-Practices-in-Python/" title="Where to Start Studying Type Annotation Practices in Python"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-13</div><div class="title">Where to Start Studying Type Annotation Practices in Python</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Lin Li</div><div class="author-info__description">今日事，今日毕</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">122</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Teaching-Code-LLMs-to-Use-Autocompletion-Tools-in-Repository-Level-Code-Generation"><span class="toc-number">1.</span> <span class="toc-text">Teaching Code LLMs to Use Autocompletion Tools in Repository-Level Code Generation</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ABSTRACET"><span class="toc-number">1.1.</span> <span class="toc-text">ABSTRACET</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#INTRODUCTION"><span class="toc-number">1.2.</span> <span class="toc-text">INTRODUCTION</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PRELIMINARIES"><span class="toc-number">1.3.</span> <span class="toc-text">PRELIMINARIES</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#A-Code-LLMs"><span class="toc-number">1.3.1.</span> <span class="toc-text">A. Code LLMs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-Autocompletion-Tools"><span class="toc-number">1.3.2.</span> <span class="toc-text">B. Autocompletion Tools</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#APPROACH"><span class="toc-number">1.4.</span> <span class="toc-text">APPROACH</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#A-Overview"><span class="toc-number">1.4.1.</span> <span class="toc-text">A. Overview</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-Trigger-Insertion-and-Model-Fine-tuning"><span class="toc-number">1.4.2.</span> <span class="toc-text">B. Trigger Insertion and Model Fine-tuning</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-Tool-integrated-Code-Generation"><span class="toc-number">1.4.3.</span> <span class="toc-text">C. Tool-integrated Code Generation</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EVALUATION-SETUP"><span class="toc-number">1.5.</span> <span class="toc-text">EVALUATION SETUP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#A-Research-Questions"><span class="toc-number">1.5.1.</span> <span class="toc-text">A. Research Questions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-Implementation"><span class="toc-number">1.5.2.</span> <span class="toc-text">B. Implementation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-Evaluation-Benchmark"><span class="toc-number">1.5.3.</span> <span class="toc-text">C. Evaluation Benchmark</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RESULTS-AND-ANALYSES"><span class="toc-number">1.6.</span> <span class="toc-text">RESULTS AND ANALYSES</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#A-RQ1-Similarity-based-Effectiveness"><span class="toc-number">1.6.1.</span> <span class="toc-text">A. RQ1: Similarity-based Effectiveness</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-RQ2-Dependency-based-Effectiveness"><span class="toc-number">1.6.2.</span> <span class="toc-text">B. RQ2: Dependency-based Effectiveness</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-RQ3-Execution-based-Effectiveness"><span class="toc-number">1.6.3.</span> <span class="toc-text">C. RQ3: Execution-based Effectiveness</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#D-RQ4-Efficiency"><span class="toc-number">1.6.4.</span> <span class="toc-text">D. RQ4: Efficiency</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#E-RQ5-Generalizability"><span class="toc-number">1.6.5.</span> <span class="toc-text">E. RQ5: Generalizability</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DISCUSSION"><span class="toc-number">1.7.</span> <span class="toc-text">DISCUSSION</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#A-Case-Study"><span class="toc-number">1.7.1.</span> <span class="toc-text">A. Case Study</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-Limitations"><span class="toc-number">1.7.2.</span> <span class="toc-text">B. Limitations</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-Threats-to-Validity"><span class="toc-number">1.7.3.</span> <span class="toc-text">C. Threats to Validity</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/08/%E8%A7%A3%E5%86%B3Camera-ready-%E2%9C%98-Problem-Not-all-fonts-are-embedded-%E9%97%AE%E9%A2%98/" title="解决Camera ready ✘ Problem: Not all fonts are embedded. 问题">解决Camera ready ✘ Problem: Not all fonts are embedded. 问题</a><time datetime="2025-04-08T14:19:21.000Z" title="发表于 2025-04-08 22:19:21">2025-04-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/21/Sequence-Oriented-DBMS-Fuzzing/" title="Sequence-Oriented DBMS Fuzzing">Sequence-Oriented DBMS Fuzzing</a><time datetime="2025-02-21T09:35:08.000Z" title="发表于 2025-02-21 17:35:08">2025-02-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/18/AGENTLESS-Demystifying-LLM-based-Software-Engineering-Agents/" title="AGENTLESS: Demystifying LLM-based Software Engineering Agents">AGENTLESS: Demystifying LLM-based Software Engineering Agents</a><time datetime="2025-02-18T12:16:29.000Z" title="发表于 2025-02-18 20:16:29">2025-02-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/01/DeepSeek-R1-Incentivizing-Reasoning-Capability-in-LLMs-via-Reinforcement-Learning/" title="DeepSeek-R1: Incentivizing Reasoning Capability in LLMs via Reinforcement Learning">DeepSeek-R1: Incentivizing Reasoning Capability in LLMs via Reinforcement Learning</a><time datetime="2025-02-01T11:11:48.000Z" title="发表于 2025-02-01 19:11:48">2025-02-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/01/DeepSeek-Coder-When-the-Large-Language-Model-Meets-Programming-The-Rise-of-Code-Intelligence/" title="DeepSeek-Coder: When the Large Language Model Meets Programming - The Rise of Code Intelligence">DeepSeek-Coder: When the Large Language Model Meets Programming - The Rise of Code Intelligence</a><time datetime="2025-02-01T02:43:19.000Z" title="发表于 2025-02-01 10:43:19">2025-02-01</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Lin Li</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>